<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>MLIR C API - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/CAPI/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>MLIR C API</h1><p><strong>Current status: Under development, API unstable, built by default.</strong></p><p><nav id=TableOfContents><ul><li><a href=#design>Design</a><ul><li><a href=#scope>Scope</a></li><li><a href=#object-model>Object Model</a></li><li><a href=#naming-convention-and-ownership-model>Naming Convention and Ownership Model</a></li><li><a href=#nullity>Nullity</a></li><li><a href=#type-hierarchies>Type Hierarchies</a></li><li><a href=#auxiliary-types>Auxiliary Types</a></li><li><a href=#printing>Printing</a></li></ul></li><li><a href=#common-patterns>Common Patterns</a><ul><li><a href=#indexed-components>Indexed Components</a></li><li><a href=#iterable-components>Iterable Components</a></li></ul></li><li><a href=#extending-the-api>Extending the API</a><ul><li><a href=#extensions-for-dialect-attributes-and-types>Extensions for Dialect Attributes and Types</a></li><li><a href=#extensions-for-interfaces>Extensions for Interfaces</a></li></ul></li></ul></nav><h2 id=design>Design&nbsp;<a class=headline-hash href=#design>¶</a></h2><p>Many languages can interoperate with C but have a harder time with C++ due to
name mangling and memory model differences. Although the C API for MLIR can be
used directly from C, it is primarily intended to be wrapped in higher-level
language- or library-specific constructs. Therefore the API tends towards
simplicity and feature minimalism.</p><p><strong>Note:</strong> while the C API is expected to be more stable than C++ API, it
currently offers no stability guarantees.</p><h3 id=scope>Scope&nbsp;<a class=headline-hash href=#scope>¶</a></h3><p>The API is provided for core IR components (attributes, blocks, operations,
regions, types, values), Passes and some fundamental type and attribute kinds.
The core IR API is intentionally low-level, e.g. exposes a plain list of
operation&rsquo;s operands and attributes without attempting to assign &ldquo;semantic&rdquo;
names to them. Users of specific dialects are expected to wrap the core API in a
dialect-specific way, for example, by implementing an ODS backend.</p><h3 id=object-model>Object Model&nbsp;<a class=headline-hash href=#object-model>¶</a></h3><p>Core IR components are exposed as opaque <em>handles</em> to an IR object existing in
C++. They are not intended to be inspected by the API users (and, in many cases,
cannot be meaningfully inspected). Instead the users are expected to pass
handles to the appropriate manipulation functions.</p><p>The handle <em>may or may not</em> own the underlying object.</p><h3 id=naming-convention-and-ownership-model>Naming Convention and Ownership Model&nbsp;<a class=headline-hash href=#naming-convention-and-ownership-model>¶</a></h3><p>All objects are prefixed with <code>Mlir</code>. They are typedefs and should be used
without <code>struct</code>.</p><p>All functions are prefixed with <code>mlir</code>.</p><p>Functions primarily operating on an instance of <code>MlirX</code> are prefixed with
<code>mlirX</code>. They take the instance being acted upon as their first argument (except
for creation functions). For example, <code>mlirOperationGetNumOperands</code> inspects an
<code>MlirOperation</code>, which it takes as its first operand.</p><p>The <em>ownership</em> model is encoded in the naming convention as follows.</p><ul><li>By default, the ownership is not transferred.</li><li>Functions that transfer the ownership of the result to the caller can be in
one of two forms:<ul><li>functions that create a new object have the name <code>mlirXCreate&lt;...></code>, for
example, <code>mlirOperationCreate</code>;</li><li>functions that detach an object from a parent object have the name
<code>mlirYTake&lt;...></code>, for example <code>mlirOperationStateTakeRegion</code>.</li></ul></li><li>Functions that take ownership of some of their arguments have the form
<code>mlirY&lt;...>OwnedX&lt;...></code> where <code>X</code> can refer to the type or any other
sufficiently unique description of the argument, the ownership of which will
be taken by the callee, for example <code>mlirRegionAppendOwnedBlock</code>.</li><li>Functions that create an object by default do not transfer its ownership to
the caller, i.e. one of other objects passed in as an argument retains the
ownership, they have the form <code>mlirX&lt;...>Get</code>. For example,
<code>mlirTypeParseGet</code>.</li><li>Functions that destroy an object owned by the caller are of the form
<code>mlirXDestroy</code>.</li></ul><p>If the code owns an object, it is responsible for destroying the object when it
is no longer necessary. If an object that owns other objects is destroyed, any
handles to those objects become invalid. Note that types and attributes are
owned by the <code>MlirContext</code> in which they were created.</p><h3 id=nullity>Nullity&nbsp;<a class=headline-hash href=#nullity>¶</a></h3><p>A handle may refer to a <em>null</em> object. It is the responsibility of the caller to
check if an object is null by using <code>mlirXIsNull(MlirX)</code>. API functions do <em>not</em>
expect null objects as arguments unless explicitly stated otherwise. API
functions <em>may</em> return null objects.</p><h3 id=type-hierarchies>Type Hierarchies&nbsp;<a class=headline-hash href=#type-hierarchies>¶</a></h3><p>MLIR objects can form type hierarchies in C++. For example, all IR classes
representing types are derived from <code>mlir::Type</code>, some of them may also be also
derived from common base classes such as <code>mlir::ShapedType</code> or dialect-specific
base classes. Type hierarchies are exposed to C API through naming conventions
as follows.</p><ul><li>Only the top-level class of each hierarchy is exposed, e.g. <code>MlirType</code> is
defined as a type but <code>MlirShapedType</code> is not. This avoids the need for
explicit upcasting when passing an object of a derived type to a function
that expects a base type (this happens more often in core/standard APIs,
while downcasting usually involves further checks anyway).</li><li>A type <code>Y</code> that derives from <code>X</code> provides a function <code>int mlirXIsAY(MlirX)</code>
that returns a non-zero value if the given dynamic instance of <code>X</code> is also
an instance of <code>Y</code>. For example, <code>int MlirTypeIsAInteger(MlirType)</code>.</li><li>A function that expects a derived type as its first argument takes the base
type instead and documents the expectation by using <code>Y</code> in its name
<code>MlirY&lt;...>(MlirX, ...)</code>. This function asserts that the dynamic instance of
its first argument is <code>Y</code>, and it is the responsibility of the caller to
ensure it is indeed the case.</li></ul><h3 id=auxiliary-types>Auxiliary Types&nbsp;<a class=headline-hash href=#auxiliary-types>¶</a></h3><h4 id=stringref><code>StringRef</code>&nbsp;<a class=headline-hash href=#stringref>¶</a></h4><p>Numerous MLIR functions return instances of <code>StringRef</code> to refer to a non-owning
segment of a string. This segment may or may not be null-terminated. In C API,
these are represented as instances of <code>MlirStringRef</code> structure that contains a
pointer to the first character of the string fragment (<code>str</code>) and the fragment
length (<code>length</code>). Note that the fragment is <em>not necessarily</em> null-terminated,
the <code>length</code> field must be used to identify the last character. <code>MlirStringRef</code>
is a non-owning pointer, the caller is in charge of performing the copy or
ensuring that the pointee outlives all uses of <code>MlirStringRef</code>.</p><h3 id=printing>Printing&nbsp;<a class=headline-hash href=#printing>¶</a></h3><p>IR objects can be printed using <code>mlirXPrint(MlirX, MlirStringCallback, void *)</code>
functions. These functions accept take arguments a callback with signature <code>void (*)(const char *, intptr_t, void *)</code> and a pointer to user-defined data. They
call the callback and supply it with chunks of the string representation,
provided as a pointer to the first character and a length, and forward the
user-defined data unmodified. It is up to the caller to allocate memory if the
string representation must be stored and perform the copy. There is no guarantee
that the pointer supplied to the callback points to a null-terminated string,
the size argument should be used to find the end of the string. The callback may
be called multiple times with consecutive chunks of the string representation
(the printing itself is buffered).</p><p><em>Rationale</em>: this approach allows the caller to have full control of the
allocation and avoid unnecessary allocation and copying inside the printer.</p><p>For convenience, <code>mlirXDump(MlirX)</code> functions are provided to print the given
object to the standard error stream.</p><h2 id=common-patterns>Common Patterns&nbsp;<a class=headline-hash href=#common-patterns>¶</a></h2><p>The API adopts the following patterns for recurrent functionality in MLIR.</p><h3 id=indexed-components>Indexed Components&nbsp;<a class=headline-hash href=#indexed-components>¶</a></h3><p>An object has an <em>indexed component</em> if it has fields accessible using a
zero-based contiguous integer index, typically arrays. For example, an
<code>MlirBlock</code> has its arguments as an indexed component. An object may have
several such components. For example, an <code>MlirOperation</code> has attributes,
operands, regions, results and successors.</p><p>For indexed components, the following pair of functions is provided.</p><ul><li><code>intptr_t mlirXGetNum&lt;Y>s(MlirX)</code> returns the upper bound on the index.</li><li><code>MlirY mlirXGet&lt;Y>(MlirX, intptr_t pos)</code> returns &lsquo;pos&rsquo;-th subobject.</li></ul><p>The sizes are accepted and returned as signed pointer-sized integers, i.e.
<code>intptr_t</code>. This typedef is available in C99.</p><p>Note that the name of subobject in the function does not necessarily match the
type of the subobject. For example, <code>mlirOperationGetOperand</code> returns an
<code>MlirValue</code>.</p><h3 id=iterable-components>Iterable Components&nbsp;<a class=headline-hash href=#iterable-components>¶</a></h3><p>An object has an <em>iterable component</em> if it has iterators accessing its fields
in some order other than integer indexing, typically linked lists. For example,
an <code>MlirBlock</code> has an iterable list of operations it contains. An object may
have several iterable components.</p><p>For iterable components, the following triple of functions is provided.</p><ul><li><code>MlirY mlirXGetFirst&lt;Y>(MlirX)</code> returns the first subobject in the list.</li><li><code>MlirY mlirYGetNextIn&lt;X>(MlirY)</code> returns the next subobject in the list that
contains the given object, or a null object if the given object is the last
in this list.</li><li><code>int mlirYIsNull(MlirY)</code> returns 1 if the given object is null.</li></ul><p>Note that the name of subobject in the function may or may not match its type.</p><p>This approach enables one to iterate as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>MlirY</span> <span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>iter</span> <span class=o>=</span> <span class=n>mlirXGetFirst</span><span class=o>&lt;</span><span class=n>Y</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>);</span> <span class=o>!</span><span class=n>mlirYIsNull</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>     <span class=n>iter</span> <span class=o>=</span> <span class=n>mlirYGetNextIn</span><span class=o>&lt;</span><span class=n>X</span><span class=o>&gt;</span><span class=p>(</span><span class=n>iter</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* User &#39;iter&#39;. */</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=extending-the-api>Extending the API&nbsp;<a class=headline-hash href=#extending-the-api>¶</a></h2><h3 id=extensions-for-dialect-attributes-and-types>Extensions for Dialect Attributes and Types&nbsp;<a class=headline-hash href=#extensions-for-dialect-attributes-and-types>¶</a></h3><p>Dialect attributes and types can follow the example of builtin attributes and
types, provided that implementations live in separate directories, i.e.
<code>include/mlir-c/&lt;...>Dialect/</code> and <code>lib/CAPI/&lt;...>Dialect/</code>. The core APIs
provide implementation-private headers in <code>include/mlir/CAPI/IR</code> that allow one
to convert between opaque C structures for core IR components and their C++
counterparts. <code>wrap</code> converts a C++ class into a C structure and <code>unwrap</code> does
the inverse conversion. Once the C++ object is available, the API implementation
should rely on <code>isa</code> to implement <code>mlirXIsAY</code> and is expected to use <code>cast</code>
inside other API calls.</p><h3 id=extensions-for-interfaces>Extensions for Interfaces&nbsp;<a class=headline-hash href=#extensions-for-interfaces>¶</a></h3><p>Interfaces can follow the example of IR interfaces and should be placed in the
appropriate library (e.g., common interfaces in <code>mlir-c/Interfaces</code> and
dialect-specific interfaces in their dialect library). Similarly to other type
hierarchies, interfaces are not expected to have objects of their own type and
instead operate on top-level objects: <code>MlirAttribute</code>, <code>MlirOperation</code> and
<code>MlirType</code>. Static interface methods are expected to take as leading argument a
canonical identifier of the class, <code>MlirStringRef</code> with the name for operations
and <code>MlirTypeID</code> for attributes and types, followed by <code>MlirContext</code> in which
the interfaces are registered.</p><p>Individual interfaces are expected provide a <code>mlir&lt;InterfaceName>TypeID()</code>
function that can be used to check whether an object or a class implements this
interface using <code>mlir&lt;Attribute/Operation/Type>ImplementsInterface</code> or
<code>mlir&lt;Attribute/Operation?Type>ImplementsInterfaceStatic</code> functions,
respectively. Rationale: C++ <code>isa</code> only works when an object exists, static
methods are usually dispatched to using templates; lookup by <code>TypeID</code> in
<code>MLIRContext</code> works even without an object.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/BytecodeFormat/ title="MLIR Bytecode Format"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - MLIR Bytecode Format</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/LangRef/ title="MLIR Language Reference">Next - MLIR Language Reference <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li class=active><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>