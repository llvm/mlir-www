<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Table-driven Declarative Rewrite Rule (DRR) - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/DeclarativeRewrites/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Table-driven Declarative Rewrite Rule (DRR)</h1><p>In addition to subclassing the <code>mlir::RewritePattern</code> C++ class, MLIR also
supports defining rewrite rules in a declarative manner. Similar to
<a href=/docs/DefiningDialects/Operations/>Op Definition Specification</a> (ODS), this is achieved via
<a href=https://llvm.org/docs/TableGen/index.html>TableGen</a>, which is a language to maintain records of domain-specific
information. The rewrite rules are specified concisely in a TableGen record,
which will be expanded into an equivalent <code>mlir::RewritePattern</code> subclass at
compiler build time.</p><p>This manual explains in detail all of the available mechanisms for defining
rewrite rules in such a declarative manner. It aims to be a specification
instead of a tutorial. Please refer to
<a href=/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a>
for the latter.</p><p>Given that declarative rewrite rules depend on op definition specification, this
manual assumes knowledge of the
<a href=/docs/DefiningDialects/Operations/>ODS</a> doc.</p><p><nav id=TableOfContents><ul><li><a href=#benefits>Benefits</a></li><li><a href=#strengths-and-limitations>Strengths and Limitations</a></li><li><a href=#rule-definition>Rule Definition</a><ul><li><a href=#source-pattern>Source pattern</a></li><li><a href=#result-pattern>Result pattern</a></li><li><a href=#supporting-auxiliary-ops>Supporting auxiliary ops</a></li><li><a href=#supporting-multi-result-ops>Supporting multi-result ops</a></li><li><a href=#supporting-variadic-ops>Supporting variadic ops</a></li><li><a href=#supplying-additional-constraints>Supplying additional constraints</a></li><li><a href=#supplying-additional-result-patterns>Supplying additional result patterns</a></li><li><a href=#adjusting-benefits>Adjusting benefits</a></li></ul></li><li><a href=#rewrite-directives>Rewrite directives</a><ul><li><a href=#location><code>location</code></a></li><li><a href=#replacewithvalue><code>replaceWithValue</code></a></li><li><a href=#returntype><code>returnType</code></a></li><li><a href=#either><code>either</code></a></li></ul></li><li><a href=#debugging-tips>Debugging Tips</a><ul><li><a href=#run-mlir-tblgen-to-see-the-generated-content>Run <code>mlir-tblgen</code> to see the generated content</a></li><li><a href=#compilation-error-no-matching-member-function-for-call-to-build>Compilation error: no matching member function for call to &lsquo;build&rsquo;</a></li></ul></li></ul></nav><h2 id=benefits>Benefits&nbsp;<a class=headline-hash href=#benefits>¶</a></h2><p>Compared to the hand-written C++ classes, this declarative approach has several
benefits, including but not limited to:</p><ul><li><strong>Being declarative</strong>: The pattern creator just needs to state the rewrite
pattern declaratively, without worrying about the concrete C++ methods to
call.</li><li><strong>Removing boilerplate and showing the very essence of the rewrite</strong>:
<code>mlir::RewritePattern</code> is already good at hiding boilerplate for defining a
rewrite rule. But we still need to write the class and function structures
required by the C++ programming language, inspect ops for matching, and call
op <code>build()</code> methods for constructing. These statements are typically quite
simple and similar, so they can be further condensed with auto-generation.
Because we reduce the boilerplate to the bare minimum, the declarative
rewrite rule will just contain the very essence of the rewrite. This makes
it very easy to understand the pattern.</li></ul><h2 id=strengths-and-limitations>Strengths and Limitations&nbsp;<a class=headline-hash href=#strengths-and-limitations>¶</a></h2><p>The declarative rewrite rule is <strong>operation-based</strong>: it describes a rule to
match against a directed acyclic graph (DAG) of operations and generate DAGs of
operations. This gives DRR both its strengths and limitations: it is good at
expressing op to op conversions, but not that well suited for, say, converting
an op into a loop nest.</p><p>Per the current implementation, DRR does not have good support for the following
features:</p><ul><li>Matching and generating ops with regions.</li><li>Matching and generating ops with block arguments.</li><li>Matching multi-result ops in nested patterns.</li><li>Matching and generating variadic operand/result ops in nested patterns.</li><li>Packing and unpacking variadic operands/results during generation.</li><li><a href=#nativecodecall-transforming-the-generated-op><code>NativeCodeCall</code></a> returning
more than one results.</li></ul><h2 id=rule-definition>Rule Definition&nbsp;<a class=headline-hash href=#rule-definition>¶</a></h2><p>The core construct for defining a rewrite rule is defined in
[<code>PatternBase.td</code>][PatternBase] as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>class</span> <span class=nv>Pattern</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>dag</span> <span class=nv>sourcePattern</span><span class=p>,</span> <span class=k>list</span><span class=p>&lt;</span><span class=k>dag</span><span class=p>&gt;</span> <span class=nv>resultPatterns</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>list</span><span class=p>&lt;</span><span class=k>dag</span><span class=p>&gt;</span> <span class=nv>additionalConstraints</span> <span class=p>=</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=k>list</span><span class=p>&lt;</span><span class=k>dag</span><span class=p>&gt;</span> <span class=nv>supplementalPatterns</span> <span class=p>=</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=k>dag</span> <span class=nv>benefitsAdded</span> <span class=p>=</span> <span class=p>(</span><span class=nv>addBenefit</span> <span class=m>0</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>A declarative rewrite rule contains two main components:</p><ul><li>A <em>source pattern</em>, which is used for matching a DAG of operations.</li><li>One or more <em>result patterns</em>, which are used for generating DAGs of
operations to replace the matched DAG of operations.</li></ul><p>We allow multiple result patterns to support
<a href=#supporting-multi-result-ops>multi-result ops</a> and
<a href=#supporting-auxiliary-ops>auxiliary ops</a>, but frequently we just want to
convert one DAG of operations to another DAG of operations. There is a handy
wrapper of <code>Pattern</code>, <code>Pat</code>, which takes a single result pattern:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>class</span> <span class=nv>Pat</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=k>dag</span> <span class=nv>sourcePattern</span><span class=p>,</span> <span class=k>dag</span> <span class=nv>resultPattern</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=k>list</span><span class=p>&lt;</span><span class=k>dag</span><span class=p>&gt;</span> <span class=nv>additionalConstraints</span> <span class=p>=</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=k>dag</span> <span class=nv>benefitsAdded</span> <span class=p>=</span> <span class=p>(</span><span class=nv>addBenefit</span> <span class=m>0</span><span class=p>)&gt;</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>Pattern</span><span class=p>&lt;</span><span class=nv>sourcePattern</span><span class=p>,</span> <span class=p>[</span><span class=nv>resultPattern</span><span class=p>],</span> <span class=nv>additionalConstraints</span><span class=p>,</span> <span class=nv>benefitAdded</span><span class=p>&gt;;</span>
</span></span></code></pre></div><p>Each pattern is specified as a TableGen <code>dag</code> object with the syntax of
<code>(operator arg0, arg1, ...)</code>.</p><p><code>operator</code> is typically an MLIR op, but it can also be other
<a href=#rewrite-directives>directives</a>. <code>argN</code> is for matching (if used in source
pattern) or generating (if used in result pattern) the <code>N</code>-th argument for
<code>operator</code>. If the <code>operator</code> is some MLIR operation, it means the <code>N</code>-th
argument as specified in the <code>arguments</code> list of the op&rsquo;s definition. Therefore,
we say op argument specification in pattern is <strong>position-based</strong>: the position
where they appear matters.</p><p><code>argN</code> can be a <code>dag</code> object itself, thus we can have nested <code>dag</code> tree to model
the def-use relationship between ops.</p><h3 id=source-pattern>Source pattern&nbsp;<a class=headline-hash href=#source-pattern>¶</a></h3><p>The source pattern is for matching a DAG of operations. Arguments in the <code>dag</code>
object are intended to <strong>capture</strong> the op arguments. They can also be used to
<strong>further limit</strong> the match criteria. The capturing is done by specifying a
symbol starting with the <code>$</code> sign, while further constraints are introduced by
specifying a <code>TypeConstraint</code> (for an operand), an <code>AttrConstraint</code> (for an
attribute, or a <code>PropConstraint</code> for a property).</p><h4 id=binding-op-arguments-and-limiting-the-match>Binding op arguments and limiting the match&nbsp;<a class=headline-hash href=#binding-op-arguments-and-limiting-the-match>¶</a></h4><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>AOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;a_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$a_input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyAttr</span><span class=p>:</span><span class=nv>$a_attr</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$a_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$attr</span><span class=p>),</span> <span class=p>...&gt;;</span>
</span></span></code></pre></div><p>In the above, we are matching an <code>AOp</code> whose <code>$input</code> can be anything valid as
defined by the op and whose <code>$attr</code> must be a float attribute. If the match
succeeds, we bind the <code>$input</code> symbol to the op&rsquo;s only input (<code>$a_input</code>) and
<code>$attr</code> to the only attribute (<code>$a_attr</code>); we can reference them using <code>$input</code>
and <code>$attr</code> in result patterns and additional constraints.</p><p>The pattern is position-based: the symbol names used for capturing here do not
need to match with the op definition as shown in the above example. As another
example, the pattern can be written as <code>def : Pat&lt;(AOp $a, F32Attr:$b), ...>;</code>
and use <code>$a</code> and <code>$b</code> to refer to the captured input and attribute. But using
the ODS name directly in the pattern is also allowed. Operands in the source
pattern can have the same name. This bounds one operand to the name while
verifying the rest are all equal.</p><p>Also note that we only need to add <code>TypeConstraint</code> or <code>AttributeConstraint</code>
when we need to further limit the match criteria. If all valid cases to the op
are acceptable, then we can leave the constraint unspecified.</p><p><code>$_</code> is a special symbol to mean ignore capturing an argument. For example,
<code>def : Pat&lt;(AOp $_, $b), ...></code> means only <code>$b</code> is interesting to capture and
will be referenced later in result patterns. It&rsquo;s still possible to place
additional constraints even if the symbol is not to be captured; for such case,
you can simply use just the <code>TypeConstraint</code> or <code>AttributeConstraint</code> without a
bound symbol, for example, <code>def : Pat&lt;(AOp $a, F32Attr), ...></code>.</p><h4 id=matching-dag-of-operations>Matching DAG of operations&nbsp;<a class=headline-hash href=#matching-dag-of-operations>¶</a></h4><p>To match a DAG of ops, use nested <code>dag</code> objects:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>BOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;b_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$b_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=p>(</span><span class=nv>BOp</span><span class=p>),</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>...&gt;;</span>
</span></span></code></pre></div><p>The above pattern matches an <code>AOp</code> whose only operand is generated by a <code>BOp</code>,
that is, the following MLIR code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;b_op&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(...)</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;a_op&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span>attr<span class=p>:</span> <span class=p>...}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(...)</span>
</span></span></code></pre></div><h4 id=binding-op-results>Binding op results&nbsp;<a class=headline-hash href=#binding-op-results>¶</a></h4><p>To bind a symbol to the results of a matched op for later reference, attach the
symbol to the op itself:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=p>(</span><span class=nv>BOp</span><span class=p>:</span><span class=nv>$b_result</span><span class=p>),</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>...&gt;;</span>
</span></span></code></pre></div><p>The above will bind <code>$b_result</code> to the matched <code>BOp</code>&rsquo;s result. (There are more
details regarding multi-result ops, which is covered
<a href=#supporting-multi-result-ops>later</a>.)</p><h3 id=result-pattern>Result pattern&nbsp;<a class=headline-hash href=#result-pattern>¶</a></h3><p>The result pattern is for generating a DAG of operations. Arguments in the <code>dag</code>
object are intended to <strong>reference</strong> values captured in the source pattern and
potentially <strong>apply transformations</strong>.</p><h4 id=referencing-bound-symbols>Referencing bound symbols&nbsp;<a class=headline-hash href=#referencing-bound-symbols>¶</a></h4><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>COp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;c_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$c_input</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyAttr</span><span class=p>:</span><span class=nv>$c_attr</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$c_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>COp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>In the above, <code>AOp</code>&rsquo;s only operand and attribute are bound to <code>$input</code> and
<code>$attr</code>, respectively. We then reference them in the result pattern for
generating the <code>COp</code> by passing them in as arguments to <code>COp</code>&rsquo;s <code>build()</code>
method.</p><p>We can also reference symbols bound to matched op&rsquo;s results:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=p>(</span><span class=nv>BOp</span><span class=p>:</span><span class=nv>$b_result</span><span class=p>)</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>COp</span> <span class=nv>$b_result</span> <span class=nv>$attr</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>In the above, we are using <code>BOp</code>&rsquo;s result for building <code>COp</code>.</p><h4 id=building-operations>Building operations&nbsp;<a class=headline-hash href=#building-operations>¶</a></h4><p>Given that <code>COp</code> was specified with table-driven op definition, there will be
several <code>build()</code> methods generated for it. One of them has aggregated
parameters for result types, operands, and properties in the signature: <code>void COp::build(..., ArrayRef&lt;Type> resultTypes, Array&lt;Value> operands, const COp::Properties& properties)</code>. The pattern in the above calls this <code>build()</code>
method for constructing the <code>COp</code>.</p><p>In general, arguments in the result pattern will be passed directly to the
<code>build()</code> method to leverage the auto-generated <code>build()</code> method, list them in
the pattern by following the exact same order as the ODS <code>arguments</code> definition.
Otherwise, a custom <code>build()</code> method that matches the argument list is required.</p><p>Right now all ODS-generated <code>build()</code> methods require specifying the result
type(s), unless the op has known traits like <code>SameOperandsAndResultType</code> that we
can use to auto-generate a <code>build()</code> method with result type deduction. When
generating an op to replace the result of the matched root op, we can use the
matched root op&rsquo;s result type when calling the ODS-generated builder. Otherwise
(e.g., generating an
<a href=#supporting-auxiliary-ops>auxiliary op</a> or generating an
op with a nested result pattern), DRR will not be able to deduce the result
type(s). The pattern author will need to define a custom builder that has result
type deduction ability via <code>OpBuilder</code> in ODS. For example, in the following
pattern</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>COp</span> <span class=p>(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>)</span> <span class=nv>$attr</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p><code>AOp</code> is generated via a nested result pattern; DRR won&rsquo;t be able to deduce the
result type for it. A custom builder for <code>AOp</code> should be defined and it should
deduce the result type by itself. The builder should have the separate parameter
for each operand and attribute and deduce the result type internally by itself.
For example, for the above <code>AOp</code>, a possible builder is:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>AOp</span><span class=o>::</span><span class=n>build</span><span class=p>(</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>builder</span><span class=p>,</span> <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>Value</span> <span class=n>input</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>attr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>addOperands</span><span class=p>({</span><span class=n>input</span><span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>addAttribute</span><span class=p>(</span><span class=s>&#34;a_attr&#34;</span><span class=p>,</span> <span class=n>attr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>Type</span> <span class=n>type</span> <span class=o>=</span> <span class=p>...;</span> <span class=c1>// Deduce result type here
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>state</span><span class=p>.</span><span class=n>addTypes</span><span class=p>({</span><span class=n>type</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Failing to define such a builder will result in an error at C++ compilation time
saying the call to <code>AOp::build()</code> cannot be resolved because of the number of
parameters mismatch.</p><h4 id=generating-dag-of-operations>Generating DAG of operations&nbsp;<a class=headline-hash href=#generating-dag-of-operations>¶</a></h4><p><code>dag</code> objects can be nested to generate a DAG of operations:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>COp</span> <span class=p>(</span><span class=nv>BOp</span><span class=p>),</span> <span class=nv>$attr</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>In the above, we generate a <code>BOp</code>, and then use its result to generate the <code>COp</code>
to replace the matched <code>AOp</code>.</p><h4 id=binding-op-results-1>Binding op results&nbsp;<a class=headline-hash href=#binding-op-results-1>¶</a></h4><p>In the result pattern, we can bind to the result(s) of a newly built op by
attaching symbols to the op. (But we <strong>cannot</strong> bind to op arguments given that
they are referencing previously bound symbols.) This is useful for reusing newly
created results where suitable. For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>DOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;d_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$d_input1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$d_input2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$d_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>AOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$ignored_attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>DOp</span> <span class=p>(</span><span class=nv>BOp</span><span class=p>:</span><span class=nv>$b_result</span><span class=p>)</span> <span class=nv>$b_result</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>In this pattern, an <code>AOp</code> is matched and replaced with a <code>DOp</code> whose two
operands are from the result of a single <code>BOp</code>. This is only possible by binding
the result of the <code>BOp</code> to a name and reuse it for the second operand of the
<code>DOp</code></p><h4 id=nativecodecall-transforming-the-generated-op><code>NativeCodeCall</code>: transforming the generated op&nbsp;<a class=headline-hash href=#nativecodecall-transforming-the-generated-op>¶</a></h4><p>Sometimes the captured arguments are not exactly what we want so they cannot be
directly fed in as arguments to build the new op. For such cases, we can apply
transformations on the arguments by calling into C++ helper functions. This is
achieved by <code>NativeCodeCall</code>.</p><p>For example, if we want to capture some op&rsquo;s attributes and group them as an
array attribute to construct a new op:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>TwoAttrOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;two_attr_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyAttr</span><span class=p>:</span><span class=nv>$op_attr1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyAttr</span><span class=p>:</span><span class=nv>$op_attr2</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$op_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>OneAttrOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;one_attr_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>ArrayAttr</span><span class=p>:</span><span class=nv>$op_attr</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyType</span><span class=p>:</span><span class=nv>$op_output</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can write a C++ helper function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ArrayAttr</span> <span class=nf>createArrayAttr</span><span class=p>(</span><span class=n>Builder</span> <span class=o>&amp;</span><span class=n>builder</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>a</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>builder</span><span class=p>.</span><span class=n>getArrayAttr</span><span class=p>({</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And then write the pattern as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>createArrayAttr</span> <span class=p>:</span> <span class=nv>NativeCodeCall</span><span class=p>&lt;</span><span class=s>&#34;createArrayAttr($_builder, $0, $1)&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>TwoAttrOp</span> <span class=nv>$attr1</span><span class=p>,</span> <span class=nv>$attr2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>OneAttrOp</span> <span class=p>(</span><span class=nv>createArrayAttr</span> <span class=nv>$attr1</span><span class=p>,</span> <span class=nv>$attr2</span><span class=p>))&gt;;</span>
</span></span></code></pre></div><p>And make sure the generated C++ code from the above pattern has access to the
definition of the C++ helper function.</p><p>In the above example, we are using a string to specialize the <code>NativeCodeCall</code>
template. The string can be an arbitrary C++ expression that evaluates into some
C++ object expected at the <code>NativeCodeCall</code> site (here it would be expecting an
array attribute). Typically the string should be a function call.</p><p>In the case of properties, the return value of the <code>NativeCodeCall</code> should
be in terms of the <em>interface</em> type of a property. For example, the <code>NativeCodeCall</code>
for a <code>StringProp</code> should return a <code>StringRef</code>, which will copied into the underlying
<code>std::string</code>, just as if it were an argument to the operation&rsquo;s builder.</p><h5 id=nativecodecall-placeholders><code>NativeCodeCall</code> placeholders&nbsp;<a class=headline-hash href=#nativecodecall-placeholders>¶</a></h5><p>In <code>NativeCodeCall</code>, we can use placeholders like <code>$_builder</code>, <code>$N</code> and <code>$N...</code>.
The former is called <em>special placeholder</em>, while the latter is called
<em>positional placeholder</em> and <em>positional range placeholder</em>.</p><p><code>NativeCodeCall</code> right now only supports three special placeholders:
<code>$_builder</code>, <code>$_loc</code>, and <code>$_self</code>:</p><ul><li><code>$_builder</code> will be replaced by the current <code>mlir::PatternRewriter</code>.</li><li><code>$_loc</code> will be replaced by the fused location or custom location (as
determined by location directive).</li><li><code>$_self</code> will be replaced by the defining operation in a source pattern.</li></ul><p>We have seen how <code>$_builder</code> can be used in the above; it allows us to pass a
<code>mlir::Builder</code> (<code>mlir::PatternRewriter</code> is a subclass of <code>mlir::OpBuilder</code>,
which is a subclass of <code>mlir::Builder</code>) to the C++ helper function to use the
handy methods on <code>mlir::Builder</code>.</p><p>Here&rsquo;s an example how we should use <code>$_self</code> in source pattern,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>OneAttrOp</span> <span class=p>(</span><span class=nv>NativeCodeCall</span><span class=p>&lt;</span><span class=s>&#34;Foo($_self, &amp;$0)&#34;</span><span class=p>&gt;</span> <span class=nv>I32Attr</span><span class=p>:</span><span class=nv>$val</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>TwoAttrOp</span> <span class=nv>$val</span><span class=p>,</span> <span class=nv>$val</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>In the above, <code>$_self</code> is substituted by the defining operation of the first
operand of OneAttrOp. Note that we don&rsquo;t support binding name to
<code>NativeCodeCall</code> in the source pattern. To carry some return values from a
helper function, put the names (constraint is optional) in the parameter list
and they will be bound to the variables with corresponding type. Then these names
must be either passed by reference or pointer to the variable used as argument
so that the matched value can be returned. In the same example, <code>$val</code> will be
bound to a variable with <code>Attribute</code> type (as <code>I32Attr</code>) and the type of the
second argument in <code>Foo()</code> could be <code>Attribute&</code> or <code>Attribute*</code>. Names with
attribute constraints will be captured as <code>Attribute</code>s, names with
property constraints (which must have a concrete interface type) will be treated
as that type, and everything else will be treated as <code>Value</code>s.</p><p>Positional placeholders will be substituted by the <code>dag</code> object parameters at
the <code>NativeCodeCall</code> use site. For example, if we define <code>SomeCall : NativeCodeCall&lt;"someFn($1, $2, $0)"></code> and use it like <code>(SomeCall $in0, $in1, $in2)</code>, then this will be translated into C++ call <code>someFn($in1, $in2, $in0)</code>.</p><p>In the case of properties, the placeholder will be bound to a value of the <em>interface</em>
type of the property. For example, passing in a <code>StringProp</code> as an argument to a <code>NativeCodeCall</code> will pass a <code>StringRef</code> (as if the getter of the matched
operation were called) and not a <code>std::string</code>. See
<code>mlir/include/mlir/IR/Properties.td</code> for details on interface vs. storage type.</p><p>Positional range placeholders will be substituted by multiple <code>dag</code> object
parameters at the <code>NativeCodeCall</code> use site. For example, if we define
<code>SomeCall : NativeCodeCall&lt;"someFn($1...)"></code> and use it like <code>(SomeCall $in0, $in1, $in2)</code>, then this will be translated into C++ call <code>someFn($in1, $in2)</code>.</p><h5 id=nativecodecall-binding-multi-results><code>NativeCodeCall</code> binding multi-results&nbsp;<a class=headline-hash href=#nativecodecall-binding-multi-results>¶</a></h5><p>To bind multi-results and access the N-th result with <code>$&lt;name>__N</code>, specify the
number of return values in the template. Note that only <code>Value</code> type is
supported for multiple results binding. For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>PackAttrs</span> <span class=p>:</span> <span class=nv>NativeCodeCall</span><span class=p>&lt;</span><span class=s>&#34;packAttrs($0, $1)&#34;</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>TwoResultOp</span> <span class=nv>$attr1</span><span class=p>,</span> <span class=nv>$attr2</span><span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>OneResultOp</span> <span class=p>(</span><span class=nv>PackAttr</span><span class=p>:</span><span class=nv>$res__0</span><span class=p>,</span> <span class=nv>$attr1</span><span class=p>,</span> <span class=nv>$attr2</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nv>OneResultOp</span> <span class=nv>$res__1</span><span class=p>)]&gt;;</span>
</span></span></code></pre></div><p>Use <code>NativeCodeCallVoid</code> for cases with no return value.</p><p>The correct number of returned value specified in NativeCodeCall is important.
It will be used to verify the consistency of the number of return values.
Additionally, <code>mlir-tblgen</code> will try to capture the return values of
<code>NativeCodeCall</code> in the generated code so that it will trigger a later
compilation error if a <code>NativeCodeCall</code> that doesn&rsquo;t return any result isn&rsquo;t
labeled with 0 returns.</p><h5 id=customizing-entire-op-building>Customizing entire op building&nbsp;<a class=headline-hash href=#customizing-entire-op-building>¶</a></h5><p><code>NativeCodeCall</code> is not only limited to transforming arguments for building an
op; it can be also used to specify how to build an op entirely. An example:</p><p>If we have a C++ function for building an op:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>Operation</span> <span class=o>*</span><span class=nf>createMyOp</span><span class=p>(</span><span class=n>OpBuilder</span> <span class=n>builder</span><span class=p>,</span> <span class=n>Value</span> <span class=n>input</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>attr</span><span class=p>);</span>
</span></span></code></pre></div><p>We can wrap it up and invoke it like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>createMyOp</span> <span class=p>:</span> <span class=nv>NativeCodeCall</span><span class=p>&lt;</span><span class=s>&#34;createMyOp($_builder, $0, $1)&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(...</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>),</span> <span class=p>(</span><span class=nv>createMyOp</span> <span class=nv>$input</span><span class=p>,</span> <span class=nv>$attr</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><h3 id=supporting-auxiliary-ops>Supporting auxiliary ops&nbsp;<a class=headline-hash href=#supporting-auxiliary-ops>¶</a></h3><p>A declarative rewrite rule supports multiple result patterns. One of the
purposes is to allow generating <em>auxiliary ops</em>. Auxiliary ops are operations
used for building the replacement ops; but they are not directly used for
replacement themselves.</p><p>For the case of uni-result ops, if there are multiple result patterns, only the
value generated from the last result pattern will be used to replace the matched
root op&rsquo;s result; all other result patterns will be considered as generating
auxiliary ops.</p><p>Normally we want to specify ops as nested <code>dag</code> objects if their def-use
relationship can be expressed in the way that an op&rsquo;s result can feed as the
argument to consuming op. But that is not always possible. For example, if we
want to allocate memory and store some computation (in pseudocode):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dst</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span>
</span></span></code></pre></div><p>into</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%shape</span> <span class=p>=</span> shape <span class=nv>%lhs</span>
</span></span><span class=line><span class=cl><span class=nv>%mem</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc <span class=nv>%shape</span>
</span></span><span class=line><span class=cl><span class=nv>%sum</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span>
</span></span><span class=line><span class=cl><span class=kt>memref</span><span class=p>.</span>store <span class=nv>%mem</span><span class=p>,</span> <span class=nv>%sum</span>
</span></span><span class=line><span class=cl><span class=nv>%dst</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%mem</span>
</span></span></code></pre></div><p>We cannot fit in with just one result pattern given <code>store</code> does not return a
value. Instead we can use multiple result patterns:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>AddIOp</span> <span class=nv>$lhs</span><span class=p>,</span> <span class=nv>$rhs</span><span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>StoreOp</span> <span class=p>(</span><span class=nv>AllocOp</span><span class=p>:</span><span class=nv>$mem</span> <span class=p>(</span><span class=nv>ShapeOp</span> <span class=nv>$lhs</span><span class=p>)),</span> <span class=p>(</span><span class=nv>AddIOp</span> <span class=nv>$lhs</span><span class=p>,</span> <span class=nv>$rhs</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nv>LoadOp</span> <span class=nv>$mem</span><span class=p>)];</span>
</span></span></code></pre></div><p>In the above we use the first result pattern to generate the first four ops, and
use the last pattern to generate the last op, which is used to replace the
matched op.</p><h3 id=supporting-multi-result-ops>Supporting multi-result ops&nbsp;<a class=headline-hash href=#supporting-multi-result-ops>¶</a></h3><p>Multi-result ops bring extra complexity to declarative rewrite rules. We use
TableGen <code>dag</code> objects to represent ops in patterns; there is no native way to
indicate that an op generates multiple results. The approach adopted is based on
<strong>naming convention</strong>: a <code>__N</code> suffix is added to a symbol to indicate the
<code>N</code>-th result.</p><h4 id=__n-suffix><code>__N</code> suffix&nbsp;<a class=headline-hash href=#__n-suffix>¶</a></h4><p>The <code>__N</code> suffix is specifying the <code>N</code>-th result as a whole (which can be
<a href=#supporting-variadic-ops>variadic</a>). For example, we can bind a symbol to some
multi-result op and reference a specific result later:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>ThreeResultOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;three_result_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=p>...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$output1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$output2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$output3</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span><span class=p>:</span><span class=nv>$results</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(...</span> <span class=nv>$results__0</span><span class=p>),</span> <span class=p>...,</span> <span class=p>(...</span> <span class=nv>$results__2</span><span class=p>),</span> <span class=p>...]&gt;;</span>
</span></span></code></pre></div><p>In the above pattern we bind <code>$results</code> to all the results generated by
<code>ThreeResultOp</code> and references its <code>$output1</code> and <code>$output3</code> later in the result
patterns.</p><p>We can also bind a symbol and reference one of its specific result at the same
time, which is typically useful when generating multi-result ops:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// TwoResultOp has similar definition as ThreeResultOp, but only has two
</span></span></span><span class=line><span class=cl><span class=c>// results.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>TwoResultOp</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>ThreeResultOp</span><span class=p>:</span><span class=nv>$results__2</span><span class=p>,</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nv>replaceWithValue</span> <span class=nv>$results__0</span><span class=p>)]&gt;;</span>
</span></span></code></pre></div><p>In the above, we created a <code>ThreeResultOp</code> and bind <code>results</code> to its results,
and uses its last result (<code>$output3</code>) and first result (<code>$output1</code>) to replace
the <code>TwoResultOp</code>&rsquo;s two results, respectively.</p><h4 id=replacing-multi-result-ops>Replacing multi-result ops&nbsp;<a class=headline-hash href=#replacing-multi-result-ops>¶</a></h4><p>The above example also shows how to replace a matched multi-result op.</p><p>To replace an <code>N</code>-result op, the result patterns must generate at least <code>N</code>
declared values (see
<a href=#declared-vs-actual-value>Declared vs. actual value</a> for
definition). If there are more than <code>N</code> declared values generated, only the last
<code>N</code> declared values will be used to replace the matched op. Note that because of
the existence of multi-result op, one result pattern <strong>may</strong> generate multiple
declared values. So it means we do not necessarily need <code>N</code> result patterns to
replace an <code>N</code>-result op. For example, to replace an op with three results, you
can have</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// ThreeResultOp/TwoResultOp/OneResultOp generates three/two/one result(s),
</span></span></span><span class=line><span class=cl><span class=c>// respectively.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// Replace each result with a result generated from an individual op.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>OneResultOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>OneResultOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>OneResultOp</span> <span class=p>...)]&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Replace the first two results with two results generated from the same op.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>TwoResultOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>OneResultOp</span> <span class=p>...)]&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Replace all three results with three results generated from the same op.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>ThreeResultOp</span> <span class=p>...)&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>AuxiliaryOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>ThreeResultOp</span> <span class=p>...)]&gt;;</span>
</span></span></code></pre></div><p>But using a single op to serve as both auxiliary op and replacement op is
forbidden, i.e., the following is not allowed because that the first
<code>TwoResultOp</code> generates two results but only the second result is used for
replacing the matched op&rsquo;s result:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>ThreeResultOp</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>TwoResultOp</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>TwoResultOp</span> <span class=p>...)]&gt;;</span>
</span></span></code></pre></div><h3 id=supporting-variadic-ops>Supporting variadic ops&nbsp;<a class=headline-hash href=#supporting-variadic-ops>¶</a></h3><h4 id=declared-vs-actual-value>Declared vs. actual value&nbsp;<a class=headline-hash href=#declared-vs-actual-value>¶</a></h4><p>Before going into details on variadic op support, we need to define a few terms
regarding an op&rsquo;s values.</p><ul><li><em>Value</em>: either an operand or a result</li><li><em>Declared operand/result/value</em>: an operand/result/value statically declared
in ODS of the op</li><li><em>Actual operand/result/value</em>: an operand/result/value of an op instance at
runtime</li></ul><p>The above terms are needed because ops can have multiple results, and some of
the results can also be variadic. For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>MultiVariadicOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=s>&#34;multi_variadic_op&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$input1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>Variadic</span><span class=p>&lt;</span><span class=nv>AnyTensor</span><span class=p>&gt;:</span><span class=nv>$input2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$input3</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$output1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>Variadic</span><span class=p>&lt;</span><span class=nv>AnyTensor</span><span class=p>&gt;:</span><span class=nv>$output2</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>AnyTensor</span><span class=p>:</span><span class=nv>$output3</span>
</span></span><span class=line><span class=cl>    <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We say the above op has 3 declared operands and 3 declared results. But at
runtime, an instance can have 3 values corresponding to <code>$input2</code> and 2 values
correspond to <code>$output2</code>; we say it has 5 actual operands and 4 actual results.
A variadic operand/result is a considered as a declared value that can
correspond to multiple actual values.</p><p>[TODO]</p><h4 id=match-variadic-operand>Match variadic operand&nbsp;<a class=headline-hash href=#match-variadic-operand>¶</a></h4><p>Use the <code>variadic</code> DAG node to match a variadic operand with a fixed number of
actual sub-operands.</p><p>For example, assume that <code>ConcatenateOp</code> is an operation with a variadic
operand:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>ConcatenateOp</span> <span class=p>:</span> <span class=nv>TEST_Op</span><span class=p>&lt;</span><span class=s>&#34;concatenate&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>    <span class=nv>Variadic</span><span class=p>&lt;</span><span class=nv>AnyTensor</span><span class=p>&gt;:</span><span class=nv>$inputs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>I32Attr</span><span class=p>:</span><span class=nv>$axis</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span>
</span></span><span class=line><span class=cl>    <span class=nv>AnyTensor$output</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can match <code>ConcatenateOp</code> with exactly 2 actual operands with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>ConcatenateOp</span> <span class=p>(</span><span class=nv>variadic</span> <span class=nv>$input0</span><span class=p>,</span> <span class=nv>$input1</span><span class=p>),</span> <span class=nv>$axis</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>...&gt;;</span>
</span></span></code></pre></div><p>The variadic sub-operands can be sub-DAGs to be matched:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>ConcatenateOp</span> <span class=p>(</span><span class=nv>variadic</span> <span class=p>(</span><span class=nv>SomeOp</span> <span class=nv>$a</span><span class=p>),</span> <span class=p>(</span><span class=nv>AnotherOp</span> <span class=nv>$b</span><span class=p>,</span> <span class=nv>$c</span><span class=p>)),</span> <span class=nv>$axis</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>OtherOp</span> <span class=nv>$a</span><span class=p>,</span> <span class=nv>$b</span><span class=p>,</span> <span class=nv>$c</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>The variadic DAG can be bound to a symbol, which refers to the full
<code>operand_range</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>ConcatenateOp</span> <span class=p>(</span><span class=nv>variadic</span><span class=p>:</span><span class=nv>$inputs</span> <span class=nv>$input0</span><span class=p>,</span> <span class=nv>$input1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                         <span class=nv>ConstantAttr</span><span class=p>&lt;</span><span class=nv>I32Attr</span><span class=p>,</span> <span class=s>&#34;0&#34;</span><span class=p>&gt;),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>VStackOp</span> <span class=nv>$inputs</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><h3 id=supplying-additional-constraints>Supplying additional constraints&nbsp;<a class=headline-hash href=#supplying-additional-constraints>¶</a></h3><p>Constraints can be placed on op arguments when matching. But sometimes we need
to also place constraints on the matched op&rsquo;s results or sometimes need to limit
the matching with some constraints that cover both the arguments and the
results. The third parameter to <code>Pattern</code> (and <code>Pat</code>) is for this purpose.</p><p>For example, we can write</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>HasNoUseOf</span><span class=p>:</span> <span class=nv>Constraint</span><span class=p>&lt;</span><span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;$_self.use_empty()&#34;</span><span class=p>&gt;,</span> <span class=s>&#34;has no use&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>HasSameElementType</span> <span class=p>:</span> <span class=nv>Constraint</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>CPred</span><span class=p>&lt;</span><span class=s>&#34;cast&lt;ShapedType&gt;($0).getElementType() == &#34;</span>
</span></span><span class=line><span class=cl>          <span class=s>&#34;cast&lt;ShapedType&gt;($1).getElementType()&#34;</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;has same element type&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;(</span><span class=nv>TwoResultOp</span><span class=p>:</span><span class=nv>$results</span> <span class=nv>$input</span><span class=p>),</span>
</span></span><span class=line><span class=cl>              <span class=p>[(...),</span> <span class=p>(...)],</span>
</span></span><span class=line><span class=cl>              <span class=p>[(</span><span class=nv>F32Tensor</span><span class=p>:</span><span class=nv>$results__0</span><span class=p>),</span> <span class=p>(</span><span class=nv>HasNoUseOf</span><span class=p>:</span><span class=nv>$results__1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>               <span class=p>(</span><span class=nv>HasSameElementShape</span> <span class=nv>$results__0</span><span class=p>,</span> <span class=nv>$input</span><span class=p>)]&gt;;</span>
</span></span></code></pre></div><p>You can</p><ul><li>Use normal <code>TypeConstraint</code>s on previous bound symbols (the first result of
<code>TwoResultOp</code> must be a float tensor);</li><li>Define new <code>Constraint</code> for previous bound symbols (the second result of
<code>TwoResultOp</code> must has no use);</li><li>Apply constraints on multiple bound symbols (<code>$input</code> and <code>TwoResultOp</code>&rsquo;s
first result must have the same element type).</li></ul><h3 id=supplying-additional-result-patterns>Supplying additional result patterns&nbsp;<a class=headline-hash href=#supplying-additional-result-patterns>¶</a></h3><p>Sometimes we need to add additional code after the result patterns, e.g. coping
the attributes of the source op to the result ops. These can be specified via
<code>SupplementalPatterns</code> parameter. Similar to auxiliary patterns, they are not
for replacing results in the source pattern.</p><p>For example, we can write</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>GetOwner</span><span class=p>:</span> <span class=nv>NativeCodeCall</span><span class=p>&lt;</span><span class=s>&#34;$0.getOwner()&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>CopyAttrFoo</span><span class=p>:</span> <span class=nv>NativeCodeCallVoid</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;$1-&gt;setAttr($_builder.getStringAttr(\&#34;</span><span class=nv>foo</span><span class=err>\</span><span class=s>&#34;), $0-&gt;getInherentAttr(\&#34;</span><span class=nv>foo</span><span class=err>\</span><span class=s>&#34;))&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>CopyAttrBar</span><span class=p>:</span> <span class=nv>NativeCodeCallVoid</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;$1-&gt;setAttr($_builder.getStringAttr(\&#34;</span><span class=nv>bar</span><span class=err>\</span><span class=s>&#34;), $0-&gt;getInherentAttr(\&#34;</span><span class=nv>bar</span><span class=err>\</span><span class=s>&#34;))&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pattern</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>ThreeResultOp</span><span class=p>:</span><span class=nv>$src</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=nv>ZeroResultOp</span><span class=p>:</span><span class=nv>$dest1</span> <span class=p>...),</span> <span class=p>(</span><span class=nv>ThreeResultOp</span><span class=p>:</span><span class=nv>$dest2</span> <span class=p>...)],</span>
</span></span><span class=line><span class=cl>  <span class=p>[(</span><span class=nv>CopyAttrFoo</span> <span class=p>(</span><span class=nv>GetOwner</span> <span class=nv>$src</span><span class=p>),</span> <span class=nv>$dest1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>CopyAttrBar</span> <span class=p>(</span><span class=nv>GetOwner</span> <span class=nv>$src</span><span class=p>),</span> <span class=p>(</span><span class=nv>GetOwner</span> <span class=nv>$dest2</span><span class=p>))]&gt;;</span>
</span></span></code></pre></div><p>This will copy the attribute <code>foo</code> and <code>bar</code> of <code>ThreeResultOp</code> in the source
pattern to <code>ZeroResultOp</code> and <code>ThreeResultOp</code> in the result patterns respectively.
The patterns are executed in specified order.</p><h3 id=adjusting-benefits>Adjusting benefits&nbsp;<a class=headline-hash href=#adjusting-benefits>¶</a></h3><p>The benefit of a <code>Pattern</code> is an integer value indicating the benefit of
matching the pattern. It determines the priorities of patterns inside the
pattern rewrite driver. A pattern with a higher benefit is applied before one
with a lower benefit.</p><p>In DRR, a rule is set to have a benefit of the number of ops in the source
pattern. This is based on the heuristics and assumptions that:</p><ul><li>Larger matches are more beneficial than smaller ones.</li><li>If a smaller one is applied first the larger one may not apply anymore.</li></ul><p>The fourth parameter to <code>Pattern</code> (and <code>Pat</code>) allows to manually tweak a
pattern&rsquo;s benefit. Just supply <code>(addBenefit N)</code> to add <code>N</code> to the benefit value.</p><h2 id=rewrite-directives>Rewrite directives&nbsp;<a class=headline-hash href=#rewrite-directives>¶</a></h2><h3 id=location><code>location</code>&nbsp;<a class=headline-hash href=#location>¶</a></h3><p>By default the C++ pattern expanded from a DRR pattern uses the fused location
of all source ops as the location for all generated ops. This is not always the
best location mapping relationship. For such cases, DRR provides the <code>location</code>
directive to provide finer control.</p><p><code>location</code> is of the following syntax:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=p>(</span><span class=nv>location</span> <span class=nv>$symbol0</span><span class=p>,</span> <span class=nv>$symbol1</span><span class=p>,</span> <span class=p>...)</span>
</span></span></code></pre></div><p>where all <code>$symbol</code> should be bound previously in the pattern and one optional
string may be specified as an attribute. The following locations are created:</p><ul><li>If only 1 symbol is specified then that symbol&rsquo;s location is used,</li><li>If multiple are specified then a fused location is created;</li><li>If no symbol is specified then string must be specified and a NamedLoc is
created instead;</li></ul><p><code>location</code> must be used as a trailing argument to an op creation. For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>LocSrc1Op</span><span class=p>:</span><span class=nv>$src1</span> <span class=p>(</span><span class=nv>LocSrc2Op</span><span class=p>:</span><span class=nv>$src2</span> <span class=p>...),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>LocDst1Op</span> <span class=p>(</span><span class=nv>LocDst2Op</span> <span class=p>...,</span> <span class=p>(</span><span class=nv>location</span> <span class=nv>$src2</span><span class=p>)),</span> <span class=p>(</span><span class=nv>location</span> <span class=s>&#34;outer&#34;</span><span class=p>))&gt;;</span>
</span></span></code></pre></div><p>In the above pattern, the generated <code>LocDst2Op</code> will use the matched location of
<code>LocSrc2Op</code> while the root <code>LocDst1Op</code> node will used the named location
<code>outer</code>.</p><h3 id=replacewithvalue><code>replaceWithValue</code>&nbsp;<a class=headline-hash href=#replacewithvalue>¶</a></h3><p>The <code>replaceWithValue</code> directive is used to eliminate a matched op by replacing
all of its uses with a captured value. It is of the following syntax:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=p>(</span><span class=nv>replaceWithValue</span> <span class=nv>$symbol</span><span class=p>)</span>
</span></span></code></pre></div><p>where <code>$symbol</code> should be a symbol bound previously in the pattern.</p><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>Foo</span> <span class=nv>$input</span><span class=p>),</span> <span class=p>(</span><span class=nv>replaceWithValue</span> <span class=nv>$input</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><p>The above pattern removes the <code>Foo</code> and replaces all uses of <code>Foo</code> with
<code>$input</code>.</p><h3 id=returntype><code>returnType</code>&nbsp;<a class=headline-hash href=#returntype>¶</a></h3><p>The <code>returnType</code> directive allows patterns to directly specify return types for
replacement ops that lack return type inference with op traits or user-defined
builders with return type deduction.</p><p>The <code>returnType</code> directive must be used as a trailing argument to a node
describing a replacement op. The directive comes in three forms:</p><ul><li><code>(returnType $value)</code>: copy the type of the operand or result bound to
<code>value</code>.</li><li><code>(returnType "$_builder.getI32Type()")</code>: a string literal embedding C++. The
embedded snippet is expected to return a <code>Type</code> or a <code>TypeRange</code>.</li><li><code>(returnType (NativeCodeCall&lt;"myFunc($0)"> $value))</code>: a DAG node with a
native code call that can be passed any bound variables arguments.</li></ul><p>Specify multiple return types with a mix of any of the above. Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>SourceOp</span> <span class=nv>$arg0</span><span class=p>,</span> <span class=nv>$arg1</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>OpA</span> <span class=nv>$arg0</span><span class=p>,</span> <span class=p>(</span><span class=nv>TwoResultOp</span><span class=p>:</span><span class=nv>$res__1</span> <span class=nv>$arg1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                         <span class=p>(</span><span class=nv>returnType</span> <span class=nv>$arg1</span><span class=p>,</span> <span class=s>&#34;$_builder.getI64Type()&#34;</span><span class=p>)))&gt;;</span>
</span></span></code></pre></div><p>Explicitly-specified return types will take precedence over return types
inferred from op traits or user-defined builders. The return types of values
replacing root op results cannot be overridden.</p><h3 id=either><code>either</code>&nbsp;<a class=headline-hash href=#either>¶</a></h3><p>The <code>either</code> directive is used to specify the operands may be matched in either
order.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>TwoArgOp</span> <span class=p>(</span><span class=nv>either</span> <span class=nv>$firstArg</span><span class=p>,</span> <span class=p>(</span><span class=nv>AnOp</span> <span class=nv>$secondArg</span><span class=p>))),</span>
</span></span><span class=line><span class=cl>          <span class=p>(...)&gt;;</span>
</span></span></code></pre></div><p>The above pattern will accept either <code>"test.TwoArgOp"(%I32Arg, %AnOpArg)</code> and
<code>"test.TwoArgOp"(%AnOpArg, %I32Arg)</code>.</p><p>Only operand is supported with <code>either</code> and note that an operation with
<code>Commutative</code> trait doesn&rsquo;t imply that it&rsquo;ll have the same behavior than
<code>either</code> while pattern matching.</p><h2 id=debugging-tips>Debugging Tips&nbsp;<a class=headline-hash href=#debugging-tips>¶</a></h2><h3 id=run-mlir-tblgen-to-see-the-generated-content>Run <code>mlir-tblgen</code> to see the generated content&nbsp;<a class=headline-hash href=#run-mlir-tblgen-to-see-the-generated-content>¶</a></h3><p>TableGen syntax sometimes can be obscure; reading the generated content can be a
very helpful way to understand and debug issues. To build <code>mlir-tblgen</code>, run
<code>cmake --build . --target mlir-tblgen</code> in your build directory and find the
<code>mlir-tblgen</code> binary in the <code>bin/</code> subdirectory. All the supported generators
can be found via <code>mlir-tblgen --help</code>.</p><p>To see the generated code, invoke <code>mlir-tblgen</code> with a specific generator by
providing include paths via <code>-I</code>. For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># To see all the C++ pattern rewrite classes</span>
</span></span><span class=line><span class=cl>mlir-tblgen --gen-rewriters -I /path/to/mlir/include /path/to/input/td/file
</span></span></code></pre></div><h3 id=compilation-error-no-matching-member-function-for-call-to-build>Compilation error: no matching member function for call to &lsquo;build&rsquo;&nbsp;<a class=headline-hash href=#compilation-error-no-matching-member-function-for-call-to-build>¶</a></h3><p>This is because DRR is failing to call a <code>build()</code> method with result type
deduction ability. See
<a href=#building-operations>building operations</a> for more
details.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/ title="Symbols and Symbol Tables"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Symbols and Symbol Tables</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Traits/ title=Traits>Next - Traits <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li class=active><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>