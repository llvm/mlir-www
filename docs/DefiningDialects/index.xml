<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Defining Dialects on MLIR</title><link>https://mlir.llvm.org/docs/DefiningDialects/</link><description>Recent content in Defining Dialects on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/DefiningDialects/index.xml" rel="self" type="application/rss+xml"/><item><title>Constraints</title><link>https://mlir.llvm.org/docs/DefiningDialects/Constraints/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DefiningDialects/Constraints/</guid><description>Attribute / Type Constraints Attribute / Type Constraints When defining the arguments of an operation in TableGen, users can specify either plain attributes/types or use attribute/type constraints to levy additional requirements on the attribute value or operand type.
def My_Type1 : MyDialect_Type&amp;lt;&amp;#34;Type1&amp;#34;, &amp;#34;type1&amp;#34;&amp;gt; { ... } def My_Type2 : MyDialect_Type&amp;lt;&amp;#34;Type2&amp;#34;, &amp;#34;type2&amp;#34;&amp;gt; { ... } // Plain type let arguments = (ins MyType1:$val); // Type constraint let arguments = (ins AnyTypeOf&amp;lt;[MyType1, MyType2]&amp;gt;:$val); AnyTypeOf is an example for a type constraints.</description></item><item><title>Customizing Assembly Behavior</title><link>https://mlir.llvm.org/docs/DefiningDialects/Assembly/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DefiningDialects/Assembly/</guid><description>Generating Aliases OpAsmDialectInterface OpAsmAttrInterface and OpAsmTypeInterface Suggesting SSA/Block Names Defining Default Dialect Generating Aliases AsmPrinter can generate aliases for frequently used types and attributes when not printing them in generic form. For example, !my_dialect.type&amp;lt;a=3,b=4,c=5,d=tuple,e=another_type&amp;gt; and #my_dialect.attr&amp;lt;a=3&amp;gt; can be aliased to !my_dialect_type and #my_dialect_attr.
There are mainly two ways to hook into the AsmPrinter. One is the attribute/type interface and the other is the dialect interface.
The attribute/type interface is the first hook to check.</description></item><item><title>Defining Dialect Attributes and Types</title><link>https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/</guid><description>This document describes how to define dialect attributes and types.
LangRef Refresher Attributes Types Attributes and Types Adding a new Attribute or Type definition Class Name CMake Targets Documentation Mnemonic Parameters Traits Interfaces Builders Parsing and Printing Verification Storage Classes Mutable attributes and types Extra declarations Mnemonic Alias in Assembly Registering with the Dialect LangRef Refresher Before diving into how to define these constructs, below is a quick refresher from the MLIR LangRef.</description></item><item><title>Operation Definition Specification (ODS)</title><link>https://mlir.llvm.org/docs/DefiningDialects/Operations/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/DefiningDialects/Operations/</guid><description>In addition to specializing the mlir::Op C++ template, MLIR also supports defining operations and data types in a table-driven manner. This is achieved via TableGen, which is both a generic language and its tooling to maintain records of domain-specific information. Facts regarding an operation are specified concisely into a TableGen record, which will be expanded into an equivalent mlir::Op C++ template specialization at compiler build time.
This manual explains in detail all the available mechanisms for defining operations in such a table-driven manner.</description></item></channel></rss>