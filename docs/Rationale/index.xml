<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rationale on MLIR</title><link>https://mlir.llvm.org/docs/Rationale/</link><description>Recent content in Rationale on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Rationale/index.xml" rel="self" type="application/rss+xml"/><item><title>Generic DAG Rewriter Infrastructure Rationale</title><link>https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/</guid><description>This document details the rationale behind a general DAG-to-DAG rewrite infrastructure for MLIR. For up-to-date documentation on the user facing API, please look at the main Pattern Rewriting document.
Introduction and Motivation The goal of a compiler IR is to represent code - at various levels of abstraction which pose different sets of tradeoffs in terms of representational capabilities and ease of transformation. However, the ability to represent code is not itself very useful - you also need to be able to implement those transformations.</description></item><item><title>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</title><link>https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/</guid><description>Introduction Positioning Inception Evolution Prior Art Lessons from ONNX Lessons from LIFT Lessons from XLA Lessons from Halide and TVM Lessons from Tensor Comprehensions Lessons from Polyhedral compilers Lessons from the Affine dialect Core Guiding Principles Transformations and Simplicity First Preservation of Information Composable and Declarative Transformations Suitability for Search and Machine Learning Extensibility and Future-Proofness Key Observations Algorithms + Data Structures = Programs The Dialect Need not be Closed Under Transformations Summary of Existing Alternatives a Picture Introduction Positioning This document describes the key design principles that led to the existing implementation of Linalg and aims at exposing the tradeoffs involved when building higher-level Intermediate Representations (IR) and Dialects to facilitate code generation.</description></item><item><title>MLIR Rationale</title><link>https://mlir.llvm.org/docs/Rationale/Rationale/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/Rationale/</guid><description>This document is intended to capture some of the alternatives considered and open debates in the design of MLIR, along with the rationale for certain decisions we made. This is not intended to be a &amp;ldquo;finely groomed&amp;rdquo; document - we prefer the ability to dump in interesting tidbits without worrying too much about their consistency or readability.
Abstract Introduction and Motivation Design Decisions Loads and stores Symbols and types Block Arguments vs PHI nodes Index type usage and limitations Data layout of non-primitive types Integer signedness semantics Splitting floating point vs integer operations Specifying sign in integer comparison operations Specifying comparison kind as attribute Regions Dialect type extensions Tuple types Assembly forms Examples Non-affine control flow Non-affine loop bounds Reference 2D Convolution Design alternatives and extensions Polyhedral code representation alternatives: schedule lists vs schedules trees vs affine loop/if forms Affine Relations Regions Read/Write/May_Read/May_Write sets for External Functions Memref Extensions affine.</description></item><item><title>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</title><link>https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/</guid><description>The existing documentation about MLIR focuses on long term vision, how its pieces fit together, and the benefits of modular and composable infrastructure in the vast and distant future. While this viewpoint appeals to some, it causes concern for others who are more concerned about the &amp;ldquo;here and now&amp;rdquo; - why does it make sense to make a &amp;ldquo;revolutionary&amp;rdquo; change when any individual problem can be fixed in place?
This document explains that adoption of MLIR to solve graph based problems isn&amp;rsquo;t a revolutionary change: it is an incremental series of steps which build on each other, each of which delivers local value.</description></item><item><title>MLIR: The case for a simplified polyhedral form</title><link>https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/</guid><description>MLIR embraces polyhedral compiler techniques for their many advantages representing and transforming dense numerical kernels, but it uses a form that differs significantly from other polyhedral frameworks.
Disclaimer / Warning
This document is a very early design proposal (which has since been accepted) that explored the tradeoffs of using this simplified form vs the traditional polyhedral schedule list form. At some point, this document could be dusted off and written as a proper academic paper, but until now, it is better to included it in this crafty form than not to.</description></item><item><title>Side Effects &amp; Speculation</title><link>https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/</guid><description>This document outlines how MLIR models side effects and how speculation works in MLIR.
This rationale only applies to operations used in CFG regions. Side effect modeling in graph regions is TBD.
Overview Categorization Modeling Examples SIMD compute operation Load like operation Overview Many MLIR operations don&amp;rsquo;t exhibit any behavior other than consuming and producing SSA values. These operations can be reordered with other operations as long as they obey SSA dominance requirements and can be eliminated or even introduced (e.</description></item><item><title>Usage of 'const' in MLIR, for core IR types</title><link>https://mlir.llvm.org/docs/Rationale/UsageOfConst/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Rationale/UsageOfConst/</guid><description>aka, where&amp;rsquo;d const go?
The MLIR data structures that represent the IR itself (Instruction, Block, etc) form a graph-based data structure, and the compiler analyses and passes frequently walk this graph (e.g. traversing from defs to users). The early design of MLIR adopted the const model of LLVM, which is familiar and well understood (even though the LLVM implementation is flawed in many ways).
The design team since decided to change to a different model, which eschews const entirely for the core IR types: you should never see a const method on Operation, should never see the type const Value, and you shouldn&amp;rsquo;t feel bad about this.</description></item></channel></rss>