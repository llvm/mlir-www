<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Usage of 'const' in MLIR, for core IR types - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Usage of 'const' in MLIR, for core IR types</h1><p>aka, where&rsquo;d <code>const</code> go?</p><p>The MLIR data structures that represent the IR itself (Instruction, Block, etc)
form a graph-based data structure, and the compiler analyses and passes
frequently walk this graph (e.g. traversing from defs to users). The early
design of MLIR adopted the <code>const</code> model of LLVM, which is familiar and well
understood (even though the LLVM implementation is flawed in many ways).</p><p>The design team since decided to change to a different model, which eschews
<code>const</code> entirely for the core IR types: you should never see a <code>const</code> method on
<code>Operation</code>, should never see the type <code>const Value</code>, and you shouldn&rsquo;t feel bad
about this. That said, you <em>should</em> use <code>const</code> for non-IR types, like
<code>SmallVector</code>&rsquo;s and many other things.</p><p>The document below explains this design point from the viewpoint of &ldquo;why make a
change&rdquo;, to explain the rationale and the tradeoffs involved that led us to this
potentially controversial design point.</p><p>Bjarke Roune summarized the situation like this:</p><blockquote><p>In my opinion <code>const</code> correctness is highly valuable, catching many bugs and
making it clear in a code base where the mutations happen. In my opinion
<code>const</code> correctness still isn&rsquo;t worth it in particular for IR elements because
of the special uses and properties of IRs, in particular that it is common to
transfer a pointer/reference to an instruction from an analysis to an
optimization which will change the instruction. The analysis should be const,
the optimization needs to get a non-<code>const</code> pointer. So all analyses either
end up being templates (and if they never get instantiated in a const context,
then the point of <code>const</code> correctness has been defeated), you need to somehow
launder the const in a safe way or there will be <code>const_cast</code>s. These options
are all bad, probably so bad as to out-weigh the benefits of const.</p></blockquote><h1 id=reconsidering-const-in-mlir>Reconsidering <code>const</code> in MLIR</h1><p>This document argues this design is introducing significant sub-optimalities
into the MLIR codebase, argues that the cost/benefit tradeoff of this design is
a poor tradeoff, and proposes switching to a much simpler approach - eliminating
the use of const of these IR types entirely.</p><p><strong>Note:</strong> This document is only discussing things like <code>const Value</code> and
<code>const Operation*</code>. There is no proposed change for other types, e.g.
<code>SmallVector</code> references, the immutable types like <code>Attribute</code>, etc.</p><h2 id=background-the-llvm-const-model>Background: The LLVM Const Model&nbsp;<a class=headline-hash href=#background-the-llvm-const-model>¶</a></h2><p>The LLVM and MLIR data structures provide the IR data structures (like
<code>mlir::Operation</code>s and their users) as a structured cyclic graph data structure.
Clients of the IR typically walk up and down the graph, perform dynamic down
casting (of various sorts) to check for patterns, and use some high-abstraction
pattern matching and binding facilities to do their work.</p><p>The basic idea of LLVM&rsquo;s design is that these traversals of the IR should
preserve the const&rsquo;ness of a pointer: if you have a const pointer to an
instruction and ask for its parent (or operand, users, etc), you should get a
const pointer to the block containing the instruction (or value defining the
operand, instruction using the instruction, etc). The instruction class looks
like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>namespace</span> <span class=n>llvm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Instruction</span> <span class=o>:</span> <span class=p>...</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>BasicBlock</span> <span class=o>*</span><span class=n>Parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// A const instruction returns a const parent pointer.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>inline</span> <span class=k>const</span> <span class=n>BasicBlock</span> <span class=o>*</span><span class=n>getParent</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Parent</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// A non-const instruction returns a non-const parent pointer.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kr>inline</span>       <span class=n>BasicBlock</span> <span class=o>*</span><span class=nf>getParent</span><span class=p>()</span>       <span class=p>{</span> <span class=k>return</span> <span class=n>Parent</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The rationale for this design is that it would be const-incorrect to return a
non-const pointer from getParent, because you could then walk the block to find
the instruction again and get non-const references to the same instruction - all
without a <code>const_cast</code>.</p><p>This <code>const</code> model is simple and the C++ type system generally supports it through
code duplication of methods. That said, LLVM is actually inconsistent and buggy
about this. Even the core classes have bugs: <code>llvm::Instruction::getOperand()</code>
isn&rsquo;t currently const correct! There are other subsystems (e.g. the
<code>llvm/IR/PatternMatch.h</code> APIs) where you can perform a pattern match on a const
IR object and bind a non-const IR object.</p><p>LLVM is a mature technology with hundreds of people working on it. The fact that
it still isn&rsquo;t correctly following the const model it set out for strongly hints
that one of: 1) The design is too complicated to be practical, 2) the benefits
of the model aren&rsquo;t worth the cost of the complexity, or 3) both 1 and 2,
together in some combination.</p><h2 id=advantages-of-const-correctness-in-mlir>Advantages of Const-correctness in MLIR&nbsp;<a class=headline-hash href=#advantages-of-const-correctness-in-mlir>¶</a></h2><p>Even though this doc argues for eliminating const from MLIR, it is important to
evaluate that as a tradeoff with the advantages the const model provides,
allowing us to do a cost/benefit tradeoff. These are the benefits we see:</p><p>The major advantage of allowing const on MLIR types is as a marker in APIs that
indicate that the function will not modify the specified values. For example,
the dominator APIs have a <code>dominates(const Block*, const Block*)</code> method, and
the consts provide a way of indicating that the call won&rsquo;t modify the blocks
passed in - similarly predicates like <code>Instruction::isTerminator() const</code> do not
modify the receiver object.</p><p>It is also an advantage that MLIR follows the generally prevailing pattern of
C++ code, which generally uses const. Consistency with the community norm is
important.</p><h2 id=costs-of-const-correctness-in-mlir>Costs of Const-correctness in MLIR&nbsp;<a class=headline-hash href=#costs-of-const-correctness-in-mlir>¶</a></h2><p>As mentioned above, early work on MLIR adopted the same design as LLVM intended,
allowing const-correct traversals in the APIs. Here we discuss the various costs
of doing this by looking at some examples, listed in roughly increasing order of
severity.</p><h3 id=pervasively-duplicated-accessors>Pervasively duplicated accessors&nbsp;<a class=headline-hash href=#pervasively-duplicated-accessors>¶</a></h3><p>Just as the getParent() example above shows, achieving this const model requires
that all of the graph traversal accessors be duplicated into const and non-const
versions. This causes API bloat and slows compile time, but these are minor
problems.</p><p>The more significant issue is that this duplication can be so significant that
the signal disappears in the noise, for example <code>mlir::Operation</code> ends up with
things like this, which is twice as much API surface area just to try to satisfy
const.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>operand_iterator</span> <span class=nf>operand_begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>operand_iterator</span> <span class=nf>operand_end</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Returns an iterator on the underlying Value&#39;s (Value ).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>operand_range</span> <span class=nf>getOperands</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Support const operand iteration.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>using</span> <span class=n>const_operand_iterator</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>OperandIterator</span><span class=o>&lt;</span><span class=k>const</span> <span class=n>Operation</span><span class=p>,</span> <span class=k>const</span> <span class=n>Value</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>const_operand_range</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>::</span><span class=n>iterator_range</span><span class=o>&lt;</span><span class=n>const_operand_iterator</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>const_operand_iterator</span> <span class=nf>operand_begin</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>const_operand_iterator</span> <span class=nf>operand_end</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Returns a const iterator on the underlying Value&#39;s (Value ).
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>llvm</span><span class=o>::</span><span class=n>iterator_range</span><span class=o>&lt;</span><span class=n>const_operand_iterator</span><span class=o>&gt;</span> <span class=n>getOperands</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>OpOperand</span><span class=o>&gt;</span> <span class=n>getOpOperands</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>getOperandStorage</span><span class=p>().</span><span class=n>getOperands</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>OpOperand</span><span class=o>&gt;</span> <span class=n>getOpOperands</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>getOperandStorage</span><span class=p>().</span><span class=n>getOperands</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>OpOperand</span> <span class=o>&amp;</span><span class=n>getOpOperand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>idx</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=nf>getOpOperands</span><span class=p>()[</span><span class=n>idx</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>OpOperand</span> <span class=o>&amp;</span><span class=n>getOpOperand</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>idx</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>getOpOperands</span><span class=p>()[</span><span class=n>idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><h3 id=templated-accessors>Templated accessors&nbsp;<a class=headline-hash href=#templated-accessors>¶</a></h3><p>A related issue is that having to provide both const and non-const versions of
accessors leads to us having to turn more code into templates than would
otherwise be desirable. Things like <code>ResultIterator</code> and <code>ResultTypeIterator</code>
are templates <em><em>only</em></em> because they are generic over const and non-const
versions of types. This leads to them being defined inline in headers (instead
of in .cpp files).</p><p>Thus, our const model is leading to more code in headers and more complexity in
the implementation.</p><h3 id=const-incorrect-in-practice>Const incorrect in practice&nbsp;<a class=headline-hash href=#const-incorrect-in-practice>¶</a></h3><p>For some things, const is more trouble than it is worth, so they never get
updated.</p><p>This means that certain API in practice don&rsquo;t provide a const variant, leading
to pervasive use of <code>const_cast</code> to drop the const qualifier. For example the
logic in <code>Matchers.h</code> doesn&rsquo;t support const pointers at all, even
though matching and binding values themselves makes perfect sense for both const
and non-const values. Actually fixing this would cause massive code bloat and
complexity.</p><p>Other parts of the code are just outright incorrect. For example, the operation
cloning methods are defined on <code>Operation</code> like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>Operation</span> <span class=o>*</span><span class=nf>clone</span><span class=p>(</span><span class=n>IRMapping</span> <span class=o>&amp;</span><span class=n>mapper</span><span class=p>,</span> <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Operation</span> <span class=o>*</span><span class=nf>clone</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></div><p>While it makes sense for a clone method to be <code>const</code> conceptually (the original
operation isn&rsquo;t modified) this is a violation of the model, since the returned
operation must be mutable, and provides access to the full graph of operands as
the original operation, violating the graph based const model we were shooting
for.</p><h3 id=the-oppointer-and-constoppointer-classes>The <code>OpPointer</code> and <code>ConstOpPointer</code> Classes&nbsp;<a class=headline-hash href=#the-oppointer-and-constoppointer-classes>¶</a></h3><p>The &ldquo;typed operation&rdquo; classes for registered operations (e.g. like <code>DimOp</code> for
the &ldquo;memref.dim&rdquo; operation in memref ops) contain a pointer to an operation and
provide typed APIs for processing it.</p><p>However, this is a problem for our current <code>const</code> design - <code>const DimOp</code> means
the pointer itself is immutable, not the pointee. The previous solution for this
was the <code>OpPointer&lt;></code> and <code>ConstOpPointer&lt;></code> classes, which existed solely to
provide const correctness when referring to a typed operation. Instead of
referring to <code>DimOp</code> directly, we used <code>OpPointer&lt;DimOp></code> and
<code>ConstOpPointer&lt;DimOp></code> to preserve this constness.</p><p>While <code>auto</code> hides many instances of these <code>OpPointer</code> classes, their presence
leads to extremely ugly APIs. It also obscures the fact that the user does not
have a direct <code>DimOp</code> object, creating easy pitfalls with subtly incorrect
semantics:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// OpPointer encodes unnecessary and superfluous information into the API.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span><span class=p>,</span> <span class=mi>8</span><span class=o>&gt;</span> <span class=n>stripmineSink</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>forOp</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>factor</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;&gt;</span> <span class=n>targets</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Compared to the much cleaner and easier to read...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=p>,</span> <span class=mi>8</span><span class=o>&gt;</span> <span class=n>stripmineSink</span><span class=p>(</span><span class=n>AffineForOp</span> <span class=n>forOp</span><span class=p>,</span> <span class=kt>uint64_t</span> <span class=n>factor</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                          <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>targets</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// OpPointer is easy to misuse.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=o>*</span><span class=n>dimOp</span> <span class=o>=</span> <span class=n>inst</span><span class=o>-&gt;</span><span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>DimOp</span><span class=o>&gt;</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is actually undefined behavior because dyn_cast actually returns
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// OpPointer&lt;DimOp&gt;. OpPointer&lt;DimOp&gt; happily implicitly converts to DimOp *
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// creating undefined behavior that will execute correctly most of the time.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>It is much better to eliminate them entirely, and just pass around <code>DimOp</code>
directly. For example, instead of:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=n>mlir</span><span class=o>::</span><span class=n>getIndexSet</span><span class=p>(</span><span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>OpPointer</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;&gt;</span> <span class=n>forOps</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>FlatAffineValueConstraints</span> <span class=o>*</span><span class=n>domain</span><span class=p>)</span> <span class=p>{</span>
</span></span></code></pre></div><p>It is a lot nicer to just have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=n>mlir</span><span class=o>::</span><span class=n>getIndexSet</span><span class=p>(</span><span class=n>MutableArrayRef</span><span class=o>&lt;</span><span class=n>AffineForOp</span><span class=o>&gt;</span> <span class=n>forOps</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>FlatAffineValueConstraints</span> <span class=o>*</span><span class=n>domain</span><span class=p>)</span> <span class=p>{</span>
</span></span></code></pre></div><p>Particularly since all of the <code>FooOp</code> classes are already semantically a smart
pointer to their underlying operation.</p><h2 id=accepted-proposal-remove-const-from-ir-objects>(Accepted) Proposal: Remove <code>const</code> from IR objects&nbsp;<a class=headline-hash href=#accepted-proposal-remove-const-from-ir-objects>¶</a></h2><p>As we can see above, there is very little benefit to our const design and
significant cost, and given that the primary purpose of an IR is to represent
transformations of code, const is providing very little benefit.</p><p>As such, we propose eliminating support for const references to IR objects in
MLIR. This implies the following changes to the codebase:</p><ol><li>All of the const-duplicated accessors would be eliminated, e.g.
<code>Operation::getParent() const</code> would be removed. This is expected to remove
approximately ~130 lines of code from just Operation.h alone.</li><li>Const-only predicates would be changed to be non-const, e.g.
<code>Operation::isTerminator() const</code> would have the const removed.</li><li>Iterators and other types and functions that are templated to support
<code>const</code> can have those template arguments removed.</li><li>Types like <code>OpPointer</code> and <code>ConstOpPointer</code> that exist solely to propagate
const can be entirely removed from the codebase.</li><li>We can close bugs complaining about const incorrectness in the IR.</li></ol><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/ title="Side Effects & Speculation"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Side Effects & Speculation</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/ShapeInference/ title="Shape Inference">Next - Shape Inference <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li class=active><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>