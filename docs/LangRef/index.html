<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>MLIR Language Reference - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/LangRef/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>MLIR Language Reference</h1><p>MLIR (Multi-Level IR) is a compiler intermediate representation with
similarities to traditional three-address SSA representations (like
<a href=http://llvm.org/docs/LangRef.html>LLVM IR</a> or
<a href=https://github.com/apple/swift/blob/main/docs/SIL.rst>SIL</a>), but which
introduces notions from polyhedral loop optimization as first-class concepts.
This hybrid design is optimized to represent, analyze, and transform high level
dataflow graphs as well as target-specific code generated for high performance
data parallel systems. Beyond its representational capabilities, its single
continuous design provides a framework to lower from dataflow graphs to
high-performance target-specific code.</p><p>This document defines and describes the key concepts in MLIR, and is intended to
be a dry reference document - the
<a href=/docs/Rationale/Rationale/>rationale documentation</a>,
<a href=/getting_started/Glossary/>glossary</a>, and other content are hosted
elsewhere.</p><p>MLIR is designed to be used in three different forms: a human-readable textual
form suitable for debugging, an in-memory form suitable for programmatic
transformations and analysis, and a compact serialized form suitable for storage
and transport. The different forms all describe the same semantic content. This
document describes the human-readable textual form.</p><p><nav id=TableOfContents><ul><li><a href=#high-level-structure>High-Level Structure</a></li><li><a href=#notation>Notation</a><ul><li><a href=#common-syntax>Common syntax</a></li><li><a href=#top-level-productions>Top level Productions</a></li><li><a href=#identifiers-and-keywords>Identifiers and keywords</a></li></ul></li><li><a href=#dialects>Dialects</a><ul><li><a href=#target-specific-operations>Target specific operations</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#builtin-operations>Builtin Operations</a></li></ul></li><li><a href=#blocks>Blocks</a></li><li><a href=#regions>Regions</a><ul><li><a href=#definition>Definition</a></li><li><a href=#value-scoping>Value Scoping</a></li><li><a href=#control-flow-and-ssacfg-regions>Control Flow and SSACFG Regions</a></li><li><a href=#graph-regions>Graph Regions</a></li><li><a href=#arguments-and-results>Arguments and Results</a></li></ul></li><li><a href=#type-system>Type System</a><ul><li><a href=#type-aliases>Type Aliases</a></li><li><a href=#dialect-types>Dialect Types</a></li><li><a href=#builtin-types>Builtin Types</a></li></ul></li><li><a href=#properties>Properties</a></li><li><a href=#attributes>Attributes</a><ul><li><a href=#attribute-value-aliases>Attribute Value Aliases</a></li><li><a href=#dialect-attribute-values>Dialect Attribute Values</a></li><li><a href=#builtin-attribute-values>Builtin Attribute Values</a></li><li><a href=#ir-versioning>IR Versioning</a></li></ul></li></ul></nav><h2 id=high-level-structure>High-Level Structure&nbsp;<a class=headline-hash href=#high-level-structure>Â¶</a></h2><p>MLIR is fundamentally based on a graph-like data structure of nodes, called
<em>Operations</em>, and edges, called <em>Values</em>. Each Value is the result of exactly
one Operation or Block Argument, and has a <em>Value Type</em> defined by the
<a href=#type-system>type system</a>.
<a href=#operations>Operations</a> are contained in
<a href=#blocks>Blocks</a> and Blocks are contained in
<a href=#regions>Regions</a>. Operations
are also ordered within their containing block and Blocks are ordered in their
containing region, although this order may or may not be semantically meaningful
in a given
<a href=/docs/Interfaces/#regionkindinterfaces>kind of region</a>). Operations
may also contain regions, enabling hierarchical structures to be represented.</p><p>Operations can represent many different concepts, from higher-level concepts
like function definitions, function calls, buffer allocations, view or slices of
buffers, and process creation, to lower-level concepts like target-independent
arithmetic, target-specific instructions, configuration registers, and logic
gates. These different concepts are represented by different operations in MLIR
and the set of operations usable in MLIR can be arbitrarily extended.</p><p>MLIR also provides an extensible framework for transformations on operations,
using familiar concepts of compiler
<a href=/docs/Passes/>Passes</a>. Enabling an arbitrary
set of passes on an arbitrary set of operations results in a significant scaling
challenge, since each transformation must potentially take into account the
semantics of any operation. MLIR addresses this complexity by allowing operation
semantics to be described abstractly using
<a href=/docs/Traits/>Traits</a> and
<a href=/docs/Interfaces/>Interfaces</a>, enabling transformations to operate on operations
more generically. Traits often describe verification constraints on valid IR,
enabling complex invariants to be captured and checked. (see
<a href=/docs/Tutorials/Toy/Ch-2/#op-vs-operation-using-mlir-operations>Op vs Operation</a>)</p><p>One obvious application of MLIR is to represent an
<a href=https://en.wikipedia.org/wiki/Static_single_assignment_form>SSA-based</a> IR,
like the LLVM core IR, with appropriate choice of operation types to define
Modules, Functions, Branches, Memory Allocation, and verification constraints to
ensure the SSA Dominance property. MLIR includes a collection of dialects which
defines just such structures. However, MLIR is intended to be general enough to
represent other compiler-like data structures, such as Abstract Syntax Trees in
a language frontend, generated instructions in a target-specific backend, or
circuits in a High-Level Synthesis tool.</p><p>Here&rsquo;s an example of an MLIR module:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Compute A*B using an implementation of multiply kernel and print the
</span></span></span><span class=line><span class=cl><span class=c>// result using a TensorFlow op. The dimensions of A and B are partially
</span></span></span><span class=line><span class=cl><span class=c>// known. The shapes are assumed to match.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@mul</span><span class=p>(</span><span class=nv>%A</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%B</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Compute the inner dimension of %A using the dim operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%n</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>dim <span class=nv>%A</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Allocate addressable &#34;buffers&#34; and copy tensors %A and %B into them.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%A_m</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>(</span><span class=nv>%n</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  bufferization<span class=p>.</span>materialize_in_destination <span class=nv>%A</span> in writable <span class=nv>%A_m</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%B_m</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>(</span><span class=nv>%n</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  bufferization<span class=p>.</span>materialize_in_destination <span class=nv>%B</span> in writable <span class=nv>%B_m</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Call function @multiply passing memrefs as arguments,
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// and getting returned the result of the multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%C_m</span> <span class=p>=</span> call <span class=nf>@multiply</span><span class=p>(</span><span class=nv>%A_m</span><span class=p>,</span> <span class=nv>%B_m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>          <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>memref</span><span class=p>.</span>dealloc <span class=nv>%A_m</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>memref</span><span class=p>.</span>dealloc <span class=nv>%B_m</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Load the buffer data into a higher level &#34;tensor&#34; value.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%C</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span><span class=kt>tensor</span>_load <span class=nv>%C_m</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>memref</span><span class=p>.</span>dealloc <span class=nv>%C_m</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Call TensorFlow built-in function to print the result tensor.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;tf.Print&#34;</span><span class=p>(</span><span class=nv>%C</span><span class=p>){</span>message<span class=p>:</span> <span class=s>&#34;mul result&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%C</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function that multiplies two memrefs and returns the result.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@multiply</span><span class=p>(</span><span class=nv>%A</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%B</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>          <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;)</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Compute the inner dimension of %A.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%n</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>dim <span class=nv>%A</span><span class=p>,</span> <span class=m>1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Allocate memory for the multiplication result.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%C</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>alloc<span class=p>()</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Multiplication loop nest.
</span></span></span><span class=line><span class=cl><span class=c></span>  affine<span class=p>.</span>for <span class=nv>%i</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>100</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     affine<span class=p>.</span>for <span class=nv>%j</span> <span class=p>=</span> <span class=m>0</span> to <span class=m>50</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>memref</span><span class=p>.</span>store <span class=m>0</span> to <span class=nv>%C</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        affine<span class=p>.</span>for <span class=nv>%k</span> <span class=p>=</span> <span class=m>0</span> to <span class=nv>%n</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>           <span class=nv>%a_v</span>  <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%A</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%k</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>           <span class=nv>%b_v</span>  <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%B</span><span class=p>[</span><span class=nv>%k</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>           <span class=nv>%prod</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%a_v</span><span class=p>,</span> <span class=nv>%b_v</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>           <span class=nv>%c_v</span>  <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>load <span class=nv>%C</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>           <span class=nv>%sum</span>  <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%c_v</span><span class=p>,</span> <span class=nv>%prod</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>           <span class=kt>memref</span><span class=p>.</span>store <span class=nv>%sum</span><span class=p>,</span> <span class=nv>%C</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>     <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%C</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>100x50x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=notation>Notation&nbsp;<a class=headline-hash href=#notation>Â¶</a></h2><p>MLIR has a simple and unambiguous grammar, allowing it to reliably round-trip
through a textual form. This is important for development of the compiler - e.g.
for understanding the state of code as it is being transformed and writing test
cases.</p><p>This document describes the grammar using
<a href=https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form>Extended Backus-Naur Form (EBNF)</a>.</p><p>This is the EBNF grammar used in this document, presented in yellow boxes.</p><pre tabindex=0><code>alternation ::= expr0 | expr1 | expr2  // Either expr0 or expr1 or expr2.
sequence    ::= expr0 expr1 expr2      // Sequence of expr0 expr1 expr2.
repetition0 ::= expr*  // 0 or more occurrences.
repetition1 ::= expr+  // 1 or more occurrences.
optionality ::= expr?  // 0 or 1 occurrence.
grouping    ::= (expr) // Everything inside parens is grouped together.
literal     ::= `abcd` // Matches the literal `abcd`.
</code></pre><p>Code examples are presented in blue boxes.</p><pre tabindex=0><code>// This is an example use of the grammar above:
// This matches things like: ba, bana, boma, banana, banoma, bomana...
example ::= `b` (`an` | `om`)* `a`
</code></pre><h3 id=common-syntax>Common syntax&nbsp;<a class=headline-hash href=#common-syntax>Â¶</a></h3><p>The following core grammar productions are used in this document:</p><pre tabindex=0><code>// TODO: Clarify the split between lexing (tokens) and parsing (grammar).
digit     ::= [0-9]
hex_digit ::= [0-9a-fA-F]
letter    ::= [a-zA-Z]
id-punct  ::= [$._-]

integer-literal ::= decimal-literal | hexadecimal-literal
decimal-literal ::= digit+
hexadecimal-literal ::= `0x` hex_digit+
float-literal ::= [-+]?[0-9]+[.][0-9]*([eE][-+]?[0-9]+)?
string-literal  ::= `&#34;` [^&#34;\n\f\v\r]* `&#34;`   TODO: define escaping rules
</code></pre><p>Not listed here, but MLIR does support comments. They use standard BCPL syntax,
starting with a <code>//</code> and going until the end of the line.</p><h3 id=top-level-productions>Top level Productions&nbsp;<a class=headline-hash href=#top-level-productions>Â¶</a></h3><pre tabindex=0><code>// Top level production
toplevel := (operation | attribute-alias-def | type-alias-def)*
</code></pre><p>The production <code>toplevel</code> is the top level production that is parsed by any parsing
consuming the MLIR syntax.
<a href=#operations>Operations</a>,
<a href=#attribute-value-aliases>Attribute aliases</a>, and
<a href=#type-aliases>Type aliases</a>
can be declared on the toplevel.</p><h3 id=identifiers-and-keywords>Identifiers and keywords&nbsp;<a class=headline-hash href=#identifiers-and-keywords>Â¶</a></h3><p>Syntax:</p><pre tabindex=0><code>// Identifiers
bare-id ::= (letter|[_]) (letter|digit|[_$.])*
bare-id-list ::= bare-id (`,` bare-id)*
value-id ::= `%` suffix-id
alias-name :: = bare-id
suffix-id ::= (digit+ | ((letter|id-punct) (letter|id-punct|digit)*))

symbol-ref-id ::= `@` (suffix-id | string-literal) (`::` symbol-ref-id)?
value-id-list ::= value-id (`,` value-id)*

// Uses of value, e.g. in an operand list to an operation.
value-use ::= value-id (`#` decimal-literal)?
value-use-list ::= value-use (`,` value-use)*
</code></pre><p>Identifiers name entities such as values, types and functions, and are chosen by
the writer of MLIR code. Identifiers may be descriptive (e.g. <code>%batch_size</code>,
<code>@matmul</code>), or may be non-descriptive when they are auto-generated (e.g. <code>%23</code>,
<code>@func42</code>). Identifier names for values may be used in an MLIR text file but are
not persisted as part of the IR - the printer will give them anonymous names
like <code>%42</code>.</p><p>MLIR guarantees identifiers never collide with keywords by prefixing identifiers
with a sigil (e.g. <code>%</code>, <code>#</code>, <code>@</code>, <code>^</code>, <code>!</code>). In certain unambiguous contexts
(e.g. affine expressions), identifiers are not prefixed, for brevity. New
keywords may be added to future versions of MLIR without danger of collision
with existing identifiers.</p><p>Value identifiers are only
<a href=#value-scoping>in scope</a> for the (nested) region in
which they are defined and cannot be accessed or referenced outside of that
region. Argument identifiers in mapping functions are in scope for the mapping
body. Particular operations may further limit which identifiers are in scope in
their regions. For instance, the scope of values in a region with
<a href=#control-flow-and-ssacfg-regions>SSA control flow semantics</a> is constrained
according to the standard definition of
<a href=https://en.wikipedia.org/wiki/Dominator_%5c%28graph_theory%5c%29>SSA dominance</a>.
Another example is the
<a href=/docs/Traits/#isolatedfromabove>IsolatedFromAbove trait</a>,
which restricts directly accessing values defined in containing regions.</p><p>Function identifiers and mapping identifiers are associated with
<a href=/docs/SymbolsAndSymbolTables/>Symbols</a> and have scoping rules dependent on symbol
attributes.</p><h2 id=dialects>Dialects&nbsp;<a class=headline-hash href=#dialects>Â¶</a></h2><p>Dialects are the mechanism by which to engage with and extend the MLIR
ecosystem. They allow for defining new
<a href=#operations>operations</a>, as well as
<a href=#attributes>attributes</a> and
<a href=#type-system>types</a>. Each dialect is given a
unique <code>namespace</code> that is prefixed to each defined attribute/operation/type.
For example, the
<a href=/docs/Dialects/Affine/>Affine dialect</a> defines the namespace:
<code>affine</code>.</p><p>MLIR allows for multiple dialects, even those outside of the main tree, to
co-exist together within one module. Dialects are produced and consumed by
certain passes. MLIR provides a
<a href=/docs/DialectConversion/>framework</a> to convert
between, and within, different dialects.</p><p>A few of the dialects supported by MLIR:</p><ul><li><a href=/docs/Dialects/Affine/>Affine dialect</a></li><li><a href=/docs/Dialects/Func/>Func dialect</a></li><li><a href=/docs/Dialects/GPU/>GPU dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector dialect</a></li></ul><h3 id=target-specific-operations>Target specific operations&nbsp;<a class=headline-hash href=#target-specific-operations>Â¶</a></h3><p>Dialects provide a modular way in which targets can expose target-specific
operations directly through to MLIR. As an example, some targets go through
LLVM. LLVM has a rich set of intrinsics for certain target-independent
operations (e.g. addition with overflow check) as well as providing access to
target-specific operations for the targets it supports (e.g. vector permutation
operations). LLVM intrinsics in MLIR are represented via operations that start
with an &ldquo;llvm.&rdquo; name.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// LLVM: %x = call {i16, i1} @llvm.sadd.with.overflow.i16(i16 %a, i16 %b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span><span class=p>:</span><span class=nl>2 =</span> <span class=s>&#34;llvm.sadd.with.overflow.i16&#34;</span><span class=p>(</span><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i16</span><span class=p>,</span> <span class=k>i16</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i16</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span>
</span></span></code></pre></div><p>These operations only work when targeting LLVM as a backend (e.g. for CPUs and
GPUs), and are required to align with the LLVM definition of these intrinsics.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>Â¶</a></h2><p>Syntax:</p><pre tabindex=0><code>operation             ::= op-result-list? (generic-operation | custom-operation)
                          trailing-location?
generic-operation     ::= string-literal `(` value-use-list? `)`  successor-list?
                          dictionary-properties? region-list? dictionary-attribute?
                          `:` function-type
custom-operation      ::= bare-id custom-operation-format
op-result-list        ::= op-result (`,` op-result)* `=`
op-result             ::= value-id (`:` integer-literal)?
successor-list        ::= `[` successor (`,` successor)* `]`
successor             ::= caret-id (`:` block-arg-list)?
dictionary-properties ::= `&lt;` dictionary-attribute `&gt;`
region-list           ::= `(` region (`,` region)* `)`
dictionary-attribute  ::= `{` (attribute-entry (`,` attribute-entry)*)? `}`
trailing-location     ::= `loc` `(` location `)`
</code></pre><p>MLIR introduces a uniform concept called <em>operations</em> to enable describing many
different levels of abstractions and computations. Operations in MLIR are fully
extensible (there is no fixed list of operations) and have application-specific
semantics. For example, MLIR supports
<a href=/docs/Dialects/MemRef/>target-independent operations</a>,
<a href=/docs/Dialects/Affine/>affine operations</a>, and
<a href=#target-specific-operations>target-specific machine operations</a>.</p><p>The internal representation of an operation is simple: an operation is
identified by a unique string (e.g. <code>dim</code>, <code>tf.Conv2d</code>, <code>x86.repmovsb</code>,
<code>ppc.eieio</code>, etc), can return zero or more results, take zero or more operands,
has storage for
<a href=#properties>properties</a>, has a dictionary of
<a href=#attributes>attributes</a>, has zero or more successors, and zero or more
enclosed
<a href=#regions>regions</a>. The generic printing form includes all these
elements literally, with a function type to indicate the types of the
results and operands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// An operation that produces two results.
</span></span></span><span class=line><span class=cl><span class=c>// The results of %result can be accessed via the &lt;name&gt; `#` &lt;opNo&gt; syntax.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%result</span><span class=p>:</span><span class=nl>2 =</span> <span class=s>&#34;foo_div&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Pretty form that defines a unique name for each result.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%foo</span><span class=p>,</span> <span class=nv>%bar</span> <span class=p>=</span> <span class=s>&#34;foo_div&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Invoke a TensorFlow function called tf.scramble with two inputs
</span></span></span><span class=line><span class=cl><span class=c>// and an attribute &#34;fruit&#34; stored in properties.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;tf.scramble&#34;</span><span class=p>(</span><span class=nv>%result#0</span><span class=p>,</span> <span class=nv>%bar</span><span class=p>)</span> <span class=p>&lt;{</span><span class=nl>fruit =</span> <span class=s>&#34;banana&#34;</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Invoke an operation with some discardable attributes
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%foo</span><span class=p>,</span> <span class=nv>%bar</span> <span class=p>=</span> <span class=s>&#34;foo_div&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>some_attr =</span> <span class=s>&#34;value&#34;</span><span class=p>,</span> <span class=nl>other_attr =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>In addition to the basic syntax above, dialects may register known operations.
This allows those dialects to support <em>custom assembly form</em> for parsing and
printing operations. In the operation sets listed below, we show both forms.</p><h3 id=builtin-operations>Builtin Operations&nbsp;<a class=headline-hash href=#builtin-operations>Â¶</a></h3><p>The
<a href=/docs/Dialects/Builtin/>builtin dialect</a> defines a select few operations that
are widely applicable by MLIR dialects, such as a universal conversion cast
operation that simplifies inter/intra dialect conversion. This dialect also
defines a top-level <code>module</code> operation, that represents a useful IR container.</p><h2 id=blocks>Blocks&nbsp;<a class=headline-hash href=#blocks>Â¶</a></h2><p>Syntax:</p><pre tabindex=0><code>block           ::= block-label operation+
block-label     ::= block-id block-arg-list? `:`
block-id        ::= caret-id
caret-id        ::= `^` suffix-id
value-id-and-type ::= value-id `:` type

// Non-empty list of names and types.
value-id-and-type-list ::= value-id-and-type (`,` value-id-and-type)*

block-arg-list ::= `(` value-id-and-type-list? `)`
</code></pre><p>A <em>Block</em> is a list of operations. In
<a href=#control-flow-and-ssacfg-regions>SSACFG regions</a>, each block represents a
compiler
<a href=https://en.wikipedia.org/wiki/Basic_block>basic block</a> where
instructions inside the block are executed in order and terminator operations
implement control flow branches between basic blocks.</p><p>The last operation in a block must be a
<a href=#control-flow-and-ssacfg-regions>terminator operation</a>. A region with a single
block may opt out of this requirement by attaching the <code>NoTerminator</code> on the
enclosing op. The top-level <code>ModuleOp</code> is an example of such an operation which
defines this trait and whose block body does not have a terminator.</p><p>Blocks in MLIR take a list of block arguments, notated in a function-like way.
Block arguments are bound to values specified by the semantics of individual
operations. Block arguments of the entry block of a region are also arguments to
the region and the values bound to these arguments are determined by the
semantics of the containing operation. Block arguments of other blocks are
determined by the semantics of terminator operations, e.g. Branches, which have
the block as a successor. In regions with
<a href=#control-flow-and-ssacfg-regions>control flow</a>, MLIR leverages this structure
to implicitly represent the passage of control-flow dependent values without the
complex nuances of PHI nodes in traditional SSA representations. Note that
values which are not control-flow dependent can be referenced directly and do
not need to be passed through block arguments.</p><p>Here is a simple example function showing branches, returns, and block
arguments:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@simple</span><span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=nv>%cond</span><span class=p>:</span> <span class=k>i1</span><span class=p>):</span> <span class=c>// Code dominated by ^bb0 may refer to %a
</span></span></span><span class=line><span class=cl><span class=c></span>  cf<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span>    <span class=c>// Branch passes %a as the argument
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%b</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%a</span><span class=p>,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%b</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span>    <span class=c>// Branch passes %b as the argument
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// ^bb3 receives an argument, named %c, from predecessors
</span></span></span><span class=line><span class=cl><span class=c>// and passes it on to bb4 along with %a. %a is referenced
</span></span></span><span class=line><span class=cl><span class=c>// directly from its defining operation and is not passed through
</span></span></span><span class=line><span class=cl><span class=c>// an argument of ^bb3.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nl>^bb3</span><span class=p>(</span><span class=nv>%c</span><span class=p>:</span> <span class=k>i64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb4</span><span class=p>(</span><span class=nv>%c</span><span class=p>,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>^bb4</span><span class=p>(</span><span class=nv>%d</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=nv>%e</span> <span class=p>:</span> <span class=k>i64</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%d</span><span class=p>,</span> <span class=nv>%e</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i64</span>   <span class=c>// Return is also a terminator.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p><strong>Context:</strong> The &ldquo;block argument&rdquo; representation eliminates a number of special
cases from the IR compared to traditional &ldquo;PHI nodes are operations&rdquo; SSA IRs
(like LLVM). For example, the
<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.524.5461&amp;rep=rep1&amp;type=pdf">parallel copy semantics</a>
of SSA is immediately apparent, and function arguments are no longer a special
case: they become arguments to the entry block
[
<a href=/docs/Rationale/Rationale/#block-arguments-vs-phi-nodes>more rationale</a>]. Blocks
are also a fundamental concept that cannot be represented by operations because
values defined in an operation cannot be accessed outside the operation.</p><h2 id=regions>Regions&nbsp;<a class=headline-hash href=#regions>Â¶</a></h2><h3 id=definition>Definition&nbsp;<a class=headline-hash href=#definition>Â¶</a></h3><p>A region is an ordered list of MLIR
<a href=#blocks>Blocks</a>. The semantics within a
region is not imposed by the IR. Instead, the containing operation defines the
semantics of the regions it contains. MLIR currently defines two kinds of
regions:
<a href=#control-flow-and-ssacfg-regions>SSACFG regions</a>, which describe
control flow between blocks, and
<a href=#graph-regions>Graph regions</a>, which do not
require control flow between block. The kinds of regions within an operation are
described using the
<a href=/docs/Interfaces/#regionkindinterfaces>RegionKindInterface</a>.</p><p>Regions do not have a name or an address, only the blocks contained in a region
do. Regions must be contained within operations and have no type or attributes.
The first block in the region is a special block called the &rsquo;entry block&rsquo;. The
arguments to the entry block are also the arguments of the region itself. The
entry block cannot be listed as a successor of any other block. The syntax for a
region is as follows:</p><pre tabindex=0><code>region      ::= `{` entry-block? block* `}`
entry-block ::= operation+
</code></pre><p>A function body is an example of a region: it consists of a CFG of blocks and
has additional semantic restrictions that other types of regions may not have.
For example, in a function body, block terminators must either branch to a
different block, or return from a function where the types of the <code>return</code>
arguments must match the result types of the function signature. Similarly, the
function arguments must match the types and count of the region arguments. In
general, operations with regions can define these correspondences arbitrarily.</p><p>An <em>entry block</em> is a block with no label and no arguments that may occur at
the beginning of a region. It enables a common pattern of using a region to
open a new scope.</p><h3 id=value-scoping>Value Scoping&nbsp;<a class=headline-hash href=#value-scoping>Â¶</a></h3><p>Regions provide hierarchical encapsulation of programs: it is impossible to
reference, i.e. branch to, a block which is not in the same region as the source
of the reference, i.e. a terminator operation. Similarly, regions provides a
natural scoping for value visibility: values defined in a region don&rsquo;t escape to
the enclosing region, if any. By default, operations inside a region can
reference values defined outside of the region whenever it would have been legal
for operands of the enclosing operation to reference those values, but this can
be restricted using traits, such as
<a href=/docs/Traits/#isolatedfromabove>OpTrait::IsolatedFromAbove</a>, or a custom
verifier.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=s>&#34;any_op&#34;</span><span class=p>(</span><span class=nv>%a</span><span class=p>)</span> <span class=p>({</span> <span class=c>// if %a is in-scope in the containing region...
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// then %a is in-scope here too.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%new_value</span> <span class=p>=</span> <span class=s>&#34;another_op&#34;</span><span class=p>(</span><span class=nv>%a</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>})</span> <span class=p>:</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span>
</span></span></code></pre></div><p>MLIR defines a generalized &lsquo;hierarchical dominance&rsquo; concept that operates across
hierarchy and defines whether a value is &lsquo;in scope&rsquo; and can be used by a
particular operation. Whether a value can be used by another operation in the
same region is defined by the kind of region. A value defined in a region can be
used by an operation which has a parent in the same region, if and only if the
parent could use the value. A value defined by an argument to a region can
always be used by any operation deeply contained in the region. A value defined
in a region can never be used outside of the region.</p><h3 id=control-flow-and-ssacfg-regions>Control Flow and SSACFG Regions&nbsp;<a class=headline-hash href=#control-flow-and-ssacfg-regions>Â¶</a></h3><p>In MLIR, control flow semantics of a region is indicated by
<a href=/docs/Interfaces/#regionkindinterfaces>RegionKind::SSACFG</a>. Informally, these
regions support semantics where operations in a region &rsquo;execute sequentially&rsquo;.
Before an operation executes, its operands have well-defined values. After an
operation executes, the operands have the same values and results also have
well-defined values. After an operation executes, the next operation in the
block executes until the operation is the terminator operation at the end of a
block, in which case some other operation will execute. The determination of the
next instruction to execute is the &lsquo;passing of control flow&rsquo;.</p><p>In general, when control flow is passed to an operation, MLIR does not restrict
when control flow enters or exits the regions contained in that operation.
However, when control flow enters a region, it always begins in the first block
of the region, called the <em>entry</em> block. Terminator operations ending each block
represent control flow by explicitly specifying the successor blocks of the
block. Control flow can only pass to one of the specified successor blocks as in
a <code>branch</code> operation, or back to the containing operation as in a <code>return</code>
operation. Terminator operations without successors can only pass control back
to the containing operation. Within these restrictions, the particular semantics
of terminator operations is determined by the specific dialect operations
involved. Blocks (other than the entry block) that are not listed as a successor
of a terminator operation are defined to be unreachable and can be removed
without affecting the semantics of the containing operation.</p><p>Although control flow always enters a region through the entry block, control
flow may exit a region through any block with an appropriate terminator. The
standard dialect leverages this capability to define operations with
Single-Entry-Multiple-Exit (SEME) regions, possibly flowing through different
blocks in the region and exiting through any block with a <code>return</code> operation.
This behavior is similar to that of a function body in most programming
languages. In addition, control flow may also not reach the end of a block or
region, for example if a function call does not return.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@accelerator_compute</span><span class=p>(</span><span class=k>i64</span><span class=p>,</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span> <span class=p>{</span> <span class=c>// An SSACFG region
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=nv>%cond</span><span class=p>:</span> <span class=k>i1</span><span class=p>):</span> <span class=c>// Code dominated by ^bb0 may refer to %a
</span></span></span><span class=line><span class=cl><span class=c></span>  cf<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb1</span><span class=p>,</span> <span class=nl>^bb2
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=c>// This def for %value does not dominate ^bb2
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%value</span> <span class=p>=</span> <span class=s>&#34;op.convert&#34;</span><span class=p>(</span><span class=nv>%a</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  cf<span class=p>.</span>br <span class=nl>^bb3</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span>    <span class=c>// Branch passes %a as the argument
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  accelerator<span class=p>.</span>launch<span class=p>()</span> <span class=p>{</span> <span class=c>// An SSACFG region
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nl>^bb0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>      <span class=c>// Region of code nested under &#34;accelerator.launch&#34;, it can reference %a but
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=c>// not %value.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nv>%new_value</span> <span class=p>=</span> <span class=s>&#34;accelerator.do_something&#34;</span><span class=p>(</span><span class=nv>%a</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c>// %new_value cannot be referenced outside of the region
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nl>^bb3</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=operations-with-multiple-regions>Operations with Multiple Regions&nbsp;<a class=headline-hash href=#operations-with-multiple-regions>Â¶</a></h4><p>An operation containing multiple regions also completely determines the
semantics of those regions. In particular, when control flow is passed to an
operation, it may transfer control flow to any contained region. When control
flow exits a region and is returned to the containing operation, the containing
operation may pass control flow to any region in the same operation. An
operation may also pass control flow to multiple contained regions concurrently.
An operation may also pass control flow into regions that were specified in
other operations, in particular those that defined the values or symbols the
given operation uses as in a call operation. This passage of control is
generally independent of passage of control flow through the basic blocks of the
containing region.</p><h4 id=closure>Closure&nbsp;<a class=headline-hash href=#closure>Â¶</a></h4><p>Regions allow defining an operation that creates a closure, for example by
âboxingâ the body of the region into a value they produce. It remains up to the
operation to define its semantics. Note that if an operation triggers
asynchronous execution of the region, it is under the responsibility of the
operation caller to wait for the region to be executed guaranteeing that any
directly used values remain live.</p><h3 id=graph-regions>Graph Regions&nbsp;<a class=headline-hash href=#graph-regions>Â¶</a></h3><p>In MLIR, graph-like semantics in a region is indicated by
<a href=/docs/Interfaces/#regionkindinterfaces>RegionKind::Graph</a>. Graph regions are
appropriate for concurrent semantics without control flow, or for modeling
generic directed graph data structures. Graph regions are appropriate for
representing cyclic relationships between coupled values where there is no
fundamental order to the relationships. For instance, operations in a graph
region may represent independent threads of control with values representing
streams of data. As usual in MLIR, the particular semantics of a region is
completely determined by its containing operation. Graph regions may only
contain a single basic block (the entry block).</p><p><strong>Rationale:</strong> Currently graph regions are arbitrarily limited to a single basic
block, although there is no particular semantic reason for this limitation. This
limitation has been added to make it easier to stabilize the pass infrastructure
and commonly used passes for processing graph regions to properly handle
feedback loops. Multi-block regions may be allowed in the future if use cases
that require it arise.</p><p>In graph regions, MLIR operations naturally represent nodes, while each MLIR
value represents a multi-edge connecting a single source node and multiple
destination nodes. All values defined in the region as results of operations are
in scope within the region and can be accessed by any other operation in the
region. In graph regions, the order of operations within a block and the order
of blocks in a region is not semantically meaningful and non-terminator
operations may be freely reordered, for instance, by canonicalization. Other
kinds of graphs, such as graphs with multiple source nodes and multiple
destination nodes, can also be represented by representing graph edges as MLIR
operations.</p><p>Note that cycles can occur within a single block in a graph region, or between
basic blocks.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=s>&#34;test.graph_region&#34;</span><span class=p>()</span> <span class=p>({</span> <span class=c>// A Graph region
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;op1&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>  <span class=c>// OK: %1, %3 allowed here
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;test.ssacfg_region&#34;</span><span class=p>()</span> <span class=p>({</span>
</span></span><span class=line><span class=cl>     <span class=nv>%5</span> <span class=p>=</span> <span class=s>&#34;op2&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=c>// OK: %1, %2, %3, %4 all defined in the containing region
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=p>})</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;op2&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>  <span class=c>// OK: %4 allowed here
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%4</span> <span class=p>=</span> <span class=s>&#34;op3&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>})</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><h3 id=arguments-and-results>Arguments and Results&nbsp;<a class=headline-hash href=#arguments-and-results>Â¶</a></h3><p>The arguments of the first block of a region are treated as arguments of the
region. The source of these arguments is defined by the semantics of the parent
operation. They may correspond to some of the values the operation itself uses.</p><p>Regions produce a (possibly empty) list of values. The operation semantics
defines the relation between the region results and the operation results.</p><h2 id=type-system>Type System&nbsp;<a class=headline-hash href=#type-system>Â¶</a></h2><p>Each value in MLIR has a type defined by the type system. MLIR has an open type
system (i.e. there is no fixed list of types), and types may have
application-specific semantics. MLIR dialects may define any number of types
with no restrictions on the abstractions they represent.</p><pre tabindex=0><code>type ::= type-alias | dialect-type | builtin-type

type-list-no-parens ::=  type (`,` type)*
type-list-parens ::= `(` `)`
                   | `(` type-list-no-parens `)`

// This is a common way to refer to a value with a specified type.
ssa-use-and-type ::= ssa-use `:` type
ssa-use ::= value-use

// Non-empty list of names and types.
ssa-use-and-type-list ::= ssa-use-and-type (`,` ssa-use-and-type)*

function-type ::= (type | type-list-parens) `-&gt;` (type | type-list-parens)
</code></pre><h3 id=type-aliases>Type Aliases&nbsp;<a class=headline-hash href=#type-aliases>Â¶</a></h3><pre tabindex=0><code>type-alias-def ::= `!` alias-name `=` type
type-alias ::= `!` alias-name
</code></pre><p>MLIR supports defining named aliases for types. A type alias is an identifier
that can be used in the place of the type that it defines. These aliases <em>must</em>
be defined before their uses. Alias names may not contain a &lsquo;.&rsquo;, since those
names are reserved for
<a href=#dialect-types>dialect types</a>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span><span class=nl>avx_m128 =</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Using the original type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;foo&#34;</span><span class=p>(</span><span class=nv>%x</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Using the type alias.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;foo&#34;</span><span class=p>(</span><span class=nv>%x</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>avx_m128 <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><h3 id=dialect-types>Dialect Types&nbsp;<a class=headline-hash href=#dialect-types>Â¶</a></h3><p>Similarly to operations, dialects may define custom extensions to the type
system.</p><pre tabindex=0><code>dialect-namespace ::= bare-id

dialect-type ::= `!` (opaque-dialect-type | pretty-dialect-type)
opaque-dialect-type ::= dialect-namespace dialect-type-body
pretty-dialect-type ::= dialect-namespace `.` pretty-dialect-type-lead-ident
                                              dialect-type-body?
pretty-dialect-type-lead-ident ::= `[A-Za-z][A-Za-z0-9._]*`

dialect-type-body ::= `&lt;` dialect-type-contents+ `&gt;`
dialect-type-contents ::= dialect-type-body
                            | `(` dialect-type-contents+ `)`
                            | `[` dialect-type-contents+ `]`
                            | `{` dialect-type-contents+ `}`
                            | [^\[&lt;({\]&gt;)}\0]+
</code></pre><p>Dialect types are generally specified in an opaque form, where the contents
of the type are defined within a body wrapped with the dialect namespace
and <code>&lt;></code>. Consider the following examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A tensorflow string type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>tf<span class=p>&lt;</span>string<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A type with complex components.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>foo<span class=p>&lt;</span>something<span class=p>&lt;</span>abcd<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// An even more complex type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>foo<span class=p>&lt;</span><span class=s>&#34;a123^^^&#34;</span> <span class=err>+</span> bar<span class=p>&gt;</span>
</span></span></code></pre></div><p>Dialect types that are simple enough may use a prettier format, which unwraps
part of the syntax into an equivalent, but lighter weight form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A tensorflow string type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>tf<span class=p>.</span>string
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A type with complex components.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>foo<span class=p>.</span>something<span class=p>&lt;</span>abcd<span class=p>&gt;</span>
</span></span></code></pre></div><p>See
<a href=/docs/DefiningDialects/AttributesAndTypes/>here</a> to learn how to define dialect types.</p><h3 id=builtin-types>Builtin Types&nbsp;<a class=headline-hash href=#builtin-types>Â¶</a></h3><p>The
<a href=/docs/Dialects/Builtin/>builtin dialect</a> defines a set of types that are
directly usable by any other dialect in MLIR. These types cover a range from
primitive integer and floating-point types, function types, and more.</p><h2 id=properties>Properties&nbsp;<a class=headline-hash href=#properties>Â¶</a></h2><p>Properties are extra data members stored directly on an Operation class. They
provide a way to store
<a href=#attributes>inherent attributes</a> and other arbitrary
data. The semantics of the data is specific to a given operation, and may be
exposed through
<a href=/docs/Interfaces/>Interfaces</a> accessors and other methods.
Properties can always be serialized to Attribute in order to be printed
generically.</p><h2 id=attributes>Attributes&nbsp;<a class=headline-hash href=#attributes>Â¶</a></h2><p>Syntax:</p><pre tabindex=0><code>attribute-entry ::= (bare-id | string-literal) `=` attribute-value
attribute-value ::= attribute-alias | dialect-attribute | builtin-attribute
</code></pre><p>Attributes are the mechanism for specifying constant data on operations in
places where a variable is never allowed - e.g. the comparison predicate of a
<a href=/docs/Dialects/ArithOps/#arithcmpi-arithcmpiop><code>cmpi</code> operation</a>. Each operation has an
attribute dictionary, which associates a set of attribute names to attribute
values. MLIR&rsquo;s builtin dialect provides a rich set of
<a href=#builtin-attribute-values>builtin attribute values</a> out of the box (such as
arrays, dictionaries, strings, etc.). Additionally, dialects can define their
own
<a href=#dialect-attribute-values>dialect attribute values</a>.</p><p>For dialects which haven&rsquo;t adopted properties yet, the top-level attribute
dictionary attached to an operation has special semantics. The attribute
entries are considered to be of two different kinds based on whether their
dictionary key has a dialect prefix:</p><ul><li><p><em>inherent attributes</em> are inherent to the definition of an operation&rsquo;s
semantics. The operation itself is expected to verify the consistency of
these attributes. An example is the <code>predicate</code> attribute of the
<code>arith.cmpi</code> op. These attributes must have names that do not start with a
dialect prefix.</p></li><li><p><em>discardable attributes</em> have semantics defined externally to the operation
itself, but must be compatible with the operations&rsquo;s semantics. These
attributes must have names that start with a dialect prefix. The dialect
indicated by the dialect prefix is expected to verify these attributes. An
example is the <code>gpu.container_module</code> attribute.</p></li></ul><p>Note that attribute values are allowed to themselves be dictionary attributes,
but only the top-level dictionary attribute attached to the operation is subject
to the classification above.</p><p>When properties are adopted, only discardable attributes are stored in the
top-level dictionary, while inherent attributes are stored in the properties
storage.</p><h3 id=attribute-value-aliases>Attribute Value Aliases&nbsp;<a class=headline-hash href=#attribute-value-aliases>Â¶</a></h3><pre tabindex=0><code>attribute-alias-def ::= `#` alias-name `=` attribute-value
attribute-alias ::= `#` alias-name
</code></pre><p>MLIR supports defining named aliases for attribute values. An attribute alias is
an identifier that can be used in the place of the attribute that it defines.
These aliases <em>must</em> be defined before their uses. Alias names may not contain a
&lsquo;.&rsquo;, since those names are reserved for
<a href=#dialect-attribute-values>dialect attributes</a>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#map</span> <span class=p>=</span> affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=err>+</span> <span class=m>10</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Using the original attribute.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%b</span> <span class=p>=</span> affine<span class=p>.</span>apply affine_map<span class=p>&lt;(</span>d0<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span>d0 <span class=err>+</span> <span class=m>10</span><span class=p>)&gt;</span> <span class=p>(</span><span class=nv>%a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Using the attribute alias.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%b</span> <span class=p>=</span> affine<span class=p>.</span>apply <span class=nv>#map</span><span class=p>(</span><span class=nv>%a</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=dialect-attribute-values>Dialect Attribute Values&nbsp;<a class=headline-hash href=#dialect-attribute-values>Â¶</a></h3><p>Similarly to operations, dialects may define custom attribute values.</p><pre tabindex=0><code>dialect-namespace ::= bare-id

dialect-attribute ::= `#` (opaque-dialect-attribute | pretty-dialect-attribute)
opaque-dialect-attribute ::= dialect-namespace dialect-attribute-body
pretty-dialect-attribute ::= dialect-namespace `.` pretty-dialect-attribute-lead-ident
                                              dialect-attribute-body?
pretty-dialect-attribute-lead-ident ::= `[A-Za-z][A-Za-z0-9._]*`

dialect-attribute-body ::= `&lt;` dialect-attribute-contents+ `&gt;`
dialect-attribute-contents ::= dialect-attribute-body
                            | `(` dialect-attribute-contents+ `)`
                            | `[` dialect-attribute-contents+ `]`
                            | `{` dialect-attribute-contents+ `}`
                            | [^\[&lt;({\]&gt;)}\0]+
</code></pre><p>Dialect attributes are generally specified in an opaque form, where the contents
of the attribute are defined within a body wrapped with the dialect namespace
and <code>&lt;></code>. Consider the following examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A string attribute.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#foo</span><span class=p>&lt;</span>string<span class=p>&lt;</span><span class=s>&#34;&#34;</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A complex attribute.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#foo</span><span class=p>&lt;</span><span class=s>&#34;a123^^^&#34;</span> <span class=err>+</span> bar<span class=p>&gt;</span>
</span></span></code></pre></div><p>Dialect attributes that are simple enough may use a prettier format, which unwraps
part of the syntax into an equivalent, but lighter weight form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A string attribute.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>#foo.string</span><span class=p>&lt;</span><span class=s>&#34;&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>See
<a href=/docs/DefiningDialects/AttributesAndTypes/>here</a> on how to define dialect attribute values.</p><h3 id=builtin-attribute-values>Builtin Attribute Values&nbsp;<a class=headline-hash href=#builtin-attribute-values>Â¶</a></h3><p>The
<a href=/docs/Dialects/Builtin/>builtin dialect</a> defines a set of attribute values
that are directly usable by any other dialect in MLIR. These types cover a range
from primitive integer and floating-point values, attribute dictionaries, dense
multi-dimensional arrays, and more.</p><h3 id=ir-versioning>IR Versioning&nbsp;<a class=headline-hash href=#ir-versioning>Â¶</a></h3><p>A dialect can opt-in to handle versioning through the
<code>BytecodeDialectInterface</code>. Few hooks are exposed to the dialect to allow
managing a version encoded into the bytecode file. The version is loaded lazily
and allows to retrieve the version information while parsing the input IR, and
gives an opportunity to each dialect for which a version is present to perform
IR upgrades post-parsing through the <code>upgradeFromVersion</code> method. Custom
Attribute and Type encodings can also be upgraded according to the dialect
version using readAttribute and readType methods.</p><p>There is no restriction on what kind of information a dialect is allowed to
encode to model its versioning. Currently, versioning is supported only for
bytecode formats.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/CAPI/ title="MLIR C API"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - MLIR C API</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/ReleaseNotes/ title="MLIR Release Notes">Next - MLIR Release Notes <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li class=active><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on âStructuredâ Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>