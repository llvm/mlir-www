<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Toy Tutorial on MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/</link><description>Recent content in Toy Tutorial on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Tutorials/Toy/index.xml" rel="self" type="application/rss+xml"/><item><title>Chapter 1: Toy Language and AST</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/</guid><description>The Language The AST The Language This tutorial will be illustrated with a toy language that we’ll call “Toy” (naming is hard&amp;hellip;). Toy is a tensor-based language that allows you to define functions, perform some math computation, and print results.
Given that we want to keep things simple, the codegen will be limited to tensors of rank &amp;lt;= 2, and the only datatype in Toy is a 64-bit floating point type (aka ‘double’ in C parlance).</description></item><item><title>Chapter 2: Emitting Basic MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/</guid><description>Introduction: Multi-Level Intermediate Representation Interfacing with MLIR Opaque API Defining a Toy Dialect Defining Toy Operations Op vs Operation: Using MLIR Operations Using the Operation Definition Specification (ODS) Framework Complete Toy Example Now that we&amp;rsquo;re familiar with our language and the AST, let&amp;rsquo;s see how MLIR can help to compile Toy.
Introduction: Multi-Level Intermediate Representation Other compilers, like LLVM (see the Kaleidoscope tutorial), offer a fixed set of predefined types and (usually low-level / RISC-like) instructions.</description></item><item><title>Chapter 3: High-level Language-Specific Analysis and Transformation</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/</guid><description>Optimize Transpose using C++ style pattern-match and rewrite Optimize Reshapes using DRR Creating a dialect that closely represents the semantics of an input language enables analyses, transformations and optimizations in MLIR that require high-level language information and are generally performed on the language AST. For example, clang has a fairly heavy mechanism for performing template instantiation in C++.
We divide compiler transformations into two categories: local and global. In this chapter, we focus on how to leverage the Toy Dialect and its high-level semantics to perform local pattern-match transformations that would be difficult in LLVM.</description></item><item><title>Chapter 4: Enabling Generic Transformation with Interfaces</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/</guid><description>Background: Grappling with an Extensible IR Shape Inference: Preparing for Code Generation Inlining Intraprocedural Shape Inference Background: Grappling with an Extensible IR Through dialects, MLIR allows for the representation of many different levels of abstraction; the Toy dialect that we have previously defined is one such example. Though these different dialects may represent different abstractions, there is often a set of common transformations and analyses that we would like to perform.</description></item><item><title>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/</guid><description>Conversion Target Conversion Patterns Partial Lowering Design Considerations With Partial Lowering Complete Toy Example Taking Advantage of Affine Optimization At this point, we are eager to generate actual code and see our Toy language take life. We will use LLVM to generate code, but just showing the LLVM builder interface here wouldn&amp;rsquo;t be very exciting. Instead, we will show how to perform progressive lowering through a mix of dialects coexisting in the same function.</description></item><item><title>Chapter 6: Lowering to LLVM and CodeGeneration</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/</guid><description>Lowering to LLVM Conversion Target Type Converter Conversion Patterns Full Lowering CodeGen: Getting Out of MLIR Emitting LLVM IR Setting up a JIT In the previous chapter, we introduced the dialect conversion framework and partially lowered many of the Toy operations to affine loop nests for optimization. In this chapter, we will finally lower to LLVM for code generation.
Lowering to LLVM For this lowering, we will again use the dialect conversion framework to perform the heavy lifting.</description></item><item><title>Chapter 7: Adding a Composite Type to Toy</title><link>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/</guid><description>Defining a struct in Toy Defining a struct in MLIR Defining the Type Class Exposing to ODS Parsing and Printing Operating on StructType In the previous chapter, we demonstrated an end-to-end compilation flow from our Toy front-end to LLVM IR. In this chapter, we will extend the Toy language to support a new composite struct type.
Defining a struct in Toy The first thing we need to define is the interface of this type in our toy source language.</description></item></channel></rss>