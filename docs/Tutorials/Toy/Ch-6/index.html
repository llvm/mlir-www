<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 6: Lowering to LLVM and CodeGeneration - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 6: Lowering to LLVM and CodeGeneration</h1><p><nav id=TableOfContents><ul><li><a href=#lowering-to-llvm>Lowering to LLVM</a><ul><li><a href=#conversion-target>Conversion Target</a></li><li><a href=#type-converter>Type Converter</a></li><li><a href=#conversion-patterns>Conversion Patterns</a></li><li><a href=#full-lowering>Full Lowering</a></li></ul></li><li><a href=#codegen-getting-out-of-mlir>CodeGen: Getting Out of MLIR</a><ul><li><a href=#emitting-llvm-ir>Emitting LLVM IR</a></li><li><a href=#setting-up-a-jit>Setting up a JIT</a></li></ul></li></ul></nav><p>In the
<a href=/docs/Tutorials/Toy/Ch-5/>previous chapter</a>, we introduced the
<a href=/docs/DialectConversion/>dialect conversion</a> framework and partially lowered
many of the <code>Toy</code> operations to affine loop nests for optimization. In this
chapter, we will finally lower to LLVM for code generation.</p><h2 id=lowering-to-llvm>Lowering to LLVM&nbsp;<a class=headline-hash href=#lowering-to-llvm>Â¶</a></h2><p>For this lowering, we will again use the dialect conversion framework to perform
the heavy lifting. However, this time, we will be performing a full conversion
to the
<a href=/docs/Dialects/LLVM/>LLVM dialect</a>. Thankfully, we have already
lowered all but one of the <code>toy</code> operations, with the last being <code>toy.print</code>.
Before going over the conversion to LLVM, let&rsquo;s lower the <code>toy.print</code> operation.
We will lower this operation to a non-affine loop nest that invokes <code>printf</code> for
each element. Note that, because the dialect conversion framework supports
<a href=/getting_started/Glossary/#transitive-lowering>transitive lowering</a>,
we don&rsquo;t need to directly emit operations in the LLVM dialect. By transitive
lowering, we mean that the conversion framework may apply multiple patterns to
fully legalize an operation. In this example, we are generating a structured
loop nest instead of the branch-form in the LLVM dialect. As long as we then
have a lowering from the loop operations to LLVM, the lowering will still
succeed.</p><p>During lowering we can get, or build, the declaration for printf as so:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/// Return a symbol reference to the printf function, inserting it into the
</span></span></span><span class=line><span class=cl><span class=c1>/// module if necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=n>FlatSymbolRefAttr</span> <span class=nf>getOrInsertPrintf</span><span class=p>(</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                           <span class=n>ModuleOp</span> <span class=n>module</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                           <span class=n>LLVM</span><span class=o>::</span><span class=n>LLVMDialect</span> <span class=o>*</span><span class=n>llvmDialect</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=o>*</span><span class=n>context</span> <span class=o>=</span> <span class=n>module</span><span class=p>.</span><span class=n>getContext</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>lookupSymbol</span><span class=o>&lt;</span><span class=n>LLVM</span><span class=o>::</span><span class=n>LLVMFuncOp</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;printf&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>SymbolRefAttr</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=s>&#34;printf&#34;</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Create a function declaration for printf, the signature is:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   * `i32 (i8*, ...)`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>llvmI32Ty</span> <span class=o>=</span> <span class=n>IntegerType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=mi>32</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>llvmI8PtrTy</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>      <span class=n>LLVM</span><span class=o>::</span><span class=n>LLVMPointerType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>IntegerType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=mi>8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>llvmFnType</span> <span class=o>=</span> <span class=n>LLVM</span><span class=o>::</span><span class=n>LLVMFunctionType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>llvmI32Ty</span><span class=p>,</span> <span class=n>llvmI8PtrTy</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                <span class=cm>/*isVarArg=*/</span><span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Insert the printf function into the body of the parent module.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>PatternRewriter</span><span class=o>::</span><span class=n>InsertionGuard</span> <span class=n>insertGuard</span><span class=p>(</span><span class=n>rewriter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>rewriter</span><span class=p>.</span><span class=n>setInsertionPointToStart</span><span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>getBody</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>LLVM</span><span class=o>::</span><span class=n>LLVMFuncOp</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>rewriter</span><span class=p>,</span> <span class=n>module</span><span class=p>.</span><span class=n>getLoc</span><span class=p>(),</span> <span class=s>&#34;printf&#34;</span><span class=p>,</span> <span class=n>llvmFnType</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>SymbolRefAttr</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=s>&#34;printf&#34;</span><span class=p>,</span> <span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now that the lowering for the printf operation has been defined, we can specify
the components necessary for the lowering. These are largely the same as the
components defined in the
<a href=/docs/Tutorials/Toy/Ch-5/>previous chapter</a>.</p><h3 id=conversion-target>Conversion Target&nbsp;<a class=headline-hash href=#conversion-target>Â¶</a></h3><p>For this conversion, aside from the top-level module, we will be lowering
everything to the LLVM dialect.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>ConversionTarget</span> <span class=n>target</span><span class=p>(</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>target</span><span class=p>.</span><span class=n>addLegalDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>LLVMDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>target</span><span class=p>.</span><span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>ModuleOp</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></div><h3 id=type-converter>Type Converter&nbsp;<a class=headline-hash href=#type-converter>Â¶</a></h3><p>This lowering will also transform the MemRef types which are currently being
operated on into a representation in LLVM. To perform this conversion, we use a
TypeConverter as part of the lowering. This converter specifies how one type
maps to another. This is necessary now that we are performing more complicated
lowerings involving block arguments. Given that we don&rsquo;t have any
Toy-dialect-specific types that need to be lowered, the default converter is
enough for our use case.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>LLVMTypeConverter</span> <span class=nf>typeConverter</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span></code></pre></div><h3 id=conversion-patterns>Conversion Patterns&nbsp;<a class=headline-hash href=#conversion-patterns>Â¶</a></h3><p>Now that the conversion target has been defined, we need to provide the patterns
used for lowering. At this point in the compilation process, we have a
combination of <code>toy</code>, <code>affine</code>, <code>arith</code>, and <code>std</code> operations. Luckily, the
<code>affine</code>, <code>arith</code>, and <code>std</code> dialects already provide the set of patterns needed
to transform them into LLVM dialect. These patterns allow for lowering the IR in
multiple stages by relying on
<a href=/getting_started/Glossary/#transitive-lowering>transitive lowering</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>RewritePatternSet</span> <span class=n>patterns</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>populateAffineToStdConversionPatterns</span><span class=p>(</span><span class=n>patterns</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>cf</span><span class=o>::</span><span class=n>populateSCFToControlFlowConversionPatterns</span><span class=p>(</span><span class=n>patterns</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>arith</span><span class=o>::</span><span class=n>populateArithToLLVMConversionPatterns</span><span class=p>(</span><span class=n>typeConverter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                                          <span class=n>patterns</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>populateFuncToLLVMConversionPatterns</span><span class=p>(</span><span class=n>typeConverter</span><span class=p>,</span> <span class=n>patterns</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>cf</span><span class=o>::</span><span class=n>populateControlFlowToLLVMConversionPatterns</span><span class=p>(</span><span class=n>patterns</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// The only remaining operation, to lower from the `toy` dialect, is the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// PrintOp.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>patterns</span><span class=p>.</span><span class=n>add</span><span class=o>&lt;</span><span class=n>PrintOpLowering</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span></code></pre></div><h3 id=full-lowering>Full Lowering&nbsp;<a class=headline-hash href=#full-lowering>Â¶</a></h3><p>We want to completely lower to LLVM, so we use a <code>FullConversion</code>. This ensures
that only legal operations will remain after the conversion.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>ModuleOp</span> <span class=n>module</span> <span class=o>=</span> <span class=n>getOperation</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>failed</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>applyFullConversion</span><span class=p>(</span><span class=n>module</span><span class=p>,</span> <span class=n>target</span><span class=p>,</span> <span class=n>patterns</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=n>signalPassFailure</span><span class=p>();</span>
</span></span></code></pre></div><p>Looking back at our current working example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>toy<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> toy<span class=p>.</span><span class=kt>constant</span> dense<span class=p>&lt;[[</span><span class=m>1.000000e+00</span><span class=p>,</span> <span class=m>2.000000e+00</span><span class=p>,</span> <span class=m>3.000000e+00</span><span class=p>],</span> <span class=p>[</span><span class=m>4.000000e+00</span><span class=p>,</span> <span class=m>5.000000e+00</span><span class=p>,</span> <span class=m>6.000000e+00</span><span class=p>]]&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> toy<span class=p>.</span>transpose<span class=p>(</span><span class=nv>%0</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>f64</span><span class=p>&gt;)</span> to <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> toy<span class=p>.</span>mul <span class=nv>%2</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  toy<span class=p>.</span>print <span class=nv>%3</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>3x2x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  toy<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can now lower down to the LLVM dialect, which produces the following code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@free</span><span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@printf</span><span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;,</span> <span class=p>...)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@malloc</span><span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1.000000e+00</span> <span class=p>:</span> <span class=k>f64</span><span class=p>)</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2.000000e+00</span> <span class=p>:</span> <span class=k>f64</span><span class=p>)</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>^bb16</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%221</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%25</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%222</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%223</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%224</span> <span class=p>=</span> llvm<span class=p>.</span>mul <span class=nv>%214</span><span class=p>,</span> <span class=nv>%223</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%225</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%222</span><span class=p>,</span> <span class=nv>%224</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%226</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%227</span> <span class=p>=</span> llvm<span class=p>.</span>mul <span class=nv>%219</span><span class=p>,</span> <span class=nv>%226</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%228</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%225</span><span class=p>,</span> <span class=nv>%227</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%229</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%221</span><span class=p>[</span><span class=nv>%228</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span><span class=s>&#34;double*&#34;</span><span class=p>&gt;,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;f64*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%230</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%229</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;double*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%231</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@printf</span><span class=p>(</span><span class=nv>%207</span><span class=p>,</span> <span class=nv>%230</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;,</span> <span class=k>f64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%232</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%219</span><span class=p>,</span> <span class=nv>%218</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>br <span class=nl>^bb15</span><span class=p>(</span><span class=nv>%232</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>^bb18</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%235</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%65</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%236</span> <span class=p>=</span> llvm<span class=p>.</span>bitcast <span class=nv>%235</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;double*&#34;</span><span class=p>&gt;</span> to <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>call <span class=nf>@free</span><span class=p>(</span><span class=nv>%236</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%237</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%45</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%238</span> <span class=p>=</span> llvm<span class=p>.</span>bitcast <span class=nv>%237</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;double*&#34;</span><span class=p>&gt;</span> to <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>call <span class=nf>@free</span><span class=p>(</span><span class=nv>%238</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%239</span> <span class=p>=</span> llvm<span class=p>.</span>extractvalue <span class=nv>%25</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;{ double*, i64, [2 x i64], [2 x i64] }&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%240</span> <span class=p>=</span> llvm<span class=p>.</span>bitcast <span class=nv>%239</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;double*&#34;</span><span class=p>&gt;</span> to <span class=p>!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>call <span class=nf>@free</span><span class=p>(</span><span class=nv>%240</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>&lt;</span><span class=s>&#34;i8*&#34;</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>See
<a href=/docs/TargetLLVMIR/>LLVM IR Target</a> for
more in-depth details on lowering to the LLVM dialect.</p><h2 id=codegen-getting-out-of-mlir>CodeGen: Getting Out of MLIR&nbsp;<a class=headline-hash href=#codegen-getting-out-of-mlir>Â¶</a></h2><p>At this point we are right at the cusp of code generation. We can generate code
in the LLVM dialect, so now we just need to export to LLVM IR and setup a JIT to
run it.</p><h3 id=emitting-llvm-ir>Emitting LLVM IR&nbsp;<a class=headline-hash href=#emitting-llvm-ir>Â¶</a></h3><p>Now that our module is comprised only of operations in the LLVM dialect, we can
export to LLVM IR. To do this programmatically, we can invoke the following
utility:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>llvm</span><span class=o>::</span><span class=n>Module</span><span class=o>&gt;</span> <span class=n>llvmModule</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>::</span><span class=n>translateModuleToLLVMIR</span><span class=p>(</span><span class=n>module</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>llvmModule</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* ... an error was encountered ... */</span>
</span></span></code></pre></div><p>Exporting our module to LLVM IR generates:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-llvm data-lang=llvm><span class=line><span class=cl><span class=k>define</span> <span class=kt>void</span> <span class=vg>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>102</span><span class=err>:</span>
</span></span><span class=line><span class=cl>  <span class=n>%103</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%8</span><span class=p>,</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>  <span class=n>%104</span> <span class=p>=</span> <span class=k>mul</span> <span class=k>i64</span> <span class=n>%96</span><span class=p>,</span> <span class=m>2</span>
</span></span><span class=line><span class=cl>  <span class=n>%105</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=n>%104</span>
</span></span><span class=line><span class=cl>  <span class=n>%106</span> <span class=p>=</span> <span class=k>mul</span> <span class=k>i64</span> <span class=n>%100</span><span class=p>,</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>  <span class=n>%107</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=n>%105</span><span class=p>,</span> <span class=n>%106</span>
</span></span><span class=line><span class=cl>  <span class=n>%108</span> <span class=p>=</span> <span class=k>getelementptr</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%103</span><span class=p>,</span> <span class=k>i64</span> <span class=n>%107</span>
</span></span><span class=line><span class=cl>  <span class=n>%109</span> <span class=p>=</span> <span class=err>memref</span><span class=p>.</span><span class=k>load</span> <span class=kt>double</span><span class=p>,</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%108</span>
</span></span><span class=line><span class=cl>  <span class=n>%110</span> <span class=p>=</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=n>%109</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%111</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i64</span> <span class=n>%100</span><span class=p>,</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>  <span class=err>cf</span><span class=p>.</span><span class=k>br</span> <span class=kt>label</span> <span class=n>%99</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=m>115</span><span class=err>:</span>
</span></span><span class=line><span class=cl>  <span class=n>%116</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%24</span><span class=p>,</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>  <span class=n>%117</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%116</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
</span></span><span class=line><span class=cl>  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%117</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%118</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%16</span><span class=p>,</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>  <span class=n>%119</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%118</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
</span></span><span class=line><span class=cl>  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%119</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%120</span> <span class=p>=</span> <span class=k>extractvalue</span> <span class=p>{</span> <span class=kt>double</span><span class=p>*,</span> <span class=k>i64</span><span class=p>,</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span> <span class=k>x</span> <span class=k>i64</span><span class=p>]</span> <span class=p>}</span> <span class=n>%8</span><span class=p>,</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>  <span class=n>%121</span> <span class=p>=</span> <span class=k>bitcast</span> <span class=kt>double</span><span class=p>*</span> <span class=n>%120</span> <span class=k>to</span> <span class=k>i8</span><span class=p>*</span>
</span></span><span class=line><span class=cl>  <span class=k>call</span> <span class=kt>void</span> <span class=vg>@free</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=n>%121</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>ret</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If we enable optimization on the generated LLVM IR, we can trim this down quite
a bit:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-llvm data-lang=llvm><span class=line><span class=cl><span class=k>define</span> <span class=kt>void</span> <span class=vg>@main</span><span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=n>%0</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>1.000000e+00</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%1</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>1.600000e+01</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%putchar</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%2</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>4.000000e+00</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%3</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>2.500000e+01</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%putchar.1</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%4</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>9.000000e+00</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>%5</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=p>(</span><span class=k>i8</span><span class=p>*,</span> <span class=p>...)</span> <span class=vg>@printf</span><span class=p>(</span><span class=k>i8</span><span class=p>*</span> <span class=k>nonnull</span> <span class=k>dereferenceable</span><span class=p>(</span><span class=m>1</span><span class=p>)</span> <span class=k>getelementptr</span> <span class=k>inbounds</span> <span class=p>([</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>],</span> <span class=p>[</span><span class=m>4</span> <span class=k>x</span> <span class=k>i8</span><span class=p>]*</span> <span class=vg>@frmt_spec</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>,</span> <span class=k>i64</span> <span class=m>0</span><span class=p>),</span> <span class=kt>double</span> <span class=m>3.600000e+01</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%putchar.2</span> <span class=p>=</span> <span class=k>tail</span> <span class=k>call</span> <span class=k>i32</span> <span class=vg>@putchar</span><span class=p>(</span><span class=k>i32</span> <span class=m>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>ret</span> <span class=kt>void</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The full code listing for dumping LLVM IR can be found in
<code>examples/toy/Ch6/toy.cpp</code> in the <code>dumpLLVMIR()</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>dumpLLVMIR</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>ModuleOp</span> <span class=n>module</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Translate the module, that contains the LLVM dialect, to LLVM IR. Use a
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// fresh LLVM IR context. (Note that LLVM is not thread-safe and any
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// concurrent use of a context requires external locking.)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>llvm</span><span class=o>::</span><span class=n>LLVMContext</span> <span class=n>llvmContext</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>llvmModule</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>::</span><span class=n>translateModuleToLLVMIR</span><span class=p>(</span><span class=n>module</span><span class=p>,</span> <span class=n>llvmContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>llvmModule</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>errs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Failed to emit LLVM IR</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Initialize LLVM targets.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>llvm</span><span class=o>::</span><span class=n>InitializeNativeTarget</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>llvm</span><span class=o>::</span><span class=n>InitializeNativeTargetAsmPrinter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>ExecutionEngine</span><span class=o>::</span><span class=n>setupTargetTriple</span><span class=p>(</span><span class=n>llvmModule</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Optionally run an optimization pipeline over the llvm module.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>optPipeline</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>::</span><span class=n>makeOptimizingTransformer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*optLevel=*/</span><span class=n>EnableOpt</span> <span class=o>?</span> <span class=mi>3</span> <span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/*sizeLevel=*/</span><span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*targetMachine=*/</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>err</span> <span class=o>=</span> <span class=n>optPipeline</span><span class=p>(</span><span class=n>llvmModule</span><span class=p>.</span><span class=n>get</span><span class=p>()))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>errs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Failed to optimize LLVM IR &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>err</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=n>llvm</span><span class=o>::</span><span class=n>errs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>llvmModule</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=setting-up-a-jit>Setting up a JIT&nbsp;<a class=headline-hash href=#setting-up-a-jit>Â¶</a></h3><p>Setting up a JIT to run the module containing the LLVM dialect can be done using
the <code>mlir::ExecutionEngine</code> infrastructure. This is a utility wrapper around
LLVM&rsquo;s JIT that accepts <code>.mlir</code> as input. The full code listing for setting up
the JIT can be found in <code>Ch6/toyc.cpp</code> in the <code>runJit()</code> function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>runJit</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>ModuleOp</span> <span class=n>module</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Initialize LLVM targets.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>llvm</span><span class=o>::</span><span class=n>InitializeNativeTarget</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>llvm</span><span class=o>::</span><span class=n>InitializeNativeTargetAsmPrinter</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// An optimization pipeline to use within the execution engine.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>optPipeline</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>::</span><span class=n>makeOptimizingTransformer</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*optLevel=*/</span><span class=n>EnableOpt</span> <span class=o>?</span> <span class=mi>3</span> <span class=o>:</span> <span class=mi>0</span><span class=p>,</span> <span class=cm>/*sizeLevel=*/</span><span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*targetMachine=*/</span><span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Create an MLIR execution engine. The execution engine eagerly JIT-compiles
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the module.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>maybeEngine</span> <span class=o>=</span> <span class=n>mlir</span><span class=o>::</span><span class=n>ExecutionEngine</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>module</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*llvmModuleBuilder=*/</span><span class=k>nullptr</span><span class=p>,</span> <span class=n>optPipeline</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>maybeEngine</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;failed to construct an execution engine&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=o>&amp;</span><span class=n>engine</span> <span class=o>=</span> <span class=n>maybeEngine</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Invoke the JIT-compiled function.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>invocationResult</span> <span class=o>=</span> <span class=n>engine</span><span class=o>-&gt;</span><span class=n>invoke</span><span class=p>(</span><span class=s>&#34;main&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>invocationResult</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>llvm</span><span class=o>::</span><span class=n>errs</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;JIT invocation failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>You can play around with it from the build directory:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=s1>&#39;def main() { print([[1, 2], [3, 4]]); }&#39;</span> <span class=p>|</span> ./bin/toyc-ch6 -emit<span class=o>=</span>jit
</span></span><span class=line><span class=cl>1.000000 2.000000
</span></span><span class=line><span class=cl>3.000000 4.000000
</span></span></code></pre></div><p>You can also play with <code>-emit=mlir</code>, <code>-emit=mlir-affine</code>, <code>-emit=mlir-llvm</code>, and
<code>-emit=llvm</code> to compare the various levels of IR involved. Also try options like
<a href=/docs/PassManagement/#ir-printing><code>--mlir-print-ir-after-all</code></a> to track the
evolution of the IR throughout the pipeline.</p><p>The example code used throughout this section can be found in
test/Examples/Toy/Ch6/llvm-lowering.mlir.</p><p>So far, we have worked with primitive data types. In the
<a href=/docs/Tutorials/Toy/Ch-7/>next chapter</a>, we will add a composite <code>struct</code> type.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/ title="Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/ title="Chapter 7: Adding a Composite Type to Toy">Next - Chapter 7: Adding a Composite Type to Toy <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on âStructuredâ Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>