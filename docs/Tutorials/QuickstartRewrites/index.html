<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Quickstart tutorial to adding MLIR graph rewrite - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Quickstart tutorial to adding MLIR graph rewrite</h1><p>This document will present a quickstart to adding graph rewrites. We shall start
by defining an operation, showing multiple ways to define the rewrite using
patterns, as well as defining the rewrite using a graph walker (note: using
patterns and the rewrite engine is preferred, showing the walker is for
demonstration purposes).</p><p>See
<a href=/docs/LangRef/>MLIR specification</a> for more information about MLIR, the
structure of the IR, operations, etc. See
<a href=/docs/DefiningDialects/Operations/>Table-driven Operation Definition</a> and
<a href=/docs/DeclarativeRewrites/>Declarative Rewrite Rule</a> for the detailed explanation
of all available mechanisms for defining operations and rewrites in a
table-driven manner.</p><h2 id=adding-operation>Adding operation&nbsp;<a class=headline-hash href=#adding-operation>¶</a></h2><p>An operation in MLIR is specified using a definition in
<a href=https://llvm.org/docs/TableGen/index.html>TableGen</a> file. TableGen is a
modeling tool to specify the ops and the C++ code to interact with these
operations are generated from. To define an operation one needs to specify:</p><ul><li>The operation name. This name is a unique identifier of the operation within
MLIR. Most operations are within a dialect, so for example one could have
<code>tfl.add</code> to represent the add operation in the TensorFlow Lite dialect.
Instead of repeating the dialect in the op definition, a base class for the
op dialect is commonly created that prepends the dialect namespace given an
op name.</li><li>The traits of the operation. These allow you to specify traits of the
operation, such as whether it has side effects or whether it should be
verified that the operands and result types are the same. These are backed
by C++ traits that perform the verification.</li><li>The arguments of the operation. These are the input operands (values at
runtime produced by other ops) and attributes (compile time known constant
values that affect the behavior of the op) that are the inputs of/define the
behavior of the operation. The input operands may be named, the attributes
must be named.</li><li>The result(s) of the operation. These may again named or not.</li><li>Documentation of the operation. This includes a one-line summary as well as
a longer human-readable description of the operation.</li><li>Dialect specific information. Additional information could be added to the
operation definition that are only used by dialect specific drivers. These
are ignored by the main op and doc generators, but could be used in, say,
the translation from a dialect to another representation.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>TFL_LeakyReluOp</span><span class=p>:</span> <span class=nv>TFL_Op</span><span class=p>&lt;</span><span class=nv>TFL_Dialect</span><span class=p>,</span> <span class=s>&#34;leaky_relu&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                            <span class=p>[</span><span class=nv>NoMemoryEffect</span><span class=p>,</span> <span class=nv>SameValueType</span><span class=p>]&gt;,</span>
</span></span><span class=line><span class=cl>                     <span class=nv>Results</span><span class=p>&lt;(</span><span class=nv>outs</span> <span class=nv>Tensor</span><span class=p>)&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>    <span class=nv>F32Tensor</span><span class=p>:</span><span class=nv>$x</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c>// Slope of the activation function at x &lt; 0.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$alpha</span>
</span></span><span class=line><span class=cl>  <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Leaky ReLU operator&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    Element-wise Leaky ReLU operator
</span></span></span><span class=line><span class=cl><span class=s>      x -&gt; x &gt;= 0 ? x : (alpha * x)
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// TFLite specific attribute that is used when generating the output
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// flatbuffer.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>hasOptions</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Note in the above the result types and inputs are specified in different ways,
one by way of trait and the other by way of let. It is possible to specify both
in either way.</p><p>Operations can also have custom parser, printer, builder, verifier, constant
folder, or canonicalizer. These require specifying additional C++ methods to
invoke for additional functionality. For example, if an operation is marked to
have a folder, the constant folder also needs to be added, e.g.,:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>OpFoldResult</span> <span class=n>SpecificOp</span><span class=o>::</span><span class=n>fold</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>constOperands</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>unable_to_fold</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>  <span class=p>....</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=adding-patterns>Adding patterns&nbsp;<a class=headline-hash href=#adding-patterns>¶</a></h2><p>There are multiple forms of graph rewrite that can be performed in MLIR. One of
the most common is DAG tile to DAG tile rewrite. Patterns provide a concise way
to express this transformation as a pair of source pattern to match and
resultant pattern. There are both the C++ classes to represent this
transformation, as well as the patterns in TableGen from which these can be
generated.</p><h3 id=tablegen-patterns>TableGen patterns&nbsp;<a class=headline-hash href=#tablegen-patterns>¶</a></h3><p>Let us continue with LeakyRelu. To map from TensorFlow&rsquo;s <code>LeakyRelu</code> to
TensorFlow Lite&rsquo;s <code>LeakyRelu</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>TF_LeakyReluOp</span> <span class=nv>$arg</span><span class=p>,</span> <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$a</span><span class=p>),</span> <span class=p>(</span><span class=nv>TFL_LeakyReluOp</span> <span class=nv>$arg</span><span class=p>,</span> <span class=nv>$a</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>The pattern is specified by instantiating a <code>Pat</code> with a source and result DAG.
The arguments in the source pattern is captured and can be used in the result
pattern. This is a simple pattern as we have a 1:1 mapping and the attribute
does not need to be transformed (e.g., both have a floating point attribute for
alpha). The names of the attributes specified in the pattern is for
matching/referencing and need not match the original attribute name in the op
definition but the order of arguments of the dags do need to match.</p><p>To specify a pattern, both the source and resultant ops need to be defined using
TableGen.</p><p>If this were a more advance pattern that the current framework could not express
as destination then one could use a general native code fallback method. This
consists of defining a pattern as well as adding a C++ function to perform the
replacement:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>createTFLLeakyRelu</span> <span class=p>:</span> <span class=nv>NativeCodeCall</span><span class=p>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;createTFLLeakyRelu($_builder, $0.getDefiningOp(), $1, $2)&#34;</span><span class=p>&gt;;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=p>:</span> <span class=nv>Pat</span><span class=p>&lt;(</span><span class=nv>TF_LeakyReluOp</span><span class=p>:</span><span class=nv>$old_value</span><span class=p>,</span> <span class=nv>$arg</span><span class=p>,</span> <span class=nv>F32Attr</span><span class=p>:</span><span class=nv>$a</span><span class=p>),</span>
</span></span><span class=line><span class=cl>          <span class=p>(</span><span class=nv>createTFLLeakyRelu</span> <span class=nv>$old_value</span><span class=p>,</span> <span class=nv>$arg</span><span class=p>,</span> <span class=nv>$a</span><span class=p>)&gt;;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>Value</span> <span class=nf>createTFLLeakyRelu</span><span class=p>(</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span> <span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>Value</span> <span class=n>operand</span><span class=p>,</span> <span class=n>Attribute</span> <span class=n>attr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>mlir</span><span class=o>::</span><span class=n>TFL</span><span class=o>::</span><span class=n>LeakyReluOp</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=n>op</span><span class=o>-&gt;</span><span class=n>getLoc</span><span class=p>(),</span> <span class=n>operands</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>getType</span><span class=p>(),</span> <span class=cm>/*arg=*/</span><span class=n>operands</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*alpha=*/</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>FloatAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=n>attrs</span><span class=p>[</span><span class=mi>0</span><span class=p>]));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This allows for arbitrarily complex builders. Input pattern side one can express
multi-op patterns with constraints on input operands and attributes. But input
patterns cannot yet express constraints across multiple operands/attributes.</p><h3 id=register-the-pattern>Register the pattern&nbsp;<a class=headline-hash href=#register-the-pattern>¶</a></h3><p>The file containing the patterns need to be processed using <code>mlir-tblgen</code>
<code>-gen-rewriters</code> during compilation time. It can be invoked with the following
configuration in CMake:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=nb>set</span><span class=p>(</span><span class=s>LLVM_TARGET_DEFINITIONS</span> <span class=s>&lt;name-of-the-td-file&gt;</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>mlir_tablegen</span><span class=p>(</span><span class=s>&lt;name-of-the-generated-inc-file&gt;</span> <span class=s>-gen-rewriters</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>add_public_tablegen_target</span><span class=p>(</span><span class=s>&lt;name-of-the-cmake-target&gt;</span><span class=p>)</span><span class=err>
</span></span></span></code></pre></div><p>Then you can <code>#include</code> the generated file in any C++ implementation file you
like. (You will also need to make sure the library depends on the CMake target
defined in the above.) The generated file will have a <code>populateWithGenerated( RewritePatternSet &amp;patterns)</code> function that you can
use to collect all the generated patterns inside <code>patterns</code> and then use
<code>patterns</code> in any pass you would like.</p><h3 id=simple-c-matchandrewrite-style-specifications>Simple C++ <code>matchAndRewrite</code> style specifications&nbsp;<a class=headline-hash href=#simple-c-matchandrewrite-style-specifications>¶</a></h3><p>Many simple rewrites can be expressed with a <code>matchAndRewrite</code> style of
pattern, e.g. when converting a multiply by a power of two into a shift. For
these cases, the you can define the pattern as a simple function:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>LogicalResult</span>
</span></span><span class=line><span class=cl><span class=nf>convertTFLeakyRelu</span><span class=p>(</span><span class=n>TFLeakyReluOp</span> <span class=n>op</span><span class=p>,</span> <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>rewriter</span><span class=p>.</span><span class=n>replaceOpWithNewOp</span><span class=o>&lt;</span><span class=n>TFL</span><span class=o>::</span><span class=n>LeakyReluOp</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>op</span><span class=p>,</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getResult</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>getType</span><span class=p>(),</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>      <span class=cm>/*alpha=*/</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrOfType</span><span class=o>&lt;</span><span class=n>FloatAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;alpha&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>populateRewrites</span><span class=p>(</span><span class=n>RewritePatternSet</span> <span class=o>&amp;</span><span class=n>patternSet</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Add it to a pattern set.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>patternSet</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>convertTFLeakyRelu</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>ODS provides a simple way to define a function-style canonicalization for your
operation. In the TableGen definition of the op, specify
<code>let hasCanonicalizeMethod = 1;</code> and then implement the <code>canonicalize</code> method in
your .cpp file:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Example from the CIRCT project which has a variadic integer multiply.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>LogicalResult</span> <span class=n>circt</span><span class=o>::</span><span class=n>MulOp</span><span class=o>::</span><span class=n>canonicalize</span><span class=p>(</span><span class=n>MulOp</span> <span class=n>op</span><span class=p>,</span> <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>inputs</span> <span class=o>=</span> <span class=n>op</span><span class=p>.</span><span class=n>inputs</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>APInt</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// mul(x, c) -&gt; shl(x, log2(c)), where c is a power of two.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>inputs</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>2</span> <span class=o>&amp;&amp;</span> <span class=n>matchPattern</span><span class=p>(</span><span class=n>inputs</span><span class=p>.</span><span class=n>back</span><span class=p>(),</span> <span class=n>m_RConstant</span><span class=p>(</span><span class=n>value</span><span class=p>))</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>      <span class=n>value</span><span class=p>.</span><span class=n>isPowerOf2</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>shift</span> <span class=o>=</span> <span class=n>rtl</span><span class=o>::</span><span class=n>ConstantOp</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>rewriter</span><span class=p>,</span> <span class=n>op</span><span class=p>.</span><span class=n>getLoc</span><span class=p>(),</span> <span class=n>op</span><span class=p>.</span><span class=n>getType</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                                  <span class=n>value</span><span class=p>.</span><span class=n>exactLogBase2</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>shlOp</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>comb</span><span class=o>::</span><span class=n>ShlOp</span><span class=o>::</span><span class=n>create</span><span class=p>(</span><span class=n>rewriter</span><span class=p>,</span> <span class=n>op</span><span class=p>.</span><span class=n>getLoc</span><span class=p>(),</span> <span class=n>inputs</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=n>shift</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>rewriter</span><span class=p>.</span><span class=n>replaceOpWithNewOp</span><span class=o>&lt;</span><span class=n>MulOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=n>op</span><span class=p>.</span><span class=n>getType</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>                                       <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span><span class=p>(</span><span class=n>shlOp</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nf>failure</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>However, you may want the full generality of canonicalization patterns, for that
you can specify an arbitrary list of <code>RewritePattern</code>s.</p><h3 id=fully-general-c-rewritepattern-specifications>Fully general C++ <code>RewritePattern</code> specifications&nbsp;<a class=headline-hash href=#fully-general-c-rewritepattern-specifications>¶</a></h3><p>In case ODS patterns and <code>matchAndRewrite</code>-style functions are not sufficient
you can also specify rewrites as a general set of <code>RewritePattern</code>s:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>ConvertTFLeakyRelu</span> <span class=o>:</span> <span class=k>public</span> <span class=n>RewritePattern</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>ConvertTFLeakyRelu</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>RewritePattern</span><span class=p>(</span><span class=s>&#34;tf.LeakyRelu&#34;</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>context</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>LogicalResult</span> <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>rewriter</span><span class=p>.</span><span class=n>replaceOpWithNewOp</span><span class=o>&lt;</span><span class=n>TFL</span><span class=o>::</span><span class=n>LeakyReluOp</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>op</span><span class=p>,</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getResult</span><span class=p>(</span><span class=mi>0</span><span class=p>).</span><span class=n>getType</span><span class=p>(),</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getOperand</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=cm>/*alpha=*/</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrOfType</span><span class=o>&lt;</span><span class=n>FloatAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;alpha&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>In the C++ rewrite the static benefit of the rewrite pattern is specified at
construction. While in the pattern generator a simple heuristic is currently
employed based around the number of ops matched and replaced.</p><p>The above rule did not capture the matching operands/attributes, but in general
the <code>match</code> function in a multi-step rewrite may populate and return a
<code>PatternState</code> (or class derived from one) to pass information extracted during
matching to the rewrite. A single-step rewrite with the <code>matchAndRewrite</code>
function has the benefit of being able to directly use any values created when
matching; removing the need for <code>PatternState</code>.</p><h2 id=testing>Testing&nbsp;<a class=headline-hash href=#testing>¶</a></h2><p>MLIR uses
<a href=https://llvm.org/docs/CommandGuide/lit.html>lit</a> (LLVM Integrated
Testing) tool for performing testing. Testing is performed by way of creating
the input IR file, running a transformation and then verifying the output IR.
C++ unit tests are the exception, with the IR transformation serving as the core
testing mechanism. This results in fewer binaries that need to be built (and
linked) and forces to focus on the representation as an important piece.</p><p>For the legalization transform above we would have a test (probably as part of
the legalization pass test in TensorFlow Lite) such as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// RUN: mlir-opt -tfl-legalize-tf %s | FileCheck %s
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@LeakyRelu</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;tf.LeakyRelu&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span>alpha<span class=p>:</span> <span class=m>0.1</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%2</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// CHECK-LABEL: LeakyRelu
</span></span></span><span class=line><span class=cl><span class=c>// CHECK:  %0 = &#34;tfl.leaky_relu&#34;(%arg0) {alpha: 1.000000e-01} : (tensor&lt;1xf32&gt;) -&gt; tensor&lt;1xf32&gt;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>The RUN command at the top results in running the <code>mlir-opt</code> binary (which is
compiler writer tool to exercise different registered passes) to invoke the
optimization pass this transform was added as part of on the current file and to
verify its output using <code>FileCheck</code>. <code>FileCheck</code> is textual output verifier. In
particular it uses the CHECK expressions to verify the given output is produced.</p><p>There can be multiple RUN commands with different corresponding CHECK prefixes.
And in addition multiple independent tests separated by <code>// -----</code> and
<code>mlir-opt</code> invoked with <code>-split-input-file</code> flag. This is especially useful for
error testing.</p><p>This results in very simple, directed testing without need to work around
constant propagation or other, unrelated, optimization passes.</p><h2 id=adding-optimization-pass>Adding optimization pass&nbsp;<a class=headline-hash href=#adding-optimization-pass>¶</a></h2><p>Optimization passes that do not fit/are difficult to specify in the above
structure can be specified as general iterations across modules/functions. See
<a href=/docs/PassManagement/>Writing a Pass</a> for a general overview and introduction to
optimization passes in MLIR.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/ title="Creating a Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Creating a Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/Toy/ title="Toy Tutorial">Next - Toy Tutorial <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>