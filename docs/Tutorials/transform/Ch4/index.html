<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 4: Matching Payload with Transform Operations - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 4: Matching Payload with Transform Operations</h1><p><strong>Check the continuously-tested version of MLIR files under
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/test/Examples/transform/Ch4>mlir/test/Examples/transform/Ch4</a>.</strong></p><p>Up until now, we were applying transform dialect scripts under the assumption
that specific payload operations are identified by the caller when the transform
dialect interpreter is invoked. This may be seen as contrary to the idea of
driving transformations from a dialect since the transformation targets must be
identified through mechanisms external to the transform dialect interpreter, for
example, when invoking the interpreter programmatically in C++ or through pass
arguments as seen in previous chapters. It also adds practical overhead due to
increased interaction with the interpreter in C++, and cognitive overhead of
manipulating two interfaces at once. To remedy this, Transform dialect proposes
a subset of operations for <em>matching</em> payload operations that need to be
transformed.</p><p><em>Match</em> operations are simply transform operations with some additional
guarantees. In particular, they are not expected to modify the payload IR and
are expected to fail if their operands (typically payload operation handles) are
not associated with payload IR objects having desired properties, such as
operation names or kinds of arguments. Using simple combinator operations, it
becomes possible to set up a higher-level match and rewrite infrastructure
directly within the transform dialect.</p><h2 id=simple-match>Simple match&nbsp;<a class=headline-hash href=#simple-match>¶</a></h2><p>Let us reconsider the “fully connected layer” example from
<a href=/docs/Tutorials/transform/Ch1/#chaining-transformations-with-handles>Chapter
1</a>, reproduced below for
convenience.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Original function to optimize.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@fc_relu</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%rhs</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>                   <span class=nv>%bias</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%output</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>                   <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Matrix-matrix multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%matmul</span> <span class=p>=</span> linalg<span class=p>.</span>matmul
</span></span><span class=line><span class=cl>            ins<span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>            outs<span class=p>(</span><span class=nv>%output</span><span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Elementwise addition.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%biased</span> <span class=p>=</span> linalg<span class=p>.</span>elementwise <span class=nl>kind=</span><span class=nv>#linalg.elementwise_kind</span><span class=p>&lt;</span>add<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    ins<span class=p>(</span><span class=nv>%matmul</span><span class=p>,</span> <span class=nv>%bias</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    outs<span class=p>(</span><span class=nv>%output</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Elementwise max with 0 (ReLU).
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%c0f</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0.0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%relued</span> <span class=p>=</span> linalg<span class=p>.</span>elementwise <span class=nl>kind=</span><span class=nv>#linalg.elementwise_kind</span><span class=p>&lt;</span>max_signed<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    ins<span class=p>(</span><span class=nv>%biased</span><span class=p>,</span> <span class=nv>%c0f</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    outs<span class=p>(</span><span class=nv>%output</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>func</span><span class=p>.</span><span class=kt>return</span> <span class=nv>%relued</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>512x512x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In Chapter 1, we were calling the test transform interpreter pass with
additional arguments, <code>bind-first-extra-to-ops=linalg.matmul bind-second-extra-to-ops=linalg.elementwise</code>, to provide initial
associations for operation handles. Instead, we can use match operations to
discover relevant operations in the payload IR. Match operations can be combined
with “regular” transform operations using, e.g., the
<code>transform.collect_matching</code> combinator operation that leverages the concept of
named sequences to organize matchers.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The module containing named sequences must have an attribute allowing them
</span></span></span><span class=line><span class=cl><span class=c>// to enable verification.
</span></span></span><span class=line><span class=cl><span class=c></span>module <span class=nf>@transforms</span> attributes <span class=p>{</span> transform<span class=p>.</span>with_named_sequence <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Entry point. This takes as the only argument the root operation (typically
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// pass root) given to the transform interpreter.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>named_sequence <span class=nf>@__transform_main</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%root</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c>// Collect operations that match the criteria specified in named sequence.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// If the named sequence fails with a silenceable failure, silences it (the
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// message is forwarded to the debug stream). If the named sequence
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// succeeds, appends its results to the results of this operation.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%elemwise</span> <span class=p>=</span> transform<span class=p>.</span>collect_matching <span class=nf>@match_elemwise</span> in <span class=nv>%root</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    <span class=nv>%matmul</span> <span class=p>=</span> transform<span class=p>.</span>collect_matching <span class=nf>@match_matmul</span> in <span class=nv>%root</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>include <span class=nf>@print_elemwise</span> failures<span class=p>(</span>propagate<span class=p>)</span>  <span class=p>(</span><span class=nv>%elemwise</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>include <span class=nf>@print_matmul</span> failures<span class=p>(</span>propagate<span class=p>)</span>  <span class=p>(</span><span class=nv>%matmul</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// This is a matcher sequence. It is given an operation to match and the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// match is considered successful unless any nested operation produces a
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// failure. The values yielded by this operation will be forwarded to the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// rewriter sequence on success.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>named_sequence <span class=nf>@match_elemwise</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%entry</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%entry</span> <span class=p>[</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield <span class=nv>%entry</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>named_sequence <span class=nf>@match_matmul</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%entry</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%entry</span> <span class=p>[</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield <span class=nv>%entry</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// This is a rewriter sequence.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>named_sequence <span class=nf>@print_elemwise</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%elemwise_binary</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>debug<span class=p>.</span>emit_remark_at
</span></span><span class=line><span class=cl>      <span class=nv>%elemwise_binary</span><span class=p>,</span> <span class=s>&#34;elementwise binary&#34;</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>named_sequence <span class=nf>@print_matmul</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%matmul</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>debug<span class=p>.</span>emit_remark_at <span class=nv>%matmul</span><span class=p>,</span> <span class=s>&#34;matmul&#34;</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This script can be executed using the non-test interpreter pass running on the
root operation of the translation unit without additional flags: <code>mlir-opt --transform-interpreter</code>. It will emit corresponding remarks at
<code>linalg.elementwise</code> and <code>linalg.matmul</code> operations. In debug builds, the
infrastructure provides a convenient method to understand the matching process
by passing <code>-debug-only=transform-matcher</code> to <code>mlir-opt</code> or a derived tool. It
will print the silenceable failure messages produced by the match operations
into the debug stream, for example:</p><pre tabindex=0><code>&lt;...&gt;
[transform-matcher] matching %0 = linalg.matmul ins(%arg0, %arg1 : tensor&lt;512x512xf32&gt;, tensor&lt;512x512xf32&gt;) outs(%arg3 : tensor&lt;512x512xf32&gt;) -&gt; tensor&lt;512x512xf32&gt; @0x5622eee08410
[transform-matcher] matcher match_elemwise failed: wrong operation name
&lt;...&gt;
</code></pre><p>This is now sufficient to run the rest of the transform script from Chapter 1,
substituting <code>%arg1</code> with <code>%matmul</code> and <code>%arg2</code> with <code>%elemwise</code>.</p><h2 id=matching-chains-of-operations>Matching Chains of Operations&nbsp;<a class=headline-hash href=#matching-chains-of-operations>¶</a></h2><p>The matcher above remains naive as it matches <em>all</em> operations of the certain
kind under the payload root. These operations may or may not be related, and
may, for example, belong to different functions. Even if they are in a single
function, if there are multiple groups of such operations, we wouldn’t be able
to differentiate them with this approach. In reality, we want to match a
specific group of operations where a <code>matmul</code> operation produces a result that
is used by an elementwise operation, which in turn feeds another elementwise
operation in a similar way.</p><p>This can be achieved using the following matcher sequence.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// This is also a matcher sequence. It is similarly given an operation to
</span></span></span><span class=line><span class=cl><span class=c>// match and nested operations must succeed in order for a match to be deemed
</span></span></span><span class=line><span class=cl><span class=c>// successful. It starts matching from the last operation in the use-def chain
</span></span></span><span class=line><span class=cl><span class=c>// and goes back because each operand (use) has exactly one definition.
</span></span></span><span class=line><span class=cl><span class=c></span>transform<span class=p>.</span>named_sequence <span class=nf>@match_matmul_elemwise</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nv>%last</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// The last operation must be an elementwise binary.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%last</span> <span class=p>[</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// Its first operand must be defined by another operation, to which we
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// will get a handle here. We are guaranteed that the first operand exists
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// because we know the operation is binary, but even in absence of such a
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// guarantee, this operation would have produced a silenceable failure when
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// `%last` does not have enough operands.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%middle</span> <span class=p>=</span> transform<span class=p>.</span>get_producer_of_operand <span class=nv>%last</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// The defining operation must itself be an elementwise binary.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%middle</span> <span class=p>[</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// And the first operand of that operation must be defined by yet another
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%matmul</span> <span class=p>=</span> transform<span class=p>.</span>get_producer_of_operand <span class=nv>%middle</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// And that operation is a matmul.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%matmul</span> <span class=p>[</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// We will yield the handles to the matmul and the two elementwise
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operations separately.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>yield <span class=nv>%matmul</span><span class=p>,</span> <span class=nv>%middle</span><span class=p>,</span> <span class=nv>%last</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This matcher is applicable in presence of other <code>elemwise</code> and <code>matmul</code>
operations and will return the triple of <em>related</em> operations rather than
operations in the order in which they are found. It can be exercised similarly
to the previous incarnation, as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Alternative entry point.
</span></span></span><span class=line><span class=cl><span class=c></span>transform<span class=p>.</span>named_sequence <span class=nf>@__transform_main</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nv>%root</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Collect groups of operations that match the criteria specified in the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// named sequence.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%matmul</span><span class=p>,</span> <span class=nv>%el1</span><span class=p>,</span> <span class=nv>%el2</span> <span class=p>=</span> transform<span class=p>.</span>collect_matching <span class=nf>@match_matmul_elemwise</span> in <span class=nv>%root</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=nv>%elemwise</span> <span class=p>=</span> transform<span class=p>.</span>merge_handles <span class=nv>%el1</span><span class=p>,</span> <span class=nv>%el2</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>include <span class=nf>@print_elemwise</span> failures<span class=p>(</span>propagate<span class=p>)</span>  <span class=p>(</span><span class=nv>%elemwise</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>include <span class=nf>@print_matmul</span> failures<span class=p>(</span>propagate<span class=p>)</span>  <span class=p>(</span><span class=nv>%matmul</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>yield
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=defining-match-operations>Defining Match Operations&nbsp;<a class=headline-hash href=#defining-match-operations>¶</a></h2><p>The matcher of a chain of operations is correct in presence of other operations,
but is still insufficiently robust for many cases of interest. In particular,
using <code>transform.get_producer_of_operand %last[0]</code> requires that the <em>first</em>
operand of elementwise operations is produced by another operation. The same
transformation strategy may however apply regardless of the operand position:
many binary operations are associative. Let us use this opportunity to introduce
a new match operation. Specifically, we would like this operation to succeed if
<em>any</em> of the operands satisfies certain conditions that can be expressed as
other match operations. We also want it to return some of the state and the
position of the matched operand in the operand list.</p><p>Match operations are defined similarly to other transform operations, with the
only difference of additionally implementing the <code>MatchOpInterface</code>. Note that
this interface has <em>no additional methods</em> (though it may add some eventually)
and is only used as a verification contract that the operation is intended for
matching and will not attempt to transform the payload. The minimal definition
of our operation is as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// Define the new operation. By convention, prefix its name with `match`
</span></span></span><span class=line><span class=cl><span class=c>// followed by the name of the dialect extension.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>HasOperandSatisfyingOp</span> <span class=p>:</span> <span class=nv>TransformDialectOp</span><span class=p>&lt;</span><span class=s>&#34;match.my.has_operand_satisfying&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MemoryEffectsOpInterface</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>     <span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>TransformOpInterface</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>     <span class=c>// Indicate that the operation implements MatchOpInterface in addition to
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// the TransformOpInterface. This interface is only used as a tag at this
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// point and has no methods that are mandatory to implement.
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=nv>MatchOpInterface</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>SingleBlockImplicitTerminator</span><span class=p>&lt;</span><span class=s>&#34;::mlir::transform::YieldOp&#34;</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Succeed if any of the operands matches all nested criteria&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>TransformHandleTypeInterface</span><span class=p>:</span><span class=nv>$op</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span> <span class=nv>TransformParamTypeInterface</span><span class=p>:</span><span class=nv>$position</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                      <span class=nv>Variadic</span><span class=p>&lt;</span><span class=nv>Transform_AnyHandleOrParamType</span><span class=p>&gt;:</span><span class=nv>$results</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Match operations can be arbitrarily complex, e.g., containing regions.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>regions</span> <span class=p>=</span> <span class=p>(</span><span class=nv>region</span> <span class=nv>SizedRegion</span><span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;:</span><span class=nv>$body</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>hasVerifier</span> <span class=p>=</span> <span class=m>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    $op `:` functional-type($op, results) attr-dict-with-keyword $body
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It takes as argument the handle associated with the payload operations whose
operands it will match, has an associated single-block region containing the
match criteria, and returns the position of the matched operand as well as any
other transform value yielded from the body on the successful match.</p><p>The matching logic is implemented in the <code>apply</code> method of the
<code>TransformOpInterface</code> and is easily composable with other transform operations.
All facilities for managing the interpreter state and recursively entering the
blocks are available in the same way as they are for “regular” transform
operations. Match operations are expected to return a silenceable failure to
indicate failure to match, and to immediately propagate definite failures. If
they have nested operations, they are expected to handle and, in most cases,
silence the silenceable failures produced when applying those operations. For
our operation, the matching is essentially a loop iterating over all operands of
the (single) payload operation and applying nested transform ops until they all
succeed for one of the operands.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Matcher ops implement `apply` similarly to other transform ops. They are not
</span></span></span><span class=line><span class=cl><span class=c1>// expected to modify payload, but use the tri-state result to signal failure or
</span></span></span><span class=line><span class=cl><span class=c1>// success to match, as well as potential irrecoverable errors.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span>
</span></span><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>HasOperandSatisfyingOp</span><span class=o>::</span><span class=n>apply</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformResults</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// For simplicity, only handle a single payload op. Actual implementations
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// can use `SingleOpMatcher` trait to simplify implementation and document
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// this expectation.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>payloadOps</span> <span class=o>=</span> <span class=n>state</span><span class=p>.</span><span class=n>getPayloadOps</span><span class=p>(</span><span class=n>getOp</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>llvm</span><span class=o>::</span><span class=n>hasSingleElement</span><span class=p>(</span><span class=n>payloadOps</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>emitSilenceableError</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;expected single payload&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Iterate over all operands of the payload op to see if they can be matched
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// using the body of this op.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Operation</span> <span class=o>*</span><span class=n>payload</span> <span class=o>=</span> <span class=o>*</span><span class=n>payloadOps</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>OpOperand</span> <span class=o>&amp;</span><span class=nl>operand</span> <span class=p>:</span> <span class=n>payload</span><span class=o>-&gt;</span><span class=n>getOpOperands</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a scope for transform values defined in the body. This corresponds
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to the syntactic scope of the region attached to this op. Any values
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// associated with payloads from now on will be automatically dissociated
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// when this object is destroyed, i.e. at the end of the iteration.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Associate the block argument handle with the operand.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>matchScope</span> <span class=o>=</span> <span class=n>state</span><span class=p>.</span><span class=n>make_region_scope</span><span class=p>(</span><span class=n>getBody</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>failed</span><span class=p>(</span><span class=n>state</span><span class=p>.</span><span class=n>mapBlockArgument</span><span class=p>(</span><span class=n>getBody</span><span class=p>().</span><span class=n>getArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                                      <span class=p>{</span><span class=n>operand</span><span class=p>.</span><span class=n>get</span><span class=p>()})))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>definiteFailure</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Iterate over all nested matchers with the current mapping and see if they
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// succeed.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>matchSucceeded</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>&amp;</span><span class=nl>matcher</span> <span class=p>:</span> <span class=n>getBody</span><span class=p>().</span><span class=n>front</span><span class=p>().</span><span class=n>without_terminator</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// Matcher ops are applied similarly to any other transform op.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>DiagnosedSilenceableFailure</span> <span class=n>diag</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>state</span><span class=p>.</span><span class=n>applyTransform</span><span class=p>(</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>TransformOpInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=n>matcher</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Definite failures are immediately propagated as they are irrecoverable.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>diag</span><span class=p>.</span><span class=n>isDefiniteFailure</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>diag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// On success, keep checking the remaining conditions.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>if</span> <span class=p>(</span><span class=n>diag</span><span class=p>.</span><span class=n>succeeded</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// Report failure-to-match for debugging purposes and stop matching this
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// operand.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>assert</span><span class=p>(</span><span class=n>diag</span><span class=p>.</span><span class=n>isSilenceableFailure</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=n>DEBUG_MATCHER</span><span class=p>(</span><span class=n>DBGS_MATCHER</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=o>&lt;&lt;</span> <span class=s>&#34;failed to match operand #&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>operand</span><span class=p>.</span><span class=n>getOperandNumber</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                    <span class=o>&lt;&lt;</span> <span class=s>&#34;: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>diag</span><span class=p>.</span><span class=n>getMessage</span><span class=p>());</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=kt>void</span><span class=p>)</span><span class=n>diag</span><span class=p>.</span><span class=n>silence</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>matchSucceeded</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// If failed to match this operand, try other operands.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>matchSucceeded</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If we reached this point, the matching succeeded for the current operand.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Remap the values associated with terminator operands to be associated
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// with op results, and also map the parameter result to the operand&#39;s
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// position. Note that it is safe to do here despite the end of the scope
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// as `results` are integrated into `state` by the interpreter after `apply`
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// returns rather than immediately.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>MappedValue</span><span class=o>&gt;&gt;</span> <span class=n>yieldedMappings</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>transform</span><span class=o>::</span><span class=n>detail</span><span class=o>::</span><span class=n>prepareValueMappings</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>yieldedMappings</span><span class=p>,</span> <span class=n>getBody</span><span class=p>().</span><span class=n>front</span><span class=p>().</span><span class=n>getTerminator</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getOperands</span><span class=p>(),</span>
</span></span><span class=line><span class=cl>        <span class=n>state</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>results</span><span class=p>.</span><span class=n>setParams</span><span class=p>(</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>OpResult</span><span class=o>&gt;</span><span class=p>(</span><span class=n>getPosition</span><span class=p>()),</span>
</span></span><span class=line><span class=cl>                      <span class=p>{</span><span class=n>rewriter</span><span class=p>.</span><span class=n>getI32IntegerAttr</span><span class=p>(</span><span class=n>operand</span><span class=p>.</span><span class=n>getOperandNumber</span><span class=p>())});</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;&amp;</span><span class=p>[</span><span class=n>result</span><span class=p>,</span> <span class=n>mapping</span><span class=p>]</span> <span class=o>:</span> <span class=n>llvm</span><span class=o>::</span><span class=n>zip</span><span class=p>(</span><span class=n>getResults</span><span class=p>(),</span> <span class=n>yieldedMappings</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=n>results</span><span class=p>.</span><span class=n>setMappedValues</span><span class=p>(</span><span class=n>result</span><span class=p>,</span> <span class=n>mapping</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If we reached this point, none of the operands succeeded the match.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=nf>emitSilenceableError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=s>&#34;none of the operands satisfied the conditions&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>By convention, operations implementing <code>MatchOpInterface</code> must not modify
payload IR and must therefore specify that they only read operand handles and
payload as their effects.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>transform</span><span class=o>::</span><span class=n>CollectMatchingOp</span><span class=o>::</span><span class=n>getEffects</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>SmallVectorImpl</span><span class=o>&lt;</span><span class=n>MemoryEffects</span><span class=o>::</span><span class=n>EffectInstance</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>effects</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>onlyReadsHandle</span><span class=p>(</span><span class=n>getRoot</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>producesHandle</span><span class=p>(</span><span class=n>getResults</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>onlyReadsPayload</span><span class=p>(</span><span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This operation can now be included in a transform dialect extension, loaded and
used in our matcher. Specifically, we will use it to indicate that either of the
operands of the “max” elementwise operation in our example can be produced by
the previous elementwise operation. The previous operation will still require
the matmul to produce the first operand for simplicity. The updated matcher
sequence looks as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>transform<span class=p>.</span>named_sequence <span class=nf>@match_matmul_elemwise</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nv>%last</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// The last operation must be an elementwise binary.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%last</span> <span class=p>[</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// One of its operands must be defined by another operation, to which we
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// will get a handle here. This is achieved thanks to a newly defined
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operation that tries to match operands one by one using the match
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operations nested in its region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%pos</span><span class=p>,</span> <span class=nv>%middle</span> <span class=p>=</span> transform<span class=p>.</span>match<span class=p>.</span>my<span class=p>.</span>has_operand_satisfying <span class=nv>%last</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%operand</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_value<span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c>// The operand must be defined by an operation.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%def</span> <span class=p>=</span> transform<span class=p>.</span>get_defining_op <span class=nv>%operand</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_value<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    <span class=c>// The defining operation must itself be an elementwise binary.
</span></span></span><span class=line><span class=cl><span class=c></span>    transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%def</span> <span class=p>[</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield <span class=nv>%def</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// And the first operand of that operation must be defined by yet another
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%matmul</span> <span class=p>=</span> transform<span class=p>.</span>get_producer_of_operand <span class=nv>%middle</span><span class=p>[</span><span class=m>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// And that operation is a matmul.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>operation_name <span class=nv>%matmul</span> <span class=p>[</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>  <span class=c>// We will yield the handles to the matmul and the two elementwise
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// operations separately.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>yield <span class=nv>%matmul</span><span class=p>,</span> <span class=nv>%middle</span><span class=p>,</span> <span class=nv>%last</span><span class=p>,</span> <span class=nv>%pos</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This achieves the desired effect and matches both <code>max(add(matmul(...), bias), 0)</code> and <code>max(0, add(matmul(...), bias))</code> in the same values. The <code>%pos</code> value is
a transform dialect <em>parameter</em>, which is used to store lists of entities known
to be constant throughout the transform application. Most often, parameters are
numeric values, but they can generally be any MLIR attributes.</p><p>In order to demonstrate that groups of operations are matched independently of
each other, let us use the <code>transform.foreach_match</code> operation that allows one
to implement a simple high-level pattern rewriting approach within the transform
dialect (for advanced or lower-level pattern rewriting, consider PDL(L) or C++
rewriting APIs). It maps a matcher named sequence to an action named sequence,
and the latter gets invoked whenever the former succeeds.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Traverses the payload IR associated with the operand handle, invoking
</span></span></span><span class=line><span class=cl><span class=c>// @match_matmul_elemwise on each of the operations. If the named sequence
</span></span></span><span class=line><span class=cl><span class=c>// succeeds, i.e., if none of the nested match (transform) operations
</span></span></span><span class=line><span class=cl><span class=c>// produced a silenceable failure, invokes @print_matmul_elemwise and
</span></span></span><span class=line><span class=cl><span class=c>// forwards the values yielded as arguments of the new invocation. If the
</span></span></span><span class=line><span class=cl><span class=c>// named sequence fails with a silenceable failure, silences it (the message
</span></span></span><span class=line><span class=cl><span class=c>// is forwarded to the debug stream). Definite failures are propagated
</span></span></span><span class=line><span class=cl><span class=c>// immediately and unconditionally, as usual.
</span></span></span><span class=line><span class=cl><span class=c></span>transform<span class=p>.</span>foreach_match in <span class=nv>%root</span>
</span></span><span class=line><span class=cl>  <span class=nf>@match_matmul_elemwise</span> <span class=p>-&gt;</span> <span class=nf>@print_matmul_elemwise</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span></code></pre></div><p>The <code>@print_matmul_elemwise</code> named sequence, available in <code>multiple.mlir</code>, will
use the parameter with the position of the operand to differentiate the two
groups.</p><h2 id=matchers-for-inferred-features>Matchers for Inferred Features&nbsp;<a class=headline-hash href=#matchers-for-inferred-features>¶</a></h2><p>The matcher sequences described above, although useful to drive transformations
from within the transform dialect interpreter, are rather basic since they
mostly rely on operation names and use-def chains. Alternative implementations
using APIs or various declarative rewrite rules are barely less expressive and
sometimes more concise. The real power of transform dialect matcher ops lies in
the possibility to define matchers of <em>inferred properties</em> of payloads, i.e.,
properties that are not directly accessible as an attribute of an operation or
any straightforward relation between IR components.</p><p>The utility of such matchers can be easily demonstrated by slightly modifying
our original example. If matrix multiplication is expressed as a special case of
tensor contraction using <code>linalg.generic</code> instead of <code>linalg.matmul</code>, the
operation name-based matcher no longer applies. Yet such a representation is
very common and can appear both in the original input and during the course of
transformation, e.g., where a higher-dimensional contraction is decomposed into
loops around a matrix multiplication.</p><p>In order to be a (potentially transposed) matrix multiplication, the
<code>linalg.generic</code> operation must have the following features:</p><ul><li>Total rank of 3.</li><li>Two inputs accessed as projected permutation of iteration dimensions.</li><li>One output accessed as projected permutation of iteration dimensions.</li><li>Iteration dimensions can be subdivided into LHS parallel, RHS parallel and reduction dimensions.</li><li>The body block consists of a multiplication and an addition.</li></ul><p>Most of these features can be derived from the properties of the operation,
e.g., the total rank corresponds to the number of entries in the <code>iterators</code>
attribute, but almost none of them are immediately accessible in the IR or in
any declarative form, which is usually limited to checking the presence or the
exact match of an attribute or a type. The transform dialect allows these
features to be implemented in the <code>apply</code> method of a matcher op and reused
across multiple matching cases. For structured linear algebra payload
operations, many such match operations are readily available in the <code>structured</code>
extension. They are sufficient to implement a matrix multiplication matcher
using the features listed above almost verbatim.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>transform<span class=p>.</span>named_sequence <span class=nf>@match_generic_matmul</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nv>%candidate</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>transform<span class=p>.</span>readonly<span class=p>})</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Match a structured linear algebra operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>match<span class=p>.</span>structured <span class=nv>%candidate</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nl>^bb0</span><span class=p>(</span><span class=nv>%c</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c>// With a rank equal to 3.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%rank</span> <span class=p>=</span> transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>rank <span class=nv>%c</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c3</span> <span class=p>=</span> transform<span class=p>.</span>param<span class=p>.</span><span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%rank</span><span class=p>,</span> <span class=nv>%c3</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// With 2 inputs.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%n_ins</span> <span class=p>=</span> transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>num_inputs <span class=nv>%c</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c2</span> <span class=p>=</span> transform<span class=p>.</span>param<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_ins</span><span class=p>,</span> <span class=nv>%c2</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// With 1 output (note that structured ops in destination passing style
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// has as many inits as outputs).
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%n_inits</span> <span class=p>=</span> transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>num_inits <span class=nv>%c</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c1</span> <span class=p>=</span> transform<span class=p>.</span>param<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_inits</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// All inputs and inits are accessed with a projected permutation.
</span></span></span><span class=line><span class=cl><span class=c></span>    transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>input <span class=nv>%c</span><span class=p>[</span>all<span class=p>]</span> <span class=p>{</span>projected_permutation<span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>init <span class=nv>%c</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>{</span>projected_permutation<span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// The body is a mulf/addf contraction with appropriate dimensions.
</span></span></span><span class=line><span class=cl><span class=c></span>    transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>body <span class=nv>%c</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span> <span class=nl>contraction =</span> <span class=p>[</span><span class=s>&#34;arith.mulf&#34;</span><span class=p>,</span> <span class=s>&#34;arith.addf&#34;</span><span class=p>]</span> <span class=p>}</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>    <span class=nv>%batch</span><span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>,</span> <span class=nv>%reduction</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>structured<span class=p>.</span>classify_contraction_dims <span class=nv>%c</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>          <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// There is one of lhs, rhs and reduction dimensions and zero batch
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// dimensions.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%n_batch</span> <span class=p>=</span> transform<span class=p>.</span>num_associations <span class=nv>%batch</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%n_lhs</span> <span class=p>=</span> transform<span class=p>.</span>num_associations <span class=nv>%lhs</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%n_rhs</span> <span class=p>=</span> transform<span class=p>.</span>num_associations <span class=nv>%rhs</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%n_reduction</span> <span class=p>=</span> transform<span class=p>.</span>num_associations <span class=nv>%reduction</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c0</span> <span class=p>=</span> transform<span class=p>.</span>param<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_batch</span><span class=p>,</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_lhs</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_rhs</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>match<span class=p>.</span>param<span class=p>.</span>cmpi eq <span class=nv>%n_reduction</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>param<span class=p>&lt;</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>yield <span class=nv>%candidate</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>While this example leverages the contraction-specific matchers that have a
rather non-trivial C++ implementation, the transform dialect is sufficiently
flexible to implement this reasoning directly if desired. One could, for
example, obtain the access map of each input as a parameter and extract the
accessed dimensions as other parameters that can be compared with each other to
ensure the subscripts are <code>m,k</code> for LHS, <code>k,n</code> for RHS and <code>m,n</code> for the
init/result given the <code>m,n,k</code> notation for loops.</p><h2 id=appendix-autogenerated-documentation>Appendix: Autogenerated Documentation&nbsp;<a class=headline-hash href=#appendix-autogenerated-documentation>¶</a></h2><h3 id=transformmatchmyhas_operand_satisfying-transformhasoperandsatisfyingop><code>transform.match.my.has_operand_satisfying</code> (transform::HasOperandSatisfyingOp)&nbsp;<a class=headline-hash href=#transformmatchmyhas_operand_satisfying-transformhasoperandsatisfyingop>¶</a></h3><p><em>Succeed if any of the operands matches all nested criteria</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `transform.match.my.has_operand_satisfying` $op `:` functional-type($op, results) attr-dict-with-keyword $body
</code></pre><p>Traits: <code>SingleBlockImplicitTerminator&lt;::mlir::transform::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>MatchOpInterface</code>, <code>MemoryEffectOpInterface</code>, <code>TransformOpInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>op</code></td><td>TransformHandleTypeInterface instance</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>position</code></td><td>TransformParamTypeInterface instance</td></tr><tr><td style=text-align:center><code>results</code></td><td>variadic of any transform handle or parameter</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/ title="Chapter 3: More than Simple Transform Operations"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Chapter 3: More than Simple Transform Operations</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/ title="Chapter H: Reproducing Halide Schedule">Next - Chapter H: Reproducing Halide Schedule <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>