<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 3: More than Simple Transform Operations - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 3: More than Simple Transform Operations</h1><h2 id=type-constraints-and-applyeach-trait>Type Constraints and ApplyEach Trait&nbsp;<a class=headline-hash href=#type-constraints-and-applyeach-trait>Â¶</a></h2><p>A transform operation that applies to each payload operation individually and requires it to be of a specific kind is a repeated pattern. One can use Transform dialect types to specify the preconditions of the type. Specifically, we can change the expected operand type from the wide <code>TransformHandleTypeInterface</code> to the more narrow <code>Transform_ConcreteOp&lt;"func.call"></code>. Furthermore, we use the <code>TransformEachOpTrait</code> trait to provide the skeleton implementation of the <code>apply</code> method that performs verification, iteration over payloads and result concatenation. The improved ODS op definition is as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// In MyExtension.td.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// Define the new operation. By convention, prefix its name with the name of the dialect extension, &#34;my.&#34;. The full operation name will be further prefixed with &#34;transform.&#34;.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>ChangeCallTargetOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;my.change_call_target&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c>// Indicate that the operation implements the required TransformOpInterface and
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// MemoryEffectsOpInterface. Use the TransformEach trait to provide the
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// implementation for TransformOpInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>[</span><span class=nv>TransformOpInterface</span><span class=p>,</span> <span class=nv>TransformEachOpTrait</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MemoryEffectsOpInterface</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Provide a brief and a full description. It is recommended that the latter describes
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// the effects on the operands and how the operation processes various failure modes.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Changes the callee of a call operation to the specified one&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    For each `func.call` payload operation associated with the handle, changes its
</span></span></span><span class=line><span class=cl><span class=s>    callee to be the symbol whose name is provided as an attribute to this operation.
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    Generates a silenceable failure if the operand is associated with payload operations
</span></span></span><span class=line><span class=cl><span class=s>    that are not `func.call`.
</span></span></span><span class=line><span class=cl><span class=s>    Only reads the operand.
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The arguments include the handle to the payload operations and the attribute that
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// specifies the new callee. The handle must implement TransformHandleTypeInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// We use a string attribute as the symbol may not exist in the transform IR so the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// verification may fail.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>    <span class=nv>Transform_ConcreteOpType</span><span class=p>&lt;</span><span class=s>&#34;func.call&#34;</span><span class=p>&gt;:</span><span class=nv>$call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$new_target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The results are empty as the transformation does not produce any new payload.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Provide nice syntax.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;$call `,` $new_target attr-dict `:` type($call)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Declare the function implementing the interface for a single payload operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>extraClassDeclaration</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    ::mlir::DiagnosedSilenceableFailure applyToOne(
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformRewriter &amp;rewriter,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::func::CallOp call,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::ApplyToEachResultList &amp;results,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformState &amp;state);
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now, instead of defining the <code>apply</code> method with a loop, we can simply define a function that applies to an individual payload operation and the trait will take care of the rest.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span> <span class=n>ChangeCallTargetOp</span><span class=o>::</span><span class=n>applyToOne</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>CallOp</span> <span class=n>call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>ApplyToEachResultList</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Call the actual transformation function.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>updateCallee</span><span class=p>(</span><span class=n>call</span><span class=p>,</span> <span class=n>getNewTarget</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Indicate success.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=defining-a-transform-type>Defining a Transform Type&nbsp;<a class=headline-hash href=#defining-a-transform-type>Â¶</a></h2><p>In addition to operations, the Transform dialect allows extensions to define and inject additional attributes and types. As we have seen above, transform types are used to specify constraints on the payload operations. Our call rewriting operation currently applies only to <code>func.call</code>. We may want to generalize it to apply to any payload operation that implements <code>CallOpInterface</code>, but the Transform dialect currently doesnât provide a type that checks if a payload operation implements this interface. Letâs define it in our extension.</p><p>Type definition is again identical to defining a dialect type with ODS.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// Transform dialect allows additional types to be defined and injected.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>CallOpInterfaceHandle</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=nv>TypeDef</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;CallOpInterfaceHandle&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=c>// The type must implement `TransformHandleTypeInterface`.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=p>[</span><span class=nv>DeclareTypeInterfaceMethods</span><span class=p>&lt;</span><span class=nv>TransformHandleTypeInterface</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The usual components of a type such as description, mnemonic and assembly format
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// should be provided.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;handle to payload operations implementing CallOpInterface&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>mnemonic</span> <span class=p>=</span> <span class=s>&#34;my.call_op_interface&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We will omit the generation of declaration and definitions using Tablegen for brevity as it is identical to the regular case.</p><p>To finalize the definition of a transform type, one must implement the interface methods.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// The interface declares this method to verify constraints this type has on
</span></span></span><span class=line><span class=cl><span class=c1>// payload operations. It returns the now familiar tri-state result.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span>
</span></span><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>CallOpInterfaceHandleType</span><span class=o>::</span><span class=n>checkPayload</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Location at which diagnostics should be emitted.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>mlir</span><span class=o>::</span><span class=n>Location</span> <span class=n>loc</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// List of payload operations that are about to be associated with the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// handle that has this type.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>llvm</span><span class=o>::</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>Operation</span> <span class=o>*&gt;</span> <span class=n>payload</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// All payload operations are expected to implement CallOpInterface, check this.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=nl>op</span> <span class=p>:</span> <span class=n>payload</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>isa</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>CallOpInterface</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// By convention, these verifiers always emit a silenceable failure since they are
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// checking a precondition.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>DiagnosedSilenceableFailure</span> <span class=n>diag</span> <span class=o>=</span> <span class=n>emitSilenceableError</span><span class=p>(</span><span class=n>loc</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;&lt;</span> <span class=s>&#34;expected the payload operation to implement CallOpInterface&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>diag</span><span class=p>.</span><span class=n>attachNote</span><span class=p>(</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getLoc</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;offending operation&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>diag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If everything is okay, return success.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Additional attributes and types need to be registered in the extension, next to operations.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyExtension</span><span class=o>::</span><span class=n>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>registerTypes</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl><span class=cp>#define GET_TYPEDEF_LIST
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;MyExtensionTypes.cpp.inc&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This type is now directly available in the Transform dialect and can be used in operations.
In the previous tablegen definition, the type of <code>$call</code> must be <code>Transform_ConcreteOp&lt;âfunc.callâ></code>,
By adding <code>CallOpInterfaceHandle</code> as an allowed type for <code>$call</code>, the corresponding handle
is allowed to be to any op implementing the interface.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=k>def</span> <span class=nv>ChangeCallTargetOp</span> <span class=p>:</span> <span class=p>...</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>    <span class=c>// Allow the handle to be to concrete `func.call` ops as well as any op implementing
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// the `CallOpInterface`.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>AnyTypeOf</span><span class=p>&lt;[</span><span class=nv>Transform_ConcreteOpType</span><span class=p>&lt;</span><span class=s>&#34;func.call&#34;</span><span class=p>&gt;,</span> <span class=nv>CallOpInterfaceHandle</span><span class=p>]&gt;:</span><span class=nv>$call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$new_target</span><span class=p>);</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We can then add the following code to <code>sequence.mlir</code> and run it with the interpreter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=c>// Cast to our new type.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%casted</span> <span class=p>=</span> transform<span class=p>.</span>cast <span class=nv>%call</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op to <span class=p>!</span>transform<span class=p>.</span>my<span class=p>.</span>call_op_interface
</span></span><span class=line><span class=cl>  <span class=c>// Using our new operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  transform<span class=p>.</span>my<span class=p>.</span>change_call_target <span class=nv>%casted</span><span class=p>,</span> <span class=s>&#34;microkernel&#34;</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>my<span class=p>.</span>call_op_interface
</span></span></code></pre></div><h2 id=operand-consumption>Operand Consumption&nbsp;<a class=headline-hash href=#operand-consumption>Â¶</a></h2><p>As an exercise, let us modify the rewriting operation to consume the operand. This would be necessary, for example, if the transformation were to rewrite the <code>func.call</code> operation into a custom operation <code>my.mm4</code>. Since the operand handle is now consumed, the operation can return a new handle to the newly produced payload operation. Otherwise, the ODS definition of the transform operation remains unchanged.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// In MyExtension.td.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// Define another transform operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>CallToOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;my.call_to_op&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=c>// Indicate that the operation implements the required TransformOpInterface and
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// MemoryEffectsOpInterface. Use the TransformEach trait to provide the
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// implementation for TransformOpInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>[</span><span class=nv>TransformOpInterface</span><span class=p>,</span> <span class=nv>TransformEachOpTrait</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MemoryEffectsOpInterface</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Summary and description omitted for brevity.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=c>// The argument is the handle to the payload operations.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>CallOpInterfaceHandle</span><span class=p>:</span><span class=nv>$call</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The result is the handle to the payload operations produced during the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// transformation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span> <span class=nv>TransformHandleTypeInterface</span><span class=p>:</span><span class=nv>$transformed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Provide nice syntax.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;$call attr-dict `:` functional-type(operands, results)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Declare the function implementing the interface for a single payload operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>extraClassDeclaration</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    ::mlir::DiagnosedSilenceableFailure applyToOne(
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformRewriter &amp;rewriter,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::CallOpInterface call,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::ApplyToEachResultList &amp;results,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformState &amp;state);
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Now letâs look at the implementation of interface methods.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span> <span class=n>CallToOp</span><span class=o>::</span><span class=n>applyToOne</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>CallOpInterface</span> <span class=n>call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>ApplyToEachResultList</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Call the actual rewrite.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Operation</span> <span class=o>*</span><span class=n>rewritten</span> <span class=o>=</span> <span class=n>rewriteToOp</span><span class=p>(</span><span class=n>call</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Report an error if the rewriter produced a null pointer. Note that it may have
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// irreversibly modified the payload IR, so we produce a definite failure.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>rewritten</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>emitDefiniteError</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;failed to rewrite call to operation&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// On success, push the resulting operation into the result list. The list is expected
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// to contain exactly one entity per result and per application. The handles will be
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// associated with lists of the respective values produced by each application.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>results</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>rewritten</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If everything is fine, return success.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CallToOp</span><span class=o>::</span><span class=n>getEffects</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>SmallVectorImpl</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>MemoryEffects</span><span class=o>::</span><span class=n>EffectInstance</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>effects</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Indicate using side effects that the operand handle is consumed, and the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// result handle is produced.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>consumesHandle</span><span class=p>(</span><span class=n>getCall</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>producesHandle</span><span class=p>(</span><span class=n>getTransformed</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Indicate that the payload IR is modified.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>modifiesPayload</span><span class=p>(</span><span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The overall flow of these implementations is similar to the previous one. The application also needs to specify the resulting entities that are going to be associated with the handles it produces. Operations are required to specify the entities to associate with <em>all</em> results on success, even if the list is empty. An assertion will be triggered if it is not the case. In case of failure, the interpreter will automatically associate all results that are not yet defined with empty lists.</p><p>Note that since <code>applyToOne</code> always expects one payload entity to be associated with each result handle in each application, it cannot be used to return handles associated with empty lists for non-empty operand handles. Instead, one would use <code>apply</code> directly.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span> <span class=n>SomeOtherOp</span><span class=o>::</span><span class=n>apply</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformResults</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Associate the result `transformed` with an empty list of payload operations.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>results</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>cast</span><span class=o>&lt;</span><span class=n>OpResult</span><span class=o>&gt;</span><span class=p>(</span><span class=n>getTransformed</span><span class=p>()),</span> <span class=p>{});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=memory-effects-traits>Memory Effects Traits&nbsp;<a class=headline-hash href=#memory-effects-traits>Â¶</a></h2><p>Some common memory effect patterns are also available as traits to minimize the boilerplate.</p><ul><li><code>FunctionalStyleTransformOpTrait</code> indicates that all handle-typed operands are consumed, all results are produced, and the payload IR is modified.</li><li><code>NavigationTransformOpTrait</code> indicates that all handle-typed operands are only read, all results are produced, and the payload IR is only read.</li></ul><p>Using these traits removes the need to declare or define the methods of the <code>MemoryEffectsOpInterface</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// In MyExtension.td.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// Define another transform operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>CallToOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;my.call_to_op&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=c>// Indicate that the operation implements the required TransformOpInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// Use the TransformEach trait to provide implementation of this interface.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>[</span><span class=nv>TransformOpInterface</span><span class=p>,</span> <span class=nv>TransformEachOpTrait</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=c>// Indicate that the operation implements the required MemoryEffectsOpInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=c>// Use the FunctionalStyle trait to provide the implementation for this interface.
</span></span></span><span class=line><span class=cl><span class=c></span>     <span class=nv>MemoryEffectsOpInterface</span><span class=p>,</span> <span class=nv>FunctionalStyleTransformOpTrait</span><span class=p>]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Summary and description omitted for brevity.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=c>// The argument is the handle to the payload operations.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span> <span class=nv>CallOpInterfaceHandle</span><span class=p>:</span><span class=nv>$call</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The result is the handle to the payload operations produced during the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// transformation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span> <span class=nv>TransformHandleTypeInterface</span><span class=p>:</span><span class=nv>$transformed</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Provide nice syntax.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;$call attr-dict `:` functional-type(operands, results)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Declare the function implementing the interface for a single payload operation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>extraClassDeclaration</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    ::mlir::DiagnosedSilenceableFailure applyToOne(
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformRewriter &amp;rewriter,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::CallOpInterface call,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::ApplyToEachResultList &amp;results,
</span></span></span><span class=line><span class=cl><span class=s>        ::mlir::transform::TransformState &amp;state);
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=appendix-autogenerated-documentation>Appendix: Autogenerated Documentation&nbsp;<a class=headline-hash href=#appendix-autogenerated-documentation>Â¶</a></h2><h3 id=transformmycall_to_op-transformcalltoop><code>transform.my.call_to_op</code> (transform::CallToOp)&nbsp;<a class=headline-hash href=#transformmycall_to_op-transformcalltoop>Â¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `transform.my.call_to_op` $call attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>FunctionalStyleTransformOpTrait</code>, <code>TransformEachOpTrait</code></p><p>Interfaces: <code>MemoryEffectsOpInterface</code>, <code>TransformOpInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>Â¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>call</code></td><td>handle to payload operations implementing CallOpInterface</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>Â¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>transformed</code></td><td>TransformHandleTypeInterface instance</td></tr></tbody></table><h3 id=transformmychange_call_target-transformchangecalltargetop><code>transform.my.change_call_target</code> (transform::ChangeCallTargetOp)&nbsp;<a class=headline-hash href=#transformmychange_call_target-transformchangecalltargetop>Â¶</a></h3><p><em>Changes the callee of a call operation to the specified one</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `transform.my.change_call_target` $call `,` $new_target attr-dict `:` qualified(type($call))
</code></pre><p>For each <code>func.call</code> payload operation associated with the handle, changes its
callee to be the symbol whose name is provided as an attribute to this operation.</p><p>Generates a silenceable failure if the operand is associated with payload operations
that are not <code>func.call</code>.
Only reads the operand.</p><p>Traits: <code>TransformEachOpTrait</code></p><p>Interfaces: <code>MemoryEffectOpInterface</code>, <code>TransformOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>Â¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>new_target</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>Â¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>call</code></td><td>Transform IR handle to func.call operations or handle to payload operations implementing CallOpInterface</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/ title="Chapter 2: Adding a Simple New Transformation Operation"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Chapter 2: Adding a Simple New Transformation Operation</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/ title="Chapter 4: Matching Payload with Transform Operations">Next - Chapter 4: Matching Payload with Transform Operations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on âStructuredâ Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>