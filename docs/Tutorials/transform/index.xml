<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Transform Dialect Tutorial on MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/transform/</link><description>Recent content in Transform Dialect Tutorial on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Tutorials/transform/index.xml" rel="self" type="application/rss+xml"/><item><title>Chapter 0: A Primer on “Structured” Linalg Operations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch0/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch0/</guid><description>Before starting the tutorial on the Transform dialect, let us take a brief look at the concept of Structured operations and its implementation in the Linalg dialect. Note that the Transform dialect does not require Structured operations and vice versa. The two co-evolved at the beginning of the Transform dialect, which makes the subset of transformations for Structured operations the most mature and most suitable for the tutorial. If you are already familiar with this concept, skip to Chapter 1.</description></item><item><title>Chapter 1: Combining Existing Transformations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch1/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch1/</guid><description>Introduction The Transform dialect allows one to precisely target transformations at specific operations in the IR and to chain them, that is to apply a transformation to operations produced by the previous transformation. To achieve this, transformations are expressed as other operations in the IR. We call these the IR containing these operations transform IR. And we call the IR that is being transformed payload IR.
Transform IR operations operate on values that may be associated with payload IR operations, values or attributes.</description></item><item><title>Chapter 2: Adding a Simple New Transformation Operation</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch2/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch2/</guid><description>Setting Up to Add New Transformations Before defining a new transform operation, we need to choose where its implementation should be located. While MLIR encourages upstream contributions, it is not always possible or even desirable to modify the main Transform dialect, for example, if the transformation is specific to some out-of-tree dialect that is not itself available upstream.
The Transform dialect uses the dialect extension mechanism to allow additional operations to be injected without modifying the dialect itself.</description></item><item><title>Chapter 3: More than Simple Transform Operations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch3/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch3/</guid><description>Type Constraints and ApplyEach Trait A transform operation that applies to each payload operation individually and requires it to be of a specific kind is a repeated pattern. One can use Transform dialect types to specify the preconditions of the type. Specifically, we can change the expected operand type from the wide TransformHandleTypeInterface to the more narrow Transform_ConcreteOp&amp;lt;&amp;quot;func.call&amp;quot;&amp;gt;. Furthermore, we use the TransformEachOpTrait trait to provide the skeleton implementation of the apply method that performs verification, iteration over payloads and result concatenation.</description></item><item><title>Chapter 4: Matching Payload with Transform Operations</title><link>https://mlir.llvm.org/docs/Tutorials/transform/Ch4/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/Ch4/</guid><description>Check the continuously-tested version of MLIR files under mlir/test/Examples/transform/Ch4.
Up until now, we were applying transform dialect scripts under the assumption that specific payload operations are identified by the caller when the transform dialect interpreter is invoked. This may be seen as contrary to the idea of driving transformations from a dialect since the transformation targets must be identified through mechanisms external to the transform dialect interpreter, for example, when invoking the interpreter programmatically in C++ or through pass arguments as seen in previous chapters.</description></item><item><title>Chapter H: Reproducing Halide Schedule</title><link>https://mlir.llvm.org/docs/Tutorials/transform/ChH/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/transform/ChH/</guid><description>This chapter demonstrates how a schedule from the Halide DSL can be implemented using Transform dialect for structured ops.
Note that the IR below is pseudo-code with types removed for brevity. It may also get out of sync with the current syntax. Always refer to the source code in mlir/examples/transform/ChH as the source of truth.
Channeled Convolution The Transform dialect provides a substrate for implementing “transformation directive” domain-specific languages (DSLs) in MLIR.</description></item></channel></rss>