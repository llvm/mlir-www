<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Chapter 2: Adding a Simple New Transformation Operation - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Chapter 2: Adding a Simple New Transformation Operation</h1><h2 id=setting-up-to-add-new-transformations>Setting Up to Add New Transformations&nbsp;<a class=headline-hash href=#setting-up-to-add-new-transformations>¶</a></h2><p>Before defining a new transform operation, we need to choose where its implementation should be located. While MLIR encourages upstream contributions, it is not always possible or even desirable to modify the main Transform dialect, for example, if the transformation is specific to some out-of-tree dialect that is not itself available upstream.</p><p>The Transform dialect uses the dialect extension mechanism to allow additional operations to be injected without modifying the dialect itself. Dialect extensions are registered with the context and loaded when the dialect itself is loaded. Extension definition is straightforward:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// In MyExtension.cpp.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/IR/TransformDialect.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Define a new Transform dialect extension. This uses the CRTP idiom to
</span></span></span><span class=line><span class=cl><span class=c1>// identify extensions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>MyExtension</span> <span class=o>:</span> <span class=k>public</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformDialectExtension</span><span class=o>&lt;</span><span class=n>MyExtension</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// The extension must derive the base constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>using</span> <span class=n>Base</span><span class=o>::</span><span class=n>Base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// This function initializes the extension, similarly to `initialize` in
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// dialect  definitions. List individual operations and dependent dialects
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// here.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>init</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyExtension</span><span class=o>::</span><span class=n>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Similarly to dialects, an extension can declare a dependent dialect. This
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// dialect will be loaded along with the extension and, therefore, along with
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the Transform  dialect. Only declare as dependent the dialects that contain
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// the attributes or types used by transform operations. Do NOT declare as
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// dependent the dialects produced during the transformation.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// declareDependentDialect&lt;MyDialect&gt;();
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// When transformations are applied, they may produce new operations from
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// previously unloaded dialects. Typically, a pass would need to declare
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// itself dependent on the dialects containing such new operations. To avoid
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// confusion with the dialects the extension itself depends on, the Transform
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// dialects differentiates between:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   - dependent dialects, which are used by the transform operations, and
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//   - generated dialects, which contain the entities (attributes, operations,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//     types) that may be produced by applying the transformation even when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>//     not present in the original payload IR.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// In the following chapter, we will be add operations that generate function
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// calls and structured control flow operations, so let&#39;s declare the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// corresponding dialects as generated.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>declareGeneratedDialect</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>scf</span><span class=o>::</span><span class=n>SCFDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=n>declareGeneratedDialect</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Finally, we register the additional transform operations with the dialect.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>registerTransformOps</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// TODO: list the operation classes.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The operations themselves can be defined using ODS, exactly in the same way as regular operations in a dialect.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// In MyExtension.td
</span></span></span><span class=line><span class=cl><span class=c></span><span class=cp>#ifndef MY_EXTENSION</span>
</span></span><span class=line><span class=cl><span class=cp>#define MY_EXTENSION</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>include</span> <span class=s>&#34;mlir/Dialect/Transform/IR/TransformDialect.td&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>include</span> <span class=s>&#34;mlir/Dialect/Transform/Interfaces/TransformInterfaces.td&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>include</span> <span class=s>&#34;mlir/IR/OpBase.td&#34;</span>
</span></span><span class=line><span class=cl><span class=nv>include</span> <span class=s>&#34;mlir/Interfaces/SideEffectInterfaces.td&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nv>MyOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;transform.my.op&#34;</span><span class=p>,</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=c>// TODO: interfaces and traits here.
</span></span></span><span class=line><span class=cl><span class=c></span>   <span class=p>]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;my transform op&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c>// TODO: define the operation properties.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif</span> <span class=c>// MY_EXTENSION
</span></span></span></code></pre></div><p>Similarly to dialects, we must use Tablegen to generate the header and implementation of these operations. We can instruct CMake to do it as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># In CMakeLists.txt next to MyExtension.td.</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Tell Tablegen to use MyExtension.td as input.</span>
</span></span><span class=line><span class=cl>set<span class=o>(</span>LLVM_TARGET_DEFINITIONS MyExtension.td<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Ask Tablegen to generate op declarations and definitions from ODS.</span>
</span></span><span class=line><span class=cl>mlir_tablegen<span class=o>(</span>MyExtension.h.inc -gen-op-decls<span class=o>)</span>
</span></span><span class=line><span class=cl>mlir_tablegen<span class=o>(</span>MyExtension.cpp.inc -gen-op-defs<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Add a CMakeTarget we can depend on to ensure the generation happens before the compilation.</span>
</span></span><span class=line><span class=cl>add_public_tablegen_target<span class=o>(</span>MyExtensionIncGen<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Don&#39;t forget to generate the documentation, this will produce a MyExtension.md under</span>
</span></span><span class=line><span class=cl><span class=c1># Dialects.</span>
</span></span><span class=line><span class=cl>add_mlir_doc<span class=o>(</span>MyExtension MyExtension Dialects/ -gen-op-doc<span class=o>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl><span class=c1># In CMakeLists.txt next to MyExtension.cpp</span>
</span></span><span class=line><span class=cl>add_mlir_library<span class=o>(</span>
</span></span><span class=line><span class=cl>  <span class=c1># Library called MyExtension.</span>
</span></span><span class=line><span class=cl>  MyExtension
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># Built from the following source files.</span>
</span></span><span class=line><span class=cl>  MyExtension.cpp
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># Make sure ODS declaration and definitions are generated before compiling</span>
</span></span><span class=line><span class=cl>  <span class=c1># this.</span>
</span></span><span class=line><span class=cl>  DEPENDS
</span></span><span class=line><span class=cl>  MyExtensionIncGen
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1># Link in the transform dialect, and all generated dialects.</span>
</span></span><span class=line><span class=cl>  LINK_LIBS PUBLIC
</span></span><span class=line><span class=cl>  MLIRTransformDialect
</span></span><span class=line><span class=cl>  MLIRFuncDialect
</span></span><span class=line><span class=cl>  MLIRSCFDialect
</span></span><span class=line><span class=cl><span class=o>)</span>
</span></span></code></pre></div><p>This will generate two files, <code>MyExtension.h.inc</code> and <code>MyExtension.cpp.inc</code>, that are supposed to be included into the declaration and definition of the transform operations, respectively.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.h.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/IR/TransformDialect.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/Dialect/Transform/Interfaces/TransformInterfaces.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define GET_OP_CLASSES
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.h.inc&#34;</span><span class=cp>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#define GET_OP_CLASSES
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.cpp.inc&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>MyExtension</span><span class=o>::</span><span class=n>init</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// …
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>// Finally, we register the additional transform operations with the dialect.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// List all  operations generated from ODS. This call will perform additional
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// checks that the  operations implement the transform and memory effect
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// interfaces required by the dialect interpreter and assert if they do not.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>registerTransformOps</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl><span class=cp>#define GET_OP_LIST
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;MyExtension.cpp.inc&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>  <span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=defining-a-transform-operation>Defining a Transform Operation&nbsp;<a class=headline-hash href=#defining-a-transform-operation>¶</a></h2><p>With this setup, we are now ready to define the new transform operation to rewrite the function call. This is identical to defining a regular operation in a dialect. Note that the Transform dialect requires operations to implement the <code>TransformOpInterface</code> as well as <code>MemoryEffectsOpInterface</code> to indicate whether the operands are consumed or only read. Our operation can be defined along the following lines.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-tablegen data-lang=tablegen><span class=line><span class=cl><span class=c>// In MyExtension.td.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// Define the new operation. By convention, prefix its name with the name of the
</span></span></span><span class=line><span class=cl><span class=c>// dialect  extension, &#34;my.&#34;. The full operation name will be further prefixed
</span></span></span><span class=line><span class=cl><span class=c>// with &#34;transform.&#34;.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=k>def</span> <span class=nv>ChangeCallTargetOp</span> <span class=p>:</span> <span class=nv>Op</span><span class=p>&lt;</span><span class=nv>Transform_Dialect</span><span class=p>,</span> <span class=s>&#34;my.change_call_target&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c>// Indicate that the operation implements the required TransformOpInterface
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// and MemoryEffectsOpInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>[</span><span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>TransformOpInterface</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>     <span class=nv>DeclareOpInterfaceMethods</span><span class=p>&lt;</span><span class=nv>MemoryEffectsOpInterface</span><span class=p>&gt;]&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Provide a brief and a full description. It is recommended that the latter
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// describes the effects on the operands and how the operation processes
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// various failure modes.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>summary</span> <span class=p>=</span> <span class=s>&#34;Changes the callee of a call operation to the specified one&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=nv>description</span> <span class=p>=</span> <span class=s>[{
</span></span></span><span class=line><span class=cl><span class=s>    For each `func.call` payload operation associated with the handle, changes
</span></span></span><span class=line><span class=cl><span class=s>    its callee to be the symbol whose name is provided as an attribute to this operation.
</span></span></span><span class=line><span class=cl><span class=s>
</span></span></span><span class=line><span class=cl><span class=s>    Generates a silenceable failure if the operand is associated with payload operations that are not `func.call`. Only reads the operand.
</span></span></span><span class=line><span class=cl><span class=s>  }]</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The arguments include the handle to the payload operations and the
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// attribute that specifies the new callee. The handle must implement
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// TransformHandleTypeInterface.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// We use a string attribute as the symbol may not exist in the transform IR
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// so the verification may fail.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>arguments</span> <span class=p>=</span> <span class=p>(</span><span class=nv>ins</span>
</span></span><span class=line><span class=cl>    <span class=nv>TransformHandleTypeInterface</span><span class=p>:</span><span class=nv>$call</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>StrAttr</span><span class=p>:</span><span class=nv>$new_target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The results are empty as the transformation does not produce any new
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// payload.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>results</span> <span class=p>=</span> <span class=p>(</span><span class=nv>outs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Provide nice syntax.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=k>let</span> <span class=nv>assemblyFormat</span> <span class=p>=</span> <span class=s>&#34;$call `,` $new_target attr-dict `:` type($call)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To finalize the definition of the transform operation, we need to implement the
interface methods. The <code>TransformOpInterface</code> currently requires only one method
– <code>apply</code> – that performs the actual transformation. It is a good practice to
limit the body of the method to manipulation of the Transform dialect constructs
and have the actual transformation implemented as a standalone function so it
can be used from other places in the code. Similar to rewrite patterns, all IR
must be modified with the provided rewriter.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Implementation of our Transform dialect operation.
</span></span></span><span class=line><span class=cl><span class=c1>// This operation returns a tri-state result that can be one of:
</span></span></span><span class=line><span class=cl><span class=c1>// - success when the transformation succeeded;
</span></span></span><span class=line><span class=cl><span class=c1>// - definite failure when the transformation failed in such a way that
</span></span></span><span class=line><span class=cl><span class=c1>//   following transformations are impossible or undesirable, typically it could
</span></span></span><span class=line><span class=cl><span class=c1>//   have left payload IR in an invalid state; it is expected that a diagnostic
</span></span></span><span class=line><span class=cl><span class=c1>//   is emitted immediately before returning the definite error;
</span></span></span><span class=line><span class=cl><span class=c1>// - silenceable failure when the transformation failed but following
</span></span></span><span class=line><span class=cl><span class=c1>//   transformations are still applicable, typically this means a precondition
</span></span></span><span class=line><span class=cl><span class=c1>//   for the transformation is not satisfied and the payload IR has not been
</span></span></span><span class=line><span class=cl><span class=c1>//   modified. The silenceable failure additionally carries a Diagnostic that
</span></span></span><span class=line><span class=cl><span class=c1>//   can be emitted to the user.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DiagnosedSilenceableFailure</span> <span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>ChangeCallTargetOp</span><span class=o>::</span><span class=n>apply</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The rewriter that should be used when modifying IR.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The list of payload IR entities that will be associated with the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// transform IR values defined by this transform operation. In this case, it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// can remain empty as there are no results.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformResults</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The transform application state. This object can be used to query the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// current associations between transform IR values and payload IR entities.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// It can also carry additional user-defined state.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>transform</span><span class=o>::</span><span class=n>TransformState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// First, we need to obtain the list of payload operations that are associated
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// with the operand handle.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>auto</span> <span class=n>payload</span> <span class=o>=</span> <span class=n>state</span><span class=p>.</span><span class=n>getPayloadOps</span><span class=p>(</span><span class=n>getCall</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Then, we iterate over the list of operands and call the actual IR-mutating
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// function. We also check the preconditions here.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>for</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=nl>payloadOp</span> <span class=p>:</span> <span class=n>payload</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>call</span> <span class=o>=</span> <span class=n>dyn_cast</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>CallOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>payloadOp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>call</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>DiagnosedSilenceableFailure</span> <span class=n>diag</span> <span class=o>=</span> <span class=n>emitSilenceableError</span><span class=p>()</span>
</span></span><span class=line><span class=cl>          <span class=o>&lt;&lt;</span> <span class=s>&#34;only applies to func.call payloads&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>diag</span><span class=p>.</span><span class=n>attachNote</span><span class=p>(</span><span class=n>payloadOp</span><span class=o>-&gt;</span><span class=n>getLoc</span><span class=p>())</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;offending payload&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>diag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>updateCallee</span><span class=p>(</span><span class=n>call</span><span class=p>,</span> <span class=n>getNewTarget</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If everything went well, return success.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>DiagnosedSilenceableFailure</span><span class=o>::</span><span class=n>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The implementation of the <code>MemoryEffectsOpInterface</code> must specify the effects this operation has on its operands (consumed or readonly) and on the payload IR (mutates or readonly). Transform dialect verifiers will check for side effects being present and assert in debug builds if they are not.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In MyExtension.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>ChangeCallTargetOp</span><span class=o>::</span><span class=n>getEffects</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>SmallVectorImpl</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>MemoryEffects</span><span class=o>::</span><span class=n>EffectInstance</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>effects</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// Indicate that the `call` handle is only read by this operation because the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// associated operation is not erased but rather modified in-place, so the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// reference to it remains valid.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>onlyReadsHandle</span><span class=p>(</span><span class=n>getCall</span><span class=p>(),</span> <span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Indicate that the payload is modified by this operation.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>modifiesPayload</span><span class=p>(</span><span class=n>effects</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=registration-and-usage>Registration and Usage&nbsp;<a class=headline-hash href=#registration-and-usage>¶</a></h2><p>This is enough to define transform operations. The only remaining bit is providing the extension registration hook that can be called from the project’s <code>main</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// In TransformDialect.cpp (don&#39;t forget a declaration in TransformDialect.h);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>registerMyExtension</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>DialectRegistry</span> <span class=o>&amp;</span><span class=n>registry</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>registry</span><span class=p>.</span><span class=n>addExtensions</span><span class=o>&lt;</span><span class=n>MyExtension</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>After registering the extension, it becomes possible to use our new operation in the Transform dialect interpreter. The upstream testing pass can be used as is. It actually exists in <code>mlir/test/Examples/transform/Ch2/sequence.mlir</code>, which contains the <code>microkernel</code> implementation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module attributes <span class=p>{</span>transform<span class=p>.</span>with_named_sequence<span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  transform<span class=p>.</span>named_sequence <span class=nf>@__transform_main</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nv>%arg1</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>      <span class=nv>%arg2</span><span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c>// Since the %arg2 handle is associated with both elementwise operations,
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// we need to split it into two handles so we can target only the second
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// elementwise operation.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%add</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>=</span> transform<span class=p>.</span>split_handle <span class=nv>%arg2</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.elementwise&#34;</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>        <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// The actual tiling transformation takes tile sizes as attributes. It
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// produces a handle to the loop generated during tiling.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%tiled</span><span class=p>,</span> <span class=nv>%loop</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_using_forall <span class=nv>%max</span>
</span></span><span class=line><span class=cl>                    tile_sizes <span class=p>[</span><span class=m>8</span><span class=p>,</span> <span class=m>32</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// We can now fuse the other operations into the loop. Here, we fuse
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// operations one-by-one. This requires the operation that is being fused
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// to define the value used within the loop, so the order of such fusions
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// is important. We could also use &#34;transform.merge_handles&#34; to obtain
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// a single handle to all operations and give it to
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// `fuse_into_containing_op` that would take care of the ordering in this
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// case.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%add_fused</span><span class=p>,</span> <span class=nv>%loop2</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%add</span> into <span class=nv>%loop</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%matmul_fused</span><span class=p>,</span> <span class=nv>%loop3</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%arg1</span>
</span></span><span class=line><span class=cl>                    into <span class=nv>%loop2</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>op<span class=p>&lt;</span><span class=s>&#34;linalg.matmul&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// Tile again to get the desired size. Note that this time this tiles the
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// &#34;add&#34; operation and fuses matmul into the loop, but doesn&#39;t affect the
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// &#34;max&#34; operation. This illustrates the precise targeting with the
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// transform dialect. Otherwise, it is difficult to differentiate &#34;add&#34; and
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// &#34;max&#34;, both of which having the same kind.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%tiled_second</span><span class=p>,</span> <span class=nv>%loop_second</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_using_forall <span class=nv>%add_fused</span>
</span></span><span class=line><span class=cl>                        tile_sizes <span class=p>[</span><span class=m>4</span><span class=p>,</span> <span class=m>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%matmul_fused_2</span><span class=p>,</span> <span class=nv>%loop_second_2</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%matmul_fused</span>
</span></span><span class=line><span class=cl>                      into <span class=nv>%loop_second</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// Since outlining is currently only implemented for region-holding
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// operations such as loops, use tiling to size 1 to materialize the outer
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=c>// loop that is going to be outlined.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=nv>%_0</span><span class=p>,</span> <span class=nv>%loop_third</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>tile_using_forall <span class=nv>%tiled_second</span> tile_sizes <span class=p>[</span><span class=m>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%_1</span><span class=p>,</span> <span class=nv>%outline_target</span> <span class=p>=</span> transform<span class=p>.</span>structured<span class=p>.</span>fuse_into_containing_op <span class=nv>%matmul_fused_2</span> into <span class=nv>%loop_third</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%func</span><span class=p>,</span> <span class=nv>%call</span> <span class=p>=</span> transform<span class=p>.</span>loop<span class=p>.</span>outline <span class=nv>%outline_target</span>
</span></span><span class=line><span class=cl>                   <span class=p>{</span><span class=nl>func_name =</span> <span class=s>&#34;outlined&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>:</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(!</span>transform<span class=p>.</span>any_op<span class=p>,</span> <span class=p>!</span>transform<span class=p>.</span>any_op<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c>// Rewrite the call target.
</span></span></span><span class=line><span class=cl><span class=c></span>    transform<span class=p>.</span>my<span class=p>.</span>change_call_target <span class=nv>%call</span><span class=p>,</span> <span class=s>&#34;microkernel&#34;</span> <span class=p>:</span> <span class=p>!</span>transform<span class=p>.</span>any_op
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    transform<span class=p>.</span>yield
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=appendix-autogenerated-documentation>Appendix: Autogenerated Documentation&nbsp;<a class=headline-hash href=#appendix-autogenerated-documentation>¶</a></h2><h3 id=transformmychange_call_target-transformchangecalltargetop><code>transform.my.change_call_target</code> (transform::ChangeCallTargetOp)&nbsp;<a class=headline-hash href=#transformmychange_call_target-transformchangecalltargetop>¶</a></h3><p><em>Changes the callee of a call operation to the specified one</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `transform.my.change_call_target` $call `,` $new_target attr-dict `:` type($call)
</code></pre><p>For each <code>func.call</code> payload operation associated with the handle, changes its
callee to be the symbol whose name is provided as an attribute to this operation.</p><p>Generates a silenceable failure if the operand is associated with payload operations
that are not <code>func.call</code>.
Only reads the operand.</p><p>Interfaces: <code>MemoryEffectOpInterface</code>, <code>TransformOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>new_target</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>call</code></td><td>TransformHandleTypeInterface instance</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/ title="Chapter 1: Combining Existing Transformations"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Chapter 1: Combining Existing Transformations</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/ title="Chapter 3: More than Simple Transform Operations">Next - Chapter 3: More than Simple Transform Operations <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>