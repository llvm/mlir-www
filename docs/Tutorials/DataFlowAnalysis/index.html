<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Writing DataFlow Analyses in MLIR - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Writing DataFlow Analyses in MLIR</h1><p>Writing dataflow analyses in MLIR, or well any compiler, can often seem quite
daunting and/or complex. A dataflow analysis generally involves propagating
information about the IR across various different types of control flow
constructs, of which MLIR has many (Block-based branches, Region-based branches,
CallGraph, etc), and it isn&rsquo;t always clear how best to go about performing the
propagation. To help writing these types of analyses in MLIR, this document
details several utilities that simplify the process and make it a bit more
approachable.</p><h2 id=forward-dataflow-analysis>Forward Dataflow Analysis&nbsp;<a class=headline-hash href=#forward-dataflow-analysis>¶</a></h2><p>One type of dataflow analysis is a forward propagation analysis. This type of
analysis, as the name may suggest, propagates information forward (e.g. from
definitions to uses). To provide a bit of concrete context, let&rsquo;s go over
writing a simple forward dataflow analysis in MLIR. Let&rsquo;s say for this analysis
that we want to propagate information about a special &ldquo;metadata&rdquo; dictionary
attribute. The contents of this attribute are simply a set of metadata that
describe a specific value, e.g. <code>metadata = { likes_pizza = true }</code>. We will
collect the <code>metadata</code> for operations in the IR and propagate them about.</p><h3 id=lattices>Lattices&nbsp;<a class=headline-hash href=#lattices>¶</a></h3><p>Before going into how one might setup the analysis itself, it is important to
first introduce the concept of a <code>Lattice</code> and how we will use it for the
analysis. A lattice represents all of the possible values or results of the
analysis for a given value. A lattice element holds the set of information
computed by the analysis for a given value, and is what gets propagated across
the IR. For our analysis, this would correspond to the <code>metadata</code> dictionary
attribute.</p><p>Regardless of the value held within, every type of lattice contains two special
element states:</p><ul><li><p><code>uninitialized</code></p><ul><li>The element has not been initialized.</li></ul></li><li><p><code>top</code>/<code>overdefined</code>/<code>unknown</code></p><ul><li>The element encompasses every possible value.</li><li>This is a very conservative state, and essentially means &ldquo;I can&rsquo;t make
any assumptions about the value, it could be anything&rdquo;</li></ul></li></ul><p>These two states are important when merging, or <code>join</code>ing as we will refer to it
further in this document, information as part of the analysis. Lattice elements
are <code>join</code>ed whenever there are two different source points, such as an argument
to a block with multiple predecessors. One important note about the <code>join</code>
operation, is that it is required to be monotonic (see the <code>join</code> method in the
example below for more information). This ensures that <code>join</code>ing elements is
consistent. The two special states mentioned above have unique properties during
a <code>join</code>:</p><ul><li><p><code>uninitialized</code></p><ul><li>If one of the elements is <code>uninitialized</code>, the other element is used.</li><li><code>uninitialized</code> in the context of a <code>join</code> essentially means &ldquo;take the
other thing&rdquo;.</li></ul></li><li><p><code>top</code>/<code>overdefined</code>/<code>unknown</code></p><ul><li>If one of the elements being joined is <code>overdefined</code>, the result is
<code>overdefined</code>.</li></ul></li></ul><p>For our analysis in MLIR, we will need to define a class representing the value
held by an element of the lattice used by our dataflow analysis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/// The value of our lattice represents the inner structure of a DictionaryAttr,
</span></span></span><span class=line><span class=cl><span class=c1>/// for the `metadata`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>MetadataLatticeValue</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MetadataLatticeValue</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// Compute a lattice value from the provided dictionary.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>MetadataLatticeValue</span><span class=p>(</span><span class=n>DictionaryAttr</span> <span class=n>attr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>metadata</span><span class=p>(</span><span class=n>attr</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>attr</span><span class=p>.</span><span class=n>end</span><span class=p>())</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Return a pessimistic value state, i.e. the `top`/`overdefined`/`unknown`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// state, for our value type. The resultant state should not assume any
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// information about the state of the IR.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>MetadataLatticeValue</span> <span class=nf>getPessimisticValueState</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// The `top`/`overdefined`/`unknown` state is when we know nothing about any
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// metadata, i.e. an empty dictionary.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>MetadataLatticeValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// Return a pessimistic value state for our value type using only information
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// about the state of the provided IR. This is similar to the above method,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// but may produce a slightly more refined result. This is okay, as the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// information is already encoded as fact in the IR.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>MetadataLatticeValue</span> <span class=nf>getPessimisticValueState</span><span class=p>(</span><span class=n>Value</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check to see if the parent operation has metadata.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>parentOp</span> <span class=o>=</span> <span class=n>value</span><span class=p>.</span><span class=n>getDefiningOp</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=k>auto</span> <span class=n>metadata</span> <span class=o>=</span> <span class=n>parentOp</span><span class=o>-&gt;</span><span class=n>getAttrOfType</span><span class=o>&lt;</span><span class=n>DictionaryAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;metadata&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>MetadataLatticeValue</span><span class=p>(</span><span class=n>metadata</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c1>// If no metadata is present, fallback to the
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// `top`/`overdefined`/`unknown` state.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>MetadataLatticeValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// This method conservatively joins the information held by `lhs` and `rhs`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// into a new value. This method is required to be monotonic. `monotonicity`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// is implied by the satisfaction of the following axioms:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * idempotence:   join(x,x) == x
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * commutativity: join(x,y) == join(y,x)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * associativity: join(x,join(y,z)) == join(join(x,y),z)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// When the above axioms are satisfied, we achieve `monotonicity`:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * monotonicity: join(x, join(x,y)) == join(x,y)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>static</span> <span class=n>MetadataLatticeValue</span> <span class=nf>join</span><span class=p>(</span><span class=k>const</span> <span class=n>MetadataLatticeValue</span> <span class=o>&amp;</span><span class=n>lhs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                   <span class=k>const</span> <span class=n>MetadataLatticeValue</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// To join `lhs` and `rhs` we will define a simple policy, which is that we
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// only keep information that is the same. This means that we only keep
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// facts that are true in both.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MetadataLatticeValue</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>lhsIt</span> <span class=p>:</span> <span class=n>lhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// As noted above, we only merge if the values are the same.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>lhsIt</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>it</span> <span class=o>==</span> <span class=n>rhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>||</span> <span class=n>it</span><span class=p>.</span><span class=n>second</span> <span class=o>!=</span> <span class=n>lhsIt</span><span class=p>.</span><span class=n>second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=n>result</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>lhsIt</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// A simple comparator that checks to see if this value is equal to the one
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// provided.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=k>const</span> <span class=n>MetadataLatticeValue</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>metadata</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>!=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>.</span><span class=n>size</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Check that `rhs` contains the same metadata.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span> <span class=o>&amp;</span><span class=nl>it</span> <span class=p>:</span> <span class=n>metadata</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>auto</span> <span class=n>rhsIt</span> <span class=o>=</span> <span class=n>rhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>it</span><span class=p>.</span><span class=n>first</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>rhsIt</span> <span class=o>==</span> <span class=n>rhs</span><span class=p>.</span><span class=n>metadata</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>||</span> <span class=n>it</span><span class=p>.</span><span class=n>second</span> <span class=o>!=</span> <span class=n>rhsIt</span><span class=p>.</span><span class=n>second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Our value represents the combined metadata, which is originally a
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// DictionaryAttr, so we use a map.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>DenseMap</span><span class=o>&lt;</span><span class=n>StringAttr</span><span class=p>,</span> <span class=n>Attribute</span><span class=o>&gt;</span> <span class=n>metadata</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>One interesting thing to note above is that we don&rsquo;t have an explicit method for
the <code>uninitialized</code> state. This state is handled by the <code>LatticeElement</code> class,
which manages a lattice value for a given IR entity. A quick overview of this
class, and the API that will be interesting to us while writing our analysis, is
shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/// This class represents a lattice element holding a specific value of type
</span></span></span><span class=line><span class=cl><span class=c1>/// `ValueT`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ValueT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LatticeElement</span> <span class=p>...</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// Return the value held by this element. This requires that a value is
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// known, i.e. not `uninitialized`.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ValueT</span> <span class=o>&amp;</span><span class=n>getValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>ValueT</span> <span class=o>&amp;</span><span class=n>getValue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Join the information contained in the &#39;rhs&#39; element into this
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// element. Returns if the state of the current element changed.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ChangeResult</span> <span class=nf>join</span><span class=p>(</span><span class=k>const</span> <span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Join the information contained in the &#39;rhs&#39; value into this
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// lattice. Returns if the state of the current lattice changed.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ChangeResult</span> <span class=nf>join</span><span class=p>(</span><span class=k>const</span> <span class=n>ValueT</span> <span class=o>&amp;</span><span class=n>rhs</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Mark the lattice element as having reached a pessimistic fixpoint. This
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// means that the lattice may potentially have conflicting value states, and
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// only the conservatively known value state should be relied on.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ChangeResult</span> <span class=nf>markPessimisticFixPoint</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>With our lattice defined, we can now define the driver that will compute and
propagate our lattice across the IR.</p><h3 id=forwarddataflowanalysis-driver>ForwardDataflowAnalysis Driver&nbsp;<a class=headline-hash href=#forwarddataflowanalysis-driver>¶</a></h3><p>The <code>ForwardDataFlowAnalysis</code> class represents the driver of the dataflow
analysis, and performs all of the related analysis computation. When defining
our analysis, we will inherit from this class and implement some of its hooks.
Before that, let&rsquo;s look at a quick overview of this class and some of the
important API for our analysis:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>/// This class represents the main driver of the forward dataflow analysis. It
</span></span></span><span class=line><span class=cl><span class=c1>/// takes as a template parameter the value type of lattice being computed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ValueT</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ForwardDataFlowAnalysis</span> <span class=o>:</span> <span class=p>...</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>ForwardDataFlowAnalysis</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Compute the analysis on operations rooted under the given top-level
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// operation. Note that the top-level operation is not visited.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>run</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>topLevelOp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Return the lattice element attached to the given value. If a lattice has
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// not been added for the given value, a new &#39;uninitialized&#39; value is
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// inserted and returned.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>getLatticeElement</span><span class=p>(</span><span class=n>Value</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Return the lattice element attached to the given value, or nullptr if no
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// lattice element for the value has yet been created.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>lookupLatticeElement</span><span class=p>(</span><span class=n>Value</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Mark all of the lattice elements for the given range of Values as having
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// reached a pessimistic fixpoint.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>ChangeResult</span> <span class=nf>markAllPessimisticFixPoint</span><span class=p>(</span><span class=n>ValueRange</span> <span class=n>values</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// Visit the given operation, and join any necessary analysis state
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// into the lattice elements for the results and block arguments owned by
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// this operation using the provided set of operand lattice elements
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// (all pointer values are guaranteed to be non-null). Returns if any result
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// or block argument value lattice elements changed during the visit. The
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// lattice element for a result or block argument value can be obtained, and
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// join&#39;ed into, by using `getLatticeElement`.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>virtual</span> <span class=n>ChangeResult</span> <span class=n>visitOperation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>operands</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>NOTE: Some API has been redacted for our example. The <code>ForwardDataFlowAnalysis</code>
contains various other hooks that allow for injecting custom behavior when
applicable.</p><p>The main API that we are responsible for defining is the <code>visitOperation</code>
method. This method is responsible for computing new lattice elements for the
results and block arguments owned by the given operation. This is where we will
inject the lattice element computation logic, also known as the transfer
function for the operation, that is specific to our analysis. A simple
implementation for our example is shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>MetadataAnalysis</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ForwardDataFlowAnalysis</span><span class=o>&lt;</span><span class=n>MetadataLatticeValue</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>ForwardDataFlowAnalysis</span><span class=o>&lt;</span><span class=n>MetadataLatticeValue</span><span class=o>&gt;::</span><span class=n>ForwardDataFlowAnalysis</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>ChangeResult</span> <span class=nf>visitOperation</span><span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>ValueT</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>operands</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DictionaryAttr</span> <span class=n>metadata</span> <span class=o>=</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getAttrOfType</span><span class=o>&lt;</span><span class=n>DictionaryAttr</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;metadata&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// If we have no metadata for this operation, we will conservatively mark
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// all of the results as having reached a pessimistic fixpoint.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>metadata</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>markAllPessimisticFixPoint</span><span class=p>(</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>getResults</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Otherwise, we will compute a lattice value for the metadata and join it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into the current lattice element for all of our results.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>MetadataLatticeValue</span> <span class=n>latticeValue</span><span class=p>(</span><span class=n>metadata</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangeResult</span> <span class=n>result</span> <span class=o>=</span> <span class=n>ChangeResult</span><span class=o>::</span><span class=n>NoChange</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>Value</span> <span class=nl>value</span> <span class=p>:</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>getResults</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// We grab the lattice element for `value` via `getLatticeElement` and
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// then join it with the lattice value for this operation&#39;s metadata. Note
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// that during the analysis phase, it is fine to freely create a new
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// lattice element for a value. This is why we don&#39;t use the
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// `lookupLatticeElement` method here.
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=n>result</span> <span class=o>|=</span> <span class=n>getLatticeElement</span><span class=p>(</span><span class=n>value</span><span class=p>).</span><span class=n>join</span><span class=p>(</span><span class=n>latticeValue</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>With that, we have all of the necessary components to compute our analysis.
After the analysis has been computed, we can grab any computed information for
values by using <code>lookupLatticeElement</code>. We use this function over
<code>getLatticeElement</code> as the analysis is not guaranteed to visit all values, e.g.
if the value is in a unreachable block, and we don&rsquo;t want to create a new
uninitialized lattice element in this case. See below for a quick example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyPass</span><span class=o>::</span><span class=n>runOnOperation</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MetadataAnalysis</span> <span class=nf>analysis</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=n>analysis</span><span class=p>.</span><span class=n>run</span><span class=p>(</span><span class=n>getOperation</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>MyPass</span><span class=o>::</span><span class=n>useAnalysisOn</span><span class=p>(</span><span class=n>MetadataAnalysis</span> <span class=o>&amp;</span><span class=n>analysis</span><span class=p>,</span> <span class=n>Value</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>LatticeElement</span><span class=o>&lt;</span><span class=n>MetadataLatticeValue</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>latticeElement</span> <span class=o>=</span> <span class=n>analysis</span><span class=p>.</span><span class=n>lookupLatticeElement</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// If we don&#39;t have an element, the `value` wasn&#39;t visited during our analysis
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// meaning that it could be dead. We need to treat this conservatively.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lattice</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Our lattice element has a value, use it:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>MetadataLatticeValue</span> <span class=o>&amp;</span><span class=n>value</span> <span class=o>=</span> <span class=n>lattice</span><span class=o>-&gt;</span><span class=n>getValue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/ title="Using `mlir-opt`"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Using `mlir-opt`</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/ title="Creating a Dialect">Next - Creating a Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li class=active><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>