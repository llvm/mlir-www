<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials on MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/</link><description>Recent content in Tutorials on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 01 Jan 1970 00:00:00 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/Tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Creating a Dialect</title><link>https://mlir.llvm.org/docs/Tutorials/CreatingADialect/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/CreatingADialect/</guid><description>CMake best practices TableGen Targets Library Targets CMake best practices Public dialects are typically separated into at least 3 directories:
mlir/include/mlir/Dialect/Foo (for public include files) mlir/lib/Dialect/Foo (for sources) mlir/lib/Dialect/Foo/IR (for operations) mlir/lib/Dialect/Foo/Transforms (for transforms) mlir/test/Dialect/Foo (for tests) Along with other public headers, the &amp;lsquo;include&amp;rsquo; directory contains a TableGen file in the ODS format, describing the operations in the dialect. This is used to generate operation declarations (FooOps.h.inc) and definitions (FooOps.</description></item><item><title>Quickstart tutorial to adding MLIR graph rewrite</title><link>https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/</guid><description>This document will present a quickstart to adding graph rewrites. We shall start by defining an operation, showing multiple ways to define the rewrite using patterns, as well as defining the rewrite using a graph walker (note: using patterns and the rewrite engine is preferred, showing the walker is for demonstration purposes).
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc. See Table-driven Operation Definition and Declarative Rewrite Rule for the detailed explanation of all available mechanisms for defining operations and rewrites in a table-driven manner.</description></item><item><title>Understanding the IR Structure</title><link>https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/</guid><description>The MLIR Language Reference describes the High Level Structure, this document illustrates this structure through examples, and introduces at the same time the C++ APIs involved in manipulating it.
We will implement a pass that traverses any MLIR input and prints the entity inside the IR. A pass (or in general almost any piece of IR) is always rooted with an operation. Most of the time the top-level operation is a ModuleOp, the MLIR PassManager is actually limited to operation on a top-level ModuleOp.</description></item><item><title>Using `mlir-opt`</title><link>https://mlir.llvm.org/docs/Tutorials/MlirOpt/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/MlirOpt/</guid><description>mlir-opt is a command-line entry point for running passes and lowerings on MLIR code. This tutorial will explain how to use mlir-opt, show some examples of its usage, and mention some useful tips for working with it.
Prerequisites:
Building MLIR from source MLIR Language Reference mlir-opt basics Running a pass Running a pass with options Building a pass pipeline on the command line Useful CLI flags Further readering mlir-opt basics The mlir-opt tool loads a textual IR or bytecode into an in-memory structure, and optionally executes a sequence of passes before serializing back the IR (textual form by default).</description></item><item><title>Writing DataFlow Analyses in MLIR</title><link>https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/</guid><description>Writing dataflow analyses in MLIR, or well any compiler, can often seem quite daunting and/or complex. A dataflow analysis generally involves propagating information about the IR across various different types of control flow constructs, of which MLIR has many (Block-based branches, Region-based branches, CallGraph, etc), and it isn&amp;rsquo;t always clear how best to go about performing the propagation. To help writing these types of analyses in MLIR, this document details several utilities that simplify the process and make it a bit more approachable.</description></item></channel></rss>