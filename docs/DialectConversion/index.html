<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect Conversion - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/DialectConversion/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Dialect Conversion</h1><p>This document describes a framework in MLIR in which to perform operation
conversions between, and within dialects. This framework allows for transforming
illegal operations to those supported by a provided conversion target, via a set
of pattern-based operation rewriting patterns.</p><p>The dialect conversion framework consists of the following components:</p><ul><li>A
<a href=#conversion-target>Conversion Target</a></li><li>A set of
<a href=#rewrite-pattern-specification>Rewrite Patterns</a></li><li>A
<a href=#type-conversion>Type Converter</a> (Optional)</li></ul><p><nav id=TableOfContents><ul><li><a href=#modes-of-conversion>Modes of Conversion</a></li><li><a href=#conversion-target>Conversion Target</a><ul><li><a href=#recursive-legality>Recursive Legality</a></li></ul></li><li><a href=#rewrite-pattern-specification>Rewrite Pattern Specification</a><ul><li><a href=#conversion-patterns>Conversion Patterns</a></li></ul></li><li><a href=#type-conversion>Type Conversion</a><ul><li><a href=#type-converter>Type Converter</a></li><li><a href=#region-signature-conversion>Region Signature Conversion</a></li></ul></li><li><a href=#debugging>Debugging</a></li></ul></nav><h2 id=modes-of-conversion>Modes of Conversion&nbsp;<a class=headline-hash href=#modes-of-conversion>¶</a></h2><p>When applying a conversion to a set of operations, there are several different
conversion modes that may be selected from:</p><ul><li><p>Partial Conversion</p><ul><li>A partial conversion will legalize as many operations to the target as
possible, but will allow pre-existing operations that were not
explicitly marked as &ldquo;illegal&rdquo; to remain unconverted. This allows for
partially lowering parts of the input in the presence of unknown
operations.</li><li>A partial conversion can be applied via <code>applyPartialConversion</code>.</li></ul></li><li><p>Full Conversion</p><ul><li>A full conversion legalizes all input operations, and is only successful
if all operations are properly legalized to the given conversion target.
This ensures that only known operations will exist after the conversion
process.</li><li>A full conversion can be applied via <code>applyFullConversion</code>.</li></ul></li><li><p>Analysis Conversion</p><ul><li>An analysis conversion will analyze which operations are legalizable to
the given conversion target if a conversion were to be applied. This is
done by performing a &lsquo;partial&rsquo; conversion and recording which operations
would have been successfully converted if successful. Note that no
rewrites, or transformations, are actually applied to the input
operations.</li><li>An analysis conversion can be applied via <code>applyAnalysisConversion</code>.</li></ul></li></ul><p>In all cases, the framework walks the operations in preorder, examining an op
before the ops in any regions it has.</p><h2 id=conversion-target>Conversion Target&nbsp;<a class=headline-hash href=#conversion-target>¶</a></h2><p>The conversion target is a formal definition of what is considered to be legal
during the conversion process. The final operations generated by the conversion
framework must be marked as legal on the <code>ConversionTarget</code> for the rewrite to
be a success. Depending on the conversion mode, existing operations need not
always be legal. Operations and dialects may be marked with any of the provided
legality actions below:</p><ul><li><p>Legal</p><ul><li>This action signals that every instance of a given operation is legal,
i.e. any combination of attributes, operands, types, etc. are valid.</li></ul></li><li><p>Dynamic</p><ul><li>This action signals that only some instances of a given operation are
legal. This allows for defining fine-tune constraints, e.g. saying that
<code>arith.addi</code> is only legal when operating on 32-bit integers.</li></ul></li><li><p>Illegal</p><ul><li>This action signals that no instance of a given operation is legal.
Operations marked as &ldquo;illegal&rdquo; must always be converted for the
conversion to be successful. This action also allows for selectively
marking specific operations as illegal in an otherwise legal dialect.</li></ul></li></ul><p>Operations and dialects that are neither explicitly marked legal nor illegal are
separate from the above (&ldquo;unknown&rdquo; operations) and are treated differently, for
example, for the purposes of partial conversion as mentioned above.</p><p>An example conversion target is shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyTarget</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ConversionTarget</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MyTarget</span><span class=p>(</span><span class=n>MLIRContext</span> <span class=o>&amp;</span><span class=n>ctx</span><span class=p>)</span> <span class=o>:</span> <span class=n>ConversionTarget</span><span class=p>(</span><span class=n>ctx</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//--------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Marking an operation as Legal:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>/// Mark all operations within the LLVM dialect are legal.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addLegalDialect</span><span class=o>&lt;</span><span class=n>LLVMDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Mark `arith.constant` op is always legal on this target.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>arith</span><span class=o>::</span><span class=n>ConstantOp</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//--------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Marking an operation as dynamically legal.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>/// Mark all operations within Affine dialect have dynamic legality
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// constraints.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addDynamicallyLegalDialect</span><span class=o>&lt;</span><span class=n>affine</span><span class=o>::</span><span class=n>AffineDialect</span><span class=o>&gt;</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=p>[](</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Mark `func.return` as dynamically legal, but provide a specific legality
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// callback.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addDynamicallyLegalOp</span><span class=o>&lt;</span><span class=n>func</span><span class=o>::</span><span class=n>ReturnOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>func</span><span class=o>::</span><span class=n>ReturnOp</span> <span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Treat unknown operations, i.e. those without a legalization action
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// directly set, as dynamically legal.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>markUnknownOpDynamicallyLegal</span><span class=p>([](</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>//--------------------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Marking an operation as illegal.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>/// All operations within the GPU dialect are illegal.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addIllegalDialect</span><span class=o>&lt;</span><span class=n>GPUDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Mark `cf.br` and `cf.cond_br` as illegal.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>addIllegalOp</span><span class=o>&lt;</span><span class=n>cf</span><span class=o>::</span><span class=n>BranchOp</span><span class=p>,</span> <span class=n>cf</span><span class=o>::</span><span class=n>CondBranchOp</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// Implement the default legalization handler to handle operations marked as
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// dynamically legal that were not provided with an explicit handler.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>bool</span> <span class=nf>isDynamicallyLegal</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 id=recursive-legality>Recursive Legality&nbsp;<a class=headline-hash href=#recursive-legality>¶</a></h3><p>In some cases, it may be desirable to mark entire regions as legal. This
provides an additional granularity of context to the concept of &ldquo;legal&rdquo;. If an
operation is marked recursively legal, either statically or dynamically, then
all of the operations nested within are also considered legal even if they would
otherwise be considered &ldquo;illegal&rdquo;. An operation can be marked via
<code>markOpRecursivelyLegal&lt;></code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>ConversionTarget</span> <span class=o>&amp;</span><span class=n>target</span> <span class=o>=</span> <span class=p>...;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// The operation must first be marked as `Legal` or `Dynamic`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>addLegalOp</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl><span class=n>target</span><span class=p>.</span><span class=n>addDynamicallyLegalOp</span><span class=o>&lt;</span><span class=n>MySecondOp</span><span class=o>&gt;</span><span class=p>(...);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// Mark the operation as always recursively legal.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=c1>/// Mark optionally with a callback to allow selective marking.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>MySecondOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=c1>/// Mark optionally with a callback to allow selective marking.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>target</span><span class=p>.</span><span class=n>markOpRecursivelyLegal</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=o>&gt;</span><span class=p>([](</span><span class=n>MyOp</span> <span class=n>op</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>});</span>
</span></span></code></pre></div><h2 id=rewrite-pattern-specification>Rewrite Pattern Specification&nbsp;<a class=headline-hash href=#rewrite-pattern-specification>¶</a></h2><p>After the conversion target has been defined, a set of legalization patterns
must be provided to transform illegal operations into legal ones. The patterns
supplied here have the same structure and similar restrictions as those
described in the main
<a href=/docs/PatternRewriter/>Pattern</a> documentation. The patterns
provided do not need to generate operations that are directly legal on the
target. The framework will automatically build a graph of conversions to convert
non-legal operations into a set of legal ones.</p><p>As an example, say you define a target that supports one operation: <code>foo.add</code>.
When providing the following patterns: [<code>bar.add</code> -> <code>baz.add</code>, <code>baz.add</code> ->
<code>foo.add</code>], the framework will automatically detect that it can legalize
<code>bar.add</code> -> <code>foo.add</code> even though a direct conversion does not exist. This
means that you don’t have to define a direct legalization pattern for <code>bar.add</code>
-> <code>foo.add</code>.</p><h3 id=conversion-patterns>Conversion Patterns&nbsp;<a class=headline-hash href=#conversion-patterns>¶</a></h3><p>Along with the general <code>RewritePattern</code> classes, the conversion framework
provides a special type of rewrite pattern that can be used when a pattern
relies on interacting with constructs specific to the conversion process, the
<code>ConversionPattern</code>.</p><h4 id=remapped-operands--adaptor>Remapped Operands / Adaptor&nbsp;<a class=headline-hash href=#remapped-operands--adaptor>¶</a></h4><p>Conversion patterns have an additional <code>operands</code> / <code>adaptor</code> argument for the
<code>matchAndRewrite</code> method. These operands correspond to the most recent
replacement values of the respective operands of the matched operation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>MyConversionPattern</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ConversionPattern</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// The `matchAndRewrite` hooks on ConversionPatterns take an additional
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// `operands` parameter, containing the remapped operands of the original
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// operation.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>virtual</span> <span class=n>LogicalResult</span>
</span></span><span class=line><span class=cl>  <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>operands</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>ConversionPatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;test.foo&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i1</span>  <span class=c>// matched by pattern A
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;test.bar&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>   <span class=c>// matched by pattern B
</span></span></span></code></pre></div><p>Let&rsquo;s assume that the two patterns are applied back-to-back: first, pattern A
replaces <code>"test.foo"</code> with <code>"test.qux"</code>, an op that has a different result
type. The dialect conversion infrastructure has special support for such
type-changing IR modifications.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;test.qux&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i2</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> builtin<span class=p>.</span>unrealized_conversion_cast <span class=nv>%0</span> <span class=p>:</span> <span class=k>i2</span> to <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=s>&#34;test.bar&#34;</span><span class=p>(</span><span class=nv>%r</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><p>Simply swapping out the operand of <code>"test.bar"</code> during the <code>replaceOp</code> call
would be unsafe, because that would change the type of operand and, therefore,
potentially the semantics of the operation. Instead, the dialect conversion
driver (conceptually) inserts a <code>builtin.unrealized_conversion_cast</code> op that
connects the newly created <code>"test.qux"</code> op with the <code>"test.bar"</code> op, without
changing the types of the latter one.</p><p>Now, the second pattern B is applied. The <code>operands</code> argument contains an SSA
value with the most recent replacement type (<code>%0</code> with type <code>i2</code>), whereas
querying the operand from the matched op still returns an SSA value with the
original operand type <code>i1</code>.</p><p>Note: If the conversion pattern is instantiated with a type converter, the
<code>operands</code> argument contains SSA values whose types match the legalized operand
types as per the type converter. See
<a href=#type-safety>Type Safety</a> for more
details.</p><p>Note: The dialect conversion framework does not guarantee the presence of any
particular value in the <code>operands</code> argument. The only thing that&rsquo;s guaranteed
is the type of the <code>operands</code> SSA values. E.g., instead of the actual
replacement values supplied to a <code>replaceOp</code> API call, <code>operands</code> may contain
results of transitory <code>builtin.unrealized_conversion_cast</code> ops that were
inserted by the conversion driver but typically fold away again throughout the
conversion process.</p><h4 id=immediate-vs-delayed-ir-modification>Immediate vs. Delayed IR Modification&nbsp;<a class=headline-hash href=#immediate-vs-delayed-ir-modification>¶</a></h4><p>The dialect conversion driver can operate in two modes: (a) rollback mode
(default) and (b) no-rollback mode. This can be controlled by
<code>ConversionConfig::allowPatternRollback</code>. When running in rollback mode, the
driver is able backtrack and roll back already applied patterns when the
current legalization path (sequence of pattern applications) gets stuck with
unlegalizable operations.</p><p>When running in no-rollback mode, all IR modifications such as op replacement,
op erasure, op insertion or in-place op modification are applied immediately.</p><p>When running in rollback mode, certain IR modifications are delayed to the end
of the conversion process. For example, a <code>ConversionPatternRewriter::eraseOp</code>
API call does not immediately erase the op, but just marks it for erasure. The
op will stay visible to patterns and IR traversals throughout the conversion
process. As another example, <code>replaceOp</code> and <code>replaceAllUsesWith</code> does not
immediately update users of the original SSA values. This step is also delayed
to the end of the conversion process.</p><p>Delaying certain IR modifications has two benefits: (1) pattern rollback is
simpler because fewer IR modifications must be rolled back, (2) pointers of
erased operations / blocks are preserved upon rollback, and (3) patterns can
still access/traverse the original IR to some degree. However, additional
bookkeeping in the form of complex internal C++ data structures is required to
support pattern rollback. Running in rollback mode has a significant toll on
compilation time, is error-prone and makes debugging conversion passes more
complicated. Therefore, programmers are encouraged to run in no-rollback mode
when possible.</p><p>The following table gives an overview of which IR changes are applied in a
delayed fasion in rollback mode.</p><table><thead><tr><th>Type</th><th>Rollback Mode</th><th>No-rollback Mode</th></tr></thead><tbody><tr><td>Op Insertion / Movement (<code>create</code>/<code>insert</code>)</td><td>Immediate</td><td>Immediate</td></tr><tr><td>Op Replacement (<code>replaceOp</code>)</td><td>Delayed</td><td>Immediate</td></tr><tr><td>Op Erasure (<code>eraseOp</code>)</td><td>Delayed</td><td>Immediate</td></tr><tr><td>Op Modification (<code>modifyOpInPlace</code>)</td><td>Immediate</td><td>Immediate</td></tr><tr><td>Value Replacement (<code>replaceAllUsesWith</code>)</td><td>Delayed</td><td>Immediate</td></tr><tr><td>Block Insertion (<code>createBlock</code>)</td><td>Immediate</td><td>Immediate</td></tr><tr><td>Block Replacement</td><td>Not supported</td><td>Not supported</td></tr><tr><td>Block Erasure</td><td>Partly delayed</td><td>Immediate</td></tr><tr><td>Block Signature Conversion (<code>applySignatureConversion</code>)</td><td>Partially delayed</td><td>Immediate</td></tr><tr><td>Region / Block Inlining (<code>inlineBlockBefore</code>, etc.)</td><td>Partially delayed</td><td>Immediate</td></tr></tbody></table><p>Value replacement is delayed and has different semantics in rollback mode:
Since the actual replacement is delayed to the end of the conversion process,
additional uses of the replaced value can be created after the
<code>replaceAllUsesWith</code> call. Those uses will also be replaced at the end of the
conversion process.</p><p>Block replacement is not supported in either mode, because the rewriter
infrastructure currently has no API for replacing blocks: there is no overload
of <code>replaceAllUsesWith</code> that accepts <code>Block *</code>.</p><p>Block erasure is partly delayed in rollback mode: the block is detached from
the IR graph, but not memory for the block is not released until the end of the
conversion process. This mechanism ensures that block pointers do not change
when a block erasure is rolled back.</p><p>Block signature conversion is a combination of block insertion, op insertion,
value replacement and block erasure. In rollback mode, the first two steps are
immediate, but the last two steps are delayed.</p><p>Region / block inlining is a combination of block / op insertion and
(optionally) value replacement. In rollback mode, the insertion steps are
immediate, but the replacement step is delayed.</p><p>Note: When running in rollback mode, the conversion driver inserts fewer
transitory <code>builtin.unrealized_conversion_cast</code> ops. Such ops are needed less
frequently because certain IR modifications are delayed, making it unnecessary
to connect old (not yet rewritten) and new (already rewritten) IR in a
type-safe way. This has a negative effect on the debugging experience: when
dumping IR throughout the conversion process, users see a mixture of old and
new IR, but the way they are connected is not always visibile in the IR. Some
of that information is stored in internal C++ data structures that is not
visibile during an IR dump.</p><h4 id=type-safety>Type Safety&nbsp;<a class=headline-hash href=#type-safety>¶</a></h4><p>The types of the remapped operands provided to a conversion pattern (through
the adaptor or <code>ArrayRef</code> of operands) depend on type conversion rules.</p><p>If the pattern was initialized with a
<a href=#type-converter>type converter</a>, the
conversion driver passes values whose types match the legalized types of the
operands of the matched operation as per the type converter. To that end, the
conversion driver may insert target materializations to convert the most
recently mapped values to the expected legalized types. The driver tries to
reuse existing materializations on a best-effort basis, but this is not
guaranteed by the infrastructure. If the operand types of the matched op could
not be legalized, the pattern fails to apply before the <code>matchAndRewrite</code> hook
is invoked.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Type converter that converts all FloatTypes to IntegerTypes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>TypeConverter</span> <span class=n>converter</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>converter</span><span class=p>.</span><span class=n>addConversion</span><span class=p>([](</span><span class=n>FloatType</span> <span class=n>t</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>IntegerType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>t</span><span class=p>.</span><span class=n>getContext</span><span class=p>(),</span> <span class=n>t</span><span class=p>.</span><span class=n>getWidth</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Assuming that `MyConversionPattern` was initialized with `converter`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=nc>MyConversionPattern</span> <span class=o>:</span> <span class=k>public</span> <span class=n>ConversionPattern</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>virtual</span> <span class=n>LogicalResult</span>
</span></span><span class=line><span class=cl>  <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Value</span><span class=o>&gt;</span> <span class=n>operands</span><span class=p>,</span> <span class=cm>/* ... */</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c1>//                                               ^^^^^^^^
</span></span></span><span class=line><span class=cl><span class=c1>//      If `op` has a FloatType operand, the respective value in `operands`
</span></span></span><span class=line><span class=cl><span class=c1>//      is guaranteed to have the legalized IntegerType. If another pattern
</span></span></span><span class=line><span class=cl><span class=c1>//      previously replaced the operand SSA value with an SSA value of the
</span></span></span><span class=line><span class=cl><span class=c1>//      legalized type (via &#34;replaceOp&#34; or &#34;applySignatureConversion&#34;), you
</span></span></span><span class=line><span class=cl><span class=c1>//      will get that SSA value directly (unless the replacement value was
</span></span></span><span class=line><span class=cl><span class=c1>//      also replaced). Otherwise, you will get a materialization to the
</span></span></span><span class=line><span class=cl><span class=c1>//      legalized type.
</span></span></span></code></pre></div><p>If the pattern was initialized without a type converter, the conversion driver
passes the most recently mapped values to the pattern, excluding any
materializations. If a value with the same type as the original operand is
desired, users can directly take the respective operand from the matched
operation.</p><p>Example: When initializing the pattern from the above example without a type
converter, <code>operands</code> contains the most recent replacement values, regardless
of their types.</p><p>Note: When running without a type converter, materializations are intentionally
excluded from the lookup process because their presence may depend on other
patterns. Passing materializations would make the conversion infrastructure
fragile and unpredictable. Moreover, there could be multiple materializations
to different types. (This can be the case when multiple patterns are running
with different type converters.) In such a case, it would be unclear which
materialization to pass.</p><p>The above rules ensure that patterns do not have to explicitly ensure type
safety, or sanitize the types of the incoming remapped operands. More
information on type conversion is detailed in the
<a href=#type-conversion>dedicated section</a> below.</p><h2 id=type-conversion>Type Conversion&nbsp;<a class=headline-hash href=#type-conversion>¶</a></h2><p>It is sometimes necessary as part of a conversion to convert the set types of
being operated on. In these cases, a <code>TypeConverter</code> object may be defined that
details how types should be converted when interfacing with a pattern. A
<code>TypeConverter</code> may be used to convert the signatures of block arguments and
regions, to define the expected inputs types of the pattern, and to reconcile
type differences in general.</p><h3 id=type-converter>Type Converter&nbsp;<a class=headline-hash href=#type-converter>¶</a></h3><p>The <code>TypeConverter</code> contains several hooks for detailing how to convert types,
and how to materialize conversions between types in various situations. The two
main aspects of the <code>TypeConverter</code> are conversion and materialization.</p><p>A <code>conversion</code> describes how a given source <code>Type</code> should be converted to N
target types. If the source type is converted to itself, we say it is a &ldquo;legal&rdquo;
type. Type conversions are specified via the <code>addConversion</code> method described
below.</p><p>There are two kind of conversion functions: context-aware and context-unaware
conversions. A context-unaware conversion function converts a <code>Type</code> into a
<code>Type</code>. A context-aware conversion function converts a <code>Value</code> into a type. The
latter allows users to customize type conversion rules based on the IR.</p><p>Note: context-aware type conversion functions impact the ability of the
framework to cache the conversion result. In the absence of a context-aware
conversion, all context-free type conversions can be cached. Otherwise only the
context-free conversions added after a context-aware type conversion can be
cached (conversions are applied in reverse order).
As such it is advised to add context-aware conversions as early as possible in
the sequence of <code>addConversion</code> calls (so that they apply last).</p><p>A <code>materialization</code> describes how a list of values should be converted to a
list of values with specific types. An important distinction from a
<code>conversion</code> is that a <code>materialization</code> can produce IR, whereas a <code>conversion</code>
cannot. These materializations are used by the conversion framework to ensure
type safety during the conversion process. There are several types of
materializations depending on the situation.</p><ul><li><p>Source Materialization</p><ul><li>A source materialization is used when a value was replaced with a value
of a different type, but there are still users that expects the original
(&ldquo;source&rdquo;) type at the end of the conversion process. A source
materialization converts the replacement value back to the source type.</li><li>This materialization is used in the following situations:<ul><li>When a block argument has been converted to a different type, but
the original argument still has users that will remain live after
the conversion process has finished.</li><li>When a block argument has been dropped, but the argument still has
users that will remain live after the conversion process has
finished.</li><li>When the result type of an operation has been converted to a
different type, but the original result still has users that will
remain live after the conversion process is finished.</li></ul></li></ul></li><li><p>Target Materialization</p><ul><li>A target materialization converts a value to the type that is expected
by a conversion pattern according to its type converter.</li><li>A target materialization is used when a pattern expects the remapped
operands to be of a certain set of types, but the original input
operands have either not been replaced or been replaced with values of
a different type.</li></ul></li></ul><p>If a converted value is used by an operation that isn&rsquo;t converted, it needs a
conversion back to the <code>source</code> type, hence source materialization; if an
unconverted value is used by an operation that is being converted, it needs
conversion to the <code>target</code> type, hence target materialization.</p><p>As noted above, the conversion process guarantees that the type contract of the
IR is preserved during the conversion. This means that the types of value uses
will not implicitly change during the conversion process. When the type of a
value definition, either block argument or operation result, is being changed,
the users of that definition must also be updated during the conversion process.
If they aren&rsquo;t, a type conversion must be materialized to ensure that a value of
the expected type is still present within the IR. If a materialization is
required, but cannot be performed, the entire conversion process fails.</p><p>Several of the available hooks are detailed below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>TypeConverter</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>/// Register a conversion function. A conversion function must be convertible
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// to any of the following forms (where `T` is `Value` or a class derived
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// from `Type`, including `Type` itself):
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * std::optional&lt;Type&gt;(T)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///     - This form represents a 1-1 type conversion. It should return nullptr
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       or `std::nullopt` to signify failure. If `std::nullopt` is returned,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       the converter is allowed to try another conversion function to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       perform the conversion.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   * std::optional&lt;LogicalResult&gt;(T, SmallVectorImpl&lt;Type&gt; &amp;)
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///     - This form represents a 1-N type conversion. It should return
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       `failure` or `std::nullopt` to signify a failed conversion. If the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       new set of types is empty, the type is removed and any usages of the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       existing value are expected to be removed during conversion. If
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       `std::nullopt` is returned, the converter is allowed to try another
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       conversion function to perform the conversion.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Conversion functions that accept `Value` as the first argument are
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// context-aware. I.e., they can take into account IR when converting the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// type of the given value. Context-unaware conversion functions accept
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// `Type` or a derived class as the first argument.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Note: Context-unaware conversions are cached, but context-aware
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// conversions are not.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Note: When attempting to convert a type, e.g. via &#39;convertType&#39;, the
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///       mostly recently added conversions will be invoked first.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>FnT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>llvm</span><span class=o>::</span><span class=n>function_traits</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;::</span><span class=k>template</span> <span class=n>arg_t</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>addConversion</span><span class=p>(</span><span class=n>FnT</span> <span class=o>&amp;&amp;</span><span class=n>callback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>registerConversion</span><span class=p>(</span><span class=n>wrapCallback</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;</span><span class=p>(</span><span class=n>callback</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// All of the following materializations require function objects that are
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// convertible to the following form:
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///   `std::optional&lt;Value&gt;(OpBuilder &amp;, T, ValueRange, Location)`,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// where `T` is any subclass of `Type`. This function is responsible for
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// creating an operation, using the OpBuilder and Location provided, that
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// &#34;casts&#34; a range of values into a single value of the given type `T`. It
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// must return a Value of the converted type on success, an `std::nullopt` if
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// it failed but other materialization can be attempted, and `nullptr` on
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// unrecoverable failure. It will only be called for (sub)types of `T`.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Materialization functions must be provided when a type conversion may
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// persist after the conversion has finished.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=c1>/// This method registers a materialization that will be called when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// converting a replacement value back to its original source type.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// This is used when some uses of the original value persist beyond the main
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// conversion.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>FnT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>llvm</span><span class=o>::</span><span class=n>function_traits</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;::</span><span class=k>template</span> <span class=n>arg_t</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>addSourceMaterialization</span><span class=p>(</span><span class=n>FnT</span> <span class=o>&amp;&amp;</span><span class=n>callback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>sourceMaterializations</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>wrapSourceMaterialization</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;</span><span class=p>(</span><span class=n>callback</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>/// This method registers a materialization that will be called when
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// converting a value to a target type according to a pattern&#39;s type
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// converter.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Note: Target materializations can optionally inspect the &#34;original&#34;
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// type. This type may be different from the type of the input value.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// For example, let&#39;s assume that a conversion pattern &#34;P1&#34; replaced an SSA
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// value &#34;v1&#34; (type &#34;t1&#34;) with &#34;v2&#34; (type &#34;t2&#34;). Then a different conversion
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// pattern &#34;P2&#34; matches an op that has &#34;v1&#34; as an operand. Let&#39;s furthermore
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// assume that &#34;P2&#34; determines that the converted target type of &#34;t1&#34; is
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// &#34;t3&#34;, which may be different from &#34;t2&#34;. In this example, the target
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// materialization will be invoked with: outputType = &#34;t3&#34;, inputs = &#34;v2&#34;,
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// originalType = &#34;t1&#34;. Note that the original type &#34;t1&#34; cannot be recovered
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// from just &#34;t3&#34; and &#34;v2&#34;; that&#39;s why the originalType parameter exists.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>///
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// Note: During a 1:N conversion, the result types can be a TypeRange. In
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>/// that case the materialization produces a SmallVector&lt;Value&gt;.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>FnT</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=k>typename</span> <span class=n>T</span> <span class=o>=</span> <span class=k>typename</span> <span class=n>llvm</span><span class=o>::</span><span class=n>function_traits</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;::</span><span class=k>template</span> <span class=n>arg_t</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>addTargetMaterialization</span><span class=p>(</span><span class=n>FnT</span> <span class=o>&amp;&amp;</span><span class=n>callback</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>targetMaterializations</span><span class=p>.</span><span class=n>emplace_back</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>wrapTargetMaterialization</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>forward</span><span class=o>&lt;</span><span class=n>FnT</span><span class=o>&gt;</span><span class=p>(</span><span class=n>callback</span><span class=p>)));</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>Materializations through the type converter are optional. If the
<code>ConversionConfig::buildMaterializations</code> flag is set to &ldquo;false&rdquo;, the dialect
conversion driver builds an <code>unrealized_conversion_cast</code> op instead of calling
the respective type converter callback whenever a materialization is required.</p><h3 id=region-signature-conversion>Region Signature Conversion&nbsp;<a class=headline-hash href=#region-signature-conversion>¶</a></h3><p>From the perspective of type conversion, the types of block arguments are a bit
special. Throughout the conversion process, blocks may move between regions of
different operations. Given this, the conversion of the types for blocks must be
done explicitly via a conversion pattern.</p><p>To convert the types of block arguments within a Region, a custom hook on the
<code>ConversionPatternRewriter</code> must be invoked; <code>convertRegionTypes</code>. This hook
uses a provided type converter to apply type conversions to all blocks of a
given region. This hook also takes an optional
<code>TypeConverter::SignatureConversion</code> parameter that applies a custom conversion
to the entry block of the region. The types of the entry block arguments are
often tied semantically to the operation, e.g., <code>func::FuncOp</code>, <code>AffineForOp</code>,
etc.</p><p>To convert the signature of just one given block, the
<code>applySignatureConversion</code> hook can be used.</p><p>A signature conversion, <code>TypeConverter::SignatureConversion</code>, can be built
programmatically:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>SignatureConversion</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>/// Remap an input of the original signature with a new set of types. The
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// new types are appended to the new signature conversion.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=n>addInputs</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>types</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Append new input types to the signature conversion, this should only be
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// used if the new types are not intended to remap an existing input.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>addInputs</span><span class=p>(</span><span class=n>ArrayRef</span><span class=o>&lt;</span><span class=n>Type</span><span class=o>&gt;</span> <span class=n>types</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Remap an input of the original signature with a range of types in the
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// new signature.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>remapInput</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=kt>unsigned</span> <span class=n>newInputNo</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=kt>unsigned</span> <span class=n>newInputCount</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>/// Remap an input of the original signature to another `replacement`
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>/// value. This drops the original argument.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>remapInput</span><span class=p>(</span><span class=kt>unsigned</span> <span class=n>origInputNo</span><span class=p>,</span> <span class=n>Value</span> <span class=n>replacement</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>The <code>TypeConverter</code> provides several default utilities for signature conversion
and legality checking:
<code>convertSignatureArgs</code>/<code>convertBlockSignature</code>/<code>isLegal(Region *|Type)</code>.</p><h2 id=debugging>Debugging&nbsp;<a class=headline-hash href=#debugging>¶</a></h2><p>To debug the execution of the dialect conversion framework,
<code>-debug-only=dialect-conversion</code> may be used. This command line flag activates
LLVM&rsquo;s debug logging infrastructure solely for the conversion framework. The
output is formatted as a tree structure, mirroring the structure of the
conversion process. This output contains all of the actions performed by the
rewriter, how generated operations get legalized, and why they fail.</p><p>Example output is shown below:</p><pre tabindex=0><code>//===-------------------------------------------===//
Legalizing operation : &#39;func.return&#39;(0x608000002e20) {
  &#34;func.return&#34;() : () -&gt; ()

  * Fold {
  } -&gt; FAILURE : unable to fold

  * Pattern : &#39;func.return -&gt; ()&#39; {
    ** Insert  : &#39;spirv.Return&#39;(0x6070000453e0)
    ** Replace : &#39;func.return&#39;(0x608000002e20)

    //===-------------------------------------------===//
    Legalizing operation : &#39;spirv.Return&#39;(0x6070000453e0) {
      &#34;spirv.Return&#34;() : () -&gt; ()

    } -&gt; SUCCESS : operation marked legal by the target
    //===-------------------------------------------===//
  } -&gt; SUCCESS : pattern applied successfully
} -&gt; SUCCESS
//===-------------------------------------------===//
</code></pre><p>This output is describing the legalization of an <code>func.return</code> operation. We
first try to legalize by folding the operation, but that is unsuccessful for
<code>func.return</code>. From there, a pattern is applied that replaces the <code>func.return</code>
with a <code>spirv.Return</code>. The newly generated <code>spirv.Return</code> is then processed for
legalization, but is found to already legal as per the target.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Diagnostics/ title="Diagnostic Infrastructure"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Diagnostic Infrastructure</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/ title=Dialects>Next - Dialects <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li class=active><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>