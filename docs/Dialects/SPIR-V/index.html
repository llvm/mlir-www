<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>SPIR-V Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/SPIR-V/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>SPIR-V Dialect</h1><p>This document describes the design of the SPIR-V dialect in MLIR. It lists
various design choices we made for modeling different SPIR-V mechanisms, and
their rationale.</p><p>This document also explains in a high-level manner how different components are
organized and implemented in the code and gives steps to follow for extending
them.</p><p>This document assumes familiarity with SPIR-V.
<a href=https://www.khronos.org/registry/spir-v/>SPIR-V</a> is the Khronos
Group’s binary intermediate language for representing graphics shaders and
compute kernels. It is adopted by multiple Khronos Group’s APIs, including
Vulkan and OpenCL. It is fully defined in a
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html>human-readable specification</a>; the syntax of various SPIR-V
instructions are encoded in a
<a href=https://raw.githubusercontent.com/KhronosGroup/SPIRV-Headers/master/include/spirv/unified1/spirv.core.grammar.json>machine-readable grammar</a>.</p><p><nav id=TableOfContents><ul><li><a href=#design-guidelines>Design Guidelines</a><ul><li><a href=#dialect-design-principles>Dialect design principles</a></li><li><a href=#dialect-scopes>Dialect scopes</a></li></ul></li><li><a href=#conventions>Conventions</a></li><li><a href=#module>Module</a><ul><li><a href=#module-level-operations>Module-level operations</a></li></ul></li><li><a href=#decorations>Decorations</a></li><li><a href=#types>Types</a><ul><li><a href=#array-type>Array type</a></li><li><a href=#image-type>Image type</a></li><li><a href=#pointer-type>Pointer type</a></li><li><a href=#runtime-array-type>Runtime array type</a></li><li><a href=#sampled-image-type>Sampled image type</a></li><li><a href=#struct-type>Struct type</a></li></ul></li><li><a href=#function>Function</a></li><li><a href=#operations>Operations</a><ul><li><a href=#ops-from-extended-instruction-sets>Ops from extended instruction sets</a></li></ul></li><li><a href=#control-flow>Control Flow</a><ul><li><a href=#selection>Selection</a></li><li><a href=#loop>Loop</a></li><li><a href=#block-argument-for-phi>Block argument for Phi</a></li></ul></li><li><a href=#version-extensions-capabilities>Version, extensions, capabilities</a></li><li><a href=#target-environment>Target environment</a></li><li><a href=#shader-interface-abi>Shader interface (ABI)</a><ul><li><a href=#shader-interface-attributes>Shader interface attributes</a></li></ul></li><li><a href=#serialization-and-deserialization>Serialization and deserialization</a></li><li><a href=#conversions>Conversions</a><ul><li><a href=#spirvconversiontarget><code>SPIRVConversionTarget</code></a></li><li><a href=#spirvtypeconverter><code>SPIRVTypeConverter</code></a></li><li><a href=#utility-functions-for-lowering>Utility functions for lowering</a></li><li><a href=#current-conversions-to-spir-v>Current conversions to SPIR-V</a></li></ul></li><li><a href=#code-organization>Code organization</a><ul><li><a href=#the-dialect>The dialect</a></li><li><a href=#op-definitions>Op definitions</a></li><li><a href=#dialect-conversions>Dialect conversions</a></li></ul></li><li><a href=#rationale>Rationale</a><ul><li><a href=#lowering-memrefs-to-spirvarray-and-spirvrtarray>Lowering <code>memref</code>s to <code>!spirv.array&lt;..></code> and <code>!spirv.rtarray&lt;..></code>.</a></li></ul></li><li><a href=#contribution>Contribution</a><ul><li><a href=#automated-development-flow>Automated development flow</a></li><li><a href=#add-a-new-op>Add a new op</a></li><li><a href=#add-a-new-enum>Add a new enum</a></li><li><a href=#add-a-new-custom-type>Add a new custom type</a></li><li><a href=#add-a-new-conversion>Add a new conversion</a></li><li><a href=#add-a-new-test>Add a new test</a></li></ul></li><li><a href=#operation-definitions>Operation definitions</a><ul><li><a href=#spirvaccesschain-spirvaccesschainop><code>spirv.AccessChain</code> (spirv::AccessChainOp)</a></li><li><a href=#spirvmliraddressof-spirvaddressofop><code>spirv.mlir.addressof</code> (spirv::AddressOfOp)</a></li><li><a href=#spirvatomicand-spirvatomicandop><code>spirv.AtomicAnd</code> (spirv::AtomicAndOp)</a></li><li><a href=#spirvatomiccompareexchange-spirvatomiccompareexchangeop><code>spirv.AtomicCompareExchange</code> (spirv::AtomicCompareExchangeOp)</a></li><li><a href=#spirvatomiccompareexchangeweak-spirvatomiccompareexchangeweakop><code>spirv.AtomicCompareExchangeWeak</code> (spirv::AtomicCompareExchangeWeakOp)</a></li><li><a href=#spirvatomicexchange-spirvatomicexchangeop><code>spirv.AtomicExchange</code> (spirv::AtomicExchangeOp)</a></li><li><a href=#spirvatomiciadd-spirvatomiciaddop><code>spirv.AtomicIAdd</code> (spirv::AtomicIAddOp)</a></li><li><a href=#spirvatomicidecrement-spirvatomicidecrementop><code>spirv.AtomicIDecrement</code> (spirv::AtomicIDecrementOp)</a></li><li><a href=#spirvatomiciincrement-spirvatomiciincrementop><code>spirv.AtomicIIncrement</code> (spirv::AtomicIIncrementOp)</a></li><li><a href=#spirvatomicisub-spirvatomicisubop><code>spirv.AtomicISub</code> (spirv::AtomicISubOp)</a></li><li><a href=#spirvatomicor-spirvatomicorop><code>spirv.AtomicOr</code> (spirv::AtomicOrOp)</a></li><li><a href=#spirvatomicsmax-spirvatomicsmaxop><code>spirv.AtomicSMax</code> (spirv::AtomicSMaxOp)</a></li><li><a href=#spirvatomicsmin-spirvatomicsminop><code>spirv.AtomicSMin</code> (spirv::AtomicSMinOp)</a></li><li><a href=#spirvatomicumax-spirvatomicumaxop><code>spirv.AtomicUMax</code> (spirv::AtomicUMaxOp)</a></li><li><a href=#spirvatomicumin-spirvatomicuminop><code>spirv.AtomicUMin</code> (spirv::AtomicUMinOp)</a></li><li><a href=#spirvatomicxor-spirvatomicxorop><code>spirv.AtomicXor</code> (spirv::AtomicXorOp)</a></li><li><a href=#spirvbitcount-spirvbitcountop><code>spirv.BitCount</code> (spirv::BitCountOp)</a></li><li><a href=#spirvbitfieldinsert-spirvbitfieldinsertop><code>spirv.BitFieldInsert</code> (spirv::BitFieldInsertOp)</a></li><li><a href=#spirvbitfieldsextract-spirvbitfieldsextractop><code>spirv.BitFieldSExtract</code> (spirv::BitFieldSExtractOp)</a></li><li><a href=#spirvbitfielduextract-spirvbitfielduextractop><code>spirv.BitFieldUExtract</code> (spirv::BitFieldUExtractOp)</a></li><li><a href=#spirvbitreverse-spirvbitreverseop><code>spirv.BitReverse</code> (spirv::BitReverseOp)</a></li><li><a href=#spirvbitcast-spirvbitcastop><code>spirv.Bitcast</code> (spirv::BitcastOp)</a></li><li><a href=#spirvbitwiseand-spirvbitwiseandop><code>spirv.BitwiseAnd</code> (spirv::BitwiseAndOp)</a></li><li><a href=#spirvbitwiseor-spirvbitwiseorop><code>spirv.BitwiseOr</code> (spirv::BitwiseOrOp)</a></li><li><a href=#spirvbitwisexor-spirvbitwisexorop><code>spirv.BitwiseXor</code> (spirv::BitwiseXorOp)</a></li><li><a href=#spirvbranchconditional-spirvbranchconditionalop><code>spirv.BranchConditional</code> (spirv::BranchConditionalOp)</a></li><li><a href=#spirvbranch-spirvbranchop><code>spirv.Branch</code> (spirv::BranchOp)</a></li><li><a href=#spirvclacos-spirvclacosop><code>spirv.CL.acos</code> (spirv::CLAcosOp)</a></li><li><a href=#spirvclacosh-spirvclacoshop><code>spirv.CL.acosh</code> (spirv::CLAcoshOp)</a></li><li><a href=#spirvclasin-spirvclasinop><code>spirv.CL.asin</code> (spirv::CLAsinOp)</a></li><li><a href=#spirvclasinh-spirvclasinhop><code>spirv.CL.asinh</code> (spirv::CLAsinhOp)</a></li><li><a href=#spirvclatan2-spirvclatan2op><code>spirv.CL.atan2</code> (spirv::CLAtan2Op)</a></li><li><a href=#spirvclatan-spirvclatanop><code>spirv.CL.atan</code> (spirv::CLAtanOp)</a></li><li><a href=#spirvclatanh-spirvclatanhop><code>spirv.CL.atanh</code> (spirv::CLAtanhOp)</a></li><li><a href=#spirvclceil-spirvclceilop><code>spirv.CL.ceil</code> (spirv::CLCeilOp)</a></li><li><a href=#spirvclcos-spirvclcosop><code>spirv.CL.cos</code> (spirv::CLCosOp)</a></li><li><a href=#spirvclcosh-spirvclcoshop><code>spirv.CL.cosh</code> (spirv::CLCoshOp)</a></li><li><a href=#spirvclerf-spirvclerfop><code>spirv.CL.erf</code> (spirv::CLErfOp)</a></li><li><a href=#spirvclexp-spirvclexpop><code>spirv.CL.exp</code> (spirv::CLExpOp)</a></li><li><a href=#spirvclfabs-spirvclfabsop><code>spirv.CL.fabs</code> (spirv::CLFAbsOp)</a></li><li><a href=#spirvclfmax-spirvclfmaxop><code>spirv.CL.fmax</code> (spirv::CLFMaxOp)</a></li><li><a href=#spirvclfmin-spirvclfminop><code>spirv.CL.fmin</code> (spirv::CLFMinOp)</a></li><li><a href=#spirvclfloor-spirvclfloorop><code>spirv.CL.floor</code> (spirv::CLFloorOp)</a></li><li><a href=#spirvclfma-spirvclfmaop><code>spirv.CL.fma</code> (spirv::CLFmaOp)</a></li><li><a href=#spirvcllog-spirvcllogop><code>spirv.CL.log</code> (spirv::CLLogOp)</a></li><li><a href=#spirvclmix-spirvclmixop><code>spirv.CL.mix</code> (spirv::CLMixOp)</a></li><li><a href=#spirvclpow-spirvclpowop><code>spirv.CL.pow</code> (spirv::CLPowOp)</a></li><li><a href=#spirvclprintf-spirvclprintfop><code>spirv.CL.printf</code> (spirv::CLPrintfOp)</a></li><li><a href=#spirvclrint-spirvclrintop><code>spirv.CL.rint</code> (spirv::CLRintOp)</a></li><li><a href=#spirvclround-spirvclroundop><code>spirv.CL.round</code> (spirv::CLRoundOp)</a></li><li><a href=#spirvclrsqrt-spirvclrsqrtop><code>spirv.CL.rsqrt</code> (spirv::CLRsqrtOp)</a></li><li><a href=#spirvcls_abs-spirvclsabsop><code>spirv.CL.s_abs</code> (spirv::CLSAbsOp)</a></li><li><a href=#spirvcls_max-spirvclsmaxop><code>spirv.CL.s_max</code> (spirv::CLSMaxOp)</a></li><li><a href=#spirvcls_min-spirvclsminop><code>spirv.CL.s_min</code> (spirv::CLSMinOp)</a></li><li><a href=#spirvclsin-spirvclsinop><code>spirv.CL.sin</code> (spirv::CLSinOp)</a></li><li><a href=#spirvclsinh-spirvclsinhop><code>spirv.CL.sinh</code> (spirv::CLSinhOp)</a></li><li><a href=#spirvclsqrt-spirvclsqrtop><code>spirv.CL.sqrt</code> (spirv::CLSqrtOp)</a></li><li><a href=#spirvcltan-spirvcltanop><code>spirv.CL.tan</code> (spirv::CLTanOp)</a></li><li><a href=#spirvcltanh-spirvcltanhop><code>spirv.CL.tanh</code> (spirv::CLTanhOp)</a></li><li><a href=#spirvclu_max-spirvclumaxop><code>spirv.CL.u_max</code> (spirv::CLUMaxOp)</a></li><li><a href=#spirvclu_min-spirvcluminop><code>spirv.CL.u_min</code> (spirv::CLUMinOp)</a></li><li><a href=#spirvcompositeconstruct-spirvcompositeconstructop><code>spirv.CompositeConstruct</code> (spirv::CompositeConstructOp)</a></li><li><a href=#spirvcompositeextract-spirvcompositeextractop><code>spirv.CompositeExtract</code> (spirv::CompositeExtractOp)</a></li><li><a href=#spirvcompositeinsert-spirvcompositeinsertop><code>spirv.CompositeInsert</code> (spirv::CompositeInsertOp)</a></li><li><a href=#spirvconstant-spirvconstantop><code>spirv.Constant</code> (spirv::ConstantOp)</a></li><li><a href=#spirvcontrolbarrier-spirvcontrolbarrierop><code>spirv.ControlBarrier</code> (spirv::ControlBarrierOp)</a></li><li><a href=#spirvconvertftos-spirvconvertftosop><code>spirv.ConvertFToS</code> (spirv::ConvertFToSOp)</a></li><li><a href=#spirvconvertftou-spirvconvertftouop><code>spirv.ConvertFToU</code> (spirv::ConvertFToUOp)</a></li><li><a href=#spirvconvertptrtou-spirvconvertptrtouop><code>spirv.ConvertPtrToU</code> (spirv::ConvertPtrToUOp)</a></li><li><a href=#spirvconvertstof-spirvconvertstofop><code>spirv.ConvertSToF</code> (spirv::ConvertSToFOp)</a></li><li><a href=#spirvconvertutof-spirvconvertutofop><code>spirv.ConvertUToF</code> (spirv::ConvertUToFOp)</a></li><li><a href=#spirvconvertutoptr-spirvconvertutoptrop><code>spirv.ConvertUToPtr</code> (spirv::ConvertUToPtrOp)</a></li><li><a href=#spirvcopymemory-spirvcopymemoryop><code>spirv.CopyMemory</code> (spirv::CopyMemoryOp)</a></li><li><a href=#spirvdot-spirvdotop><code>spirv.Dot</code> (spirv::DotOp)</a></li><li><a href=#spirvextatomicfadd-spirvextatomicfaddop><code>spirv.EXT.AtomicFAdd</code> (spirv::EXTAtomicFAddOp)</a></li><li><a href=#spirvextconstantcompositereplicate-spirvextconstantcompositereplicateop><code>spirv.EXT.ConstantCompositeReplicate</code> (spirv::EXTConstantCompositeReplicateOp)</a></li><li><a href=#spirvextemitmeshtasks-spirvextemitmeshtasksop><code>spirv.EXT.EmitMeshTasks</code> (spirv::EXTEmitMeshTasksOp)</a></li><li><a href=#spirvextsetmeshoutputs-spirvextsetmeshoutputsop><code>spirv.EXT.SetMeshOutputs</code> (spirv::EXTSetMeshOutputsOp)</a></li><li><a href=#spirvextspecconstantcompositereplicate-spirvextspecconstantcompositereplicateop><code>spirv.EXT.SpecConstantCompositeReplicate</code> (spirv::EXTSpecConstantCompositeReplicateOp)</a></li><li><a href=#spirvemitvertex-spirvemitvertexop><code>spirv.EmitVertex</code> (spirv::EmitVertexOp)</a></li><li><a href=#spirvendprimitive-spirvendprimitiveop><code>spirv.EndPrimitive</code> (spirv::EndPrimitiveOp)</a></li><li><a href=#spirventrypoint-spirventrypointop><code>spirv.EntryPoint</code> (spirv::EntryPointOp)</a></li><li><a href=#spirvexecutionmode-spirvexecutionmodeop><code>spirv.ExecutionMode</code> (spirv::ExecutionModeOp)</a></li><li><a href=#spirvfadd-spirvfaddop><code>spirv.FAdd</code> (spirv::FAddOp)</a></li><li><a href=#spirvfconvert-spirvfconvertop><code>spirv.FConvert</code> (spirv::FConvertOp)</a></li><li><a href=#spirvfdiv-spirvfdivop><code>spirv.FDiv</code> (spirv::FDivOp)</a></li><li><a href=#spirvfmod-spirvfmodop><code>spirv.FMod</code> (spirv::FModOp)</a></li><li><a href=#spirvfmul-spirvfmulop><code>spirv.FMul</code> (spirv::FMulOp)</a></li><li><a href=#spirvfnegate-spirvfnegateop><code>spirv.FNegate</code> (spirv::FNegateOp)</a></li><li><a href=#spirvfordequal-spirvfordequalop><code>spirv.FOrdEqual</code> (spirv::FOrdEqualOp)</a></li><li><a href=#spirvfordgreaterthanequal-spirvfordgreaterthanequalop><code>spirv.FOrdGreaterThanEqual</code> (spirv::FOrdGreaterThanEqualOp)</a></li><li><a href=#spirvfordgreaterthan-spirvfordgreaterthanop><code>spirv.FOrdGreaterThan</code> (spirv::FOrdGreaterThanOp)</a></li><li><a href=#spirvfordlessthanequal-spirvfordlessthanequalop><code>spirv.FOrdLessThanEqual</code> (spirv::FOrdLessThanEqualOp)</a></li><li><a href=#spirvfordlessthan-spirvfordlessthanop><code>spirv.FOrdLessThan</code> (spirv::FOrdLessThanOp)</a></li><li><a href=#spirvfordnotequal-spirvfordnotequalop><code>spirv.FOrdNotEqual</code> (spirv::FOrdNotEqualOp)</a></li><li><a href=#spirvfrem-spirvfremop><code>spirv.FRem</code> (spirv::FRemOp)</a></li><li><a href=#spirvfsub-spirvfsubop><code>spirv.FSub</code> (spirv::FSubOp)</a></li><li><a href=#spirvfunordequal-spirvfunordequalop><code>spirv.FUnordEqual</code> (spirv::FUnordEqualOp)</a></li><li><a href=#spirvfunordgreaterthanequal-spirvfunordgreaterthanequalop><code>spirv.FUnordGreaterThanEqual</code> (spirv::FUnordGreaterThanEqualOp)</a></li><li><a href=#spirvfunordgreaterthan-spirvfunordgreaterthanop><code>spirv.FUnordGreaterThan</code> (spirv::FUnordGreaterThanOp)</a></li><li><a href=#spirvfunordlessthanequal-spirvfunordlessthanequalop><code>spirv.FUnordLessThanEqual</code> (spirv::FUnordLessThanEqualOp)</a></li><li><a href=#spirvfunordlessthan-spirvfunordlessthanop><code>spirv.FUnordLessThan</code> (spirv::FUnordLessThanOp)</a></li><li><a href=#spirvfunordnotequal-spirvfunordnotequalop><code>spirv.FUnordNotEqual</code> (spirv::FUnordNotEqualOp)</a></li><li><a href=#spirvfunc-spirvfuncop><code>spirv.func</code> (spirv::FuncOp)</a></li><li><a href=#spirvfunctioncall-spirvfunctioncallop><code>spirv.FunctionCall</code> (spirv::FunctionCallOp)</a></li><li><a href=#spirvglacos-spirvglacosop><code>spirv.GL.Acos</code> (spirv::GLAcosOp)</a></li><li><a href=#spirvglacosh-spirvglacoshop><code>spirv.GL.Acosh</code> (spirv::GLAcoshOp)</a></li><li><a href=#spirvglasin-spirvglasinop><code>spirv.GL.Asin</code> (spirv::GLAsinOp)</a></li><li><a href=#spirvglasinh-spirvglasinhop><code>spirv.GL.Asinh</code> (spirv::GLAsinhOp)</a></li><li><a href=#spirvglatan-spirvglatanop><code>spirv.GL.Atan</code> (spirv::GLAtanOp)</a></li><li><a href=#spirvglatanh-spirvglatanhop><code>spirv.GL.Atanh</code> (spirv::GLAtanhOp)</a></li><li><a href=#spirvglceil-spirvglceilop><code>spirv.GL.Ceil</code> (spirv::GLCeilOp)</a></li><li><a href=#spirvglcos-spirvglcosop><code>spirv.GL.Cos</code> (spirv::GLCosOp)</a></li><li><a href=#spirvglcosh-spirvglcoshop><code>spirv.GL.Cosh</code> (spirv::GLCoshOp)</a></li><li><a href=#spirvglcross-spirvglcrossop><code>spirv.GL.Cross</code> (spirv::GLCrossOp)</a></li><li><a href=#spirvgldistance-spirvgldistanceop><code>spirv.GL.Distance</code> (spirv::GLDistanceOp)</a></li><li><a href=#spirvglexp2-spirvglexp2op><code>spirv.GL.Exp2</code> (spirv::GLExp2Op)</a></li><li><a href=#spirvglexp-spirvglexpop><code>spirv.GL.Exp</code> (spirv::GLExpOp)</a></li><li><a href=#spirvglfabs-spirvglfabsop><code>spirv.GL.FAbs</code> (spirv::GLFAbsOp)</a></li><li><a href=#spirvglfclamp-spirvglfclampop><code>spirv.GL.FClamp</code> (spirv::GLFClampOp)</a></li><li><a href=#spirvglfmax-spirvglfmaxop><code>spirv.GL.FMax</code> (spirv::GLFMaxOp)</a></li><li><a href=#spirvglfmin-spirvglfminop><code>spirv.GL.FMin</code> (spirv::GLFMinOp)</a></li><li><a href=#spirvglfmix-spirvglfmixop><code>spirv.GL.FMix</code> (spirv::GLFMixOp)</a></li><li><a href=#spirvglfsign-spirvglfsignop><code>spirv.GL.FSign</code> (spirv::GLFSignOp)</a></li><li><a href=#spirvglfindilsb-spirvglfindilsbop><code>spirv.GL.FindILsb</code> (spirv::GLFindILsbOp)</a></li><li><a href=#spirvglfindsmsb-spirvglfindsmsbop><code>spirv.GL.FindSMsb</code> (spirv::GLFindSMsbOp)</a></li><li><a href=#spirvglfindumsb-spirvglfindumsbop><code>spirv.GL.FindUMsb</code> (spirv::GLFindUMsbOp)</a></li><li><a href=#spirvglfloor-spirvglfloorop><code>spirv.GL.Floor</code> (spirv::GLFloorOp)</a></li><li><a href=#spirvglfma-spirvglfmaop><code>spirv.GL.Fma</code> (spirv::GLFmaOp)</a></li><li><a href=#spirvglfract-spirvglfractop><code>spirv.GL.Fract</code> (spirv::GLFractOp)</a></li><li><a href=#spirvglfrexpstruct-spirvglfrexpstructop><code>spirv.GL.FrexpStruct</code> (spirv::GLFrexpStructOp)</a></li><li><a href=#spirvglinversesqrt-spirvglinversesqrtop><code>spirv.GL.InverseSqrt</code> (spirv::GLInverseSqrtOp)</a></li><li><a href=#spirvglldexp-spirvglldexpop><code>spirv.GL.Ldexp</code> (spirv::GLLdexpOp)</a></li><li><a href=#spirvgllength-spirvgllengthop><code>spirv.GL.Length</code> (spirv::GLLengthOp)</a></li><li><a href=#spirvgllog2-spirvgllog2op><code>spirv.GL.Log2</code> (spirv::GLLog2Op)</a></li><li><a href=#spirvgllog-spirvgllogop><code>spirv.GL.Log</code> (spirv::GLLogOp)</a></li><li><a href=#spirvglnormalize-spirvglnormalizeop><code>spirv.GL.Normalize</code> (spirv::GLNormalizeOp)</a></li><li><a href=#spirvglpackhalf2x16-spirvglpackhalf2x16op><code>spirv.GL.PackHalf2x16</code> (spirv::GLPackHalf2x16Op)</a></li><li><a href=#spirvglpow-spirvglpowop><code>spirv.GL.Pow</code> (spirv::GLPowOp)</a></li><li><a href=#spirvglreflect-spirvglreflectop><code>spirv.GL.Reflect</code> (spirv::GLReflectOp)</a></li><li><a href=#spirvglroundeven-spirvglroundevenop><code>spirv.GL.RoundEven</code> (spirv::GLRoundEvenOp)</a></li><li><a href=#spirvglround-spirvglroundop><code>spirv.GL.Round</code> (spirv::GLRoundOp)</a></li><li><a href=#spirvglsabs-spirvglsabsop><code>spirv.GL.SAbs</code> (spirv::GLSAbsOp)</a></li><li><a href=#spirvglsclamp-spirvglsclampop><code>spirv.GL.SClamp</code> (spirv::GLSClampOp)</a></li><li><a href=#spirvglsmax-spirvglsmaxop><code>spirv.GL.SMax</code> (spirv::GLSMaxOp)</a></li><li><a href=#spirvglsmin-spirvglsminop><code>spirv.GL.SMin</code> (spirv::GLSMinOp)</a></li><li><a href=#spirvglssign-spirvglssignop><code>spirv.GL.SSign</code> (spirv::GLSSignOp)</a></li><li><a href=#spirvglsin-spirvglsinop><code>spirv.GL.Sin</code> (spirv::GLSinOp)</a></li><li><a href=#spirvglsinh-spirvglsinhop><code>spirv.GL.Sinh</code> (spirv::GLSinhOp)</a></li><li><a href=#spirvglsqrt-spirvglsqrtop><code>spirv.GL.Sqrt</code> (spirv::GLSqrtOp)</a></li><li><a href=#spirvgltan-spirvgltanop><code>spirv.GL.Tan</code> (spirv::GLTanOp)</a></li><li><a href=#spirvgltanh-spirvgltanhop><code>spirv.GL.Tanh</code> (spirv::GLTanhOp)</a></li><li><a href=#spirvgluclamp-spirvgluclampop><code>spirv.GL.UClamp</code> (spirv::GLUClampOp)</a></li><li><a href=#spirvglumax-spirvglumaxop><code>spirv.GL.UMax</code> (spirv::GLUMaxOp)</a></li><li><a href=#spirvglumin-spirvgluminop><code>spirv.GL.UMin</code> (spirv::GLUMinOp)</a></li><li><a href=#spirvglunpackhalf2x16-spirvglunpackhalf2x16op><code>spirv.GL.UnpackHalf2x16</code> (spirv::GLUnpackHalf2x16Op)</a></li><li><a href=#spirvgenericcasttoptrexplicit-spirvgenericcasttoptrexplicitop><code>spirv.GenericCastToPtrExplicit</code> (spirv::GenericCastToPtrExplicitOp)</a></li><li><a href=#spirvgenericcasttoptr-spirvgenericcasttoptrop><code>spirv.GenericCastToPtr</code> (spirv::GenericCastToPtrOp)</a></li><li><a href=#spirvglobalvariable-spirvglobalvariableop><code>spirv.GlobalVariable</code> (spirv::GlobalVariableOp)</a></li><li><a href=#spirvarmgraph-spirvgrapharmop><code>spirv.ARM.Graph</code> (spirv::GraphARMOp)</a></li><li><a href=#spirvarmgraphconstant-spirvgraphconstantarmop><code>spirv.ARM.GraphConstant</code> (spirv::GraphConstantARMOp)</a></li><li><a href=#spirvarmgraphentrypoint-spirvgraphentrypointarmop><code>spirv.ARM.GraphEntryPoint</code> (spirv::GraphEntryPointARMOp)</a></li><li><a href=#spirvarmgraphoutputs-spirvgraphoutputsarmop><code>spirv.ARM.GraphOutputs</code> (spirv::GraphOutputsARMOp)</a></li><li><a href=#spirvgroupbroadcast-spirvgroupbroadcastop><code>spirv.GroupBroadcast</code> (spirv::GroupBroadcastOp)</a></li><li><a href=#spirvgroupfadd-spirvgroupfaddop><code>spirv.GroupFAdd</code> (spirv::GroupFAddOp)</a></li><li><a href=#spirvgroupfmax-spirvgroupfmaxop><code>spirv.GroupFMax</code> (spirv::GroupFMaxOp)</a></li><li><a href=#spirvgroupfmin-spirvgroupfminop><code>spirv.GroupFMin</code> (spirv::GroupFMinOp)</a></li><li><a href=#spirvkhrgroupfmul-spirvgroupfmulkhrop><code>spirv.KHR.GroupFMul</code> (spirv::GroupFMulKHROp)</a></li><li><a href=#spirvgroupiadd-spirvgroupiaddop><code>spirv.GroupIAdd</code> (spirv::GroupIAddOp)</a></li><li><a href=#spirvkhrgroupimul-spirvgroupimulkhrop><code>spirv.KHR.GroupIMul</code> (spirv::GroupIMulKHROp)</a></li><li><a href=#spirvgroupnonuniformallequal-spirvgroupnonuniformallequalop><code>spirv.GroupNonUniformAllEqual</code> (spirv::GroupNonUniformAllEqualOp)</a></li><li><a href=#spirvgroupnonuniformall-spirvgroupnonuniformallop><code>spirv.GroupNonUniformAll</code> (spirv::GroupNonUniformAllOp)</a></li><li><a href=#spirvgroupnonuniformany-spirvgroupnonuniformanyop><code>spirv.GroupNonUniformAny</code> (spirv::GroupNonUniformAnyOp)</a></li><li><a href=#spirvgroupnonuniformballotbitcount-spirvgroupnonuniformballotbitcountop><code>spirv.GroupNonUniformBallotBitCount</code> (spirv::GroupNonUniformBallotBitCountOp)</a></li><li><a href=#spirvgroupnonuniformballotfindlsb-spirvgroupnonuniformballotfindlsbop><code>spirv.GroupNonUniformBallotFindLSB</code> (spirv::GroupNonUniformBallotFindLSBOp)</a></li><li><a href=#spirvgroupnonuniformballotfindmsb-spirvgroupnonuniformballotfindmsbop><code>spirv.GroupNonUniformBallotFindMSB</code> (spirv::GroupNonUniformBallotFindMSBOp)</a></li><li><a href=#spirvgroupnonuniformballot-spirvgroupnonuniformballotop><code>spirv.GroupNonUniformBallot</code> (spirv::GroupNonUniformBallotOp)</a></li><li><a href=#spirvgroupnonuniformbitwiseand-spirvgroupnonuniformbitwiseandop><code>spirv.GroupNonUniformBitwiseAnd</code> (spirv::GroupNonUniformBitwiseAndOp)</a></li><li><a href=#spirvgroupnonuniformbitwiseor-spirvgroupnonuniformbitwiseorop><code>spirv.GroupNonUniformBitwiseOr</code> (spirv::GroupNonUniformBitwiseOrOp)</a></li><li><a href=#spirvgroupnonuniformbitwisexor-spirvgroupnonuniformbitwisexorop><code>spirv.GroupNonUniformBitwiseXor</code> (spirv::GroupNonUniformBitwiseXorOp)</a></li><li><a href=#spirvgroupnonuniformbroadcast-spirvgroupnonuniformbroadcastop><code>spirv.GroupNonUniformBroadcast</code> (spirv::GroupNonUniformBroadcastOp)</a></li><li><a href=#spirvgroupnonuniformelect-spirvgroupnonuniformelectop><code>spirv.GroupNonUniformElect</code> (spirv::GroupNonUniformElectOp)</a></li><li><a href=#spirvgroupnonuniformfadd-spirvgroupnonuniformfaddop><code>spirv.GroupNonUniformFAdd</code> (spirv::GroupNonUniformFAddOp)</a></li><li><a href=#spirvgroupnonuniformfmax-spirvgroupnonuniformfmaxop><code>spirv.GroupNonUniformFMax</code> (spirv::GroupNonUniformFMaxOp)</a></li><li><a href=#spirvgroupnonuniformfmin-spirvgroupnonuniformfminop><code>spirv.GroupNonUniformFMin</code> (spirv::GroupNonUniformFMinOp)</a></li><li><a href=#spirvgroupnonuniformfmul-spirvgroupnonuniformfmulop><code>spirv.GroupNonUniformFMul</code> (spirv::GroupNonUniformFMulOp)</a></li><li><a href=#spirvgroupnonuniformiadd-spirvgroupnonuniformiaddop><code>spirv.GroupNonUniformIAdd</code> (spirv::GroupNonUniformIAddOp)</a></li><li><a href=#spirvgroupnonuniformimul-spirvgroupnonuniformimulop><code>spirv.GroupNonUniformIMul</code> (spirv::GroupNonUniformIMulOp)</a></li><li><a href=#spirvgroupnonuniformlogicaland-spirvgroupnonuniformlogicalandop><code>spirv.GroupNonUniformLogicalAnd</code> (spirv::GroupNonUniformLogicalAndOp)</a></li><li><a href=#spirvgroupnonuniformlogicalor-spirvgroupnonuniformlogicalorop><code>spirv.GroupNonUniformLogicalOr</code> (spirv::GroupNonUniformLogicalOrOp)</a></li><li><a href=#spirvgroupnonuniformlogicalxor-spirvgroupnonuniformlogicalxorop><code>spirv.GroupNonUniformLogicalXor</code> (spirv::GroupNonUniformLogicalXorOp)</a></li><li><a href=#spirvgroupnonuniformrotatekhr-spirvgroupnonuniformrotatekhrop><code>spirv.GroupNonUniformRotateKHR</code> (spirv::GroupNonUniformRotateKHROp)</a></li><li><a href=#spirvgroupnonuniformsmax-spirvgroupnonuniformsmaxop><code>spirv.GroupNonUniformSMax</code> (spirv::GroupNonUniformSMaxOp)</a></li><li><a href=#spirvgroupnonuniformsmin-spirvgroupnonuniformsminop><code>spirv.GroupNonUniformSMin</code> (spirv::GroupNonUniformSMinOp)</a></li><li><a href=#spirvgroupnonuniformshuffledown-spirvgroupnonuniformshuffledownop><code>spirv.GroupNonUniformShuffleDown</code> (spirv::GroupNonUniformShuffleDownOp)</a></li><li><a href=#spirvgroupnonuniformshuffle-spirvgroupnonuniformshuffleop><code>spirv.GroupNonUniformShuffle</code> (spirv::GroupNonUniformShuffleOp)</a></li><li><a href=#spirvgroupnonuniformshuffleup-spirvgroupnonuniformshuffleupop><code>spirv.GroupNonUniformShuffleUp</code> (spirv::GroupNonUniformShuffleUpOp)</a></li><li><a href=#spirvgroupnonuniformshufflexor-spirvgroupnonuniformshufflexorop><code>spirv.GroupNonUniformShuffleXor</code> (spirv::GroupNonUniformShuffleXorOp)</a></li><li><a href=#spirvgroupnonuniformumax-spirvgroupnonuniformumaxop><code>spirv.GroupNonUniformUMax</code> (spirv::GroupNonUniformUMaxOp)</a></li><li><a href=#spirvgroupnonuniformumin-spirvgroupnonuniformuminop><code>spirv.GroupNonUniformUMin</code> (spirv::GroupNonUniformUMinOp)</a></li><li><a href=#spirvgroupsmax-spirvgroupsmaxop><code>spirv.GroupSMax</code> (spirv::GroupSMaxOp)</a></li><li><a href=#spirvgroupsmin-spirvgroupsminop><code>spirv.GroupSMin</code> (spirv::GroupSMinOp)</a></li><li><a href=#spirvgroupumax-spirvgroupumaxop><code>spirv.GroupUMax</code> (spirv::GroupUMaxOp)</a></li><li><a href=#spirvgroupumin-spirvgroupuminop><code>spirv.GroupUMin</code> (spirv::GroupUMinOp)</a></li><li><a href=#spirviaddcarry-spirviaddcarryop><code>spirv.IAddCarry</code> (spirv::IAddCarryOp)</a></li><li><a href=#spirviadd-spirviaddop><code>spirv.IAdd</code> (spirv::IAddOp)</a></li><li><a href=#spirviequal-spirviequalop><code>spirv.IEqual</code> (spirv::IEqualOp)</a></li><li><a href=#spirvimul-spirvimulop><code>spirv.IMul</code> (spirv::IMulOp)</a></li><li><a href=#spirvintelcontrolbarrierarrive-spirvintelcontrolbarrierarriveop><code>spirv.INTEL.ControlBarrierArrive</code> (spirv::INTELControlBarrierArriveOp)</a></li><li><a href=#spirvintelcontrolbarrierwait-spirvintelcontrolbarrierwaitop><code>spirv.INTEL.ControlBarrierWait</code> (spirv::INTELControlBarrierWaitOp)</a></li><li><a href=#spirvintelconvertbf16tof-spirvintelconvertbf16tofop><code>spirv.INTEL.ConvertBF16ToF</code> (spirv::INTELConvertBF16ToFOp)</a></li><li><a href=#spirvintelconvertftobf16-spirvintelconvertftobf16op><code>spirv.INTEL.ConvertFToBF16</code> (spirv::INTELConvertFToBF16Op)</a></li><li><a href=#spirvintelroundftotf32-spirvintelroundftotf32op><code>spirv.INTEL.RoundFToTF32</code> (spirv::INTELRoundFToTF32Op)</a></li><li><a href=#spirvintelsubgroupblockread-spirvintelsubgroupblockreadop><code>spirv.INTEL.SubgroupBlockRead</code> (spirv::INTELSubgroupBlockReadOp)</a></li><li><a href=#spirvintelsubgroupblockwrite-spirvintelsubgroupblockwriteop><code>spirv.INTEL.SubgroupBlockWrite</code> (spirv::INTELSubgroupBlockWriteOp)</a></li><li><a href=#spirvinotequal-spirvinotequalop><code>spirv.INotEqual</code> (spirv::INotEqualOp)</a></li><li><a href=#spirvisubborrow-spirvisubborrowop><code>spirv.ISubBorrow</code> (spirv::ISubBorrowOp)</a></li><li><a href=#spirvisub-spirvisubop><code>spirv.ISub</code> (spirv::ISubOp)</a></li><li><a href=#spirvimagedrefgather-spirvimagedrefgatherop><code>spirv.ImageDrefGather</code> (spirv::ImageDrefGatherOp)</a></li><li><a href=#spirvimagefetch-spirvimagefetchop><code>spirv.ImageFetch</code> (spirv::ImageFetchOp)</a></li><li><a href=#spirvimage-spirvimageop><code>spirv.Image</code> (spirv::ImageOp)</a></li><li><a href=#spirvimagequerysize-spirvimagequerysizeop><code>spirv.ImageQuerySize</code> (spirv::ImageQuerySizeOp)</a></li><li><a href=#spirvimageread-spirvimagereadop><code>spirv.ImageRead</code> (spirv::ImageReadOp)</a></li><li><a href=#spirvimagesampleexplicitlod-spirvimagesampleexplicitlodop><code>spirv.ImageSampleExplicitLod</code> (spirv::ImageSampleExplicitLodOp)</a></li><li><a href=#spirvimagesampleimplicitlod-spirvimagesampleimplicitlodop><code>spirv.ImageSampleImplicitLod</code> (spirv::ImageSampleImplicitLodOp)</a></li><li><a href=#spirvimagesampleprojdrefimplicitlod-spirvimagesampleprojdrefimplicitlodop><code>spirv.ImageSampleProjDrefImplicitLod</code> (spirv::ImageSampleProjDrefImplicitLodOp)</a></li><li><a href=#spirvimagewrite-spirvimagewriteop><code>spirv.ImageWrite</code> (spirv::ImageWriteOp)</a></li><li><a href=#spirvinboundsptraccesschain-spirvinboundsptraccesschainop><code>spirv.InBoundsPtrAccessChain</code> (spirv::InBoundsPtrAccessChainOp)</a></li><li><a href=#spirvisfinite-spirvisfiniteop><code>spirv.IsFinite</code> (spirv::IsFiniteOp)</a></li><li><a href=#spirvisinf-spirvisinfop><code>spirv.IsInf</code> (spirv::IsInfOp)</a></li><li><a href=#spirvisnan-spirvisnanop><code>spirv.IsNan</code> (spirv::IsNanOp)</a></li><li><a href=#spirvkhrassumetrue-spirvkhrassumetrueop><code>spirv.KHR.AssumeTrue</code> (spirv::KHRAssumeTrueOp)</a></li><li><a href=#spirvkhrcooperativematrixlength-spirvkhrcooperativematrixlengthop><code>spirv.KHR.CooperativeMatrixLength</code> (spirv::KHRCooperativeMatrixLengthOp)</a></li><li><a href=#spirvkhrcooperativematrixload-spirvkhrcooperativematrixloadop><code>spirv.KHR.CooperativeMatrixLoad</code> (spirv::KHRCooperativeMatrixLoadOp)</a></li><li><a href=#spirvkhrcooperativematrixmuladd-spirvkhrcooperativematrixmuladdop><code>spirv.KHR.CooperativeMatrixMulAdd</code> (spirv::KHRCooperativeMatrixMulAddOp)</a></li><li><a href=#spirvkhrcooperativematrixstore-spirvkhrcooperativematrixstoreop><code>spirv.KHR.CooperativeMatrixStore</code> (spirv::KHRCooperativeMatrixStoreOp)</a></li><li><a href=#spirvkhrsubgroupballot-spirvkhrsubgroupballotop><code>spirv.KHR.SubgroupBallot</code> (spirv::KHRSubgroupBallotOp)</a></li><li><a href=#spirvkill-spirvkillop><code>spirv.Kill</code> (spirv::KillOp)</a></li><li><a href=#spirvload-spirvloadop><code>spirv.Load</code> (spirv::LoadOp)</a></li><li><a href=#spirvlogicaland-spirvlogicalandop><code>spirv.LogicalAnd</code> (spirv::LogicalAndOp)</a></li><li><a href=#spirvlogicalequal-spirvlogicalequalop><code>spirv.LogicalEqual</code> (spirv::LogicalEqualOp)</a></li><li><a href=#spirvlogicalnotequal-spirvlogicalnotequalop><code>spirv.LogicalNotEqual</code> (spirv::LogicalNotEqualOp)</a></li><li><a href=#spirvlogicalnot-spirvlogicalnotop><code>spirv.LogicalNot</code> (spirv::LogicalNotOp)</a></li><li><a href=#spirvlogicalor-spirvlogicalorop><code>spirv.LogicalOr</code> (spirv::LogicalOrOp)</a></li><li><a href=#spirvmlirloop-spirvloopop><code>spirv.mlir.loop</code> (spirv::LoopOp)</a></li><li><a href=#spirvmatrixtimesmatrix-spirvmatrixtimesmatrixop><code>spirv.MatrixTimesMatrix</code> (spirv::MatrixTimesMatrixOp)</a></li><li><a href=#spirvmatrixtimesscalar-spirvmatrixtimesscalarop><code>spirv.MatrixTimesScalar</code> (spirv::MatrixTimesScalarOp)</a></li><li><a href=#spirvmatrixtimesvector-spirvmatrixtimesvectorop><code>spirv.MatrixTimesVector</code> (spirv::MatrixTimesVectorOp)</a></li><li><a href=#spirvmemorybarrier-spirvmemorybarrierop><code>spirv.MemoryBarrier</code> (spirv::MemoryBarrierOp)</a></li><li><a href=#spirvmlirmerge-spirvmergeop><code>spirv.mlir.merge</code> (spirv::MergeOp)</a></li><li><a href=#spirvmodule-spirvmoduleop><code>spirv.module</code> (spirv::ModuleOp)</a></li><li><a href=#spirvnot-spirvnotop><code>spirv.Not</code> (spirv::NotOp)</a></li><li><a href=#spirvordered-spirvorderedop><code>spirv.Ordered</code> (spirv::OrderedOp)</a></li><li><a href=#spirvptraccesschain-spirvptraccesschainop><code>spirv.PtrAccessChain</code> (spirv::PtrAccessChainOp)</a></li><li><a href=#spirvptrcasttogeneric-spirvptrcasttogenericop><code>spirv.PtrCastToGeneric</code> (spirv::PtrCastToGenericOp)</a></li><li><a href=#spirvmlirreferenceof-spirvreferenceofop><code>spirv.mlir.referenceof</code> (spirv::ReferenceOfOp)</a></li><li><a href=#spirvreturn-spirvreturnop><code>spirv.Return</code> (spirv::ReturnOp)</a></li><li><a href=#spirvreturnvalue-spirvreturnvalueop><code>spirv.ReturnValue</code> (spirv::ReturnValueOp)</a></li><li><a href=#spirvsconvert-spirvsconvertop><code>spirv.SConvert</code> (spirv::SConvertOp)</a></li><li><a href=#spirvsdiv-spirvsdivop><code>spirv.SDiv</code> (spirv::SDivOp)</a></li><li><a href=#spirvsdotaccsat-spirvsdotaccsatop><code>spirv.SDotAccSat</code> (spirv::SDotAccSatOp)</a></li><li><a href=#spirvsdot-spirvsdotop><code>spirv.SDot</code> (spirv::SDotOp)</a></li><li><a href=#spirvsgreaterthanequal-spirvsgreaterthanequalop><code>spirv.SGreaterThanEqual</code> (spirv::SGreaterThanEqualOp)</a></li><li><a href=#spirvsgreaterthan-spirvsgreaterthanop><code>spirv.SGreaterThan</code> (spirv::SGreaterThanOp)</a></li><li><a href=#spirvslessthanequal-spirvslessthanequalop><code>spirv.SLessThanEqual</code> (spirv::SLessThanEqualOp)</a></li><li><a href=#spirvslessthan-spirvslessthanop><code>spirv.SLessThan</code> (spirv::SLessThanOp)</a></li><li><a href=#spirvsmod-spirvsmodop><code>spirv.SMod</code> (spirv::SModOp)</a></li><li><a href=#spirvsmulextended-spirvsmulextendedop><code>spirv.SMulExtended</code> (spirv::SMulExtendedOp)</a></li><li><a href=#spirvsnegate-spirvsnegateop><code>spirv.SNegate</code> (spirv::SNegateOp)</a></li><li><a href=#spirvsrem-spirvsremop><code>spirv.SRem</code> (spirv::SRemOp)</a></li><li><a href=#spirvsudotaccsat-spirvsudotaccsatop><code>spirv.SUDotAccSat</code> (spirv::SUDotAccSatOp)</a></li><li><a href=#spirvsudot-spirvsudotop><code>spirv.SUDot</code> (spirv::SUDotOp)</a></li><li><a href=#spirvselect-spirvselectop><code>spirv.Select</code> (spirv::SelectOp)</a></li><li><a href=#spirvmlirselection-spirvselectionop><code>spirv.mlir.selection</code> (spirv::SelectionOp)</a></li><li><a href=#spirvshiftleftlogical-spirvshiftleftlogicalop><code>spirv.ShiftLeftLogical</code> (spirv::ShiftLeftLogicalOp)</a></li><li><a href=#spirvshiftrightarithmetic-spirvshiftrightarithmeticop><code>spirv.ShiftRightArithmetic</code> (spirv::ShiftRightArithmeticOp)</a></li><li><a href=#spirvshiftrightlogical-spirvshiftrightlogicalop><code>spirv.ShiftRightLogical</code> (spirv::ShiftRightLogicalOp)</a></li><li><a href=#spirvspecconstantcomposite-spirvspecconstantcompositeop><code>spirv.SpecConstantComposite</code> (spirv::SpecConstantCompositeOp)</a></li><li><a href=#spirvspecconstant-spirvspecconstantop><code>spirv.SpecConstant</code> (spirv::SpecConstantOp)</a></li><li><a href=#spirvspecconstantoperation-spirvspecconstantoperationop><code>spirv.SpecConstantOperation</code> (spirv::SpecConstantOperationOp)</a></li><li><a href=#spirvstore-spirvstoreop><code>spirv.Store</code> (spirv::StoreOp)</a></li><li><a href=#spirvtranspose-spirvtransposeop><code>spirv.Transpose</code> (spirv::TransposeOp)</a></li><li><a href=#spirvuconvert-spirvuconvertop><code>spirv.UConvert</code> (spirv::UConvertOp)</a></li><li><a href=#spirvudiv-spirvudivop><code>spirv.UDiv</code> (spirv::UDivOp)</a></li><li><a href=#spirvudotaccsat-spirvudotaccsatop><code>spirv.UDotAccSat</code> (spirv::UDotAccSatOp)</a></li><li><a href=#spirvudot-spirvudotop><code>spirv.UDot</code> (spirv::UDotOp)</a></li><li><a href=#spirvugreaterthanequal-spirvugreaterthanequalop><code>spirv.UGreaterThanEqual</code> (spirv::UGreaterThanEqualOp)</a></li><li><a href=#spirvugreaterthan-spirvugreaterthanop><code>spirv.UGreaterThan</code> (spirv::UGreaterThanOp)</a></li><li><a href=#spirvulessthanequal-spirvulessthanequalop><code>spirv.ULessThanEqual</code> (spirv::ULessThanEqualOp)</a></li><li><a href=#spirvulessthan-spirvulessthanop><code>spirv.ULessThan</code> (spirv::ULessThanOp)</a></li><li><a href=#spirvumod-spirvumodop><code>spirv.UMod</code> (spirv::UModOp)</a></li><li><a href=#spirvumulextended-spirvumulextendedop><code>spirv.UMulExtended</code> (spirv::UMulExtendedOp)</a></li><li><a href=#spirvundef-spirvundefop><code>spirv.Undef</code> (spirv::UndefOp)</a></li><li><a href=#spirvunordered-spirvunorderedop><code>spirv.Unordered</code> (spirv::UnorderedOp)</a></li><li><a href=#spirvunreachable-spirvunreachableop><code>spirv.Unreachable</code> (spirv::UnreachableOp)</a></li><li><a href=#spirvvariable-spirvvariableop><code>spirv.Variable</code> (spirv::VariableOp)</a></li><li><a href=#spirvvectorextractdynamic-spirvvectorextractdynamicop><code>spirv.VectorExtractDynamic</code> (spirv::VectorExtractDynamicOp)</a></li><li><a href=#spirvvectorinsertdynamic-spirvvectorinsertdynamicop><code>spirv.VectorInsertDynamic</code> (spirv::VectorInsertDynamicOp)</a></li><li><a href=#spirvvectorshuffle-spirvvectorshuffleop><code>spirv.VectorShuffle</code> (spirv::VectorShuffleOp)</a></li><li><a href=#spirvvectortimesmatrix-spirvvectortimesmatrixop><code>spirv.VectorTimesMatrix</code> (spirv::VectorTimesMatrixOp)</a></li><li><a href=#spirvvectortimesscalar-spirvvectortimesscalarop><code>spirv.VectorTimesScalar</code> (spirv::VectorTimesScalarOp)</a></li><li><a href=#spirvmliryield-spirvyieldop><code>spirv.mlir.yield</code> (spirv::YieldOp)</a></li></ul></li></ul></nav><h2 id=design-guidelines>Design Guidelines&nbsp;<a class=headline-hash href=#design-guidelines>¶</a></h2><p>SPIR-V is a binary intermediate language that serves dual purpose: on one side,
it is an intermediate language to represent graphics shaders and compute kernels
for high-level languages to target; on the other side, it defines a stable
binary format for hardware driver consumption. As a result, SPIR-V has design
principles pertain to not only intermediate language, but also binary format.
For example, regularity is one of the design goals of SPIR-V. All concepts are
represented as SPIR-V instructions, including declaring extensions and
capabilities, defining types and constants, defining functions, attaching
additional properties to computation results, etc. This way favors binary
encoding and decoding for driver consumption but not necessarily compiler
transformations.</p><h3 id=dialect-design-principles>Dialect design principles&nbsp;<a class=headline-hash href=#dialect-design-principles>¶</a></h3><p>The main objective of the SPIR-V dialect is to be a proper intermediate
representation (IR) to facilitate compiler transformations. While we still aim
to support serializing to and deserializing from the binary format for various
good reasons, the binary format and its concerns play less a role in the design
of the SPIR-V dialect: when there is a trade-off to be made between favoring IR
and supporting binary format, we lean towards the former.</p><p>On the IR aspect, the SPIR-V dialect aims to model SPIR-V at the same semantic
level. It is not intended to be a higher level or lower level abstraction than
the SPIR-V specification. Those abstractions are easily outside the domain of
SPIR-V and should be modeled with other proper dialects so they can be shared
among various compilation paths. Because of the dual purpose of SPIR-V, SPIR-V
dialect staying at the same semantic level as the SPIR-V specification also
means we can still have straightforward serialization and deserialization for
the majority of functionalities.</p><p>To summarize, the SPIR-V dialect follows the following design principles:</p><ul><li>Stay as the same semantic level as the SPIR-V specification by having
one-to-one mapping for most concepts and entities.</li><li>Adopt SPIR-V specification&rsquo;s syntax if possible, but deviate intentionally
to utilize MLIR mechanisms if it results in better representation and
benefits transformation.</li><li>Be straightforward to serialize into and deserialize from the SPIR-V binary
format.</li></ul><p>SPIR-V is designed to be consumed by hardware drivers, so its representation is
quite clear, yet verbose for some cases. Allowing representational deviation
gives us the flexibility to reduce the verbosity by using MLIR mechanisms.</p><h3 id=dialect-scopes>Dialect scopes&nbsp;<a class=headline-hash href=#dialect-scopes>¶</a></h3><p>SPIR-V supports multiple execution environments, specified by client APIs.
Notable adopters include Vulkan and OpenCL. It follows that the SPIR-V dialect
should support multiple execution environments if to be a proper proxy of SPIR-V
in MLIR systems. The SPIR-V dialect is designed with these considerations: it
has proper support for versions, extensions, and capabilities and is as
extensible as SPIR-V specification.</p><h2 id=conventions>Conventions&nbsp;<a class=headline-hash href=#conventions>¶</a></h2><p>The SPIR-V dialect adopts the following conventions for IR:</p><ul><li>The prefix for all SPIR-V types and operations are <code>spirv.</code>.</li><li>All instructions in an extended instruction set are further qualified with
the extended instruction set&rsquo;s prefix. For example, all operations in the
GLSL extended instruction set have the prefix of <code>spirv.GL.</code>.</li><li>Ops that directly mirror instructions in the specification have <code>CamelCase</code>
names that are the same as the instruction opnames (without the <code>Op</code>
prefix). For example, <code>spirv.FMul</code> is a direct mirror of <code>OpFMul</code> in the
specification. Such an op will be serialized into and deserialized from one
SPIR-V instruction.</li><li>Ops with <code>snake_case</code> names are those that have different representation
from corresponding instructions (or concepts) in the specification. These
ops are mostly for defining the SPIR-V structure. For example, <code>spirv.module</code>
and <code>spirv.Constant</code>. They may correspond to one or more instructions during
(de)serialization.</li><li>Ops with <code>mlir.snake_case</code> names are those that have no corresponding
instructions (or concepts) in the binary format. They are introduced to
satisfy MLIR structural requirements. For example, <code>spirv.mlir.merge</code>. They
map to no instructions during (de)serialization.</li></ul><p>(TODO: consider merging the last two cases and adopting <code>spirv.mlir.</code> prefix for
them.)</p><h2 id=module>Module&nbsp;<a class=headline-hash href=#module>¶</a></h2><p>A SPIR-V module is defined via the <code>spirv.module</code> op, which has one region that
contains one block. Model-level instructions, including function definitions,
are all placed inside the block. Functions are defined using the builtin <code>func</code>
op.</p><p>We choose to model a SPIR-V module with a dedicated <code>spirv.module</code> op based on the
following considerations:</p><ul><li>It maps cleanly to a SPIR-V module in the specification.</li><li>We can enforce SPIR-V specific verification that is suitable to be performed
at the module-level.</li><li>We can attach additional model-level attributes.</li><li>We can control custom assembly form.</li></ul><p>The <code>spirv.module</code> op&rsquo;s region cannot capture SSA values from outside, neither
implicitly nor explicitly. The <code>spirv.module</code> op&rsquo;s region is closed as to what ops
can appear inside: apart from the builtin <code>func</code> op, it can only contain ops
from the SPIR-V dialect. The <code>spirv.module</code> op&rsquo;s verifier enforces this rule. This
meaningfully guarantees that a <code>spirv.module</code> can be the entry point and boundary
for serialization.</p><h3 id=module-level-operations>Module-level operations&nbsp;<a class=headline-hash href=#module-level-operations>¶</a></h3><p>SPIR-V binary format defines the following
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_logicallayout_a_logical_layout_of_a_module>sections</a>:</p><ol><li>Capabilities required by the module.</li><li>Extensions required by the module.</li><li>Extended instructions sets required by the module.</li><li>Addressing and memory model specification.</li><li>Entry point specifications.</li><li>Execution mode declarations.</li><li>Debug instructions.</li><li>Annotation/decoration instructions.</li><li>Type, constant, global variables.</li><li>Function declarations.</li><li>Function definitions.</li></ol><p>Basically, a SPIR-V binary module contains multiple module-level instructions
followed by a list of functions. Those module-level instructions are essential
and they can generate result ids referenced by functions, notably, declaring
resource variables to interact with the execution environment.</p><p>Compared to the binary format, we adjust how these module-level SPIR-V
instructions are represented in the SPIR-V dialect:</p><h4 id=use-mlir-attributes-for-metadata>Use MLIR attributes for metadata&nbsp;<a class=headline-hash href=#use-mlir-attributes-for-metadata>¶</a></h4><ul><li>Requirements for capabilities, extensions, extended instruction sets,
addressing model, and memory model are conveyed using <code>spirv.module</code>
attributes. This is considered better because these information are for the
execution environment. It&rsquo;s easier to probe them if on the module op itself.</li><li>Annotations/decoration instructions are &ldquo;folded&rdquo; into the instructions they
decorate and represented as attributes on those ops. This eliminates
potential forward references of SSA values, improves IR readability, and
makes querying the annotations more direct. More discussions can be found in
the
<a href=#decorations><code>Decorations</code></a> section.</li></ul><h4 id=model-types-with-mlir-custom-types>Model types with MLIR custom types&nbsp;<a class=headline-hash href=#model-types-with-mlir-custom-types>¶</a></h4><ul><li>Types are represented using MLIR builtin types and SPIR-V dialect specific
types. There are no type declaration ops in the SPIR-V dialect. More
discussions can be found in the
<a href=#types>Types</a> section later.</li></ul><h4 id=unify-and-localize-constants>Unify and localize constants&nbsp;<a class=headline-hash href=#unify-and-localize-constants>¶</a></h4><ul><li>Various normal constant instructions are represented by the same
<code>spirv.Constant</code> op. Those instructions are just for constants of different
types; using one op to represent them reduces IR verbosity and makes
transformations less tedious.</li><li>Normal constants are not placed in <code>spirv.module</code>&rsquo;s region; they are localized
into functions. This is to make functions in the SPIR-V dialect to be
isolated and explicit capturing. Constants are cheap to duplicate given
attributes are made unique in <code>MLIRContext</code>.</li></ul><h4 id=adopt-symbol-based-global-variables-and-specialization-constant>Adopt symbol-based global variables and specialization constant&nbsp;<a class=headline-hash href=#adopt-symbol-based-global-variables-and-specialization-constant>¶</a></h4><ul><li>Global variables are defined with the <code>spirv.GlobalVariable</code> op. They do not
generate SSA values. Instead they have symbols and should be referenced via
symbols. To use global variables in a function block, <code>spirv.mlir.addressof</code> is
needed to turn the symbol into an SSA value.</li><li>Specialization constants are defined with the <code>spirv.SpecConstant</code> op. Similar
to global variables, they do not generate SSA values and have symbols for
reference, too. <code>spirv.mlir.referenceof</code> is needed to turn the symbol into an SSA
value for use in a function block.</li></ul><p>The above choices enables functions in the SPIR-V dialect to be isolated and
explicit capturing.</p><h4 id=disallow-implicit-capturing-in-functions>Disallow implicit capturing in functions&nbsp;<a class=headline-hash href=#disallow-implicit-capturing-in-functions>¶</a></h4><ul><li>In SPIR-V specification, functions support implicit capturing: they can
reference SSA values defined in modules. In the SPIR-V dialect functions are
defined with <code>func</code> op, which disallows implicit capturing. This is more
friendly to compiler analyses and transformations. More discussions can be
found in the
<a href=#function>Function</a> section later.</li></ul><h4 id=model-entry-points-and-execution-models-as-normal-ops>Model entry points and execution models as normal ops&nbsp;<a class=headline-hash href=#model-entry-points-and-execution-models-as-normal-ops>¶</a></h4><ul><li>A SPIR-V module can have multiple entry points. And these entry points refer
to the function and interface variables. It’s not suitable to model them as
<code>spirv.module</code> op attributes. We can model them as normal ops of using symbol
references.</li><li>Similarly for execution modes, which are coupled with entry points, we can
model them as normal ops in <code>spirv.module</code>&rsquo;s region.</li></ul><h2 id=decorations>Decorations&nbsp;<a class=headline-hash href=#decorations>¶</a></h2><p>Annotations/decorations provide additional information on result ids. In SPIR-V,
all instructions can generate result ids, including value-computing and
type-defining ones.</p><p>For decorations on value result ids, we can just have a corresponding attribute
attached to the operation generating the SSA value. For example, for the
following SPIR-V:</p><pre tabindex=0><code class=language-spirv data-lang=spirv>OpDecorate %v1 RelaxedPrecision
OpDecorate %v2 NoContraction
...
%v1 = OpFMul %float %0 %0
%v2 = OpFMul %float %1 %1
</code></pre><p>We can represent them in the SPIR-V dialect as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%v1</span> <span class=p>=</span> <span class=s>&#34;spirv.FMul&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>{</span>RelaxedPrecision<span class=p>:</span> unit<span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>%v2</span> <span class=p>=</span> <span class=s>&#34;spirv.FMul&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>{</span>NoContraction<span class=p>:</span> unit<span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><p>This approach benefits transformations. Essentially those decorations are just
additional properties of the result ids (and thus their defining instructions).
In SPIR-V binary format, they are just represented as instructions. Literally
following SPIR-V binary format means we need to through def-use chains to find
the decoration instructions and query information from them.</p><p>For decorations on type result ids, notice that practically, only result ids
generated from composite types (e.g., <code>OpTypeArray</code>, <code>OpTypeStruct</code>) need to be
decorated for memory layouting purpose (e.g., <code>ArrayStride</code>, <code>Offset</code>, etc.);
scalar/vector types are required to be uniqued in SPIR-V. Therefore, we can just
encode them directly in the dialect-specific type.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><p>Theoretically we can define all SPIR-V types using MLIR extensible type system,
but other than representational purity, it does not buy us more. Instead, we
need to maintain the code and invest in pretty printing them. So we prefer to
use builtin types if possible.</p><p>The SPIR-V dialect reuses builtin integer, float, and vector types:</p><table><thead><tr><th style=text-align:center>Specification</th><th style=text-align:center>Dialect</th></tr></thead><tbody><tr><td style=text-align:center><code>OpTypeBool</code></td><td style=text-align:center><code>i1</code></td></tr><tr><td style=text-align:center><code>OpTypeFloat &lt;bitwidth></code></td><td style=text-align:center><code>f&lt;bitwidth></code></td></tr><tr><td style=text-align:center><code>OpTypeVector &lt;scalar-type> &lt;count></code></td><td style=text-align:center><code>vector&lt;&lt;count> x &lt;scalar-type>></code></td></tr></tbody></table><p>For integer types, the SPIR-V dialect supports all signedness semantics
(signless, signed, unsigned) in order to ease transformations from higher level
dialects. However, SPIR-V spec only defines two signedness semantics state: 0
indicates unsigned, or no signedness semantics, 1 indicates signed semantics. So
both <code>iN</code> and <code>uiN</code> are serialized into the same <code>OpTypeInt N 0</code>. For
deserialization, we always treat <code>OpTypeInt N 0</code> as <code>iN</code>.</p><p><code>mlir::NoneType</code> is used for SPIR-V <code>OpTypeVoid</code>; builtin function types are
used for SPIR-V <code>OpTypeFunction</code> types.</p><p>The SPIR-V dialect and defines the following dialect-specific types:</p><pre tabindex=0><code>spirv-type ::= array-type
             | image-type
             | pointer-type
             | runtime-array-type
             | sampled-image-type
             | struct-type
</code></pre><h3 id=array-type>Array type&nbsp;<a class=headline-hash href=#array-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeArray>array type</a>. Its syntax is</p><pre tabindex=0><code>element-type ::= integer-type
               | floating-point-type
               | vector-type
               | spirv-type

array-type ::= `!spirv.array` `&lt;` integer-literal `x` element-type
               (`,` `stride` `=` integer-literal)? `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4 x</span> <span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4 x</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>stride =</span> <span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>16 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h3 id=image-type>Image type&nbsp;<a class=headline-hash href=#image-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeImage>image type</a>. Its syntax is</p><pre tabindex=0><code>dim ::= `1D` | `2D` | `3D` | `Cube` | &lt;and other SPIR-V Dim specifiers...&gt;

depth-info ::= `NoDepth` | `IsDepth` | `DepthUnknown`

arrayed-info ::= `NonArrayed` | `Arrayed`

sampling-info ::= `SingleSampled` | `MultiSampled`

sampler-use-info ::= `SamplerUnknown` | `NeedSampler` | `NoSampler`

format ::= `Unknown` | `Rgba32f` | &lt;and other SPIR-V Image Formats...&gt;

image-type ::= `!spirv.image&lt;` element-type `,` dim `,` depth-info `,`
                           arrayed-info `,` sampling-info `,`
                           sampler-use-info `,` format `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span>D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> SamplerUnknown<span class=p>,</span> Unknown<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Cube<span class=p>,</span> IsDepth<span class=p>,</span> Arrayed<span class=p>,</span> MultiSampled<span class=p>,</span> NeedSampler<span class=p>,</span> Rgba32f<span class=p>&gt;</span>
</span></span></code></pre></div><h3 id=pointer-type>Pointer type&nbsp;<a class=headline-hash href=#pointer-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypePointer>pointer type</a>. Its syntax is</p><pre tabindex=0><code>storage-class ::= `UniformConstant`
                | `Uniform`
                | `Workgroup`
                | &lt;and other storage classes...&gt;

pointer-type ::= `!spirv.ptr&lt;` element-type `,` storage-class `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;,</span> Uniform<span class=p>&gt;</span>
</span></span></code></pre></div><h3 id=runtime-array-type>Runtime array type&nbsp;<a class=headline-hash href=#runtime-array-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeRuntimeArray>runtime array type</a>. Its syntax is</p><pre tabindex=0><code>runtime-array-type ::= `!spirv.rtarray` `&lt;` element-type (`,` `stride` `=` integer-literal)? `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>rtarray<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>rtarray<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=nl>stride=</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>rtarray<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4 x</span> <span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h3 id=sampled-image-type>Sampled image type&nbsp;<a class=headline-hash href=#sampled-image-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeSampledImage>sampled image type</a>. Its syntax is</p><pre tabindex=0><code>sampled-image-type ::= `!spirv.sampled_image&lt;!spirv.image&lt;` element-type `,` dim `,` depth-info `,`
                                                        arrayed-info `,` sampling-info `,`
                                                        sampler-use-info `,` format `&gt;&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim1D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Rect<span class=p>,</span> DepthUnknown<span class=p>,</span> Arrayed<span class=p>,</span> MultiSampled<span class=p>,</span> NeedSampler<span class=p>,</span> R8ui<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h3 id=struct-type>Struct type&nbsp;<a class=headline-hash href=#struct-type>¶</a></h3><p>This corresponds to SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#Structure>struct type</a>. Its syntax is</p><pre tabindex=0><code>struct-member-decoration ::= integer-literal? spirv-decoration*
struct-type ::= `!spirv.struct&lt;` spirv-type (`[` struct-member-decoration `]`)?
                     (`, ` spirv-type (`[` struct-member-decoration `]`)? `&gt;`
</code></pre><p>For Example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span> <span class=p>[</span><span class=m>0</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span>D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> SamplerUnknown<span class=p>,</span> Unknown<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span> <span class=p>[</span><span class=m>0</span><span class=p>],</span> <span class=k>i32</span> <span class=p>[</span><span class=m>4</span><span class=p>]&gt;</span>
</span></span></code></pre></div><h2 id=function>Function&nbsp;<a class=headline-hash href=#function>¶</a></h2><p>In SPIR-V, a function construct consists of multiple instructions involving
<code>OpFunction</code>, <code>OpFunctionParameter</code>, <code>OpLabel</code>, <code>OpFunctionEnd</code>.</p><pre tabindex=0><code class=language-spirv data-lang=spirv>// int f(int v) { return v; }
%1 = OpTypeInt 32 0
%2 = OpTypeFunction %1 %1
%3 = OpFunction %1 %2
%4 = OpFunctionParameter %1
%5 = OpLabel
%6 = OpReturnValue %4
     OpFunctionEnd
</code></pre><p>This construct is very clear yet quite verbose. It is intended for driver
consumption. There is little benefit to literally replicate this construct in
the SPIR-V dialect. Instead, we reuse the builtin <code>func</code> op to express functions
more concisely:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@f</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;spirv.ReturnValue&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>A SPIR-V function can have at most one result. It cannot contain nested
functions or non-SPIR-V operations. <code>spirv.module</code> verifies these requirements.</p><p>A major difference between the SPIR-V dialect and the SPIR-V specification for
functions is that the former are isolated and require explicit capturing, while
the latter allows implicit capturing. In SPIR-V specification, functions can
refer to SSA values (generated by constants, global variables, etc.) defined in
modules. The SPIR-V dialect adjusted how constants and global variables are
modeled to enable isolated functions. Isolated functions are more friendly to
compiler analyses and transformations. This also enables the SPIR-V dialect to
better utilize core infrastructure: many functionalities in the core
infrastructure require ops to be isolated, e.g., the
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/lib/Transforms/Utils/GreedyPatternRewriteDriver.cpp>greedy pattern rewriter</a> can only act on ops isolated
from above.</p><p>(TODO: create a dedicated <code>spirv.fn</code> op for SPIR-V functions.)</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p>In SPIR-V, instruction is a generalized concept; a SPIR-V module is just a
sequence of instructions. Declaring types, expressing computations, annotating
result ids, expressing control flows and others are all in the form of
instructions.</p><p>We only discuss instructions expressing computations here, which can be
represented via SPIR-V dialect ops. Module-level instructions for declarations
and definitions are represented differently in the SPIR-V dialect as explained
earlier in the
<a href=#module-level-operations>Module-level operations</a> section.</p><p>An instruction computes zero or one result from zero or more operands. The
result is a new result id. An operand can be a result id generated by a previous
instruction, an immediate value, or a case of an enum type. We can model result
id operands and results with MLIR SSA values; for immediate value and enum
cases, we can model them with MLIR attributes.</p><p>For example,</p><pre tabindex=0><code class=language-spirv data-lang=spirv>%i32 = OpTypeInt 32 0
%c42 = OpConstant %i32 42
...
%3 = OpVariable %i32 Function 42
%4 = OpIAdd %i32 %c42 %c42
</code></pre><p>can be represented in the dialect as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;spirv.Constant&#34;</span><span class=p>()</span> <span class=p>{</span> <span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;spirv.Variable&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>{</span> <span class=nl>storage_class =</span> <span class=s>&#34;Function&#34;</span> <span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;spirv.IAdd&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Operation documentation is written in each op&rsquo;s Op Definition Spec using
TableGen. A markdown version of the doc can be generated using
<code>mlir-tblgen -gen-doc</code> and is attached in the
<a href=#operation-definitions>Operation definitions</a> section.</p><h3 id=ops-from-extended-instruction-sets>Ops from extended instruction sets&nbsp;<a class=headline-hash href=#ops-from-extended-instruction-sets>¶</a></h3><p>Analogically extended instruction set is a mechanism to import SPIR-V
instructions within another namespace.
<a href=https://www.khronos.org/registry/spir-v/specs/1.0/GLSL.std.450.html><code>GLSL.std.450</code></a> is an
extended instruction set that provides common mathematical routines that should
be supported. Instead of modeling <code>OpExtInstImport</code> as a separate op and use a
single op to model <code>OpExtInst</code> for all extended instructions, we model each
SPIR-V instruction in an extended instruction set as a separate op with the
proper name prefix. For example, for</p><pre tabindex=0><code class=language-spirv data-lang=spirv>%glsl = OpExtInstImport &#34;GLSL.std.450&#34;

%f32 = OpTypeFloat 32
%cst = OpConstant %f32 ...

%1 = OpExtInst %f32 %glsl 28 %cst
%2 = OpExtInst %f32 %glsl 31 %cst
</code></pre><p>we can have</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;spirv.GL.Log&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;spirv.GL.Sqrt&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=control-flow>Control Flow&nbsp;<a class=headline-hash href=#control-flow>¶</a></h2><p>SPIR-V binary format uses merge instructions (<code>OpSelectionMerge</code> and
<code>OpLoopMerge</code>) to declare structured control flow. They explicitly declare a
header block before the control flow diverges and a merge block where control
flow subsequently converges. These blocks delimit constructs that must nest, and
can only be entered and exited in structured ways.</p><p>In the SPIR-V dialect, we use regions to mark the boundary of a structured
control flow construct. With this approach, it&rsquo;s easier to discover all blocks
belonging to a structured control flow construct. It is also more idiomatic to
MLIR system.</p><p>We introduce a <code>spirv.mlir.selection</code> and <code>spirv.mlir.loop</code> op for structured selections and
loops, respectively. The merge targets are the next ops following them. Inside
their regions, a special terminator, <code>spirv.mlir.merge</code> is introduced for branching to
the merge target and yielding values.</p><h3 id=selection>Selection&nbsp;<a class=headline-hash href=#selection>¶</a></h3><p><code>spirv.mlir.selection</code> defines a selection construct. It contains one region. The
region should contain at least two blocks: one selection header block and one
merge block.</p><ul><li>The selection header block should be the first block. It should contain the
<code>spirv.BranchConditional</code> or <code>spirv.Switch</code> op.</li><li>The merge block should be the last block. The merge block should only
contain a <code>spirv.mlir.merge</code> op. Any block can branch to the merge block for early
exit.</li></ul><pre tabindex=0><code>               +--------------+
               | header block |                 (may have multiple outgoing branches)
               +--------------+
                    / | \
                     ...


   +---------+   +---------+   +---------+
   | case #0 |   | case #1 |   | case #2 |  ... (may have branches between each other)
   +---------+   +---------+   +---------+


                     ...
                    \ | /
                      v
               +-------------+
               | merge block |                  (may have multiple incoming branches)
               +-------------+
</code></pre><p>For example, for the given function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>loop</span><span class=p>(</span><span class=kt>bool</span> <span class=n>cond</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>cond</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>It will be represented as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@selection</span><span class=p>(</span><span class=nv>%cond</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%zero</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>0</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%one</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%two</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>2</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%x</span> <span class=p>=</span> spirv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%zero</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>mlir<span class=p>.</span>selection <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>BranchConditional <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^then</span><span class=p>,</span> <span class=nl>^else
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^then</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%one</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^merge
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%two</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^merge
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^merge</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>mlir<span class=p>.</span>merge
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>The selection can return values by yielding them with <code>spirv.mlir.merge</code>. This
mechanism allows values defined within the selection region to be used outside of it.
Without this, values that were sunk into the selection region, but used outside, would
not be able to escape it.</p><p>For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@selection</span><span class=p>(</span><span class=nv>%cond</span><span class=p>:</span> <span class=k>i1</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%zero</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>0</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%var1</span> <span class=p>=</span> spirv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%zero</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nv>%var2</span> <span class=p>=</span> spirv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%zero</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%yield</span><span class=p>:</span><span class=nl>2 =</span> spirv<span class=p>.</span>mlir<span class=p>.</span>selection <span class=p>-&gt;</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>BranchConditional <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^then</span><span class=p>,</span> <span class=nl>^else
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^then</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%one</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%three</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>3</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^merge</span><span class=p>(</span><span class=nv>%one</span><span class=p>,</span> <span class=nv>%three</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>^else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%two</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>2</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^merge</span><span class=p>(</span><span class=nv>%two</span><span class=p>,</span> <span class=nv>%four</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>^merge</span><span class=p>(</span><span class=nv>%merged_1_2</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%merged_3_4</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>mlir<span class=p>.</span>merge <span class=nv>%merged_1_2</span><span class=p>,</span> <span class=nv>%merged_3_4</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%var1</span><span class=p>,</span> <span class=nv>%yield#0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%var2</span><span class=p>,</span> <span class=nv>%yield#1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>Return
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=loop>Loop&nbsp;<a class=headline-hash href=#loop>¶</a></h3><p><code>spirv.mlir.loop</code> defines a loop construct. It contains one region. The region should
contain at least four blocks: one entry block, one loop header block, one loop
continue block, one merge block.</p><ul><li>The entry block should be the first block and it should jump to the loop
header block, which is the second block.</li><li>The merge block should be the last block. The merge block should only
contain a <code>spirv.mlir.merge</code> op. Any block except the entry block can branch to
the merge block for early exit.</li><li>The continue block should be the second to last block and it should have a
branch to the loop header block.</li><li>The loop continue block should be the only block, except the entry block,
branching to the loop header block.</li></ul><pre tabindex=0><code>    +-------------+
    | entry block |           (one outgoing branch)
    +-------------+
           |
           v
    +-------------+           (two incoming branches)
    | loop header | &lt;-----+   (may have one or two outgoing branches)
    +-------------+       |
                          |
          ...             |
         \ | /            |
           v              |
   +---------------+      |   (may have multiple incoming branches)
   | loop continue | -----+   (may have one or two outgoing branches)
   +---------------+

          ...
         \ | /
           v
    +-------------+           (may have multiple incoming branches)
    | merge block |
    +-------------+
</code></pre><p>The reason to have another entry block instead of directly using the loop header
block as the entry block is to satisfy region&rsquo;s requirement: entry block of
region may not have predecessors. We have a merge block so that branch ops can
reference it as successors. The loop continue block here corresponds to
&ldquo;continue construct&rdquo; using SPIR-V spec&rsquo;s term; it does not mean the &ldquo;continue
block&rdquo; as defined in the SPIR-V spec, which is &ldquo;a block containing a branch to
an OpLoopMerge instruction’s Continue Target.&rdquo;</p><p>For example, for the given function</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>loop</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>It will be represented as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@loop</span><span class=p>(</span><span class=nv>%count</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%zero</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>0</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%one</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%var</span> <span class=p>=</span> spirv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%zero</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>mlir<span class=p>.</span>loop <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^header
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^header</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%val0</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%var</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%cmp</span> <span class=p>=</span> spirv<span class=p>.</span>SLessThan <span class=nv>%val0</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>BranchConditional <span class=nv>%cmp</span><span class=p>,</span> <span class=nl>^body</span><span class=p>,</span> <span class=nl>^merge
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^body</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c>// ...
</span></span></span><span class=line><span class=cl><span class=c></span>    spirv<span class=p>.</span>Branch <span class=nl>^continue
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^continue</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%val1</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%var</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%add</span> <span class=p>=</span> spirv<span class=p>.</span>IAdd <span class=nv>%val1</span><span class=p>,</span> <span class=nv>%one</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%var</span><span class=p>,</span> <span class=nv>%add</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^header
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^merge</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>mlir<span class=p>.</span>merge
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Similarly to selection, loops can also yield values using <code>spirv.mlir.merge</code>. This
mechanism allows values defined within the loop region to be used outside of it.</p><p>For example</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%yielded</span> <span class=p>=</span> spirv<span class=p>.</span>mlir<span class=p>.</span>loop <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span><span class=line><span class=cl><span class=c></span>  spirv<span class=p>.</span>mlir<span class=p>.</span>merge <span class=nv>%to_yield</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=block-argument-for-phi>Block argument for Phi&nbsp;<a class=headline-hash href=#block-argument-for-phi>¶</a></h3><p>There are no direct Phi operations in the SPIR-V dialect; SPIR-V <code>OpPhi</code>
instructions are modelled as block arguments in the SPIR-V dialect. (See the
<a href=/docs/Rationale/Rationale/#block-arguments-vs-phi-nodes>Rationale</a> doc for &ldquo;Block Arguments vs Phi nodes&rdquo;.) Each block
argument corresponds to one <code>OpPhi</code> instruction in the SPIR-V binary format. For
example, for the following SPIR-V function <code>foo</code>:</p><pre tabindex=0><code class=language-spirv data-lang=spirv>  %foo = OpFunction %void None ...
%entry = OpLabel
  %var = OpVariable %_ptr_Function_int Function
         OpSelectionMerge %merge None
         OpBranchConditional %true %true %false
 %true = OpLabel
         OpBranch %phi
%false = OpLabel
         OpBranch %phi
  %phi = OpLabel
  %val = OpPhi %int %int_1 %false %int_0 %true
         OpStore %var %val
         OpReturn
%merge = OpLabel
         OpReturn
         OpFunctionEnd
</code></pre><p>It will be represented as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%var</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>mlir<span class=p>.</span>selection <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%true</span> <span class=p>=</span> spirv<span class=p>.</span>Constant true
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>BranchConditional <span class=nv>%true</span><span class=p>,</span> <span class=nl>^true</span><span class=p>,</span> <span class=nl>^false
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl>  ^true</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%zero</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^phi</span><span class=p>(</span><span class=nv>%zero</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>^false</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nv>%one</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Branch <span class=nl>^phi</span><span class=p>(</span><span class=nv>%one</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>^phi</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%var</span><span class=p>,</span> <span class=nv>%arg</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Return
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nl>^merge</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>mlir<span class=p>.</span>merge
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span>Return
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=version-extensions-capabilities>Version, extensions, capabilities&nbsp;<a class=headline-hash href=#version-extensions-capabilities>¶</a></h2><p>SPIR-V supports versions, extensions, and capabilities as ways to indicate the
availability of various features (types, ops, enum cases) on target hardware.
For example, non-uniform group operations were missing before v1.3, and they
require special capabilities like <code>GroupNonUniformArithmetic</code> to be used. These
availability information relates to
<a href=#target-environment>target environment</a>
and affects the legality of patterns during dialect conversion.</p><p>SPIR-V ops&rsquo; availability requirements are modeled with
<a href=/docs/Interfaces/#operation-interfaces>op interfaces</a>:</p><ul><li><code>QueryMinVersionInterface</code> and <code>QueryMaxVersionInterface</code> for version
requirements</li><li><code>QueryExtensionInterface</code> for extension requirements</li><li><code>QueryCapabilityInterface</code> for capability requirements</li></ul><p>These interface declarations are auto-generated from TableGen definitions
included in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td><code>SPIRVBase.td</code></a>. At the moment all SPIR-V ops
implement the above interfaces.</p><p>SPIR-V ops&rsquo; availability implementation methods are automatically synthesized
from the availability specification on each op and enum attribute in TableGen.
An op needs to look into not only the opcode but also operands to derive its
availability requirements. For example, <code>spirv.ControlBarrier</code> requires no
special capability if the execution scope is <code>Subgroup</code>, but it will require
the <code>VulkanMemoryModel</code> capability if the scope is <code>QueueFamily</code>.</p><p>SPIR-V types&rsquo; availability implementation methods are manually written as
overrides in the SPIR-V
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h>type hierarchy</a>.</p><p>These availability requirements serve as the &ldquo;ingredients&rdquo; for the
<a href=#spirvconversiontarget><code>SPIRVConversionTarget</code></a> and
<a href=#spirvtypeconverter><code>SPIRVTypeConverter</code></a> to perform op and type conversions,
by following the requirements in
<a href=#target-environment>target environment</a>.</p><h2 id=target-environment>Target environment&nbsp;<a class=headline-hash href=#target-environment>¶</a></h2><p>SPIR-V aims to support multiple execution environments as specified by client
APIs. These execution environments affect the availability of certain SPIR-V
features. For example, a
<a href=https://renderdoc.org/vkspec_chunked/chap40.html#spirvenv>Vulkan 1.1</a> implementation must support
the 1.0, 1.1, 1.2, and 1.3 versions of SPIR-V and the 1.0 version of the SPIR-V
extended instructions for GLSL. Further Vulkan extensions may enable more SPIR-V
instructions.</p><p>SPIR-V compilation should also take into consideration of the execution
environment, so we generate SPIR-V modules valid for the target environment.
This is conveyed by the <code>spirv.target_env</code> (<code>spirv::TargetEnvAttr</code>) attribute. It
should be of <code>#spirv.target_env</code> attribute kind, which is defined as:</p><pre tabindex=0><code>spirv-version    ::= `v1.0` | `v1.1` | ...
spirv-extension  ::= `SPV_KHR_16bit_storage` | `SPV_EXT_physical_storage_buffer` | ...
spirv-capability ::= `Shader` | `Kernel` | `GroupNonUniform` | ...

spirv-extension-list     ::= `[` (spirv-extension-elements)? `]`
spirv-extension-elements ::= spirv-extension (`,` spirv-extension)*

spirv-capability-list     ::= `[` (spirv-capability-elements)? `]`
spirv-capability-elements ::= spirv-capability (`,` spirv-capability)*

spirv-resource-limits ::= dictionary-attribute

spirv-vce-attribute ::= `#` `spirv.vce` `&lt;`
                            spirv-version `,`
                            spirv-capability-list `,`
                            spirv-extensions-list `&gt;`

spirv-vendor-id ::= `AMD` | `NVIDIA` | ...
spirv-device-type ::= `DiscreteGPU` | `IntegratedGPU` | `CPU` | ...
spirv-device-id ::= integer-literal
spirv-device-info ::= spirv-vendor-id (`:` spirv-device-type (`:` spirv-device-id)?)?

spirv-target-env-attribute ::= `#` `spirv.target_env` `&lt;`
                                  spirv-vce-attribute,
                                  (spirv-device-info `,`)?
                                  spirv-resource-limits `&gt;`
</code></pre><p>The attribute has a few fields:</p><ul><li>A <code>#spirv.vce</code> (<code>spirv::VerCapExtAttr</code>) attribute:<ul><li>The target SPIR-V version.</li><li>A list of SPIR-V extensions for the target.</li><li>A list of SPIR-V capabilities for the target.</li></ul></li><li>A dictionary of target resource limits (see the
<a href=https://renderdoc.org/vkspec_chunked/chap36.html#limits>Vulkan spec</a> for explanation):<ul><li><code>max_compute_workgroup_invocations</code></li><li><code>max_compute_workgroup_size</code></li></ul></li></ul><p>For example,</p><pre tabindex=0><code>module attributes {
spirv.target_env = #spirv.target_env&lt;
    #spirv.vce&lt;v1.3, [Shader, GroupNonUniform], [SPV_KHR_8bit_storage]&gt;,
    ARM:IntegratedGPU,
    {
      max_compute_workgroup_invocations = 128 : i32,
      max_compute_workgroup_size = dense&lt;[128, 128, 64]&gt; : vector&lt;3xi32&gt;
    }&gt;
} { ... }
</code></pre><p>Dialect conversion framework will utilize the information in <code>spirv.target_env</code> to
properly filter out patterns and ops not available in the target execution
environment. When targeting SPIR-V, one needs to create a
<a href=#spirvconversiontarget><code>SPIRVConversionTarget</code></a> by providing such an
attribute.</p><h2 id=shader-interface-abi>Shader interface (ABI)&nbsp;<a class=headline-hash href=#shader-interface-abi>¶</a></h2><p>SPIR-V itself is just expressing computation happening on GPU device. SPIR-V
programs themselves are not enough for running workloads on GPU; a companion
host application is needed to manage the resources referenced by SPIR-V programs
and dispatch the workload. For the Vulkan execution environment, the host
application will be written using Vulkan API. Unlike CUDA, the SPIR-V program
and the Vulkan application are typically authored with different front-end
languages, which isolates these two worlds. Yet they still need to match
<em>interfaces</em>: the variables declared in a SPIR-V program for referencing
resources need to match with the actual resources managed by the application
regarding their parameters.</p><p>Still using Vulkan as an example execution environment, there are two primary
resource types in Vulkan: buffers and images. They are used to back various uses
that may differ regarding the classes of operations (load, store, atomic) to be
performed. These uses are differentiated via descriptor types. (For example,
uniform storage buffer descriptors can only support load operations while
storage buffer descriptors can support load, store, and atomic operations.)
Vulkan uses a binding model for resources. Resources are associated with
descriptors and descriptors are further grouped into sets. Each descriptor thus
has a set number and a binding number. Descriptors in the application
corresponds to variables in the SPIR-V program. Their parameters must match,
including but not limited to set and binding numbers.</p><p>Apart from buffers and images, there is other data that is set up by Vulkan and
referenced inside the SPIR-V program, for example, push constants. They also
have parameters that require matching between the two worlds.</p><p>The interface requirements are external information to the SPIR-V compilation
path in MLIR. Besides, each Vulkan application may want to handle resources
differently. To avoid duplication and to share common utilities, a SPIR-V shader
interface specification needs to be defined to provide the external requirements
to and guide the SPIR-V compilation path.</p><h3 id=shader-interface-attributes>Shader interface attributes&nbsp;<a class=headline-hash href=#shader-interface-attributes>¶</a></h3><p>The SPIR-V dialect defines
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/TargetAndABI.h>a few attributes</a> for specifying these
interfaces:</p><ul><li><code>spirv.entry_point_abi</code> is a struct attribute that should be attached to the
entry function. It contains:<ul><li><code>local_size</code> for specifying the local work group size for the dispatch.</li></ul></li><li><code>spirv.interface_var_abi</code> is attribute that should be attached to each operand
and result of the entry function. It should be of <code>#spirv.interface_var_abi</code>
attribute kind, which is defined as:</li></ul><pre tabindex=0><code>spv-storage-class     ::= `StorageBuffer` | ...
spv-descriptor-set    ::= integer-literal
spv-binding           ::= integer-literal
spv-interface-var-abi ::= `#` `spirv.interface_var_abi` `&lt;(` spv-descriptor-set
                          `,` spv-binding `)` (`,` spv-storage-class)? `&gt;`
</code></pre><p>For example,</p><pre tabindex=0><code>#spirv.interface_var_abi&lt;(0, 0), StorageBuffer&gt;
#spirv.interface_var_abi&lt;(0, 1)&gt;
</code></pre><p>The attribute has a few fields:</p><ul><li>Descriptor set number for the corresponding resource variable.</li><li>Binding number for the corresponding resource variable.</li><li>Storage class for the corresponding resource variable.</li></ul><p>The SPIR-V dialect provides a
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/Passes.h><code>LowerABIAttributesPass</code></a> that
uses this information to lower the entry point function and its ABI consistent
with the Vulkan validation rules. Specifically,</p><ul><li>Creates <code>spirv.GlobalVariable</code>s for the arguments, and replaces all uses of
the argument with this variable. The SSA value used for replacement is
obtained using the <code>spirv.mlir.addressof</code> operation.</li><li>Adds the <code>spirv.EntryPoint</code> and <code>spirv.ExecutionMode</code> operations into the
<code>spirv.module</code> for the entry function.</li></ul><h2 id=serialization-and-deserialization>Serialization and deserialization&nbsp;<a class=headline-hash href=#serialization-and-deserialization>¶</a></h2><p>Although the main objective of the SPIR-V dialect is to act as a proper IR for
compiler transformations, being able to serialize to and deserialize from the
binary format is still very valuable for many good reasons. Serialization
enables the artifacts of SPIR-V compilation to be consumed by an execution
environment; deserialization allows us to import SPIR-V binary modules and run
transformations on them. So serialization and deserialization are supported from
the very beginning of the development of the SPIR-V dialect.</p><p>The serialization library provides two entry points, <code>mlir::spirv::serialize()</code>
and <code>mlir::spirv::deserialize()</code>, for converting a MLIR SPIR-V module to binary
format and back. The
<a href=#code-organization>Code organization</a> explains more about
this.</p><p>Given that the focus is transformations, which inevitably means changes to the
binary module; so serialization is not designed to be a general tool for
investigating the SPIR-V binary module and does not guarantee roundtrip
equivalence (at least for now). For the latter, please use the
assembler/disassembler in the
<a href=https://github.com/KhronosGroup/SPIRV-Tools>SPIRV-Tools</a> project.</p><p>A few transformations are performed in the process of serialization because of
the representational differences between SPIR-V dialect and binary format:</p><ul><li>Attributes on <code>spirv.module</code> are emitted as their corresponding SPIR-V
instructions.</li><li>Types are serialized into <code>OpType*</code> instructions in the SPIR-V binary module
section for types, constants, and global variables.</li><li><code>spirv.Constant</code>s are unified and placed in the SPIR-V binary module section
for types, constants, and global variables.</li><li>Attributes on ops, if not part of the op&rsquo;s binary encoding, are emitted as
<code>OpDecorate*</code> instructions in the SPIR-V binary module section for
decorations.</li><li><code>spirv.mlir.selection</code>s and <code>spirv.mlir.loop</code>s are emitted as basic blocks with <code>Op*Merge</code>
instructions in the header block as required by the binary format.</li><li>Block arguments are materialized as <code>OpPhi</code> instructions at the beginning of
the corresponding blocks.</li></ul><p>Similarly, a few transformations are performed during deserialization:</p><ul><li>Instructions for execution environment requirements (extensions,
capabilities, extended instruction sets, etc.) will be placed as attributes
on <code>spirv.module</code>.</li><li><code>OpType*</code> instructions will be converted into proper <code>mlir::Type</code>s.</li><li><code>OpConstant*</code> instructions are materialized as <code>spirv.Constant</code> at each use
site.</li><li><code>OpVariable</code> instructions will be converted to <code>spirv.GlobalVariable</code> ops if
in module-level; otherwise they will be converted into <code>spirv.Variable</code> ops.</li><li>Every use of a module-level <code>OpVariable</code> instruction will materialize a
<code>spirv.mlir.addressof</code> op to turn the symbol of the corresponding
<code>spirv.GlobalVariable</code> into an SSA value.</li><li>Every use of a <code>OpSpecConstant</code> instruction will materialize a
<code>spirv.mlir.referenceof</code> op to turn the symbol of the corresponding
<code>spirv.SpecConstant</code> into an SSA value.</li><li><code>OpPhi</code> instructions are converted to block arguments.</li><li>Structured control flow are placed inside <code>spirv.mlir.selection</code> and <code>spirv.mlir.loop</code>.</li></ul><h2 id=conversions>Conversions&nbsp;<a class=headline-hash href=#conversions>¶</a></h2><p>One of the main features of MLIR is the ability to progressively lower from
dialects that capture programmer abstraction into dialects that are closer to a
machine representation, like SPIR-V dialect. This progressive lowering through
multiple dialects is enabled through the use of the
<a href=/docs/DialectConversion/>DialectConversion</a> framework in MLIR. To simplify
targeting SPIR-V dialect using the Dialect Conversion framework, two utility
classes are provided.</p><p>(<strong>Note</strong> : While SPIR-V has some
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#_a_id_shadervalidation_a_validation_rules_for_shader_a_href_capability_capabilities_a>validation rules</a>,
additional rules are imposed by
<a href=https://renderdoc.org/vkspec_chunked/chap40.html#spirvenv>Vulkan execution environment</a>. The
lowering described below implements both these requirements.)</p><h3 id=spirvconversiontarget><code>SPIRVConversionTarget</code>&nbsp;<a class=headline-hash href=#spirvconversiontarget>¶</a></h3><p>The <code>mlir::spirv::SPIRVConversionTarget</code> class derives from the
<code>mlir::ConversionTarget</code> class and serves as a utility to define a conversion
target satisfying a given
<a href=#target-environment><code>spirv.target_env</code></a>. It registers
proper hooks to check the dynamic legality of SPIR-V ops. Users can further
register other legality constraints into the returned <code>SPIRVConversionTarget</code>.</p><p><code>spirv::lookupTargetEnvOrDefault()</code> is a handy utility function to query an
<code>spirv.target_env</code> attached in the input IR or use the default to construct a
<code>SPIRVConversionTarget</code>.</p><h3 id=spirvtypeconverter><code>SPIRVTypeConverter</code>&nbsp;<a class=headline-hash href=#spirvtypeconverter>¶</a></h3><p>The <code>mlir::SPIRVTypeConverter</code> derives from <code>mlir::TypeConverter</code> and provides
type conversion for builtin types to SPIR-V types conforming to the
<a href=#target-environment>target environment</a> it is constructed with. If the
required extension/capability for the resultant type is not available in the
given target environment, <code>convertType()</code> will return a null type.</p><p>Builtin scalar types are converted to their corresponding SPIR-V scalar types.</p><p>(TODO: Note that if the bitwidth is not available in the target environment,
it will be unconditionally converted to 32-bit. This should be switched to
properly emulating non-32-bit scalar types.)</p><p><a href=/docs/Dialects/Builtin/#indextype>Builtin index type</a> need special handling since they are not
directly supported in SPIR-V. Currently the <code>index</code> type is converted to <code>i32</code>.</p><p>(TODO: Allow for configuring the integer width to use for <code>index</code> types in the
SPIR-V dialect)</p><p>SPIR-V only supports vectors of 2/3/4 elements; so
<a href=/docs/Dialects/Builtin/#vectortype>builtin vector types</a> of these lengths can be converted
directly.</p><p>(TODO: Convert other vectors of lengths to scalars or arrays)</p><p><a href=/docs/Dialects/Builtin/#memreftype>Builtin memref types</a> with static shape and stride are
converted to <code>spirv.ptr&lt;spirv.struct&lt;spirv.array&lt;...>>></code>s. The resultant SPIR-V array
types have the same element type as the source memref and its number of elements
is obtained from the layout specification of the memref. The storage class of
the pointer type are derived from the memref&rsquo;s memory space with
<code>SPIRVTypeConverter::getStorageClassForMemorySpace()</code>.</p><h3 id=utility-functions-for-lowering>Utility functions for lowering&nbsp;<a class=headline-hash href=#utility-functions-for-lowering>¶</a></h3><h4 id=setting-layout-for-shader-interface-variables>Setting layout for shader interface variables&nbsp;<a class=headline-hash href=#setting-layout-for-shader-interface-variables>¶</a></h4><p>SPIR-V validation rules for shaders require composite objects to be explicitly
laid out. If a <code>spirv.GlobalVariable</code> is not explicitly laid out, the utility
method <code>mlir::spirv::decorateType</code> implements a layout consistent with
the
<a href=https://renderdoc.org/vkspec_chunked/chap14.html#interfaces-resources>Vulkan shader requirements</a>.</p><h4 id=creating-builtin-variables>Creating builtin variables&nbsp;<a class=headline-hash href=#creating-builtin-variables>¶</a></h4><p>In SPIR-V dialect, builtins are represented using <code>spirv.GlobalVariable</code>s, with
<code>spirv.mlir.addressof</code> used to get a handle to the builtin as an SSA value. The
method <code>mlir::spirv::getBuiltinVariableValue</code> creates a <code>spirv.GlobalVariable</code> for
the builtin in the current <code>spirv.module</code> if it does not exist already, and
returns an SSA value generated from an <code>spirv.mlir.addressof</code> operation.</p><h3 id=current-conversions-to-spir-v>Current conversions to SPIR-V&nbsp;<a class=headline-hash href=#current-conversions-to-spir-v>¶</a></h3><p>Using the above infrastructure, conversions are implemented from</p><ul><li>[Arith Dialect][MlirArithDialect]</li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a> : A gpu.module is converted to a <code>spirv.module</code>.
A gpu.function within this module is lowered as an entry function.</li></ul><h2 id=code-organization>Code organization&nbsp;<a class=headline-hash href=#code-organization>¶</a></h2><p>We aim to provide multiple libraries with clear dependencies for SPIR-V related
functionalities in MLIR so developers can just choose the needed components
without pulling in the whole world.</p><h3 id=the-dialect>The dialect&nbsp;<a class=headline-hash href=#the-dialect>¶</a></h3><p>The code for the SPIR-V dialect resides in a few places:</p><ul><li>Public headers are placed in
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Dialect/SPIRV>include/mlir/Dialect/SPIRV</a>.</li><li>Libraries are placed in
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/lib/Dialect/SPIRV>lib/Dialect/SPIRV</a>.</li><li>IR tests are placed in
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/test/Dialect/SPIRV>test/Dialect/SPIRV</a>.</li><li>Unit tests are placed in
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/unittests/Dialect/SPIRV>unittests/Dialect/SPIRV</a>.</li></ul><p>The whole SPIR-V dialect is exposed via multiple headers for better
organization:</p><ul><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVDialect.h>SPIRVDialect.h</a> defines the SPIR-V dialect.</li><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h>SPIRVTypes.h</a> defines all SPIR-V specific types.</li><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.h>SPIRVOps.h</a> defines all SPIR-V operations.</li><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Target/SPIRV/Serialization.h>Serialization.h</a> defines the entry points for
serialization and deserialization.</li></ul><p>The dialect itself, including all types and ops, is in the <code>MLIRSPIRV</code> library.
Serialization functionalities are in the <code>MLIRSPIRVSerialization</code> library.</p><h3 id=op-definitions>Op definitions&nbsp;<a class=headline-hash href=#op-definitions>¶</a></h3><p>We use
<a href=/docs/DefiningDialects/Operations/>Op Definition Spec</a> to define all SPIR-V ops. They are written in
TableGen syntax and placed in various <code>*Ops.td</code> files in the header directory.
Those <code>*Ops.td</code> files are organized according to the instruction categories used
in the SPIR-V specification, for example, an op belonging to the &ldquo;Atomics
Instructions&rdquo; section is put in the <code>SPIRVAtomicOps.td</code> file.</p><p><code>SPIRVOps.td</code> serves as the main op definition file that includes all files
for specific categories.</p><p><code>SPIRVBase.td</code> defines common classes and utilities used by various op
definitions. It contains the TableGen SPIR-V dialect definition, SPIR-V
versions, known extensions, various SPIR-V enums, TableGen SPIR-V types, and
base op classes, etc.</p><p>Many of the contents in <code>SPIRVBase.td</code>, e.g., the opcodes and various enums, and
all <code>*Ops.td</code> files can be automatically updated via a Python script, which
queries the SPIR-V specification and grammar. This greatly reduces the burden of
supporting new ops and keeping updated with the SPIR-V spec. More details on
this automated development can be found in the
<a href=#automated-development-flow>Automated development flow</a> section.</p><h3 id=dialect-conversions>Dialect conversions&nbsp;<a class=headline-hash href=#dialect-conversions>¶</a></h3><p>The code for conversions from other dialects to the SPIR-V dialect also resides
in a few places:</p><ul><li>From GPU dialect: headers are at
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Conversion/GPUToSPIRV>include/mlir/Conversion/GPUTOSPIRV</a>; libraries are
at
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/lib/Conversion/GPUToSPIRV>lib/Conversion/GPUToSPIRV</a>.</li><li>From Func dialect: headers are at
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/include/mlir/Conversion/FuncToSPIRV>include/mlir/Conversion/FuncToSPIRV</a>; libraries
are at
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/lib/Conversion/FuncToSPIRV>lib/Conversion/FuncToSPIRV</a>.</li></ul><p>These dialect to dialect conversions have their dedicated libraries,
<code>MLIRGPUToSPIRV</code> and <code>MLIRFuncToSPIRV</code>, respectively.</p><p>There are also common utilities when targeting SPIR-V from any dialect:</p><ul><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h>include/mlir/Dialect/SPIRV/Transforms/SPIRVConversion.h</a>
contains type converters and other utility functions.</li><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/Transforms/Passes.h>include/mlir/Dialect/SPIRV/Transforms/Passes.h</a> contains
SPIR-V specific analyses and transformations.</li></ul><p>These common utilities are implemented in the <code>MLIRSPIRVConversion</code> and
<code>MLIRSPIRVTransforms</code> library, respectively.</p><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><h3 id=lowering-memrefs-to-spirvarray-and-spirvrtarray>Lowering <code>memref</code>s to <code>!spirv.array&lt;..></code> and <code>!spirv.rtarray&lt;..></code>.&nbsp;<a class=headline-hash href=#lowering-memrefs-to-spirvarray-and-spirvrtarray>¶</a></h3><p>The LLVM dialect lowers <code>memref</code> types to a <code>MemrefDescriptor</code>:</p><pre tabindex=0><code>struct MemrefDescriptor {
  void *allocated_ptr; // Pointer to the base allocation.
  void *aligned_ptr;   // Pointer within base allocation which is aligned to
                       // the value set in the memref.
  size_t offset;       // Offset from aligned_ptr from where to get values
                       // corresponding to the memref.
  size_t shape[rank];  // Shape of the memref.
  size_t stride[rank]; // Strides used while accessing elements of the memref.
};
</code></pre><p>In SPIR-V dialect, we chose not to use a <code>MemrefDescriptor</code>. Instead a <code>memref</code>
is lowered directly to a <code>!spirv.ptr&lt;!spirv.array&lt;nelts x elem_type>></code> when the
<code>memref</code> is statically shaped, and <code>!spirv.ptr&lt;!spirv.rtarray&lt;elem_type>></code> when the
<code>memref</code> is dynamically shaped. The rationale behind this choice is described
below.</p><ol><li><p>Inputs/output buffers to a SPIR-V kernel are specified using
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpVariable><code>OpVariable</code></a> inside
<a href=https://renderdoc.org/vkspec_chunked/chap15.html#interfaces>interface storage
classes</a> (e.g., Uniform, StorageBuffer,
etc.), while kernel private variables reside in non-interface storage
classes (e.g., Function, Workgroup, etc.). By default, Vulkan-flavored
SPIR-V requires logical addressing mode: one cannot load/store pointers
from/to variables and cannot perform pointer arithmetic. Expressing a
struct like <code>MemrefDescriptor</code> in interface storage class requires special
addressing mode
(
<a href=https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_physical_storage_buffer.html>PhysicalStorageBuffer</a>) and
manipulating such a struct in non-interface storage classes requires special
capabilities (
<a href=https://github.com/KhronosGroup/SPIRV-Registry/blob/main/extensions/KHR/SPV_KHR_variable_pointers.html>VariablePointers</a>).
Requiring these two extensions together will significantly limit the
Vulkan-capable device we can target; basically ruling out mobile support..</p></li><li><p>An alternative to having one level of indirection (as is the case with
<code>MemrefDescriptor</code>s), is to embed the <code>!spirv.array</code> or <code>!spirv.rtarray</code>
directly in the <code>MemrefDescriptor</code>, Having such a descriptor at the ABI
boundary implies that the first few bytes of the input/output buffers would
need to be reserved for shape/stride information. This adds an unnecessary
burden on the host side.</p></li><li><p>A more performant approach would be to have the data be an <code>OpVariable</code>,
with the shape and strides passed using a separate <code>OpVariable</code>. This has
further advantages:</p><ul><li>All the dynamic shape/stride information of the <code>memref</code> can be combined
into a single descriptor. Descriptors are
<a href="https://vulkan.gpuinfo.org/displaydevicelimit.php?name=maxPerStageDescriptorStorageBuffers&amp;platform=android">limited resources on many
Vulkan hardware</a>. So
combining them would help make the generated code more portable across
devices.</li><li>If the shape/stride information is small enough, they could be accessed
using
<a href=https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCmdPushConstants.html>PushConstants</a> that are faster to access and
avoid buffer allocation overheads. These would be unnecessary if all
shapes are static. In the dynamic shape cases, a few parameters are
typically enough to compute the shape of all <code>memref</code>s used/referenced
within the kernel making the use of PushConstants possible.</li><li>The shape/stride information (typically) needs to be update less
frequently than the data stored in the buffers. They could be part of
different descriptor sets.</li></ul></li></ol><h2 id=contribution>Contribution&nbsp;<a class=headline-hash href=#contribution>¶</a></h2><p>All kinds of contributions are highly appreciated! :) We have GitHub issues for
tracking the
<a href=https://github.com/tensorflow/mlir/issues/302>dialect</a> and
<a href=https://github.com/tensorflow/mlir/issues/303>lowering</a> development. You can find todo tasks there.
The
<a href=#code-organization>Code organization</a> section gives an overview of how
SPIR-V related functionalities are implemented in MLIR. This section gives more
concrete steps on how to contribute.</p><h3 id=automated-development-flow>Automated development flow&nbsp;<a class=headline-hash href=#automated-development-flow>¶</a></h3><p>One of the goals of SPIR-V dialect development is to leverage both the SPIR-V
<a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html>human-readable specification</a> and
<a href=https://raw.githubusercontent.com/KhronosGroup/SPIRV-Headers/master/include/spirv/unified1/spirv.core.grammar.json>machine-readable grammar</a> to auto-generate as much contents as
possible. Specifically, the following tasks can be automated (partially or
fully):</p><ul><li>Adding support for a new operation.</li><li>Adding support for a new SPIR-V enum.</li><li>Serialization and deserialization of a new operation.</li></ul><p>We achieve this using the Python script
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/utils/spirv/gen_spirv_dialect.py><code>gen_spirv_dialect.py</code></a>. It fetches the human-readable
specification and machine-readable grammar directly from the Internet and
updates various SPIR-V <code>*.td</code> files in place. The script gives us an automated
flow for adding support for new ops or enums.</p><p>Afterwards, we have SPIR-V specific <code>mlir-tblgen</code> backends for reading the Op
Definition Spec and generate various components, including (de)serialization
logic for ops. Together with standard <code>mlir-tblgen</code> backends, we auto-generate
all op classes, enum classes, etc.</p><p>In the following subsections, we list the detailed steps to follow for common
tasks.</p><h3 id=add-a-new-op>Add a new op&nbsp;<a class=headline-hash href=#add-a-new-op>¶</a></h3><p>To add a new op, invoke the <code>define_inst.sh</code> script wrapper in utils/spirv.
<code>define_inst.sh</code> requires a few parameters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./define_inst.sh &lt;filename&gt; &lt;base-class-name&gt; &lt;opname&gt;
</span></span></code></pre></div><p>For example, to define the op for <code>OpIAdd</code>, invoke</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./define_inst.sh SPIRVArithmeticOps.td ArithmeticBinaryOp OpIAdd
</span></span></code></pre></div><p>where <code>SPIRVArithmeticOps.td</code> is the filename for hosting the new op and
<code>ArithmeticBinaryOp</code> is the direct base class the newly defined op will derive
from.</p><p>Similarly, to define the op for <code>OpAtomicAnd</code>,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./define_inst.sh SPIRVAtomicOps.td AtomicUpdateWithValueOp OpAtomicAnd
</span></span></code></pre></div><p>Note that the generated SPIR-V op definition is just a best-effort template; it
is still expected to be updated to have more accurate traits, arguments, and
results.</p><p>It is also expected that a custom assembly form is defined for the new op,
which will require providing the parser and printer. The EBNF form of the
custom assembly should be described in the op&rsquo;s description and the parser
and printer should be placed in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp><code>SPIRVOps.cpp</code></a> with the
following signatures:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>static</span> <span class=n>ParseResult</span> <span class=n>parse</span><span class=o>&lt;</span><span class=n>spirv</span><span class=o>-</span><span class=n>op</span><span class=o>-</span><span class=n>symbol</span><span class=o>&gt;</span><span class=n>Op</span><span class=p>(</span><span class=n>OpAsmParser</span> <span class=o>&amp;</span><span class=n>parser</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                            <span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>spirv</span><span class=o>::&lt;</span><span class=n>spirv</span><span class=o>-</span><span class=n>op</span><span class=o>-</span><span class=n>symbol</span><span class=o>&gt;</span><span class=n>Op</span> <span class=n>op</span><span class=p>,</span> <span class=n>OpAsmPrinter</span> <span class=o>&amp;</span><span class=n>printer</span><span class=p>);</span>
</span></span></code></pre></div><p>See any existing op as an example.</p><p>Verification should be provided for the new op to cover all the rules described
in the SPIR-V specification. Choosing the proper ODS types and attribute kinds,
which can be found in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVBase.td><code>SPIRVBase.td</code></a>, can help here. Still
sometimes we need to manually write additional verification logic in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp><code>SPIRVOps.cpp</code></a> in a function with the following signature:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=n>spirv</span><span class=o>::&lt;</span><span class=n>spirv</span><span class=o>-</span><span class=n>op</span><span class=o>-</span><span class=n>symbol</span><span class=o>&gt;</span><span class=n>Op</span><span class=o>::</span><span class=n>verify</span><span class=p>();</span>
</span></span></code></pre></div><p>See any such function in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/lib/Dialect/SPIRV/IR/SPIRVOps.cpp><code>SPIRVOps.cpp</code></a> as an example.</p><p>If no additional verification is needed, one needs to add the following to
the op&rsquo;s Op Definition Spec:</p><pre tabindex=0><code>let hasVerifier = 0;
</code></pre><p>To suppress the requirement of the above C++ verification function.</p><p>Tests for the op&rsquo;s custom assembly form and verification should be added to
the proper file in test/Dialect/SPIRV/.</p><p>The generated op will automatically gain the logic for (de)serialization.
However, tests still need to be coupled with the change to make sure no
surprises (see
<a href=#add-a-new-test>Add a new test</a> below).</p><h3 id=add-a-new-enum>Add a new enum&nbsp;<a class=headline-hash href=#add-a-new-enum>¶</a></h3><p>To add a new enum, invoke the <code>define_enum.sh</code> script wrapper in utils/spirv.
<code>define_enum.sh</code> expects the following parameters:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./define_enum.sh &lt;enum-class-name&gt;
</span></span></code></pre></div><p>For example, to add the definition for SPIR-V storage class in to
<code>SPIRVBase.td</code>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>./define_enum.sh StorageClass
</span></span></code></pre></div><h3 id=add-a-new-custom-type>Add a new custom type&nbsp;<a class=headline-hash href=#add-a-new-custom-type>¶</a></h3><p>SPIR-V specific types are defined in
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVTypes.h><code>SPIRVTypes.h</code></a>. See
examples there and the
<a href=/docs/DefiningDialects/AttributesAndTypes/>tutorial</a> for defining new
custom types.</p><h3 id=add-a-new-conversion>Add a new conversion&nbsp;<a class=headline-hash href=#add-a-new-conversion>¶</a></h3><p>To add conversion for a type update the <code>mlir::spirv::SPIRVTypeConverter</code> to
return the converted type (must be a valid SPIR-V type). See
<a href=/docs/DialectConversion/#type-converter>Type
Conversion</a> for more details.</p><p>To lower an operation into SPIR-V dialect, implement a
<a href=/docs/DialectConversion/#conversion-patterns>conversion
pattern</a>. If the conversion requires type
conversion as well, the pattern must inherit from the
<code>mlir::spirv::SPIRVOpLowering</code> class to get access to
<code>mlir::spirv::SPIRVTypeConverter</code>. If the operation has a region,
<a href=/docs/DialectConversion/#region-signature-conversion>signature
conversion</a> might be needed as well.</p><p><strong>Note</strong>: The current validation rules of <code>spirv.module</code> require that all
operations contained within its region are valid operations in the SPIR-V
dialect.</p><h3 id=add-a-new-test>Add a new test&nbsp;<a class=headline-hash href=#add-a-new-test>¶</a></h3><p>Currently the SPIR-V dialect has three types of tests that should be added or
updated accordingly:</p><ol><li><p><strong>Dialect tests</strong> - Those tests check different aspects of the op in isolation.
They should include both positive and negative case, and exercise the verifier,
parser and printer. Dialect tests do not have to form a valid SPIR-V code and
should be kept as simple as possible. They are run with <code>mlir-opt</code>; and are
also used to test transformations.</p></li><li><p><strong>Target tests</strong> - Those tests are designed to exercise serialization and
deserialization, so each module should be a valid SPIR-V module. (De)serialization
is tested using the <code>mlir-translate --test-spirv-roundtrip</code> option.</p><p>To ensure that the SPIR-V MLIR forms and serializes into a valid SPIR-V, the
<code>spriv-val</code> tool should be run on a serialized binary (<code>--serialize-spirv</code>).
This can be automated by adding a conditional validation section to the test:</p><pre tabindex=0><code>// RUN: %if spirv-tools %{ rm -rf %t %}
// RUN: %if spirv-tools %{ mkdir %t %}
// RUN: %if spirv-tools %{ mlir-translate --no-implicit-module --serialize-spirv --split-input-file --spirv-save-validation-files-with-prefix=%t/module %s %}
// RUN: %if spirv-tools %{ spirv-val %t %}
</code></pre><p>This sequence serializes and dumps each MLIR SPIR-V module into a separate
SPIR-V binary (MLIR allows multiple modules per files, however the SPIR-V
spec restricts each binary to a single module), and then runs <code>spirv-val</code>
on each of the file.</p></li><li><p><strong>Integration tests</strong> - Those tests execute the MLIR code using the <code>mlir-runner</code>
to verify its functional correctness.</p></li></ol><h2 id=operation-definitions>Operation definitions&nbsp;<a class=headline-hash href=#operation-definitions>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SPIRV/IR/SPIRVOps.td>source</a></p><h3 id=spirvaccesschain-spirvaccesschainop><code>spirv.AccessChain</code> (spirv::AccessChainOp)&nbsp;<a class=headline-hash href=#spirvaccesschain-spirvaccesschainop>¶</a></h3><p><em>Create a pointer into a composite object.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AccessChain` $base_ptr `[` $indices `]` attr-dict `:` type($base_ptr) `,` type($indices) `-&gt;` type(results)
</code></pre><p>Result Type must be an OpTypePointer. Its Type operand must be the type
reached by walking the Base’s type hierarchy down to the last provided
index in Indexes, and its Storage Class operand must be the same as the
Storage Class of Base.</p><p>Base must be a pointer, pointing to the base of a composite object.</p><p>Indexes walk the type hierarchy to the desired depth, potentially down
to scalar granularity. The first index in Indexes will select the top-
level member/element/component/element of the base composite. All
composite constituents use zero-based numbering, as described by their
OpType… instruction. The second index will apply similarly to that
result, and so on. Once any non-composite type is reached, there must be
no remaining (unused) indexes.</p><p>Each index in Indexes</p><ul><li><p>must be a scalar integer type,</p></li><li><p>is treated as a signed count, and</p></li><li><p>must be an OpConstant when indexing into a structure.</p></li></ul><h4 id=example>Example:&nbsp;<a class=headline-hash href=#example>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;spirv.Constant&#34;</span><span class=p>()</span> <span class=p>{</span> <span class=nl>value =</span> <span class=m>1</span><span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>AccessChain <span class=nv>%1</span><span class=p>[</span><span class=nv>%0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Function<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%2</span> <span class=p>[</span><span class=s>&#34;Volatile&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base_ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>component_ptr</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvmliraddressof-spirvaddressofop><code>spirv.mlir.addressof</code> (spirv::AddressOfOp)&nbsp;<a class=headline-hash href=#spirvmliraddressof-spirvaddressofop>¶</a></h3><p><em>Get the address of a global variable.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.mlir.addressof` $variable attr-dict `:` type($pointer)
</code></pre><p>Variables in module scope are defined using symbol names. This op generates
an SSA value that can be used to refer to the symbol within function scope
for use in ops that expect an SSA value. This operation has no corresponding
SPIR-V instruction; it&rsquo;s merely used for modelling purpose in the SPIR-V
dialect. Since variables in module scope in SPIR-V dialect are of pointer
type, this op returns a pointer type as well, and the type is the same as
the variable referenced.</p><h4 id=example-1>Example:&nbsp;<a class=headline-hash href=#example-1>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@global_var</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Input<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>variable</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvatomicand-spirvatomicandop><code>spirv.AtomicAnd</code> (spirv::AtomicAndOp)&nbsp;<a class=headline-hash href=#spirvatomicand-spirvatomicandop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicAnd` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise AND of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-2>Example:&nbsp;<a class=headline-hash href=#example-2>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicAnd <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                   <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomiccompareexchange-spirvatomiccompareexchangeop><code>spirv.AtomicCompareExchange</code> (spirv::AtomicCompareExchangeOp)&nbsp;<a class=headline-hash href=#spirvatomiccompareexchange-spirvatomiccompareexchangeop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicCompareExchange` $memory_scope $equal_semantics $unequal_semantics operands attr-dict `:`
              type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value from Value only if Original Value equals Comparator,
and</p></li><li><p>store the New Value back through Pointer&rsquo;only if &lsquo;Original Value
equaled Comparator.</p></li></ol><p>The instruction&rsquo;s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>Use Equal for the memory semantics of this instruction when Value and
Original Value compare equal.</p><p>Use Unequal for the memory semantics of this instruction when Value and
Original Value compare unequal. Unequal must not be set to Release or
Acquire and Release. In addition, Unequal cannot be set to a stronger
memory-order then Equal.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type. This type
must also match the type of Comparator.</p><p>Memory is a memory Scope.</p><h4 id=example-3>Example:&nbsp;<a class=headline-hash href=#example-3>¶</a></h4><pre tabindex=0><code>%0 = spirv.AtomicCompareExchange &lt;Workgroup&gt; &lt;Acquire&gt; &lt;None&gt;
                                %pointer, %value, %comparator
                                : !spirv.ptr&lt;i32, WorkGroup&gt;
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>equal_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr><tr><td><code>unequal_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>comparator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomiccompareexchangeweak-spirvatomiccompareexchangeweakop><code>spirv.AtomicCompareExchangeWeak</code> (spirv::AtomicCompareExchangeWeakOp)&nbsp;<a class=headline-hash href=#spirvatomiccompareexchangeweak-spirvatomiccompareexchangeweakop>¶</a></h3><p><em>Deprecated (use OpAtomicCompareExchange).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicCompareExchangeWeak` $memory_scope $equal_semantics $unequal_semantics operands attr-dict `:`
              type($pointer)
</code></pre><p>Has the same semantics as OpAtomicCompareExchange.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-4>Example:&nbsp;<a class=headline-hash href=#example-4>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicCompareExchangeWeak <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Acquire<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>                                   <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%comparator</span>
</span></span><span class=line><span class=cl>                                   <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> WorkGroup<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>equal_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr><tr><td><code>unequal_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>comparator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicexchange-spirvatomicexchangeop><code>spirv.AtomicExchange</code> (spirv::AtomicExchangeOp)&nbsp;<a class=headline-hash href=#spirvatomicexchange-spirvatomicexchangeop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicExchange` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value from copying Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction&rsquo;s result is the Original Value.</p><p>Result Type must be a scalar of integer type or floating-point type.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory is a memory Scope.</p><h4 id=example-5>Example:&nbsp;<a class=headline-hash href=#example-5>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicExchange <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Acquire<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> WorkGroup<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16</td></tr></tbody></table><h3 id=spirvatomiciadd-spirvatomiciaddop><code>spirv.AtomicIAdd</code> (spirv::AtomicIAddOp)&nbsp;<a class=headline-hash href=#spirvatomiciadd-spirvatomiciaddop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicIAdd` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by integer addition of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-6>Example:&nbsp;<a class=headline-hash href=#example-6>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicIAdd <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicidecrement-spirvatomicidecrementop><code>spirv.AtomicIDecrement</code> (spirv::AtomicIDecrementOp)&nbsp;<a class=headline-hash href=#spirvatomicidecrement-spirvatomicidecrementop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicIDecrement` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value through integer subtraction of 1 from Original Value,
and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar. The type of the value
pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-7>Example:&nbsp;<a class=headline-hash href=#example-7>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicIDecrement <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                          <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomiciincrement-spirvatomiciincrementop><code>spirv.AtomicIIncrement</code> (spirv::AtomicIIncrementOp)&nbsp;<a class=headline-hash href=#spirvatomiciincrement-spirvatomiciincrementop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicIIncrement` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value through integer addition of 1 to Original Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar. The type of the value
pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-8>Example:&nbsp;<a class=headline-hash href=#example-8>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicIncrement <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                         <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicisub-spirvatomicisubop><code>spirv.AtomicISub</code> (spirv::AtomicISubOp)&nbsp;<a class=headline-hash href=#spirvatomicisub-spirvatomicisubop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicISub` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by integer subtraction of Value from Original Value,
and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-9>Example:&nbsp;<a class=headline-hash href=#example-9>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicISub <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicor-spirvatomicorop><code>spirv.AtomicOr</code> (spirv::AtomicOrOp)&nbsp;<a class=headline-hash href=#spirvatomicor-spirvatomicorop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicOr` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise OR of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-10>Example:&nbsp;<a class=headline-hash href=#example-10>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicOr <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                  <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicsmax-spirvatomicsmaxop><code>spirv.AtomicSMax</code> (spirv::AtomicSMaxOp)&nbsp;<a class=headline-hash href=#spirvatomicsmax-spirvatomicsmaxop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicSMax` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the largest signed integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-11>Example:&nbsp;<a class=headline-hash href=#example-11>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicSMax <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicsmin-spirvatomicsminop><code>spirv.AtomicSMin</code> (spirv::AtomicSMinOp)&nbsp;<a class=headline-hash href=#spirvatomicsmin-spirvatomicsminop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicSMin` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the smallest signed integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-12>Example:&nbsp;<a class=headline-hash href=#example-12>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicSMin <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicumax-spirvatomicumaxop><code>spirv.AtomicUMax</code> (spirv::AtomicUMaxOp)&nbsp;<a class=headline-hash href=#spirvatomicumax-spirvatomicumaxop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicUMax` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the largest unsigned integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-13>Example:&nbsp;<a class=headline-hash href=#example-13>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicUMax <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>UnsignedOp</code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicumin-spirvatomicuminop><code>spirv.AtomicUMin</code> (spirv::AtomicUMinOp)&nbsp;<a class=headline-hash href=#spirvatomicumin-spirvatomicuminop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicUMin` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by finding the smallest unsigned integer of Original
Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-14>Example:&nbsp;<a class=headline-hash href=#example-14>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicUMin <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                    <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>UnsignedOp</code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvatomicxor-spirvatomicxorop><code>spirv.AtomicXor</code> (spirv::AtomicXorOp)&nbsp;<a class=headline-hash href=#spirvatomicxor-spirvatomicxorop>¶</a></h3><p><em>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.AtomicXor` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by the bitwise exclusive OR of Original Value and
Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction’s result is the Original Value.</p><p>Result Type must be an integer type scalar.</p><p>The type of Value must be the same as Result Type. The type of the
value pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-15>Example:&nbsp;<a class=headline-hash href=#example-15>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>AtomicXor <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                   <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvbitcount-spirvbitcountop><code>spirv.BitCount</code> (spirv::BitCountOp)&nbsp;<a class=headline-hash href=#spirvbitcount-spirvbitcountop>¶</a></h3><p><em>Count the number of set bits in an object.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitCount` $operand `:` type($operand) attr-dict
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type. The components
must be wide enough to hold the unsigned Width of Base as an unsigned
value. That is, no sign bit is needed or counted when checking for a
wide enough result width.</p><p>Base must be a scalar or vector of integer type. It must have the same
number of components as Result Type.</p><p>The result is the unsigned value that is the number of bits in Base that
are 1.</p><h4 id=example-16>Example:&nbsp;<a class=headline-hash href=#example-16>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitCount <span class=nv>%0</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>BitCount <span class=nv>%1</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitfieldinsert-spirvbitfieldinsertop><code>spirv.BitFieldInsert</code> (spirv::BitFieldInsertOp)&nbsp;<a class=headline-hash href=#spirvbitfieldinsert-spirvbitfieldinsertop>¶</a></h3><p><em>Make a copy of an object, with a modified bit field that comes from
another object.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitFieldInsert` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base and Insert must be the same as Result Type.</p><p>Any result bits numbered outside [Offset, Offset + Count - 1]
(inclusive) will come from the corresponding bits in Base.</p><p>Any result bits numbered in [Offset, Offset + Count - 1] come, in
order, from the bits numbered [0, Count - 1] of Insert.</p><p>Count must be an integer type scalar. Count is the number of bits taken
from Insert. It will be consumed as an unsigned value. Count can be 0,
in which case the result will be Base.</p><p>Offset must be an integer type scalar. Offset is the lowest-order bit
of the bit field. It will be consumed as an unsigned value.</p><p>The resulting value is undefined if Count or Offset or their sum is
greater than the number of bits in the result.</p><h4 id=example-17>Example:&nbsp;<a class=headline-hash href=#example-17>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>BitFieldInsert <span class=nv>%base</span><span class=p>,</span> <span class=nv>%insert</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>insert</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitfieldsextract-spirvbitfieldsextractop><code>spirv.BitFieldSExtract</code> (spirv::BitFieldSExtractOp)&nbsp;<a class=headline-hash href=#spirvbitfieldsextract-spirvbitfieldsextractop>¶</a></h3><p><em>Extract a bit field from an object, with sign extension.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitFieldSExtract` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base must be the same as Result Type.</p><p>If Count is greater than 0: The bits of Base numbered in [Offset, Offset</p><ul><li>Count - 1] (inclusive) become the bits numbered [0, Count - 1] of the
result. The remaining bits of the result will all be the same as bit
Offset + Count - 1 of Base.</li></ul><p>Count must be an integer type scalar. Count is the number of bits
extracted from Base. It will be consumed as an unsigned value. Count can
be 0, in which case the result will be 0.</p><p>Offset must be an integer type scalar. Offset is the lowest-order bit
of the bit field to extract from Base. It will be consumed as an
unsigned value.</p><p>The resulting value is undefined if Count or Offset or their sum is
greater than the number of bits in the result.</p><h4 id=example-18>Example:&nbsp;<a class=headline-hash href=#example-18>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>BitFieldSExtract <span class=nv>%base</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitfielduextract-spirvbitfielduextractop><code>spirv.BitFieldUExtract</code> (spirv::BitFieldUExtractOp)&nbsp;<a class=headline-hash href=#spirvbitfielduextract-spirvbitfielduextractop>¶</a></h3><p><em>Extract a bit field from an object, without sign extension.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitFieldUExtract` operands attr-dict `:` type($base) `,` type($offset) `,` type($count)
</code></pre><p>The semantics are the same as with OpBitFieldSExtract with the exception
that there is no sign extension. The remaining bits of the result will
all be 0.</p><h4 id=example-19>Example:&nbsp;<a class=headline-hash href=#example-19>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>BitFieldUExtract <span class=nv>%base</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%count</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i8</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>offset</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>count</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitreverse-spirvbitreverseop><code>spirv.BitReverse</code> (spirv::BitReverseOp)&nbsp;<a class=headline-hash href=#spirvbitreverse-spirvbitreverseop>¶</a></h3><p><em>Reverse the bits in an object.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitReverse` $operand `:` type($operand) attr-dict
</code></pre><p>Results are computed per component.</p><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Base must be the same as Result Type.</p><p>The bit-number n of the result will be taken from bit-number Width - 1 -
n of Base, where Width is the OpTypeInt operand of the Result Type.</p><h4 id=example-20>Example:&nbsp;<a class=headline-hash href=#example-20>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitReverse <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>BitReverse <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitcast-spirvbitcastop><code>spirv.Bitcast</code> (spirv::BitcastOp)&nbsp;<a class=headline-hash href=#spirvbitcast-spirvbitcastop>¶</a></h3><p><em>Bit pattern-preserving type conversion.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Bitcast` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be an OpTypePointer, or a scalar or vector of
numerical-type.</p><p>Operand must have a type of OpTypePointer, or a scalar or vector of
numerical-type. It must be a different type than Result Type.</p><p>If either Result Type or Operand is a pointer, the other must be a
pointer (diverges from the SPIR-V spec).</p><p>If Result Type has a different number of components than Operand, the
total number of bits in Result Type must equal the total number of bits
in Operand. Let L be the type, either Result Type or Operand&rsquo;s type,
that has the larger number of components. Let S be the other type, with
the smaller number of components. The number of components in L must be
an integer multiple of the number of components in S. The first
component (that is, the only or lowest-numbered component) of S maps to
the first components of L, and so on, up to the last component of S
mapping to the last components of L. Within this mapping, any single
component of S (mapping to multiple components of L) maps its lower-
ordered bits to the lower-numbered components of L.</p><h4 id=example-21>Example:&nbsp;<a class=headline-hash href=#example-21>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Bitcast <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Bitcast <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Bitcast <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span> to <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvbitwiseand-spirvbitwiseandop><code>spirv.BitwiseAnd</code> (spirv::BitwiseAndOp)&nbsp;<a class=headline-hash href=#spirvbitwiseand-spirvbitwiseandop>¶</a></h3><p><em>Result is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either
Operand 1 or Operand 2 are 0.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitwiseAnd` operands attr-dict `:` type($result)
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h4 id=example-22>Example:&nbsp;<a class=headline-hash href=#example-22>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseAnd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseAnd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitwiseor-spirvbitwiseorop><code>spirv.BitwiseOr</code> (spirv::BitwiseOrOp)&nbsp;<a class=headline-hash href=#spirvbitwiseor-spirvbitwiseorop>¶</a></h3><p><em>Result is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both
Operand 1 and Operand 2 are 0.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitwiseOr` operands attr-dict `:` type($result)
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h4 id=example-23>Example:&nbsp;<a class=headline-hash href=#example-23>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseOr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseOr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbitwisexor-spirvbitwisexorop><code>spirv.BitwiseXor</code> (spirv::BitwiseXorOp)&nbsp;<a class=headline-hash href=#spirvbitwisexor-spirvbitwisexorop>¶</a></h3><p><em>Result is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0
if Operand 1 and Operand 2 have the same value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.BitwiseXor` operands attr-dict `:` type($result)
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type. The type of
Operand 1 and Operand 2 must be a scalar or vector of integer type.
They must have the same number of components as Result Type. They must
have the same component width as Result Type.</p><h4 id=example-24>Example:&nbsp;<a class=headline-hash href=#example-24>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseXor <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>BitwiseXor <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvbranchconditional-spirvbranchconditionalop><code>spirv.BranchConditional</code> (spirv::BranchConditionalOp)&nbsp;<a class=headline-hash href=#spirvbranchconditional-spirvbranchconditionalop>¶</a></h3><p><em>If Condition is true, branch to true block, otherwise branch to false
block.</em></p><p>Condition must be a Boolean type scalar.</p><p>Branch weights are unsigned 32-bit integer literals. There must be
either no Branch Weights or exactly two branch weights. If present, the
first is the weight for branching to True Label, and the second is the
weight for branching to False Label. The implied probability that a
branch is taken is its weight divided by the sum of the two Branch
weights. At least one weight must be non-zero. A weight of zero does not
imply a branch is dead or permit its removal; branch weights are only
hints. The two weights must not overflow a 32-bit unsigned integer when
added together.</p><p>This instruction must be the last instruction in a block.</p><pre tabindex=0><code>branch-conditional-op ::= `spirv.BranchConditional` ssa-use
                          (`[` integer-literal, integer-literal `]`)?
                          `,` successor `,` successor
successor ::= bb-id branch-use-list?
branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`
</code></pre><h4 id=example-25>Example:&nbsp;<a class=headline-hash href=#example-25>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>BranchConditional <span class=nv>%condition</span><span class=p>,</span> <span class=nl>^true_branch</span><span class=p>,</span> <span class=nl>^false_branch
</span></span></span><span class=line><span class=cl><span class=nl></span>spirv<span class=p>.</span>BranchConditional <span class=nv>%condition</span><span class=p>,</span> <span class=nl>^true_branch</span><span class=p>(</span><span class=nv>%0</span><span class=p>:</span> <span class=k>i32</span><span class=p>),</span> <span class=nl>^false_branch</span><span class=p>(</span><span class=nv>%1</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>branch_weights</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>bool</td></tr><tr><td style=text-align:center><code>trueTargetOperands</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr><tr><td style=text-align:center><code>falseTargetOperands</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueTarget</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseTarget</code></td><td>any successor</td></tr></tbody></table><h3 id=spirvbranch-spirvbranchop><code>spirv.Branch</code> (spirv::BranchOp)&nbsp;<a class=headline-hash href=#spirvbranch-spirvbranchop>¶</a></h3><p><em>Unconditional branch to target block.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Branch` $target (`(` $targetOperands^ `:` type($targetOperands) `)`)? attr-dict
</code></pre><p>This instruction must be the last instruction in a block.</p><h4 id=example-26>Example:&nbsp;<a class=headline-hash href=#example-26>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>Branch <span class=nl>^target
</span></span></span><span class=line><span class=cl><span class=nl></span>spirv<span class=p>.</span>Branch <span class=nl>^target</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>targetOperands</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>target</code></td><td>any successor</td></tr></tbody></table><h3 id=spirvclacos-spirvclacosop><code>spirv.CL.acos</code> (spirv::CLAcosOp)&nbsp;<a class=headline-hash href=#spirvclacos-spirvclacosop>¶</a></h3><p><em>Compute the arc cosine of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.acos` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-27>Example:&nbsp;<a class=headline-hash href=#example-27>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>acos <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>acos <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclacosh-spirvclacoshop><code>spirv.CL.acosh</code> (spirv::CLAcoshOp)&nbsp;<a class=headline-hash href=#spirvclacosh-spirvclacoshop>¶</a></h3><p><em>Compute the inverse hyperbolic cosine of x .</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.acosh` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-28>Example:&nbsp;<a class=headline-hash href=#example-28>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>acosh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>acosh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclasin-spirvclasinop><code>spirv.CL.asin</code> (spirv::CLAsinOp)&nbsp;<a class=headline-hash href=#spirvclasin-spirvclasinop>¶</a></h3><p><em>Compute the arc sine of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.asin` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-29>Example:&nbsp;<a class=headline-hash href=#example-29>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>asin <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>asin <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclasinh-spirvclasinhop><code>spirv.CL.asinh</code> (spirv::CLAsinhOp)&nbsp;<a class=headline-hash href=#spirvclasinh-spirvclasinhop>¶</a></h3><p><em>Compute the inverse hyperbolic sine of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.asinh` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-30>Example:&nbsp;<a class=headline-hash href=#example-30>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>asinh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>asinh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclatan2-spirvclatan2op><code>spirv.CL.atan2</code> (spirv::CLAtan2Op)&nbsp;<a class=headline-hash href=#spirvclatan2-spirvclatan2op>¶</a></h3><p><em>Compute the arc tangent of y / x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.atan2` operands attr-dict `:` type($result)
</code></pre><p>Result is an angle in radians.</p><p>Result Type, y and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-31>Example:&nbsp;<a class=headline-hash href=#example-31>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atan2 <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atan2 <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclatan-spirvclatanop><code>spirv.CL.atan</code> (spirv::CLAtanOp)&nbsp;<a class=headline-hash href=#spirvclatan-spirvclatanop>¶</a></h3><p><em>Compute the arc tangent of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.atan` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-32>Example:&nbsp;<a class=headline-hash href=#example-32>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atan <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atan <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclatanh-spirvclatanhop><code>spirv.CL.atanh</code> (spirv::CLAtanhOp)&nbsp;<a class=headline-hash href=#spirvclatanh-spirvclatanhop>¶</a></h3><p><em>Compute the hyperbolic arc tangent of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.atanh` $operand `:` type($operand) attr-dict
</code></pre><p>Result is an angle in radians.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-33>Example:&nbsp;<a class=headline-hash href=#example-33>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atanh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>atanh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclceil-spirvclceilop><code>spirv.CL.ceil</code> (spirv::CLCeilOp)&nbsp;<a class=headline-hash href=#spirvclceil-spirvclceilop>¶</a></h3><p><em>Round x to integral value using the round to positive infinity rounding
mode.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.ceil` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-34>Example:&nbsp;<a class=headline-hash href=#example-34>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>ceil <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>ceil <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclcos-spirvclcosop><code>spirv.CL.cos</code> (spirv::CLCosOp)&nbsp;<a class=headline-hash href=#spirvclcos-spirvclcosop>¶</a></h3><p><em>Compute the cosine of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.cos` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-35>Example:&nbsp;<a class=headline-hash href=#example-35>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>cos <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>cos <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclcosh-spirvclcoshop><code>spirv.CL.cosh</code> (spirv::CLCoshOp)&nbsp;<a class=headline-hash href=#spirvclcosh-spirvclcoshop>¶</a></h3><p><em>Compute the hyperbolic cosine of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.cosh` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-36>Example:&nbsp;<a class=headline-hash href=#example-36>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>cosh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>cosh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclerf-spirvclerfop><code>spirv.CL.erf</code> (spirv::CLErfOp)&nbsp;<a class=headline-hash href=#spirvclerf-spirvclerfop>¶</a></h3><p><em>Error function of x encountered in integrating the normal distribution.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.erf` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-37>Example:&nbsp;<a class=headline-hash href=#example-37>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>erf <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>erf <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclexp-spirvclexpop><code>spirv.CL.exp</code> (spirv::CLExpOp)&nbsp;<a class=headline-hash href=#spirvclexp-spirvclexpop>¶</a></h3><p><em>Exponentiation of Operand 1</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.exp` $operand `:` type($operand) attr-dict
</code></pre><p>Compute the base-e exponential of x. (i.e. ex)</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand,
must be of the same type.</p><h4 id=example-38>Example:&nbsp;<a class=headline-hash href=#example-38>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>exp <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>exp <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclfabs-spirvclfabsop><code>spirv.CL.fabs</code> (spirv::CLFAbsOp)&nbsp;<a class=headline-hash href=#spirvclfabs-spirvclfabsop>¶</a></h3><p><em>Absolute value of operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.fabs` $operand `:` type($operand) attr-dict
</code></pre><p>Compute the absolute value of x.</p><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand,
must be of the same type.</p><h4 id=example-39>Example:&nbsp;<a class=headline-hash href=#example-39>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fabs <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fabs <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclfmax-spirvclfmaxop><code>spirv.CL.fmax</code> (spirv::CLFMaxOp)&nbsp;<a class=headline-hash href=#spirvclfmax-spirvclfmaxop>¶</a></h3><p><em>Return maximum of two floating-point operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.fmax` operands attr-dict `:` type($result)
</code></pre><p>Returns y if x &lt; y, otherwise it returns x. If one argument is a NaN,
Fmax returns the other argument. If both arguments are NaNs, Fmax returns a NaN.</p><p>Result Type, x and y must be floating-point or vector(2,3,4,8,16)
of floating-point values.</p><p>All of the operands, including the Result Type operand,
must be of the same type.</p><h4 id=example-40>Example:&nbsp;<a class=headline-hash href=#example-40>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fmax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fmax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclfmin-spirvclfminop><code>spirv.CL.fmin</code> (spirv::CLFMinOp)&nbsp;<a class=headline-hash href=#spirvclfmin-spirvclfminop>¶</a></h3><p><em>Return minimum of two floating-point operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.fmin` operands attr-dict `:` type($result)
</code></pre><p>Returns y if y &lt; x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.
If both arguments are NaNs, Fmin returns a NaN.</p><p>Result Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the same type.</p><h4 id=example-41>Example:&nbsp;<a class=headline-hash href=#example-41>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fmin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fmin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclfloor-spirvclfloorop><code>spirv.CL.floor</code> (spirv::CLFloorOp)&nbsp;<a class=headline-hash href=#spirvclfloor-spirvclfloorop>¶</a></h3><p><em>Round x to the integral value using the round to negative infinity
rounding mode.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.floor` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-42>Example:&nbsp;<a class=headline-hash href=#example-42>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>floor <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>floor <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclfma-spirvclfmaop><code>spirv.CL.fma</code> (spirv::CLFmaOp)&nbsp;<a class=headline-hash href=#spirvclfma-spirvclfmaop>¶</a></h3><p><em>Compute the correctly rounded floating-point representation of the sum
of c with the infinitely precise product of a and b. Rounding of
intermediate products shall not occur. Edge case results are per the
IEEE 754-2008 standard.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.fma` operands attr-dict `:` type($result)
</code></pre><p>Result Type, a, b and c must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-43>Example:&nbsp;<a class=headline-hash href=#example-43>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>fma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcllog-spirvcllogop><code>spirv.CL.log</code> (spirv::CLLogOp)&nbsp;<a class=headline-hash href=#spirvcllog-spirvcllogop>¶</a></h3><p><em>Compute the natural logarithm of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.log` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-44>Example:&nbsp;<a class=headline-hash href=#example-44>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>log <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>log <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclmix-spirvclmixop><code>spirv.CL.mix</code> (spirv::CLMixOp)&nbsp;<a class=headline-hash href=#spirvclmix-spirvclmixop>¶</a></h3><p><em>Returns the linear blend of x & y implemented as: x + (y - x) * a</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.mix` operands attr-dict `:` type($result)
</code></pre><p>Result Type, x, y and a must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><p>Note: This instruction can be implemented using contractions such as mad
or fma.</p><h4 id=example-45>Example:&nbsp;<a class=headline-hash href=#example-45>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>mix <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>mix <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclpow-spirvclpowop><code>spirv.CL.pow</code> (spirv::CLPowOp)&nbsp;<a class=headline-hash href=#spirvclpow-spirvclpowop>¶</a></h3><p><em>Compute x to the power y.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.pow` operands attr-dict `:` type($result)
</code></pre><p>Result Type, x and y must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-46>Example:&nbsp;<a class=headline-hash href=#example-46>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>pow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>pow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclprintf-spirvclprintfop><code>spirv.CL.printf</code> (spirv::CLPrintfOp)&nbsp;<a class=headline-hash href=#spirvclprintf-spirvclprintfop>¶</a></h3><p><em>The printf extended instruction writes output to an implementation-
defined stream such as stdout under control of the string pointed to by
format that specifies how subsequent arguments are converted for output.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.printf` $format ( $arguments^ )? attr-dict `:`  type($format) ( `,` type($arguments)^ )? `-&gt;` type($result)
</code></pre><p>printf returns 0 if it was executed successfully and -1 otherwise.</p><p>Result Type must be i32.</p><p>Format must be a pointer(constant) to i8. If there are insufficient
arguments for the format, the behavior is undefined. If the format
is exhausted while arguments remain, the excess arguments are evaluated
(as always) but are otherwise ignored. The printf instruction returns
when the end of the format string is encountered.</p><h4 id=example-47>Example:&nbsp;<a class=headline-hash href=#example-47>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>printf <span class=nv>%fmt</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span>  <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i8</span><span class=p>,</span> UniformConstant<span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>format</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvclrint-spirvclrintop><code>spirv.CL.rint</code> (spirv::CLRintOp)&nbsp;<a class=headline-hash href=#spirvclrint-spirvclrintop>¶</a></h3><p><em>Round x to integral value (using round to nearest even rounding mode) in
floating-point format.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.rint` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-48>Example:&nbsp;<a class=headline-hash href=#example-48>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>rint <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>rint <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclround-spirvclroundop><code>spirv.CL.round</code> (spirv::CLRoundOp)&nbsp;<a class=headline-hash href=#spirvclround-spirvclroundop>¶</a></h3><p><em>Return the integral value nearest to x rounding halfway cases away from
zero, regardless of the current rounding direction.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.round` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-49>Example:&nbsp;<a class=headline-hash href=#example-49>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>round <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>round <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclrsqrt-spirvclrsqrtop><code>spirv.CL.rsqrt</code> (spirv::CLRsqrtOp)&nbsp;<a class=headline-hash href=#spirvclrsqrt-spirvclrsqrtop>¶</a></h3><p><em>Compute inverse square root of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.rsqrt` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-50>Example:&nbsp;<a class=headline-hash href=#example-50>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>rsqrt <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>rsqrt <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcls_abs-spirvclsabsop><code>spirv.CL.s_abs</code> (spirv::CLSAbsOp)&nbsp;<a class=headline-hash href=#spirvcls_abs-spirvclsabsop>¶</a></h3><p><em>Absolute value of operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.s_abs` $operand `:` type($operand) attr-dict
</code></pre><p>Returns |x|, where x is treated as signed integer.</p><p>Result Type and x must be integer or vector(2,3,4,8,16) of
integer values.</p><p>All of the operands, including the Result Type operand,
must be of the same type.</p><h4 id=example-51>Example:&nbsp;<a class=headline-hash href=#example-51>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_abs <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_abs <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcls_max-spirvclsmaxop><code>spirv.CL.s_max</code> (spirv::CLSMaxOp)&nbsp;<a class=headline-hash href=#spirvcls_max-spirvclsmaxop>¶</a></h3><p><em>Return maximum of two signed integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.s_max` operands attr-dict `:` type($result)
</code></pre><p>Returns y if x &lt; y, otherwise it returns x, where x and y are treated as signed integers.</p><p>Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.</p><p>All of the operands, including the Result Type operand, must be of the same type.</p><h4 id=example-52>Example:&nbsp;<a class=headline-hash href=#example-52>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_max <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_max <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcls_min-spirvclsminop><code>spirv.CL.s_min</code> (spirv::CLSMinOp)&nbsp;<a class=headline-hash href=#spirvcls_min-spirvclsminop>¶</a></h3><p><em>Return minimum of two signed integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.s_min` operands attr-dict `:` type($result)
</code></pre><p>Returns y if x &lt; y, otherwise it returns x, where x and y are treated as signed integers.</p><p>Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.</p><p>All of the operands, including the Result Type operand, must be of the same type.</p><h4 id=example-53>Example:&nbsp;<a class=headline-hash href=#example-53>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_min <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>s_min <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclsin-spirvclsinop><code>spirv.CL.sin</code> (spirv::CLSinOp)&nbsp;<a class=headline-hash href=#spirvclsin-spirvclsinop>¶</a></h3><p><em>Compute sine of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.sin` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-54>Example:&nbsp;<a class=headline-hash href=#example-54>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sin <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sin <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclsinh-spirvclsinhop><code>spirv.CL.sinh</code> (spirv::CLSinhOp)&nbsp;<a class=headline-hash href=#spirvclsinh-spirvclsinhop>¶</a></h3><p><em>Compute hyperbolic sine of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.sinh` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-55>Example:&nbsp;<a class=headline-hash href=#example-55>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sinh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sinh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclsqrt-spirvclsqrtop><code>spirv.CL.sqrt</code> (spirv::CLSqrtOp)&nbsp;<a class=headline-hash href=#spirvclsqrt-spirvclsqrtop>¶</a></h3><p><em>Compute square root of x.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.sqrt` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-56>Example:&nbsp;<a class=headline-hash href=#example-56>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sqrt <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>sqrt <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcltan-spirvcltanop><code>spirv.CL.tan</code> (spirv::CLTanOp)&nbsp;<a class=headline-hash href=#spirvcltan-spirvcltanop>¶</a></h3><p><em>Compute tangent of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.tan` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-57>Example:&nbsp;<a class=headline-hash href=#example-57>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>tan <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>tan <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcltanh-spirvcltanhop><code>spirv.CL.tanh</code> (spirv::CLTanhOp)&nbsp;<a class=headline-hash href=#spirvcltanh-spirvcltanhop>¶</a></h3><p><em>Compute hyperbolic tangent of x radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.tanh` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type and x must be floating-point or vector(2,3,4,8,16) of
floating-point values.</p><p>All of the operands, including the Result Type operand, must be of the
same type.</p><h4 id=example-58>Example:&nbsp;<a class=headline-hash href=#example-58>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>tanh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>tanh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclu_max-spirvclumaxop><code>spirv.CL.u_max</code> (spirv::CLUMaxOp)&nbsp;<a class=headline-hash href=#spirvclu_max-spirvclumaxop>¶</a></h3><p><em>Return maximum of two unsigned integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.u_max` operands attr-dict `:` type($result)
</code></pre><p>Returns y if x &lt; y, otherwise it returns x, where x and y are treated as unsigned integers.</p><p>Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.</p><p>All of the operands, including the Result Type operand, must be of the same type.</p><h4 id=example-59>Example:&nbsp;<a class=headline-hash href=#example-59>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>u_max <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>u_max <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvclu_min-spirvcluminop><code>spirv.CL.u_min</code> (spirv::CLUMinOp)&nbsp;<a class=headline-hash href=#spirvclu_min-spirvcluminop>¶</a></h3><p><em>Return minimum of two unsigned integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CL.u_min` operands attr-dict `:` type($result)
</code></pre><p>Returns y if x &lt; y, otherwise it returns x, where x and y are treated as unsigned integers.</p><p>Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.</p><p>All of the operands, including the Result Type operand, must be of the same type.</p><h4 id=example-60>Example:&nbsp;<a class=headline-hash href=#example-60>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>u_min <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>CL<span class=p>.</span>u_min <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvcompositeconstruct-spirvcompositeconstructop><code>spirv.CompositeConstruct</code> (spirv::CompositeConstructOp)&nbsp;<a class=headline-hash href=#spirvcompositeconstruct-spirvcompositeconstructop>¶</a></h3><p><em>Construct a new composite object from a set of constituent objects.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.CompositeConstruct` $constituents attr-dict `:` `(` type(operands) `)` `-&gt;` type($result)
</code></pre><p>Result Type must be a composite type, whose top-level
members/elements/components/columns have the same type as the types of
the operands, with one exception. The exception is that for constructing
a vector, the operands may also be vectors with the same component type
as the Result Type component type. When constructing a vector, the total
number of components in all the operands must equal the number of
components in Result Type.</p><p>Constituents will become members of a structure, or elements of an
array, or components of a vector, or columns of a matrix. There must be
exactly one Constituent for each top-level
member/element/component/column of the result, with one exception. The
exception is that for constructing a vector, a contiguous subset of the
scalars consumed can be represented by a vector operand instead. The
Constituents must appear in the order needed by the definition of the
type of the result. When constructing a vector, there must be at least
two Constituent operands.</p><h4 id=example-61>Example:&nbsp;<a class=headline-hash href=#example-61>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeConstruct <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeConstruct <span class=nv>%a</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%c</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeConstruct <span class=nv>%1</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>coopmatrix<span class=p>&lt;</span><span class=m>4x4x</span><span class=k>f32</span><span class=p>,</span> Subgroup<span class=p>,</span> MatrixA<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%d</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeConstruct <span class=nv>%a</span><span class=p>,</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%5</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>f32</span><span class=p>)&gt;)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>f32</span><span class=p>)&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>constituents</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvcompositeextract-spirvcompositeextractop><code>spirv.CompositeExtract</code> (spirv::CompositeExtractOp)&nbsp;<a class=headline-hash href=#spirvcompositeextract-spirvcompositeextractop>¶</a></h3><p><em>Extract a part of a composite object.</em></p><p>Result Type must be the type of object selected by the last provided
index. The instruction result is the extracted object.</p><p>Composite is the composite to extract from.</p><p>Indexes walk the type hierarchy, potentially down to component
granularity, to select the part to extract. All indexes must be in
bounds. All composite constituents use zero-based numbering, as
described by their OpType… instruction.</p><pre tabindex=0><code>composite-extract-op ::= ssa-id `=` `spirv.CompositeExtract` ssa-use
                         `[` integer-literal (&#39;,&#39; integer-literal)* `]`
                         `:` composite-type
</code></pre><h4 id=example-62>Example:&nbsp;<a class=headline-hash href=#example-62>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span> <span class=p>[</span><span class=s>&#34;Volatile&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeExtract <span class=nv>%1</span><span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>indices</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>composite</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>component</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvcompositeinsert-spirvcompositeinsertop><code>spirv.CompositeInsert</code> (spirv::CompositeInsertOp)&nbsp;<a class=headline-hash href=#spirvcompositeinsert-spirvcompositeinsertop>¶</a></h3><p><em>Make a copy of a composite object, while modifying one part of it.</em></p><p>Result Type must be the same type as Composite.</p><p>Object is the object to use as the modified part.</p><p>Composite is the composite to copy all but the modified part from.</p><p>Indexes walk the type hierarchy of Composite to the desired depth,
potentially down to component granularity, to select the part to modify.
All indexes must be in bounds. All composite constituents use zero-based
numbering, as described by their OpType… instruction. The type of the
part selected to modify must match the type of Object.</p><pre tabindex=0><code>composite-insert-op ::= ssa-id `=` `spirv.CompositeInsert` ssa-use, ssa-use
                        `[` integer-literal (&#39;,&#39; integer-literal)* `]`
                        `:` object-type `into` composite-type
</code></pre><h4 id=example-63>Example:&nbsp;<a class=headline-hash href=#example-63>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>CompositeInsert <span class=nv>%object</span><span class=p>,</span> <span class=nv>%composite</span><span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span> into <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>indices</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>object</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr><tr><td style=text-align:center><code>composite</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvconstant-spirvconstantop><code>spirv.Constant</code> (spirv::ConstantOp)&nbsp;<a class=headline-hash href=#spirvconstant-spirvconstantop>¶</a></h3><p><em>Declare a new integer-type or floating-point-type scalar constant.</em></p><p>This op declares a SPIR-V normal constant. SPIR-V has multiple constant
instructions covering different constant types:</p><ul><li><code>OpConstantTrue</code> and <code>OpConstantFalse</code> for boolean constants</li><li><code>OpConstant</code> for scalar constants</li><li><code>OpConstantComposite</code> for composite constants</li><li><code>OpConstantNull</code> for null constants</li><li>&mldr;</li></ul><p>Having such a plethora of constant instructions renders IR transformations
more tedious. Therefore, we use a single <code>spirv.Constant</code> op to represent
them all. Note that conversion between those SPIR-V constant instructions
and this op is purely mechanical; so it can be scoped to the binary
(de)serialization process.</p><pre tabindex=0><code>spirv.Constant-op ::= ssa-id `=` `spirv.Constant` attribute-value
                    (`:` spirv-type)?
</code></pre><h4 id=example-64>Example:&nbsp;<a class=headline-hash href=#example-64>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Constant true
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Constant dense<span class=p>&lt;[</span><span class=m>2.0</span><span class=p>,</span> <span class=m>3.0</span><span class=p>]&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=p>[</span>dense<span class=p>&lt;</span><span class=m>3.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>TODO: support constant structs</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>constant</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvcontrolbarrier-spirvcontrolbarrierop><code>spirv.ControlBarrier</code> (spirv::ControlBarrierOp)&nbsp;<a class=headline-hash href=#spirvcontrolbarrier-spirvcontrolbarrierop>¶</a></h3><p><em>Wait for other invocations of this module to reach the current point of
execution.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ControlBarrier` $execution_scope `,` $memory_scope `,` $memory_semantics attr-dict
</code></pre><p>All invocations of this module within Execution scope must reach this
point of execution before any invocation will proceed beyond it.</p><p>When Execution is Workgroup or larger, behavior is undefined if this
instruction is used in control flow that is non-uniform within
Execution. When Execution is Subgroup or Invocation, the behavior of
this instruction in non-uniform control flow is defined by the client
API.</p><p>If Semantics is not None, this instruction also serves as an
OpMemoryBarrier instruction, and must also perform and adhere to the
description and semantics of an OpMemoryBarrier instruction with the
same Memory and Semantics operands. This allows atomically specifying
both a control barrier and a memory barrier (that is, without needing
two instructions). If Semantics is None, Memory is ignored.</p><p>Before version 1.3, it is only valid to use this instruction with
TessellationControl, GLCompute, or Kernel execution models. There is no
such restriction starting with version 1.3.</p><p>When used with the TessellationControl execution model, it also
implicitly synchronizes the Output Storage Class: Writes to Output
variables performed by any invocation executed prior to a
OpControlBarrier will be visible to any other invocation after return
from that OpControlBarrier.</p><h4 id=example-65>Example:&nbsp;<a class=headline-hash href=#example-65>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ControlBarrier <span class=p>&lt;</span>Workgroup<span class=p>&gt;,</span> <span class=p>&lt;</span>Device<span class=p>&gt;,</span> <span class=p>&lt;</span>Acquire<span class=err>|</span>UniformMemory<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h3 id=spirvconvertftos-spirvconvertftosop><code>spirv.ConvertFToS</code> (spirv::ConvertFToSOp)&nbsp;<a class=headline-hash href=#spirvconvertftos-spirvconvertftosop>¶</a></h3><p><em>Convert value numerically from floating point to signed integer, with
round toward 0.0.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertFToS` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-66>Example:&nbsp;<a class=headline-hash href=#example-66>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToS <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToS <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvconvertftou-spirvconvertftouop><code>spirv.ConvertFToU</code> (spirv::ConvertFToUOp)&nbsp;<a class=headline-hash href=#spirvconvertftou-spirvconvertftouop>¶</a></h3><p><em>Convert value numerically from floating point to unsigned integer, with
round toward 0.0.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertFToU` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-67>Example:&nbsp;<a class=headline-hash href=#example-67>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToU <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToU <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvconvertptrtou-spirvconvertptrtouop><code>spirv.ConvertPtrToU</code> (spirv::ConvertPtrToUOp)&nbsp;<a class=headline-hash href=#spirvconvertptrtou-spirvconvertptrtouop>¶</a></h3><p><em>Bit pattern-preserving conversion of a pointer to
an unsigned scalar integer of possibly different bit width.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertPtrToU` $pointer attr-dict `:` type($pointer) `to` type($result)
</code></pre><p>Result Type must be a scalar of integer type, whose Signedness operand is 0.</p><p>Pointer must be a physical pointer type. If the bit width of Pointer is
smaller than that of Result Type, the conversion zero extends Pointer.
If the bit width of Pointer is larger than that of Result Type,
the conversion truncates Pointer.</p><p>For same bit width Pointer and Result Type, this is the same as OpBitcast.</p><h4 id=example-68>Example:&nbsp;<a class=headline-hash href=#example-68>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertPtrToU <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Generic<span class=p>&gt;</span> to <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvconvertstof-spirvconvertstofop><code>spirv.ConvertSToF</code> (spirv::ConvertSToFOp)&nbsp;<a class=headline-hash href=#spirvconvertstof-spirvconvertstofop>¶</a></h3><p><em>Convert value numerically from signed integer to floating point.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertSToF` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Signed Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-69>Example:&nbsp;<a class=headline-hash href=#example-69>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertSToF <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span> to <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertSToF <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h3 id=spirvconvertutof-spirvconvertutofop><code>spirv.ConvertUToF</code> (spirv::ConvertUToFOp)&nbsp;<a class=headline-hash href=#spirvconvertutof-spirvconvertutofop>¶</a></h3><p><em>Convert value numerically from unsigned integer to floating point.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertUToF` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Unsigned Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-70>Example:&nbsp;<a class=headline-hash href=#example-70>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertUToF <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span> to <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertUToF <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h3 id=spirvconvertutoptr-spirvconvertutoptrop><code>spirv.ConvertUToPtr</code> (spirv::ConvertUToPtrOp)&nbsp;<a class=headline-hash href=#spirvconvertutoptr-spirvconvertutoptrop>¶</a></h3><p><em>Bit pattern-preserving conversion of an unsigned scalar integer
to a pointer.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ConvertUToPtr` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a physical pointer type.</p><p>Integer Value must be a scalar of integer type, whose Signedness
operand is 0. If the bit width of Integer Value is smaller
than that of Result Type, the conversion zero extends Integer Value.
If the bit width of Integer Value is larger than that of Result Type,
the conversion truncates Integer Value.</p><p>For same-width Integer Value and Result Type, this is the same as OpBitcast.</p><h4 id=example-71>Example:&nbsp;<a class=headline-hash href=#example-71>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertUToPtr <span class=nv>%0</span> <span class=p>:</span>  <span class=k>i32</span> to <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Generic<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>UnsignedOp</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvcopymemory-spirvcopymemoryop><code>spirv.CopyMemory</code> (spirv::CopyMemoryOp)&nbsp;<a class=headline-hash href=#spirvcopymemory-spirvcopymemoryop>¶</a></h3><p><em>Copy from the memory pointed to by Source to the memory pointed to by
Target. Both operands must be non-void pointers and having the same <id>Type operand in their OpTypePointer type declaration. Matching Storage
Class is not required. The amount of memory copied is the size of the
type pointed to. The copied type must have a fixed size; i.e., it must
not be, nor include, any OpTypeRuntimeArray types.</em></p><p>If present, any Memory Operands must begin with a memory operand
literal. If not present, it is the same as specifying the memory operand
None. Before version 1.4, at most one memory operands mask can be
provided. Starting with version 1.4 two masks can be provided, as
described in Memory Operands. If no masks or only one mask is present,
it applies to both Source and Target. If two masks are present, the
first applies to Target and cannot include MakePointerVisible, and the
second applies to Source and cannot include MakePointerAvailable.</p><pre tabindex=0><code>copy-memory-op ::= `spirv.CopyMemory ` storage-class ssa-use
                   storage-class ssa-use
                   (`[` memory-access `]` (`, [` memory-access `]`)?)?
                   ` : ` spirv-element-type
</code></pre><h4 id=example-72>Example:&nbsp;<a class=headline-hash href=#example-72>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>CopyMemory <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=s>&#34;Function&#34;</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_access</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr><tr><td><code>source_memory_access</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>source_alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr></table><h4 id=operands-69>Operands:&nbsp;<a class=headline-hash href=#operands-69>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>target</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>source</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvdot-spirvdotop><code>spirv.Dot</code> (spirv::DotOp)&nbsp;<a class=headline-hash href=#spirvdot-spirvdotop>¶</a></h3><p><em>Dot product of Vector 1 and Vector 2</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Dot` operands attr-dict `:` type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be a floating point scalar.</p><p>Vector 1 and Vector 2 must be vectors of the same type, and their component
type must be Result Type.</p><h4 id=example-73>Example:&nbsp;<a class=headline-hash href=#example-73>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Dot <span class=nv>%v1</span><span class=p>,</span> <span class=nv>%v2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-70>Operands:&nbsp;<a class=headline-hash href=#operands-70>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or BFloat16</td></tr></tbody></table><h3 id=spirvextatomicfadd-spirvextatomicfaddop><code>spirv.EXT.AtomicFAdd</code> (spirv::EXTAtomicFAddOp)&nbsp;<a class=headline-hash href=#spirvextatomicfadd-spirvextatomicfaddop>¶</a></h3><p><em>TBD</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EXT.AtomicFAdd` $memory_scope $semantics operands attr-dict `:` type($pointer)
</code></pre><p>Perform the following steps atomically with respect to any other atomic
accesses within Scope to the same location:</p><ol><li><p>load through Pointer to get an Original Value,</p></li><li><p>get a New Value by float addition of Original Value and Value, and</p></li><li><p>store the New Value back through Pointer.</p></li></ol><p>The instruction&rsquo;s result is the Original Value.</p><p>Result Type must be a floating-point type scalar.</p><p>The type of Value must be the same as Result Type. The type of the value
pointed to by Pointer must be the same as Result Type.</p><p>Memory must be a valid memory Scope.</p><h4 id=example-74>Example:&nbsp;<a class=headline-hash href=#example-74>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>EXT<span class=p>.</span>AtomicFAdd <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>None<span class=p>&gt;</span> <span class=nv>%pointer</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>                       <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> StorageBuffer<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h4 id=operands-71>Operands:&nbsp;<a class=headline-hash href=#operands-71>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float</td></tr></tbody></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float</td></tr></tbody></table><h3 id=spirvextconstantcompositereplicate-spirvextconstantcompositereplicateop><code>spirv.EXT.ConstantCompositeReplicate</code> (spirv::EXTConstantCompositeReplicateOp)&nbsp;<a class=headline-hash href=#spirvextconstantcompositereplicate-spirvextconstantcompositereplicateop>¶</a></h3><p><em>Declare a new replicated composite constant op.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EXT.ConstantCompositeReplicate` ` ` `[` $value `]` `:` type($replicated_constant) attr-dict
</code></pre><p>Represents a splat composite constant i.e., all elements of composite constant
have the same value.</p><h4 id=example-75>Example:&nbsp;<a class=headline-hash href=#example-75>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>EXT<span class=p>.</span>ConstantCompositeReplicate <span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>EXT<span class=p>.</span>ConstantCompositeReplicate <span class=p>[</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>EXT<span class=p>.</span>ConstantCompositeReplicate <span class=p>[</span>dense<span class=p>&lt;[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>replicated_constant</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvextemitmeshtasks-spirvextemitmeshtasksop><code>spirv.EXT.EmitMeshTasks</code> (spirv::EXTEmitMeshTasksOp)&nbsp;<a class=headline-hash href=#spirvextemitmeshtasks-spirvextemitmeshtasksop>¶</a></h3><p><em>Defines the grid size of subsequent mesh shader workgroups to generate upon
completion of the task shader workgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EXT.EmitMeshTasks` operands attr-dict `:` type(operands)
</code></pre><p>Defines the grid size of subsequent mesh shader workgroups to generate upon
completion of the task shader workgroup.</p><p>Group Count X Y Z must each be a 32-bit unsigned integer value. They
configure the number of local workgroups in each respective dimensions for the
launch of child mesh tasks. See Vulkan API specification for more detail.</p><p>Payload is an optional pointer to the payload structure to pass to the
generated mesh shader invocations. Payload must be the result of an OpVariable
with a storage class of TaskPayloadWorkgroupEXT.</p><p>The arguments are taken from the first invocation in each workgroup.
Behaviour is undefined if any invocation terminates without executing this
instruction, or if any invocation executes this instruction in non-uniform
control flow.</p><p>This instruction also serves as an OpControlBarrier instruction, and also
performs and adheres to the description and semantics of an OpControlBarrier
instruction with the Execution and Memory operands set to Workgroup and the
Semantics operand set to a combination of WorkgroupMemory and AcquireRelease.</p><p>Ceases all further processing: Only instructions executed before
OpEmitMeshTasksEXT have observable side effects.</p><p>This instruction must be the last instruction in a block.</p><p>This instruction is only valid in the TaskEXT Execution Model.</p><h4 id=example-76>Example:&nbsp;<a class=headline-hash href=#example-76>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>EmitMeshTasksEXT <span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>EmitMeshTasksEXT <span class=nv>%x</span><span class=p>,</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%z</span><span class=p>,</span> <span class=nv>%payload</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> TaskPayloadWorkgroupEXT<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-72>Operands:&nbsp;<a class=headline-hash href=#operands-72>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>group_count_x</code></td><td>32-bit signless/unsigned integer</td></tr><tr><td style=text-align:center><code>group_count_y</code></td><td>32-bit signless/unsigned integer</td></tr><tr><td style=text-align:center><code>group_count_z</code></td><td>32-bit signless/unsigned integer</td></tr><tr><td style=text-align:center><code>payload</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvextsetmeshoutputs-spirvextsetmeshoutputsop><code>spirv.EXT.SetMeshOutputs</code> (spirv::EXTSetMeshOutputsOp)&nbsp;<a class=headline-hash href=#spirvextsetmeshoutputs-spirvextsetmeshoutputsop>¶</a></h3><p><em>Sets the actual output size of the primitives and vertices that the mesh
shader workgroup will emit upon completion.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EXT.SetMeshOutputs` operands attr-dict `:` type(operands)
</code></pre><p>Vertex Count must be a 32-bit unsigned integer value. It defines the array size
of per-vertex outputs.</p><p>Primitive Count must a 32-bit unsigned integer value. It defines the array size
of per-primitive outputs.</p><p>The arguments are taken from the first invocation in each workgroup. Behavior
is undefined if any invocation executes this instruction more than once or
under non-uniform control flow. Behavior is undefined if there is any control
flow path to an output write that is not preceded by this instruction.</p><p>This instruction is only valid in the MeshEXT Execution Model.</p><h4 id=example-77>Example:&nbsp;<a class=headline-hash href=#example-77>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>SetMeshOutputsEXT <span class=nv>%vcount</span><span class=p>,</span> <span class=nv>%pcount</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-73>Operands:&nbsp;<a class=headline-hash href=#operands-73>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vertex_count</code></td><td>32-bit signless/unsigned integer</td></tr><tr><td style=text-align:center><code>primitive_count</code></td><td>32-bit signless/unsigned integer</td></tr></tbody></table><h3 id=spirvextspecconstantcompositereplicate-spirvextspecconstantcompositereplicateop><code>spirv.EXT.SpecConstantCompositeReplicate</code> (spirv::EXTSpecConstantCompositeReplicateOp)&nbsp;<a class=headline-hash href=#spirvextspecconstantcompositereplicate-spirvextspecconstantcompositereplicateop>¶</a></h3><p><em>Declare a new replicated composite specialization constant op.</em></p><p>Represents a splat spec composite constant i.e., all elements of spec composite
constant have the same value. The splat value must come from a symbol reference
of spec constant instruction.</p><h4 id=example-78>Example:&nbsp;<a class=headline-hash href=#example-78>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@sc_i32_1</span> <span class=p>=</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>EXT<span class=p>.</span>SpecConstantCompositeReplicate <span class=nf>@scc_splat_array_of_i32</span> <span class=p>(</span><span class=nf>@sc_i32_1</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>EXT<span class=p>.</span>SpecConstantCompositeReplicate <span class=nf>@scc_splat_struct_of_i32</span> <span class=p>(</span><span class=nf>@sc_i32_1</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>constituent</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h3 id=spirvemitvertex-spirvemitvertexop><code>spirv.EmitVertex</code> (spirv::EmitVertexOp)&nbsp;<a class=headline-hash href=#spirvemitvertex-spirvemitvertexop>¶</a></h3><p><em>Emits the current values of all output variables to the current output
primitive. After execution, the values of all output variables are
undefined.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EmitVertex` attr-dict
</code></pre><p>This instruction must only be used when only one stream is present.</p><h4 id=example-79>Example:&nbsp;<a class=headline-hash href=#example-79>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>EmitVertex
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h3 id=spirvendprimitive-spirvendprimitiveop><code>spirv.EndPrimitive</code> (spirv::EndPrimitiveOp)&nbsp;<a class=headline-hash href=#spirvendprimitive-spirvendprimitiveop>¶</a></h3><p><em>Finish the current primitive and start a new one. No vertex is emitted.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.EndPrimitive` attr-dict
</code></pre><p>This instruction must only be used when only one stream is present.</p><h4 id=example-80>Example:&nbsp;<a class=headline-hash href=#example-80>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>EndPrimitive
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h3 id=spirventrypoint-spirventrypointop><code>spirv.EntryPoint</code> (spirv::EntryPointOp)&nbsp;<a class=headline-hash href=#spirventrypoint-spirventrypointop>¶</a></h3><p><em>Declare an entry point, its execution model, and its interface.</em></p><p>Execution Model is the execution model for the entry point and its
static call tree. See Execution Model.</p><p>Entry Point must be the Result <id>of an OpFunction instruction.</p><p>Name is a name string for the entry point. A module cannot have two
OpEntryPoint instructions with the same Execution Model and the same
Name string.</p><p>Interface is a list of symbol references to <code>spirv.GlobalVariable</code>
operations. These declare the set of global variables from a
module that form the interface of this entry point. The set of
Interface symbols must be equal to or a superset of the
<code>spirv.GlobalVariable</code>s referenced by the entry point’s static call
tree, within the interface’s storage classes. Before version 1.4,
the interface’s storage classes are limited to the Input and
Output storage classes. Starting with version 1.4, the interface’s
storage classes are all storage classes used in declaring all
global variables referenced by the entry point’s call tree.</p><pre tabindex=0><code>execution-model ::= &#34;Vertex&#34; | &#34;TesellationControl&#34; |
                    &lt;and other SPIR-V execution models...&gt;

entry-point-op ::= ssa-id `=` `spirv.EntryPoint` execution-model
                   symbol-reference (`, ` symbol-reference)*
</code></pre><h4 id=example-81>Example:&nbsp;<a class=headline-hash href=#example-81>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>EntryPoint <span class=s>&#34;GLCompute&#34;</span> <span class=nf>@foo</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>EntryPoint <span class=s>&#34;Kernel&#34;</span> <span class=nf>@foo</span><span class=p>,</span> <span class=nf>@var1</span><span class=p>,</span> <span class=nf>@var2</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_model</code></td><td>::mlir::spirv::ExecutionModelAttr</td><td>valid SPIR-V ExecutionModel</td></tr><tr><td><code>fn</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>interface</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr></table><h3 id=spirvexecutionmode-spirvexecutionmodeop><code>spirv.ExecutionMode</code> (spirv::ExecutionModeOp)&nbsp;<a class=headline-hash href=#spirvexecutionmode-spirvexecutionmodeop>¶</a></h3><p><em>Declare an execution mode for an entry point.</em></p><p>Entry Point must be the Entry Point <id>operand of an OpEntryPoint
instruction.</p><p>Mode is the execution mode. See Execution Mode.</p><p>This instruction is only valid when the Mode operand is an execution
mode that takes no Extra Operands, or takes Extra Operands that are not
<id>operands.</p><pre tabindex=0><code>execution-mode ::= &#34;Invocations&#34; | &#34;SpacingEqual&#34; |
                   &lt;and other SPIR-V execution modes...&gt;

execution-mode-op ::= `spirv.ExecutionMode ` ssa-use execution-mode
                      (integer-literal (`, ` integer-literal)* )?
</code></pre><h4 id=example-82>Example:&nbsp;<a class=headline-hash href=#example-82>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ExecutionMode <span class=nf>@foo</span> <span class=s>&#34;ContractionOff&#34;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>ExecutionMode <span class=nf>@bar</span> <span class=s>&#34;LocalSizeHint&#34;</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>,</span> <span class=m>5</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fn</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>execution_mode</code></td><td>::mlir::spirv::ExecutionModeAttr</td><td>valid SPIR-V ExecutionMode</td></tr><tr><td><code>values</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h3 id=spirvfadd-spirvfaddop><code>spirv.FAdd</code> (spirv::FAddOp)&nbsp;<a class=headline-hash href=#spirvfadd-spirvfaddop>¶</a></h3><p><em>Floating-point addition of Operand 1 and Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FAdd` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h4 id=example-83>Example:&nbsp;<a class=headline-hash href=#example-83>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FAdd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FAdd <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-74>Operands:&nbsp;<a class=headline-hash href=#operands-74>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvfconvert-spirvfconvertop><code>spirv.FConvert</code> (spirv::FConvertOp)&nbsp;<a class=headline-hash href=#spirvfconvert-spirvfconvertop>¶</a></h3><p><em>Convert value numerically from one floating-point width to another
width.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FConvert` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Float Value must be a scalar or vector of floating-point type. It must
have the same number of components as Result Type. The component width
cannot equal the component width in Result Type.</p><p>Results are computed per component.</p><h4 id=example-84>Example:&nbsp;<a class=headline-hash href=#example-84>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>FConvertOp <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>f64</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>FConvertOp <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-75>Operands:&nbsp;<a class=headline-hash href=#operands-75>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or BFloat16 or fixed-length vector of 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float or BFloat16 values</td></tr></tbody></table><h3 id=spirvfdiv-spirvfdivop><code>spirv.FDiv</code> (spirv::FDivOp)&nbsp;<a class=headline-hash href=#spirvfdiv-spirvfdivop>¶</a></h3><p><em>Floating-point division of Operand 1 divided by Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FDiv` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h4 id=example-85>Example:&nbsp;<a class=headline-hash href=#example-85>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FDiv <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FDiv <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-76>Operands:&nbsp;<a class=headline-hash href=#operands-76>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvfmod-spirvfmodop><code>spirv.FMod</code> (spirv::FModOp)&nbsp;<a class=headline-hash href=#spirvfmod-spirvfmodop>¶</a></h3><p><em>The floating-point remainder whose sign matches the sign of Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FMod` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 2.</p><h4 id=example-86>Example:&nbsp;<a class=headline-hash href=#example-86>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FMod <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FMod <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-77>Operands:&nbsp;<a class=headline-hash href=#operands-77>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfmul-spirvfmulop><code>spirv.FMul</code> (spirv::FMulOp)&nbsp;<a class=headline-hash href=#spirvfmul-spirvfmulop>¶</a></h3><p><em>Floating-point multiplication of Operand 1 and Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FMul` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h4 id=example-87>Example:&nbsp;<a class=headline-hash href=#example-87>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FMul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FMul <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-78>Operands:&nbsp;<a class=headline-hash href=#operands-78>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvfnegate-spirvfnegateop><code>spirv.FNegate</code> (spirv::FNegateOp)&nbsp;<a class=headline-hash href=#spirvfnegate-spirvfnegateop>¶</a></h3><p><em>Inverts the sign bit of Operand. (Note, however, that OpFNegate is still
considered a floating-point instruction, and so is subject to the
general floating-point rules regarding, for example, subnormals and NaN
propagation).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FNegate` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The type of Operand must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-88>Example:&nbsp;<a class=headline-hash href=#example-88>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>FNegate <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>FNegate <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-79>Operands:&nbsp;<a class=headline-hash href=#operands-79>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-77>Results:&nbsp;<a class=headline-hash href=#results-77>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvfordequal-spirvfordequalop><code>spirv.FOrdEqual</code> (spirv::FOrdEqualOp)&nbsp;<a class=headline-hash href=#spirvfordequal-spirvfordequalop>¶</a></h3><p><em>Floating-point comparison for being ordered and equal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-89>Example:&nbsp;<a class=headline-hash href=#example-89>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-80>Operands:&nbsp;<a class=headline-hash href=#operands-80>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-78>Results:&nbsp;<a class=headline-hash href=#results-78>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfordgreaterthanequal-spirvfordgreaterthanequalop><code>spirv.FOrdGreaterThanEqual</code> (spirv::FOrdGreaterThanEqualOp)&nbsp;<a class=headline-hash href=#spirvfordgreaterthanequal-spirvfordgreaterthanequalop>¶</a></h3><p><em>Floating-point comparison if operands are ordered and Operand 1 is
greater than or equal to Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdGreaterThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-90>Example:&nbsp;<a class=headline-hash href=#example-90>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdGreaterThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdGreaterThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-81>Operands:&nbsp;<a class=headline-hash href=#operands-81>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-79>Results:&nbsp;<a class=headline-hash href=#results-79>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfordgreaterthan-spirvfordgreaterthanop><code>spirv.FOrdGreaterThan</code> (spirv::FOrdGreaterThanOp)&nbsp;<a class=headline-hash href=#spirvfordgreaterthan-spirvfordgreaterthanop>¶</a></h3><p><em>Floating-point comparison if operands are ordered and Operand 1 is
greater than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdGreaterThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-91>Example:&nbsp;<a class=headline-hash href=#example-91>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdGreaterThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdGreaterThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-82>Operands:&nbsp;<a class=headline-hash href=#operands-82>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-80>Results:&nbsp;<a class=headline-hash href=#results-80>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfordlessthanequal-spirvfordlessthanequalop><code>spirv.FOrdLessThanEqual</code> (spirv::FOrdLessThanEqualOp)&nbsp;<a class=headline-hash href=#spirvfordlessthanequal-spirvfordlessthanequalop>¶</a></h3><p><em>Floating-point comparison if operands are ordered and Operand 1 is less
than or equal to Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdLessThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-92>Example:&nbsp;<a class=headline-hash href=#example-92>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdLessThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdLessThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-83>Operands:&nbsp;<a class=headline-hash href=#operands-83>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-81>Results:&nbsp;<a class=headline-hash href=#results-81>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfordlessthan-spirvfordlessthanop><code>spirv.FOrdLessThan</code> (spirv::FOrdLessThanOp)&nbsp;<a class=headline-hash href=#spirvfordlessthan-spirvfordlessthanop>¶</a></h3><p><em>Floating-point comparison if operands are ordered and Operand 1 is less
than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdLessThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-93>Example:&nbsp;<a class=headline-hash href=#example-93>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdLessThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdLessThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-84>Operands:&nbsp;<a class=headline-hash href=#operands-84>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-82>Results:&nbsp;<a class=headline-hash href=#results-82>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfordnotequal-spirvfordnotequalop><code>spirv.FOrdNotEqual</code> (spirv::FOrdNotEqualOp)&nbsp;<a class=headline-hash href=#spirvfordnotequal-spirvfordnotequalop>¶</a></h3><p><em>Floating-point comparison for being ordered and not equal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FOrdNotEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-94>Example:&nbsp;<a class=headline-hash href=#example-94>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdNotEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FOrdNotEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-85>Operands:&nbsp;<a class=headline-hash href=#operands-85>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-83>Results:&nbsp;<a class=headline-hash href=#results-83>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfrem-spirvfremop><code>spirv.FRem</code> (spirv::FRemOp)&nbsp;<a class=headline-hash href=#spirvfrem-spirvfremop>¶</a></h3><p><em>The floating-point remainder whose sign matches the sign of Operand 1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FRem` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 1.</p><h4 id=example-95>Example:&nbsp;<a class=headline-hash href=#example-95>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FRemOp <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FRemOp <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-86>Operands:&nbsp;<a class=headline-hash href=#operands-86>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-84>Results:&nbsp;<a class=headline-hash href=#results-84>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfsub-spirvfsubop><code>spirv.FSub</code> (spirv::FSubOp)&nbsp;<a class=headline-hash href=#spirvfsub-spirvfsubop>¶</a></h3><p><em>Floating-point subtraction of Operand 2 from Operand 1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FSub` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component.</p><h4 id=example-96>Example:&nbsp;<a class=headline-hash href=#example-96>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FRemOp <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FRemOp <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-87>Operands:&nbsp;<a class=headline-hash href=#operands-87>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-85>Results:&nbsp;<a class=headline-hash href=#results-85>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvfunordequal-spirvfunordequalop><code>spirv.FUnordEqual</code> (spirv::FUnordEqualOp)&nbsp;<a class=headline-hash href=#spirvfunordequal-spirvfunordequalop>¶</a></h3><p><em>Floating-point comparison for being unordered or equal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-97>Example:&nbsp;<a class=headline-hash href=#example-97>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-88>Operands:&nbsp;<a class=headline-hash href=#operands-88>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-86>Results:&nbsp;<a class=headline-hash href=#results-86>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunordgreaterthanequal-spirvfunordgreaterthanequalop><code>spirv.FUnordGreaterThanEqual</code> (spirv::FUnordGreaterThanEqualOp)&nbsp;<a class=headline-hash href=#spirvfunordgreaterthanequal-spirvfunordgreaterthanequalop>¶</a></h3><p><em>Floating-point comparison if operands are unordered or Operand 1 is
greater than or equal to Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordGreaterThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-98>Example:&nbsp;<a class=headline-hash href=#example-98>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordGreaterThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordGreaterThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-89>Operands:&nbsp;<a class=headline-hash href=#operands-89>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-87>Results:&nbsp;<a class=headline-hash href=#results-87>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunordgreaterthan-spirvfunordgreaterthanop><code>spirv.FUnordGreaterThan</code> (spirv::FUnordGreaterThanOp)&nbsp;<a class=headline-hash href=#spirvfunordgreaterthan-spirvfunordgreaterthanop>¶</a></h3><p><em>Floating-point comparison if operands are unordered or Operand 1 is
greater than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordGreaterThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-99>Example:&nbsp;<a class=headline-hash href=#example-99>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordGreaterThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordGreaterThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-90>Operands:&nbsp;<a class=headline-hash href=#operands-90>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-88>Results:&nbsp;<a class=headline-hash href=#results-88>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunordlessthanequal-spirvfunordlessthanequalop><code>spirv.FUnordLessThanEqual</code> (spirv::FUnordLessThanEqualOp)&nbsp;<a class=headline-hash href=#spirvfunordlessthanequal-spirvfunordlessthanequalop>¶</a></h3><p><em>Floating-point comparison if operands are unordered or Operand 1 is less
than or equal to Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordLessThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-100>Example:&nbsp;<a class=headline-hash href=#example-100>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordLessThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordLessThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-91>Operands:&nbsp;<a class=headline-hash href=#operands-91>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-89>Results:&nbsp;<a class=headline-hash href=#results-89>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunordlessthan-spirvfunordlessthanop><code>spirv.FUnordLessThan</code> (spirv::FUnordLessThanOp)&nbsp;<a class=headline-hash href=#spirvfunordlessthan-spirvfunordlessthanop>¶</a></h3><p><em>Floating-point comparison if operands are unordered or Operand 1 is less
than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordLessThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-101>Example:&nbsp;<a class=headline-hash href=#example-101>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordLessThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordLessThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-92>Operands:&nbsp;<a class=headline-hash href=#operands-92>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-90>Results:&nbsp;<a class=headline-hash href=#results-90>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunordnotequal-spirvfunordnotequalop><code>spirv.FUnordNotEqual</code> (spirv::FUnordNotEqualOp)&nbsp;<a class=headline-hash href=#spirvfunordnotequal-spirvfunordnotequalop>¶</a></h3><p><em>Floating-point comparison for being unordered or not equal.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FUnordNotEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
floating-point type. They must have the same type, and they must have
the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-102>Example:&nbsp;<a class=headline-hash href=#example-102>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordNotEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>FUnordNotEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-93>Operands:&nbsp;<a class=headline-hash href=#operands-93>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-91>Results:&nbsp;<a class=headline-hash href=#results-91>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvfunc-spirvfuncop><code>spirv.func</code> (spirv::FuncOp)&nbsp;<a class=headline-hash href=#spirvfunc-spirvfuncop>¶</a></h3><p><em>Declare or define a function</em></p><p>This op declares or defines a SPIR-V function using one region, which
contains one or more blocks.</p><p>Different from the SPIR-V binary format, this op is not allowed to
implicitly capture global values, and all external references must use
function arguments or symbol references. This op itself defines a symbol
that is unique in the enclosing module op.</p><p>This op itself takes no operands and generates no results. Its region
can take zero or more arguments and return zero or one values.</p><p>From <code>SPV_KHR_physical_storage_buffer</code>:
If a parameter of function is</p><ul><li>a pointer (or contains a pointer) in the PhysicalStorageBuffer storage
class, the function parameter must be decorated with exactly one of
<code>Aliased</code> or <code>Restrict</code>.</li><li>a pointer (or contains a pointer) and the type it points to is a pointer
in the PhysicalStorageBuffer storage class, the function parameter must
be decorated with exactly one of <code>AliasedPointer</code> or <code>RestrictPointer</code>.</li></ul><pre tabindex=0><code>spv-function-control ::= &#34;None&#34; | &#34;Inline&#34; | &#34;DontInline&#34; | ...
spv-function-op ::= `spirv.func` function-signature
                     spv-function-control region
</code></pre><h4 id=example-103>Example:&nbsp;<a class=headline-hash href=#example-103>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;Inline|Pure&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@aliased_pointer</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> PhysicalStorageBuffer<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=nl>spirv.decoration =</span> <span class=nv>#spirv.decoration</span><span class=p>&lt;</span>Aliased<span class=p>&gt;</span> <span class=p>})</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@restrict_pointer</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> PhysicalStorageBuffer<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span> <span class=nl>spirv.decoration =</span> <span class=nv>#spirv.decoration</span><span class=p>&lt;</span>Restrict<span class=p>&gt;</span> <span class=p>})</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@aliased_pointee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    PhysicalStorageBuffer<span class=p>&gt;,</span> Generic<span class=p>&gt;</span> <span class=p>{</span> <span class=nl>spirv.decoration =</span>
</span></span><span class=line><span class=cl>    <span class=nv>#spirv.decoration</span><span class=p>&lt;</span>AliasedPointer<span class=p>&gt;</span> <span class=p>})</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@restrict_pointee</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    PhysicalStorageBuffer<span class=p>&gt;,</span> Generic<span class=p>&gt;</span> <span class=p>{</span> <span class=nl>spirv.decoration =</span>
</span></span><span class=line><span class=cl>    <span class=nv>#spirv.decoration</span><span class=p>&lt;</span>RestrictPointer<span class=p>&gt;</span> <span class=p>})</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=s>&#34;None&#34;</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_control</code></td><td>::mlir::spirv::FunctionControlAttr</td><td>valid SPIR-V FunctionControl</td></tr><tr><td><code>linkage_attributes</code></td><td>::mlir::spirv::LinkageAttributesAttr</td><td></td></tr></table><h3 id=spirvfunctioncall-spirvfunctioncallop><code>spirv.FunctionCall</code> (spirv::FunctionCallOp)&nbsp;<a class=headline-hash href=#spirvfunctioncall-spirvfunctioncallop>¶</a></h3><p><em>Call a function.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.FunctionCall` $callee `(` $arguments `)` attr-dict `:`
              functional-type($arguments, results)
</code></pre><p>Result Type is the type of the return value of the function. It must be
the same as the Return Type operand of the Function Type operand of the
Function operand.</p><p>Function is an OpFunction instruction. This could be a forward
reference.</p><p>Argument N is the object to copy to parameter N of Function.</p><p>Note: A forward call is possible because there is no missing type
information: Result Type must match the Return Type of the function, and
the calling argument types must match the formal parameter types.</p><h4 id=example-104>Example:&nbsp;<a class=headline-hash href=#example-104>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>FunctionCall <span class=nf>@f_void</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span>  <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>FunctionCall <span class=nf>@f_iadd</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-94>Operands:&nbsp;<a class=headline-hash href=#operands-94>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-92>Results:&nbsp;<a class=headline-hash href=#results-92>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>return_value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvglacos-spirvglacosop><code>spirv.GL.Acos</code> (spirv::GLAcosOp)&nbsp;<a class=headline-hash href=#spirvglacos-spirvglacosop>¶</a></h3><p><em>Arc Cosine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Acos` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric arc cosine of x radians.</p><p>Result is an angle, in radians, whose cosine is x. The range of result
values is [0, π]. Result is undefined if abs x > 1.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-105>Example:&nbsp;<a class=headline-hash href=#example-105>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Acos <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Acos <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-95>Operands:&nbsp;<a class=headline-hash href=#operands-95>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-93>Results:&nbsp;<a class=headline-hash href=#results-93>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglacosh-spirvglacoshop><code>spirv.GL.Acosh</code> (spirv::GLAcoshOp)&nbsp;<a class=headline-hash href=#spirvglacosh-spirvglacoshop>¶</a></h3><p><em>Arc hyperbolic cosine of operand in radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Acosh` $operand `:` type($operand) attr-dict
</code></pre><p>Arc hyperbolic cosine; result is the non-negative inverse of cosh. The resulting
value is NaN if x &lt; 1.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-106>Example:&nbsp;<a class=headline-hash href=#example-106>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Acosh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Acosh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-96>Operands:&nbsp;<a class=headline-hash href=#operands-96>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-94>Results:&nbsp;<a class=headline-hash href=#results-94>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglasin-spirvglasinop><code>spirv.GL.Asin</code> (spirv::GLAsinOp)&nbsp;<a class=headline-hash href=#spirvglasin-spirvglasinop>¶</a></h3><p><em>Arc Sine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Asin` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric arc sine of x radians.</p><p>Result is an angle, in radians, whose sine is x. The range of result values
is [-π / 2, π / 2]. Result is undefined if abs x > 1.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-107>Example:&nbsp;<a class=headline-hash href=#example-107>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Asin <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Asin <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-97>Operands:&nbsp;<a class=headline-hash href=#operands-97>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-95>Results:&nbsp;<a class=headline-hash href=#results-95>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglasinh-spirvglasinhop><code>spirv.GL.Asinh</code> (spirv::GLAsinhOp)&nbsp;<a class=headline-hash href=#spirvglasinh-spirvglasinhop>¶</a></h3><p><em>Arc hyperbolic sine of operand in radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Asinh` $operand `:` type($operand) attr-dict
</code></pre><p>Arc hyperbolic sine; result is the inverse of sinh.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-108>Example:&nbsp;<a class=headline-hash href=#example-108>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Asinh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Asinh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-98>Operands:&nbsp;<a class=headline-hash href=#operands-98>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-96>Results:&nbsp;<a class=headline-hash href=#results-96>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglatan-spirvglatanop><code>spirv.GL.Atan</code> (spirv::GLAtanOp)&nbsp;<a class=headline-hash href=#spirvglatan-spirvglatanop>¶</a></h3><p><em>Arc Tangent of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Atan` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric arc tangent of x radians.</p><p>Result is an angle, in radians, whose tangent is y_over_x. The range of
result values is [-π / 2, π / 2].</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-109>Example:&nbsp;<a class=headline-hash href=#example-109>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Atan <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Atan <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-99>Operands:&nbsp;<a class=headline-hash href=#operands-99>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-97>Results:&nbsp;<a class=headline-hash href=#results-97>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglatanh-spirvglatanhop><code>spirv.GL.Atanh</code> (spirv::GLAtanhOp)&nbsp;<a class=headline-hash href=#spirvglatanh-spirvglatanhop>¶</a></h3><p><em>Arc hyperbolic tangent of operand in radians.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Atanh` $operand `:` type($operand) attr-dict
</code></pre><p>Arc hyperbolic tangent; result is the inverse of tanh. The resulting value
is NaN if abs x ≥ 1.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-110>Example:&nbsp;<a class=headline-hash href=#example-110>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Atanh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Atanh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-100>Operands:&nbsp;<a class=headline-hash href=#operands-100>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-98>Results:&nbsp;<a class=headline-hash href=#results-98>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglceil-spirvglceilop><code>spirv.GL.Ceil</code> (spirv::GLCeilOp)&nbsp;<a class=headline-hash href=#spirvglceil-spirvglceilop>¶</a></h3><p><em>Rounds up to the next whole number</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Ceil` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the value equal to the nearest whole number that is greater than
or equal to x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-111>Example:&nbsp;<a class=headline-hash href=#example-111>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Ceil <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Ceil <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-101>Operands:&nbsp;<a class=headline-hash href=#operands-101>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-99>Results:&nbsp;<a class=headline-hash href=#results-99>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglcos-spirvglcosop><code>spirv.GL.Cos</code> (spirv::GLCosOp)&nbsp;<a class=headline-hash href=#spirvglcos-spirvglcosop>¶</a></h3><p><em>Cosine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Cos` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric cosine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-112>Example:&nbsp;<a class=headline-hash href=#example-112>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cos <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cos <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-102>Operands:&nbsp;<a class=headline-hash href=#operands-102>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-100>Results:&nbsp;<a class=headline-hash href=#results-100>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglcosh-spirvglcoshop><code>spirv.GL.Cosh</code> (spirv::GLCoshOp)&nbsp;<a class=headline-hash href=#spirvglcosh-spirvglcoshop>¶</a></h3><p><em>Hyperbolic cosine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Cosh` $operand `:` type($operand) attr-dict
</code></pre><p>Hyperbolic cosine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-113>Example:&nbsp;<a class=headline-hash href=#example-113>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cosh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cosh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-103>Operands:&nbsp;<a class=headline-hash href=#operands-103>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-101>Results:&nbsp;<a class=headline-hash href=#results-101>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglcross-spirvglcrossop><code>spirv.GL.Cross</code> (spirv::GLCrossOp)&nbsp;<a class=headline-hash href=#spirvglcross-spirvglcrossop>¶</a></h3><p><em>Return the cross product of two 3-component vectors</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Cross` operands attr-dict `:` type($result)
</code></pre><p>Result is the cross product of x and y, i.e., the resulting components are, in order:</p><p>x[1] * y[2] - y[1] * x[2]</p><p>x[2] * y[0] - y[2] * x[0]</p><p>x[0] * y[1] - y[0] * x[1]</p><p>All the operands must be vectors of 3 components of a floating-point type.</p><p>Result Type and the type of all operands must be the same type.</p><h4 id=example-114>Example:&nbsp;<a class=headline-hash href=#example-114>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cross <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Cross <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-104>Operands:&nbsp;<a class=headline-hash href=#operands-104>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-102>Results:&nbsp;<a class=headline-hash href=#results-102>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgldistance-spirvgldistanceop><code>spirv.GL.Distance</code> (spirv::GLDistanceOp)&nbsp;<a class=headline-hash href=#spirvgldistance-spirvgldistanceop>¶</a></h3><p><em>Return distance between two points</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Distance` operands attr-dict `:` type($p0) `,` type($p1) `-&gt;` type($result)
</code></pre><p>Result is the distance between p0 and p1, i.e., length(p0 - p1).</p><p>The operands must all be a scalar or vector whose component type is floating-point.</p><p>Result Type must be a scalar of the same type as the component type of the operands.</p><h4 id=example-115>Example:&nbsp;<a class=headline-hash href=#example-115>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Distance <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-105>Operands:&nbsp;<a class=headline-hash href=#operands-105>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>p0</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>p1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-103>Results:&nbsp;<a class=headline-hash href=#results-103>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float</td></tr></tbody></table><h3 id=spirvglexp2-spirvglexp2op><code>spirv.GL.Exp2</code> (spirv::GLExp2Op)&nbsp;<a class=headline-hash href=#spirvglexp2-spirvglexp2op>¶</a></h3><p><em>Result is 2 raised to the x power</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Exp2` $operand `:` type($operand) attr-dict
</code></pre><p>Result is 2 raised to the x power; 2**x.</p><pre tabindex=0><code>exp2(Inf) = Inf.
exp2(-Inf) = +0.
</code></pre><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-116>Example:&nbsp;<a class=headline-hash href=#example-116>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Exp2 <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Exp2 <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-106>Operands:&nbsp;<a class=headline-hash href=#operands-106>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-104>Results:&nbsp;<a class=headline-hash href=#results-104>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglexp-spirvglexpop><code>spirv.GL.Exp</code> (spirv::GLExpOp)&nbsp;<a class=headline-hash href=#spirvglexp-spirvglexpop>¶</a></h3><p><em>Exponentiation of Operand 1</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Exp` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the natural exponentiation of x; e^x.</p><p>The operand x must be a scalar or vector whose component type is
16-bit or 32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are
computed per component.";</p><h4 id=example-117>Example:&nbsp;<a class=headline-hash href=#example-117>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Exp <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Exp <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-107>Operands:&nbsp;<a class=headline-hash href=#operands-107>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-105>Results:&nbsp;<a class=headline-hash href=#results-105>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfabs-spirvglfabsop><code>spirv.GL.FAbs</code> (spirv::GLFAbsOp)&nbsp;<a class=headline-hash href=#spirvglfabs-spirvglfabsop>¶</a></h3><p><em>Absolute value of operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FAbs` $operand `:` type($operand) attr-dict
</code></pre><p>Result is x if x >= 0; otherwise result is -x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-118>Example:&nbsp;<a class=headline-hash href=#example-118>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FAbs <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FAbs <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-108>Operands:&nbsp;<a class=headline-hash href=#operands-108>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-106>Results:&nbsp;<a class=headline-hash href=#results-106>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfclamp-spirvglfclampop><code>spirv.GL.FClamp</code> (spirv::GLFClampOp)&nbsp;<a class=headline-hash href=#spirvglfclamp-spirvglfclampop>¶</a></h3><p><em>Clamp x between min and max values.</em></p><p>Result is min(max(x, minVal), maxVal). The resulting value is undefined if
minVal > maxVal. The semantics used by min() and max() are those of FMin and
FMax.</p><p>The operands must all be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of all operands must be the same type. Results are
computed per component.</p><pre tabindex=0><code>fclamp-op ::= ssa-id `=` `spirv.GL.FClamp` ssa-use, ssa-use, ssa-use `:`
           float-scalar-vector-type
</code></pre><h4 id=example-119>Example:&nbsp;<a class=headline-hash href=#example-119>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-109>Operands:&nbsp;<a class=headline-hash href=#operands-109>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-107>Results:&nbsp;<a class=headline-hash href=#results-107>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfmax-spirvglfmaxop><code>spirv.GL.FMax</code> (spirv::GLFMaxOp)&nbsp;<a class=headline-hash href=#spirvglfmax-spirvglfmaxop>¶</a></h3><p><em>Return maximum of two floating-point operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FMax` operands attr-dict `:` type($result)
</code></pre><p>Result is y if x &lt; y; otherwise result is x. Which operand is the
result is undefined if one of the operands is a NaN.</p><p>The operands must all be a scalar or vector whose component type
is floating-point.</p><p>Result Type and the type of all operands must be the same
type. Results are computed per component.</p><h4 id=example-120>Example:&nbsp;<a class=headline-hash href=#example-120>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-110>Operands:&nbsp;<a class=headline-hash href=#operands-110>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-108>Results:&nbsp;<a class=headline-hash href=#results-108>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfmin-spirvglfminop><code>spirv.GL.FMin</code> (spirv::GLFMinOp)&nbsp;<a class=headline-hash href=#spirvglfmin-spirvglfminop>¶</a></h3><p><em>Return minimum of two floating-point operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FMin` operands attr-dict `:` type($result)
</code></pre><p>Result is y if y &lt; x; otherwise result is x. Which operand is the result is
undefined if one of the operands is a NaN.</p><p>The operands must all be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of all operands must be the same type. Results are
computed per component.</p><h4 id=example-121>Example:&nbsp;<a class=headline-hash href=#example-121>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-111>Operands:&nbsp;<a class=headline-hash href=#operands-111>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-109>Results:&nbsp;<a class=headline-hash href=#results-109>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfmix-spirvglfmixop><code>spirv.GL.FMix</code> (spirv::GLFMixOp)&nbsp;<a class=headline-hash href=#spirvglfmix-spirvglfmixop>¶</a></h3><p><em>Builds the linear blend of x and y</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FMix` attr-dict $x `:` type($x) `,` $y `:` type($y) `,` $a `:` type($a) `-&gt;` type($result)
</code></pre><p>Result is the linear blend of x and y, i.e., x * (1 - a) + y * a.</p><p>The operands must all be a scalar or vector whose component type is floating-point.</p><p>Result Type and the type of all operands must be the same type. Results are computed per component.</p><h4 id=example-122>Example:&nbsp;<a class=headline-hash href=#example-122>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMix <span class=nv>%x</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%y</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FMix <span class=nv>%x</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%y</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-112>Operands:&nbsp;<a class=headline-hash href=#operands-112>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>a</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-110>Results:&nbsp;<a class=headline-hash href=#results-110>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfsign-spirvglfsignop><code>spirv.GL.FSign</code> (spirv::GLFSignOp)&nbsp;<a class=headline-hash href=#spirvglfsign-spirvglfsignop>¶</a></h3><p><em>Returns the sign of the operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FSign` $operand `:` type($operand) attr-dict
</code></pre><p>Result is 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x &lt; 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-123>Example:&nbsp;<a class=headline-hash href=#example-123>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FSign <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FSign <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-113>Operands:&nbsp;<a class=headline-hash href=#operands-113>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-111>Results:&nbsp;<a class=headline-hash href=#results-111>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfindilsb-spirvglfindilsbop><code>spirv.GL.FindILsb</code> (spirv::GLFindILsbOp)&nbsp;<a class=headline-hash href=#spirvglfindilsb-spirvglfindilsbop>¶</a></h3><p><em>Integer least-significant bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FindILsb` $operand `:` type($operand) attr-dict
</code></pre><p>Results in the bit number of the least-significant 1-bit in the binary
representation of Value. If Value is 0, the result is -1.</p><p>Result Type and the type of Value must both be integer scalar or
integer vector types. Result Type and operand types must have the
same number of components with the same component width. Results are
computed per component.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-114>Operands:&nbsp;<a class=headline-hash href=#operands-114>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-112>Results:&nbsp;<a class=headline-hash href=#results-112>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfindsmsb-spirvglfindsmsbop><code>spirv.GL.FindSMsb</code> (spirv::GLFindSMsbOp)&nbsp;<a class=headline-hash href=#spirvglfindsmsb-spirvglfindsmsbop>¶</a></h3><p><em>Signed-integer most-significant bit, with Value interpreted as a signed integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FindSMsb` $operand `:` type($operand) attr-dict
</code></pre><p>For positive numbers, the result will be the bit number of the most significant
1-bit. For negative numbers, the result will be the bit number of the most
significant 0-bit. For a Value of 0 or -1, the result is -1.</p><p>Result Type and the type of Value must both be integer scalar or
integer vector types. Result Type and operand types must have the
same number of components with the same component width. Results are
computed per component.</p><p>This instruction is currently limited to 32-bit width components.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-115>Operands:&nbsp;<a class=headline-hash href=#operands-115>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Int32 or fixed-length vector of Int32 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-113>Results:&nbsp;<a class=headline-hash href=#results-113>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Int32 or fixed-length vector of Int32 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfindumsb-spirvglfindumsbop><code>spirv.GL.FindUMsb</code> (spirv::GLFindUMsbOp)&nbsp;<a class=headline-hash href=#spirvglfindumsb-spirvglfindumsbop>¶</a></h3><p><em>Unsigned-integer most-significant bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FindUMsb` $operand `:` type($operand) attr-dict
</code></pre><p>Results in the bit number of the most-significant 1-bit in the binary
representation of Value. If Value is 0, the result is -1.</p><p>Result Type and the type of Value must both be integer scalar or
integer vector types. Result Type and operand types must have the
same number of components with the same component width. Results are
computed per component.</p><p>This instruction is currently limited to 32-bit width components.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-116>Operands:&nbsp;<a class=headline-hash href=#operands-116>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Int32 or fixed-length vector of Int32 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-114>Results:&nbsp;<a class=headline-hash href=#results-114>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Int32 or fixed-length vector of Int32 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfloor-spirvglfloorop><code>spirv.GL.Floor</code> (spirv::GLFloorOp)&nbsp;<a class=headline-hash href=#spirvglfloor-spirvglfloorop>¶</a></h3><p><em>Rounds down to the next whole number</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Floor` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the value equal to the nearest whole number that is less than or
equal to x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-124>Example:&nbsp;<a class=headline-hash href=#example-124>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Floor <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Floor <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-117>Operands:&nbsp;<a class=headline-hash href=#operands-117>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-115>Results:&nbsp;<a class=headline-hash href=#results-115>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfma-spirvglfmaop><code>spirv.GL.Fma</code> (spirv::GLFmaOp)&nbsp;<a class=headline-hash href=#spirvglfma-spirvglfmaop>¶</a></h3><p><em>Computes a * b + c.</em></p><p>In uses where this operation is decorated with NoContraction:</p><ul><li>fma is considered a single operation, whereas the expression a * b + c
is considered two operations.</li><li>The precision of fma can differ from the precision of the expression
a * b + c.</li><li>fma will be computed with the same precision as any other fma decorated
with NoContraction, giving invariant results for the same input values
of a, b, and c.</li></ul><p>Otherwise, in the absence of a NoContraction decoration, there are no
special constraints on the number of operations or difference in precision
between fma and the expression a * b +c.</p><p>The operands must all be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of all operands must be the same type. Results
are computed per component.</p><pre tabindex=0><code>fma-op ::= ssa-id `=` `spirv.GL.Fma` ssa-use, ssa-use, ssa-use `:`
           float-scalar-vector-type
</code></pre><h4 id=example-125>Example:&nbsp;<a class=headline-hash href=#example-125>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Fma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Fma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-118>Operands:&nbsp;<a class=headline-hash href=#operands-118>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-116>Results:&nbsp;<a class=headline-hash href=#results-116>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfract-spirvglfractop><code>spirv.GL.Fract</code> (spirv::GLFractOp)&nbsp;<a class=headline-hash href=#spirvglfract-spirvglfractop>¶</a></h3><p><em>Returns the <code>x - floor(x)</code> of the operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Fract` $operand `:` type($operand) attr-dict
</code></pre><p>Result is:</p><pre tabindex=0><code>fract(x) = x - floor(x)
fract(±0) = +0
fract(±Inf) = NaN
</code></pre><p>The operand x must be a scalar or vector whose component type is floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed per component.</p><h4 id=example-126>Example:&nbsp;<a class=headline-hash href=#example-126>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sqrt <span class=nv>%x</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sqrt <span class=nv>%x</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-119>Operands:&nbsp;<a class=headline-hash href=#operands-119>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-117>Results:&nbsp;<a class=headline-hash href=#results-117>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglfrexpstruct-spirvglfrexpstructop><code>spirv.GL.FrexpStruct</code> (spirv::GLFrexpStructOp)&nbsp;<a class=headline-hash href=#spirvglfrexpstruct-spirvglfrexpstructop>¶</a></h3><p><em>Splits x into two components such that x = significand * 2^exponent</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.FrexpStruct` attr-dict $operand `:` type($operand) `-&gt;` type($result)
</code></pre><p>Result is a structure containing x split into a floating-point significand
in the range (-1.0, 0.5] or [0.5, 1.0) and an integral exponent of 2, such that:</p><p>x = significand * 2^exponent</p><p>If x is a zero, the exponent is 0.0. If x is an infinity or a NaN, the
exponent is undefined. If x is 0.0, the significand is 0.0. If x is -0.0,
the significand is -0.0</p><p>Result Type must be an OpTypeStruct with two members. Member 0 must have
the same type as the type of x. Member 0 holds the significand. Member 1
must be a scalar or vector with integer component type, with 32-bit
component width. Member 1 holds the exponent. These two members and x must
have the same number of components.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><h4 id=example-127>Example:&nbsp;<a class=headline-hash href=#example-127>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FrexpStruct <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>FrexpStruct <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-120>Operands:&nbsp;<a class=headline-hash href=#operands-120>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-118>Results:&nbsp;<a class=headline-hash href=#results-118>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V struct type</td></tr></tbody></table><h3 id=spirvglinversesqrt-spirvglinversesqrtop><code>spirv.GL.InverseSqrt</code> (spirv::GLInverseSqrtOp)&nbsp;<a class=headline-hash href=#spirvglinversesqrt-spirvglinversesqrtop>¶</a></h3><p><em>Reciprocal of sqrt(operand)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.InverseSqrt` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the reciprocal of sqrt x. Result is undefined if x &lt;= 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-128>Example:&nbsp;<a class=headline-hash href=#example-128>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>InverseSqrt <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>InverseSqrt <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-121>Operands:&nbsp;<a class=headline-hash href=#operands-121>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-119>Results:&nbsp;<a class=headline-hash href=#results-119>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglldexp-spirvglldexpop><code>spirv.GL.Ldexp</code> (spirv::GLLdexpOp)&nbsp;<a class=headline-hash href=#spirvglldexp-spirvglldexpop>¶</a></h3><p><em>Builds y such that y = significand * 2^exponent</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Ldexp` attr-dict $x `:` type($x) `,` $exp `:` type($exp) `-&gt;` type($y)
</code></pre><p>Builds a floating-point number from x and the corresponding
integral exponent of two in exp:</p><p>significand * 2^exponent</p><p>If this product is too large to be represented in the floating-point
type, the resulting value is undefined. If exp is greater than +128
(single precision) or +1024 (double precision), the resulting value is
undefined. If exp is less than -126 (single precision) or -1022 (double precision),
the result may be flushed to zero. Additionally, splitting the value
into a significand and exponent using frexp and then reconstructing a
floating-point value using ldexp should yield the original input for
zero and all finite non-denormalized values.</p><p>The operand x must be a scalar or vector whose component type is floating-point.</p><p>The exp operand must be a scalar or vector with integer component type.
The number of components in x and exp must be the same.</p><p>Result Type must be the same type as the type of x. Results are computed per
component.</p><h4 id=example-129>Example:&nbsp;<a class=headline-hash href=#example-129>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%y</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Ldexp <span class=nv>%x</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%exp</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%y</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Ldexp <span class=nv>%x</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=nv>%exp</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-122>Operands:&nbsp;<a class=headline-hash href=#operands-122>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>exp</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-120>Results:&nbsp;<a class=headline-hash href=#results-120>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>y</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgllength-spirvgllengthop><code>spirv.GL.Length</code> (spirv::GLLengthOp)&nbsp;<a class=headline-hash href=#spirvgllength-spirvgllengthop>¶</a></h3><p><em>Return the length of a vector x</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Length` $operand attr-dict `:` type($operand) `-&gt;` type($result)
</code></pre><p>Result is the length of vector x, i.e., sqrt(x[0]**2 + x[1]**2 + &mldr;).</p><p>The operand x must be a scalar or vector whose component type is floating-point.</p><p>Result Type must be a scalar of the same type as the component type of x.</p><h4 id=example-130>Example:&nbsp;<a class=headline-hash href=#example-130>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Length <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Length <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-123>Operands:&nbsp;<a class=headline-hash href=#operands-123>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-121>Results:&nbsp;<a class=headline-hash href=#results-121>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float</td></tr></tbody></table><h3 id=spirvgllog2-spirvgllog2op><code>spirv.GL.Log2</code> (spirv::GLLog2Op)&nbsp;<a class=headline-hash href=#spirvgllog2-spirvgllog2op>¶</a></h3><p><em>Result is the base-2 logarithm of x</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Log2` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the base-2 logarithm of x, i.e., the value y which satisfies the
equation x = 2**y. The resulting value is NaN if x &lt; 0. Moreover:</p><pre tabindex=0><code>log(Inf) = Inf
log(1.0) = +0
log(±0) = -Inf
</code></pre><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-131>Example:&nbsp;<a class=headline-hash href=#example-131>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Log2 <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Log2 <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-124>Operands:&nbsp;<a class=headline-hash href=#operands-124>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-122>Results:&nbsp;<a class=headline-hash href=#results-122>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgllog-spirvgllogop><code>spirv.GL.Log</code> (spirv::GLLogOp)&nbsp;<a class=headline-hash href=#spirvgllog-spirvgllogop>¶</a></h3><p><em>Natural logarithm of the operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Log` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the natural logarithm of x, i.e., the value y which satisfies the
equation x = ey. Result is undefined if x &lt;= 0.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-132>Example:&nbsp;<a class=headline-hash href=#example-132>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Log <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Log <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-125>Operands:&nbsp;<a class=headline-hash href=#operands-125>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-123>Results:&nbsp;<a class=headline-hash href=#results-123>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglnormalize-spirvglnormalizeop><code>spirv.GL.Normalize</code> (spirv::GLNormalizeOp)&nbsp;<a class=headline-hash href=#spirvglnormalize-spirvglnormalizeop>¶</a></h3><p><em>Normalizes a vector operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Normalize` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the vector in the same direction as x but with a length of 1.</p><p>The operand x must be a scalar or vector whose component type is floating-point.</p><p>Result Type and the type of x must be the same type.</p><h4 id=example-133>Example:&nbsp;<a class=headline-hash href=#example-133>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Normalize <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Normalize <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-126>Operands:&nbsp;<a class=headline-hash href=#operands-126>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-124>Results:&nbsp;<a class=headline-hash href=#results-124>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglpackhalf2x16-spirvglpackhalf2x16op><code>spirv.GL.PackHalf2x16</code> (spirv::GLPackHalf2x16Op)&nbsp;<a class=headline-hash href=#spirvglpackhalf2x16-spirvglpackhalf2x16op>¶</a></h3><p><em>Pack two-component vector of 32-bit floats into a 32-bit integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.PackHalf2x16` attr-dict $operand `:` type($operand) `-&gt;` type($result)
</code></pre><p>Result is the unsigned integer obtained by converting the components of a
two-component floating-point vector to the 16-bit OpTypeFloat, and then packing
these two 16-bit integers into a 32-bit unsigned integer. The first vector
component specifies the 16 least-significant bits of the result; the second
component specifies the 16 most-significant bits.</p><p>The RelaxedPrecision Decoration only affects the conversion step of the instruction.</p><p>The v operand must be a vector of 2 components whose type is a 32-bit floating-point.</p><p>Result Type must be a 32-bit integer type.</p><h4 id=example-134>Example:&nbsp;<a class=headline-hash href=#example-134>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>PackHalf2x16 <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-127>Operands:&nbsp;<a class=headline-hash href=#operands-127>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>vector of Float32 values of length 2</td></tr></tbody></table><h4 id=results-125>Results:&nbsp;<a class=headline-hash href=#results-125>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Int32</td></tr></tbody></table><h3 id=spirvglpow-spirvglpowop><code>spirv.GL.Pow</code> (spirv::GLPowOp)&nbsp;<a class=headline-hash href=#spirvglpow-spirvglpowop>¶</a></h3><p><em>Return x raised to the y power of two operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Pow` operands attr-dict `:` type($result)
</code></pre><p>Result is x raised to the y power; x^y.</p><p>Result is undefined if x = 0 and y ≤ 0.</p><p>The operand x and y must be a scalar or vector whose component type is
16-bit or 32-bit floating-point.</p><p>Result Type and the type of all operands must be the same type. Results are
computed per component.</p><h4 id=example-135>Example:&nbsp;<a class=headline-hash href=#example-135>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Pow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Pow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-128>Operands:&nbsp;<a class=headline-hash href=#operands-128>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-126>Results:&nbsp;<a class=headline-hash href=#results-126>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglreflect-spirvglreflectop><code>spirv.GL.Reflect</code> (spirv::GLReflectOp)&nbsp;<a class=headline-hash href=#spirvglreflect-spirvglreflectop>¶</a></h3><p><em>Calculate reflection direction vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Reflect` operands attr-dict `:` type($result)
</code></pre><p>For the incident vector I and surface orientation N, the result is the reflection direction:</p><p>I - 2 * dot(N, I) * N</p><p>N must already be normalized in order to achieve the desired result.</p><p>The operands must all be a scalar or vector whose component type is floating-point.</p><p>Result Type and the type of all operands must be the same type.</p><h4 id=example-136>Example:&nbsp;<a class=headline-hash href=#example-136>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Reflect <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Reflect <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-129>Operands:&nbsp;<a class=headline-hash href=#operands-129>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-127>Results:&nbsp;<a class=headline-hash href=#results-127>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglroundeven-spirvglroundevenop><code>spirv.GL.RoundEven</code> (spirv::GLRoundEvenOp)&nbsp;<a class=headline-hash href=#spirvglroundeven-spirvglroundevenop>¶</a></h3><p><em>Rounds to the nearest even whole number</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.RoundEven` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the value equal to the nearest whole number to x. A fractional
part of 0.5 will round toward the nearest even whole number. (Both 3.5 and
4.5 for x will be 4.0.)</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-137>Example:&nbsp;<a class=headline-hash href=#example-137>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>RoundEven <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>RoundEven <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-130>Operands:&nbsp;<a class=headline-hash href=#operands-130>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-128>Results:&nbsp;<a class=headline-hash href=#results-128>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglround-spirvglroundop><code>spirv.GL.Round</code> (spirv::GLRoundOp)&nbsp;<a class=headline-hash href=#spirvglround-spirvglroundop>¶</a></h3><p><em>Rounds to the nearest whole number</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Round` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the value equal to the nearest whole number to x. The fraction
0.5 will round in a direction chosen by the implementation, presumably
the direction that is fastest. This includes the possibility that
Round x is the same value as RoundEven x for all values of x.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-138>Example:&nbsp;<a class=headline-hash href=#example-138>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Round <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Round <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-131>Operands:&nbsp;<a class=headline-hash href=#operands-131>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-129>Results:&nbsp;<a class=headline-hash href=#results-129>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsabs-spirvglsabsop><code>spirv.GL.SAbs</code> (spirv::GLSAbsOp)&nbsp;<a class=headline-hash href=#spirvglsabs-spirvglsabsop>¶</a></h3><p><em>Absolute value of operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.SAbs` $operand `:` type($operand) attr-dict
</code></pre><p>Result is x if x ≥ 0; otherwise result is -x, where x is interpreted as a
signed integer.</p><p>Result Type and the type of x must both be integer scalar or integer vector
types. Result Type and operand types must have the same number of components
with the same component width. Results are computed per component.</p><h4 id=example-139>Example:&nbsp;<a class=headline-hash href=#example-139>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SAbs <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SAbs <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-132>Operands:&nbsp;<a class=headline-hash href=#operands-132>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-130>Results:&nbsp;<a class=headline-hash href=#results-130>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsclamp-spirvglsclampop><code>spirv.GL.SClamp</code> (spirv::GLSClampOp)&nbsp;<a class=headline-hash href=#spirvglsclamp-spirvglsclampop>¶</a></h3><p><em>Clamp x between min and max values.</em></p><p>Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
interpreted as signed integers. The resulting value is undefined if
minVal > maxVal.</p><p>Result Type and the type of the operands must both be integer scalar or
integer vector types. Result Type and operand types must have the same number
of components with the same component width. Results are computed per
component.</p><pre tabindex=0><code>uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
           sgined-scalar-vector-type
</code></pre><h4 id=example-140>Example:&nbsp;<a class=headline-hash href=#example-140>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> si32
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span>si16<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-133>Operands:&nbsp;<a class=headline-hash href=#operands-133>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-131>Results:&nbsp;<a class=headline-hash href=#results-131>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsmax-spirvglsmaxop><code>spirv.GL.SMax</code> (spirv::GLSMaxOp)&nbsp;<a class=headline-hash href=#spirvglsmax-spirvglsmaxop>¶</a></h3><p><em>Return maximum of two signed integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.SMax` operands attr-dict `:` type($result)
</code></pre><p>Result is y if x &lt; y; otherwise result is x, where x and y are interpreted
as signed integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h4 id=example-141>Example:&nbsp;<a class=headline-hash href=#example-141>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-134>Operands:&nbsp;<a class=headline-hash href=#operands-134>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-132>Results:&nbsp;<a class=headline-hash href=#results-132>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsmin-spirvglsminop><code>spirv.GL.SMin</code> (spirv::GLSMinOp)&nbsp;<a class=headline-hash href=#spirvglsmin-spirvglsminop>¶</a></h3><p><em>Return minimum of two signed integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.SMin` operands attr-dict `:` type($result)
</code></pre><p>Result is y if y &lt; x; otherwise result is x, where x and y are interpreted
as signed integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h4 id=example-142>Example:&nbsp;<a class=headline-hash href=#example-142>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-135>Operands:&nbsp;<a class=headline-hash href=#operands-135>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-133>Results:&nbsp;<a class=headline-hash href=#results-133>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglssign-spirvglssignop><code>spirv.GL.SSign</code> (spirv::GLSSignOp)&nbsp;<a class=headline-hash href=#spirvglssign-spirvglssignop>¶</a></h3><p><em>Returns the sign of the operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.SSign` $operand `:` type($operand) attr-dict
</code></pre><p>Result is 1 if x > 0, 0 if x = 0, or -1 if x &lt; 0, where x is interpreted as
a signed integer.</p><p>Result Type and the type of x must both be integer scalar or integer vector
types. Result Type and operand types must have the same number of components
with the same component width. Results are computed per component.</p><h4 id=example-143>Example:&nbsp;<a class=headline-hash href=#example-143>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SSign <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>SSign <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-136>Operands:&nbsp;<a class=headline-hash href=#operands-136>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-134>Results:&nbsp;<a class=headline-hash href=#results-134>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsin-spirvglsinop><code>spirv.GL.Sin</code> (spirv::GLSinOp)&nbsp;<a class=headline-hash href=#spirvglsin-spirvglsinop>¶</a></h3><p><em>Sine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Sin` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric sine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-144>Example:&nbsp;<a class=headline-hash href=#example-144>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sin <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sin <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-137>Operands:&nbsp;<a class=headline-hash href=#operands-137>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-135>Results:&nbsp;<a class=headline-hash href=#results-135>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsinh-spirvglsinhop><code>spirv.GL.Sinh</code> (spirv::GLSinhOp)&nbsp;<a class=headline-hash href=#spirvglsinh-spirvglsinhop>¶</a></h3><p><em>Hyperbolic sine of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Sinh` $operand `:` type($operand) attr-dict
</code></pre><p>Hyperbolic sine of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-145>Example:&nbsp;<a class=headline-hash href=#example-145>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sinh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sinh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-138>Operands:&nbsp;<a class=headline-hash href=#operands-138>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-136>Results:&nbsp;<a class=headline-hash href=#results-136>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglsqrt-spirvglsqrtop><code>spirv.GL.Sqrt</code> (spirv::GLSqrtOp)&nbsp;<a class=headline-hash href=#spirvglsqrt-spirvglsqrtop>¶</a></h3><p><em>Returns the square root of the operand</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Sqrt` $operand `:` type($operand) attr-dict
</code></pre><p>Result is the square root of x. Result is undefined if x &lt; 0.</p><p>The operand x must be a scalar or vector whose component type is
floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-146>Example:&nbsp;<a class=headline-hash href=#example-146>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sqrt <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Sqrt <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-139>Operands:&nbsp;<a class=headline-hash href=#operands-139>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-137>Results:&nbsp;<a class=headline-hash href=#results-137>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgltan-spirvgltanop><code>spirv.GL.Tan</code> (spirv::GLTanOp)&nbsp;<a class=headline-hash href=#spirvgltan-spirvgltanop>¶</a></h3><p><em>Tangent of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Tan` $operand `:` type($operand) attr-dict
</code></pre><p>The standard trigonometric tangent of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-147>Example:&nbsp;<a class=headline-hash href=#example-147>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Tan <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Tan <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-140>Operands:&nbsp;<a class=headline-hash href=#operands-140>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-138>Results:&nbsp;<a class=headline-hash href=#results-138>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgltanh-spirvgltanhop><code>spirv.GL.Tanh</code> (spirv::GLTanhOp)&nbsp;<a class=headline-hash href=#spirvgltanh-spirvgltanhop>¶</a></h3><p><em>Hyperbolic tangent of operand in radians</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.Tanh` $operand `:` type($operand) attr-dict
</code></pre><p>Hyperbolic tangent of x radians.</p><p>The operand x must be a scalar or vector whose component type is 16-bit or
32-bit floating-point.</p><p>Result Type and the type of x must be the same type. Results are computed
per component.</p><h4 id=example-148>Example:&nbsp;<a class=headline-hash href=#example-148>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Tanh <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>Tanh <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-141>Operands:&nbsp;<a class=headline-hash href=#operands-141>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-139>Results:&nbsp;<a class=headline-hash href=#results-139>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32-bit float or fixed-length vector of 16/32-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgluclamp-spirvgluclampop><code>spirv.GL.UClamp</code> (spirv::GLUClampOp)&nbsp;<a class=headline-hash href=#spirvgluclamp-spirvgluclampop>¶</a></h3><p><em>Clamp x between min and max values.</em></p><p>Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
interpreted as unsigned integers. The resulting value is undefined if
minVal > maxVal.</p><p>Result Type and the type of the operands must both be integer scalar or
integer vector types. Result Type and operand types must have the same number
of components with the same component width. Results are computed per
component.</p><pre tabindex=0><code>uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
           unsigned-signless-scalar-vector-type
</code></pre><h4 id=example-149>Example:&nbsp;<a class=headline-hash href=#example-149>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UClamp <span class=nv>%x</span><span class=p>,</span> <span class=nv>%min</span><span class=p>,</span> <span class=nv>%max</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span>ui16<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-142>Operands:&nbsp;<a class=headline-hash href=#operands-142>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>y</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>z</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-140>Results:&nbsp;<a class=headline-hash href=#results-140>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglumax-spirvglumaxop><code>spirv.GL.UMax</code> (spirv::GLUMaxOp)&nbsp;<a class=headline-hash href=#spirvglumax-spirvglumaxop>¶</a></h3><p><em>Return maximum of two unsigned integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.UMax` operands attr-dict `:` type($result)
</code></pre><p>Result is y if x &lt; y; otherwise result is x, where x and y are interpreted
as unsigned integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h4 id=example-150>Example:&nbsp;<a class=headline-hash href=#example-150>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UMax <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-143>Operands:&nbsp;<a class=headline-hash href=#operands-143>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-141>Results:&nbsp;<a class=headline-hash href=#results-141>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglumin-spirvgluminop><code>spirv.GL.UMin</code> (spirv::GLUMinOp)&nbsp;<a class=headline-hash href=#spirvglumin-spirvgluminop>¶</a></h3><p><em>Return minimum of two unsigned integer operands</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.UMin` operands attr-dict `:` type($result)
</code></pre><p>Result is y if y &lt; x; otherwise result is x, where x and y are interpreted
as unsigned integers.</p><p>Result Type and the type of x and y must both be integer scalar or integer
vector types. Result Type and operand types must have the same number of
components with the same component width. Results are computed per
component.</p><h4 id=example-151>Example:&nbsp;<a class=headline-hash href=#example-151>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UMin <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-144>Operands:&nbsp;<a class=headline-hash href=#operands-144>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-142>Results:&nbsp;<a class=headline-hash href=#results-142>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvglunpackhalf2x16-spirvglunpackhalf2x16op><code>spirv.GL.UnpackHalf2x16</code> (spirv::GLUnpackHalf2x16Op)&nbsp;<a class=headline-hash href=#spirvglunpackhalf2x16-spirvglunpackhalf2x16op>¶</a></h3><p><em>Unpack 32-bit integer into two-component vector of 32-bit floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GL.UnpackHalf2x16` attr-dict $operand `:` type($operand) `-&gt;` type($result)
</code></pre><p>Result is the two-component floating-point vector with components obtained by
unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting
those values as 16-bit floating-point numbers according to the OpenGL
Specification, and converting them to 32-bit floating-point values. Subnormal
numbers are either preserved or flushed to zero, consistently within an
implementation.</p><p>The first component of the vector is obtained from the 16 least-significant bits
of v; the second component is obtained from the 16 most-significant bits of v.</p><p>The RelaxedPrecision Decoration only affects the conversion step of the instruction.</p><p>The v operand must be a scalar with 32-bit integer type.</p><p>Result Type must be a vector of 2 components whose type is 32-bit floating point.</p><h4 id=example-152>Example:&nbsp;<a class=headline-hash href=#example-152>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GL<span class=p>.</span>UnpackHalf2x16 <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-145>Operands:&nbsp;<a class=headline-hash href=#operands-145>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Int32</td></tr></tbody></table><h4 id=results-143>Results:&nbsp;<a class=headline-hash href=#results-143>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of Float32 values of length 2</td></tr></tbody></table><h3 id=spirvgenericcasttoptrexplicit-spirvgenericcasttoptrexplicitop><code>spirv.GenericCastToPtrExplicit</code> (spirv::GenericCastToPtrExplicitOp)&nbsp;<a class=headline-hash href=#spirvgenericcasttoptrexplicit-spirvgenericcasttoptrexplicitop>¶</a></h3><p><em>Attempts to explicitly convert Pointer to Storage storage-class pointer
value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GenericCastToPtrExplicit` $pointer attr-dict `:` type($pointer) `to` type($result)
</code></pre><p>Result Type must be an OpTypePointer. Its Storage Class must be Storage.</p><p>Pointer must have a type of OpTypePointer whose Type is the same as the
Type of Result Type.Pointer must point to the Generic Storage Class. If
the cast fails, the instruction result is an OpConstantNull pointer in
the Storage Storage Class.</p><p>Storage must be one of the following literal values from Storage Class:
Workgroup, CrossWorkgroup, or Function.</p><h4 id=example-153>Example:&nbsp;<a class=headline-hash href=#example-153>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>   <span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GenericCastToPtrExplicitOp <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Generic<span class=p>&gt;</span> to
</span></span><span class=line><span class=cl>   <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkGroup<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-146>Operands:&nbsp;<a class=headline-hash href=#operands-146>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-144>Results:&nbsp;<a class=headline-hash href=#results-144>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvgenericcasttoptr-spirvgenericcasttoptrop><code>spirv.GenericCastToPtr</code> (spirv::GenericCastToPtrOp)&nbsp;<a class=headline-hash href=#spirvgenericcasttoptr-spirvgenericcasttoptrop>¶</a></h3><p><em>Convert a pointer’s Storage Class to a non-Generic class.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GenericCastToPtr` $pointer attr-dict `:` type($pointer) `to` type($result)
</code></pre><p>Result Type must be an OpTypePointer. Its Storage Class must be
Workgroup, CrossWorkgroup, or Function.</p><p>Pointer must point to the Generic Storage Class.</p><p>Result Type and Pointer must point to the same type.</p><h4 id=example-154>Example:&nbsp;<a class=headline-hash href=#example-154>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>   <span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GenericCastToPtrOp <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Generic<span class=p>&gt;</span> to
</span></span><span class=line><span class=cl>   <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkGroup<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-147>Operands:&nbsp;<a class=headline-hash href=#operands-147>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-145>Results:&nbsp;<a class=headline-hash href=#results-145>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvglobalvariable-spirvglobalvariableop><code>spirv.GlobalVariable</code> (spirv::GlobalVariableOp)&nbsp;<a class=headline-hash href=#spirvglobalvariable-spirvglobalvariableop>¶</a></h3><p><em>Allocate an object in memory at module scope. The object is
referenced using a symbol name.</em></p><p>The variable type must be an OpTypePointer. Its type operand is the type of
object in memory.</p><p>Storage Class is the Storage Class of the memory holding the object. It
cannot be Generic. It must be the same as the Storage Class operand of
the variable types. Only those storage classes that are valid at module
scope (like Input, Output, StorageBuffer, etc.) are valid.</p><p>Initializer is optional. If Initializer is present, it will be
the initial value of the variable’s memory content. Initializer
must be an symbol defined from a constant instruction or other
<code>spirv.GlobalVariable</code> operation in module scope. Initializer must
have the same type as the type of the defined symbol.</p><pre tabindex=0><code>variable-op ::= `spirv.GlobalVariable` spirv-type symbol-ref-id
                (`initializer(` symbol-ref-id `)`)?
                (`bind(` integer-literal, integer-literal `)`)?
                (`built_in(` string-literal `)`)?
                attribute-dict?
</code></pre><p>where <code>initializer</code> specifies initializer and <code>bind</code> specifies the
descriptor set and binding number. <code>built_in</code> specifies SPIR-V
BuiltIn decoration associated with the op.</p><h4 id=example-155>Example:&nbsp;<a class=headline-hash href=#example-155>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@var0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Input<span class=p>&gt;</span> <span class=nf>@var0</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@var1</span> initializer<span class=p>(</span><span class=nf>@var0</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Output<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@var2</span> bind<span class=p>(</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Uniform<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@var3</span> built_in<span class=p>(</span><span class=s>&#34;GlobalInvocationId&#34;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> Input<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>initializer</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>location</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>binding</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>descriptor_set</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>built_in</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>linkage_attributes</code></td><td>::mlir::spirv::LinkageAttributesAttr</td><td></td></tr></table><h3 id=spirvarmgraph-spirvgrapharmop><code>spirv.ARM.Graph</code> (spirv::GraphARMOp)&nbsp;<a class=headline-hash href=#spirvarmgraph-spirvgrapharmop>¶</a></h3><p><em>Declare or define a SPIR-V graph</em></p><p>This op declares or defines a SPIR-V graph using one region, which
contains one or more blocks.</p><p>This op is not allowed to implicitly capture global values, and all external
references must use function arguments or symbol references. This op itself
defines a symbol that is unique in the enclosing module op.</p><p>Note that this op does not have a 1:1 mapping to the SPIR-V ops representing
a graph. Indeed during serialization a single GraphARMOp is serialized into
several different SPIR-V ops: OpGraphARM, OpGraphInputARM and OpGraphEndARM.
There are as many occurences of OpGraphInputARM ops as many inputs in the
graph. Deserialization maps that set of operations into a single GraphARMOp.</p><p>This op itself takes no operands and generates no results. Its region
can take zero or more arguments and return one or more values.</p><pre tabindex=0><code>spv-graph-arm-op ::= `spirv.ARM.Graph` function-signature
                    region
</code></pre><h4 id=example-156>Example:&nbsp;<a class=headline-hash href=#example-156>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ARM<span class=p>.</span>Graph <span class=nf>@graph</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>ARM<span class=p>.</span>GraphOutputs <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of graph type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>entry_point</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=spirvarmgraphconstant-spirvgraphconstantarmop><code>spirv.ARM.GraphConstant</code> (spirv::GraphConstantARMOp)&nbsp;<a class=headline-hash href=#spirvarmgraphconstant-spirvgraphconstantarmop>¶</a></h3><p><em>Declare a graph constant.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ARM.GraphConstant` attr-dict `:` type($output)
</code></pre><p>Declare a graph constant.
Result Type must be an OpTypeTensorARM.
GraphConstantID must be a 32-bit integer literal.</p><h4 id=example-157>Example:&nbsp;<a class=headline-hash href=#example-157>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>ARM<span class=p>.</span>GraphConstant <span class=p>{</span> <span class=nl>graph_constant_id =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>}</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>GraphConstantID is a unique identifier which is use to map the contants
defined by GraphConstantARM in the SPIRV module with the one provided at
shader creation time via the VkDataGraphPipelineShaderModuleCreateInfoARM.
That Vulkan structure provides a list of VkDataGraphPipelineConstantARM
which contains the bindings from id to data. (For more details see
<a href=https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#graphs>https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#graphs</a>)</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>graph_constant_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=results-146>Results:&nbsp;<a class=headline-hash href=#results-146>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvarmgraphentrypoint-spirvgraphentrypointarmop><code>spirv.ARM.GraphEntryPoint</code> (spirv::GraphEntryPointARMOp)&nbsp;<a class=headline-hash href=#spirvarmgraphentrypoint-spirvgraphentrypointarmop>¶</a></h3><p><em>Declare a graph entry point and its interface.</em></p><p>Graph Entry Point must be the Result <id>of an OpGraphARM instruction.</p><p>Name is a name string for the graphentry point. A module cannot have two
OpGraphEntryPointARM instructions with the same Name string.</p><p>Interface is a list of symbol references to <code>spirv.GlobalVariable</code>
operations. These declare the set of global variables from a
module that form the interface of this entry point. The set of
Interface symbols must be equal to or a superset of the
<code>spirv.GlobalVariable</code>s referenced by the entry point’s static call
tree, within the interface’s storage classes.</p><h4 id=example-158>Example:&nbsp;<a class=headline-hash href=#example-158>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@arg_0</span> bind<span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>0</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;,</span> UniformConstant<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>GlobalVariable <span class=nf>@res_0</span> bind<span class=p>(</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;,</span> UniformConstant<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>ARM<span class=p>.</span>GraphEntryPoint <span class=nf>@graph</span><span class=p>,</span> <span class=nf>@arg_0</span><span class=p>,</span> <span class=nf>@res_0</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>ARM<span class=p>.</span>Graph <span class=nf>@graph</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fn</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>interface</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr></table><h3 id=spirvarmgraphoutputs-spirvgraphoutputsarmop><code>spirv.ARM.GraphOutputs</code> (spirv::GraphOutputsARMOp)&nbsp;<a class=headline-hash href=#spirvarmgraphoutputs-spirvgraphoutputsarmop>¶</a></h3><p><em>Define graph outputs.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ARM.GraphOutputs` $value attr-dict `:` type($value)
</code></pre><p>Values are the graph outputs values and must match the GraphOutputs Type
operand of the OpTypeGraphARM type of the OpGraphARM body this
instruction is in.</p><p>This instruction must be the last instruction in a block.</p><h4 id=example-159>Example:&nbsp;<a class=headline-hash href=#example-159>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ARM<span class=p>.</span>Graph <span class=nf>@graph</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>ARM<span class=p>.</span>GraphOutputs <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>arm<span class=p>.</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>14x19x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-148>Operands:&nbsp;<a class=headline-hash href=#operands-148>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>variadic of any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupbroadcast-spirvgroupbroadcastop><code>spirv.GroupBroadcast</code> (spirv::GroupBroadcastOp)&nbsp;<a class=headline-hash href=#spirvgroupbroadcast-spirvgroupbroadcastop>¶</a></h3><p><em>Broadcast the Value of the invocation identified by the local id LocalId
to the result of all invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupBroadcast` $execution_scope operands attr-dict `:` type($value) `,` type($localid)
</code></pre><p>All invocations of this module within Execution must reach this point of
execution.</p><p>Behavior is undefined if this instruction is used in control flow that
is non-uniform within Execution.</p><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The type of Value must be the same as Result Type.</p><p>LocalId must be an integer datatype. It can be a scalar, or a vector
with 2 components or a vector with 3 components. LocalId must be the
same for all invocations in the group.</p><h4 id=example-160>Example:&nbsp;<a class=headline-hash href=#example-160>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%scalar_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar_localid</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector_localid</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupBroadcast <span class=s>&#34;Subgroup&#34;</span> <span class=nv>%scalar_value</span><span class=p>,</span> <span class=nv>%scalar_localid</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupBroadcast <span class=s>&#34;Workgroup&#34;</span> <span class=nv>%vector_value</span><span class=p>,</span> <span class=nv>%vector_localid</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-149>Operands:&nbsp;<a class=headline-hash href=#operands-149>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr><tr><td style=text-align:center><code>localid</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-147>Results:&nbsp;<a class=headline-hash href=#results-147>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupfadd-spirvgroupfaddop><code>spirv.GroupFAdd</code> (spirv::GroupFAddOp)&nbsp;<a class=headline-hash href=#spirvgroupfadd-spirvgroupfaddop>¶</a></h3><p><em>A floating-point add group operation specified for all values of X
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupFAdd` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-161>Example:&nbsp;<a class=headline-hash href=#example-161>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupFAdd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-150>Operands:&nbsp;<a class=headline-hash href=#operands-150>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-148>Results:&nbsp;<a class=headline-hash href=#results-148>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupfmax-spirvgroupfmaxop><code>spirv.GroupFMax</code> (spirv::GroupFMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupfmax-spirvgroupfmaxop>¶</a></h3><p><em>A floating-point maximum group operation specified for all values of X
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupFMax` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is -INF.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-162>Example:&nbsp;<a class=headline-hash href=#example-162>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupFMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-151>Operands:&nbsp;<a class=headline-hash href=#operands-151>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-149>Results:&nbsp;<a class=headline-hash href=#results-149>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupfmin-spirvgroupfminop><code>spirv.GroupFMin</code> (spirv::GroupFMinOp)&nbsp;<a class=headline-hash href=#spirvgroupfmin-spirvgroupfminop>¶</a></h3><p><em>A floating-point minimum group operation specified for all values of X
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupFMin` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is +INF.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-163>Example:&nbsp;<a class=headline-hash href=#example-163>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupFMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-152>Operands:&nbsp;<a class=headline-hash href=#operands-152>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-150>Results:&nbsp;<a class=headline-hash href=#results-150>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvkhrgroupfmul-spirvgroupfmulkhrop><code>spirv.KHR.GroupFMul</code> (spirv::GroupFMulKHROp)&nbsp;<a class=headline-hash href=#spirvkhrgroupfmul-spirvgroupfmulkhrop>¶</a></h3><p><em>A floating-point multiplication group operation specified for all values of
&lsquo;X&rsquo; specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.GroupFMul` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
&lsquo;Execution&rsquo; reach this point of execution.</p><p>Behavior is undefined unless all invocations within &lsquo;Execution&rsquo; execute the
same dynamic instance of this instruction.</p><p>&lsquo;Result Type&rsquo; must be a scalar or vector of floating-point type.</p><p>&lsquo;Execution&rsquo; is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for &lsquo;Operation&rsquo; is 1.</p><p>The type of &lsquo;X&rsquo; must be the same as &lsquo;Result Type&rsquo;.</p><h4 id=example-164>Example:&nbsp;<a class=headline-hash href=#example-164>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>KHR<span class=p>.</span>GroupFMul <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-153>Operands:&nbsp;<a class=headline-hash href=#operands-153>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-151>Results:&nbsp;<a class=headline-hash href=#results-151>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupiadd-spirvgroupiaddop><code>spirv.GroupIAdd</code> (spirv::GroupIAddOp)&nbsp;<a class=headline-hash href=#spirvgroupiadd-spirvgroupiaddop>¶</a></h3><p><em>An integer add group operation specified for all values of X specified
by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupIAdd` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-165>Example:&nbsp;<a class=headline-hash href=#example-165>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupIAdd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-154>Operands:&nbsp;<a class=headline-hash href=#operands-154>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-152>Results:&nbsp;<a class=headline-hash href=#results-152>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvkhrgroupimul-spirvgroupimulkhrop><code>spirv.KHR.GroupIMul</code> (spirv::GroupIMulKHROp)&nbsp;<a class=headline-hash href=#spirvkhrgroupimul-spirvgroupimulkhrop>¶</a></h3><p><em>An integer multiplication group operation specified for all values of &lsquo;X&rsquo;
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.GroupIMul` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
&lsquo;Execution&rsquo; reach this point of execution.</p><p>Behavior is undefined unless all invocations within &lsquo;Execution&rsquo; execute the
same dynamic instance of this instruction.</p><p>&lsquo;Result Type&rsquo; must be a scalar or vector of integer type.</p><p>&lsquo;Execution&rsquo; is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for &lsquo;Operation&rsquo; is 1.</p><p>The type of &lsquo;X&rsquo; must be the same as &lsquo;Result Type&rsquo;.</p><h4 id=example-166>Example:&nbsp;<a class=headline-hash href=#example-166>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>KHR<span class=p>.</span>GroupIMul <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-155>Operands:&nbsp;<a class=headline-hash href=#operands-155>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-153>Results:&nbsp;<a class=headline-hash href=#results-153>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformallequal-spirvgroupnonuniformallequalop><code>spirv.GroupNonUniformAllEqual</code> (spirv::GroupNonUniformAllEqualOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformallequal-spirvgroupnonuniformallequalop>¶</a></h3><p><em>Evaluates a value for all tangled invocations within the Execution
scope. The result is true if Value is equal for all tangled invocations
within the Execution scope. Otherwise, the result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformAllEqual` $execution_scope $value attr-dict `:` type($value) `,` type($result)
</code></pre><p>Result Type must be a Boolean type.</p><p>Execution is the scope defining the scope restricted tangle affected by
this command. It must be Subgroup.</p><p>Value must be a scalar or vector of floating-point type, integer type,
or Boolean type. The compare operation is based on this type, and if it
is a floating-point type, an ordered-and-equal compare is used.</p><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its scope restricted tangle have executed
all dynamic instances that are program-ordered before X&rsquo;.</p><h4 id=example-167>Example:&nbsp;<a class=headline-hash href=#example-167>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%scalar_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformAllEqual <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%scalar_value</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformAllEqual <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%vector_value</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-156>Operands:&nbsp;<a class=headline-hash href=#operands-156>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-154>Results:&nbsp;<a class=headline-hash href=#results-154>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool</td></tr></tbody></table><h3 id=spirvgroupnonuniformall-spirvgroupnonuniformallop><code>spirv.GroupNonUniformAll</code> (spirv::GroupNonUniformAllOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformall-spirvgroupnonuniformallop>¶</a></h3><p><em>Evaluates a predicate for all tangled invocations within the Execution
scope, resulting in true if predicate evaluates to true for all tangled
invocations within the Execution scope, otherwise the result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformAll` $execution_scope $predicate attr-dict `:` type($result)
</code></pre><p>Result Type must be a Boolean type.</p><p>Execution is the scope defining the scope restricted tangle affected by
this command. It must be Subgroup.</p><p>Predicate must be a Boolean type.</p><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its scope restricted tangle have executed
all dynamic instances that are program-ordered before X&rsquo;.</p><h4 id=example-168>Example:&nbsp;<a class=headline-hash href=#example-168>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%predicate</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformAll <span class=s>&#34;Subgroup&#34;</span> <span class=nv>%predicate</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-40>Attributes:&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-157>Operands:&nbsp;<a class=headline-hash href=#operands-157>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>bool</td></tr></tbody></table><h4 id=results-155>Results:&nbsp;<a class=headline-hash href=#results-155>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool</td></tr></tbody></table><h3 id=spirvgroupnonuniformany-spirvgroupnonuniformanyop><code>spirv.GroupNonUniformAny</code> (spirv::GroupNonUniformAnyOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformany-spirvgroupnonuniformanyop>¶</a></h3><p><em>Evaluates a predicate for all tangled invocations within the Execution
scope, resulting in true if predicate evaluates to true for any tangled
invocations within the Execution scope, otherwise the result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformAny` $execution_scope $predicate attr-dict `:` type($result)
</code></pre><p>Result Type must be a Boolean type.</p><p>Execution is the scope defining the scope restricted tangle affected by
this command. It must be Subgroup.</p><p>Predicate must be a Boolean type.</p><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its scope restricted tangle have executed
all dynamic instances that are program-ordered before X&rsquo;.</p><h4 id=example-169>Example:&nbsp;<a class=headline-hash href=#example-169>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%predicate</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformAny <span class=s>&#34;Subgroup&#34;</span> <span class=nv>%predicate</span> <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-41>Attributes:&nbsp;<a class=headline-hash href=#attributes-41>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-158>Operands:&nbsp;<a class=headline-hash href=#operands-158>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>bool</td></tr></tbody></table><h4 id=results-156>Results:&nbsp;<a class=headline-hash href=#results-156>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool</td></tr></tbody></table><h3 id=spirvgroupnonuniformballotbitcount-spirvgroupnonuniformballotbitcountop><code>spirv.GroupNonUniformBallotBitCount</code> (spirv::GroupNonUniformBallotBitCountOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformballotbitcount-spirvgroupnonuniformballotbitcountop>¶</a></h3><p><em>Result is the number of bits that are set to 1 in Value, considering
only the bits in Value required to represent all bits of the scope
restricted tangle.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBallotBitCount` $execution_scope $group_operation $value attr-dict `:` type($value) `-&gt;` type($result)
</code></pre><p>Result Type must be a scalar of integer type, whose Signedness operand
is 0.</p><p>Execution is the scope defining the scope restricted tangle affected by
this command. It must be Subgroup.</p><p>The identity I for Operation is 0.</p><p>Value must be a vector of four components of integer type scalar, whose
Width operand is 32 and whose Signedness operand is 0.</p><p>Value is a set of bitfields where the first invocation is represented in
the lowest bit of the first vector component and the last (up to the
size of the scope) is the higher bit number of the last bitmask needed
to represent all bits of the invocations in the scope restricted tangle.</p><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its scope restricted tangle have executed
all dynamic instances that are program-ordered before X&rsquo;.</p><h4 id=example-170>Example:&nbsp;<a class=headline-hash href=#example-170>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%count</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBallotBitCount <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%val</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-42>Attributes:&nbsp;<a class=headline-hash href=#attributes-42>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-159>Operands:&nbsp;<a class=headline-hash href=#operands-159>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 32-bit signless/unsigned integer values of length 4</td></tr></tbody></table><h4 id=results-157>Results:&nbsp;<a class=headline-hash href=#results-157>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit signless/unsigned integer</td></tr></tbody></table><h3 id=spirvgroupnonuniformballotfindlsb-spirvgroupnonuniformballotfindlsbop><code>spirv.GroupNonUniformBallotFindLSB</code> (spirv::GroupNonUniformBallotFindLSBOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformballotfindlsb-spirvgroupnonuniformballotfindlsbop>¶</a></h3><p><em>Find the least significant bit set to 1 in Value, considering only the
bits in Value required to represent all bits of the group&rsquo;s invocations.
If none of the considered bits is set to 1, the resulting value is
undefined.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBallotFindLSB` $execution_scope $value attr-dict `:` type($value) `,` type($result)
</code></pre><p>Result Type must be a scalar of integer type, whose Signedness operand
is 0.</p><p>Execution is a Scope that identifies the group of invocations affected
by this command. It must be Subgroup.</p><p>Value must be a vector of four components of integer type scalar, whose
Width operand is 32 and whose Signedness operand is 0.</p><p>Value is a set of bitfields where the first invocation is represented in
the lowest bit of the first vector component and the last (up to the
size of the group) is the higher bit number of the last bitmask needed
to represent all bits of the group invocations.</p><h4 id=example-171>Example:&nbsp;<a class=headline-hash href=#example-171>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBallotFindLSB <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%vector</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-43>Attributes:&nbsp;<a class=headline-hash href=#attributes-43>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-160>Operands:&nbsp;<a class=headline-hash href=#operands-160>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 8/16/32/64-bit signless/unsigned integer values of length 4</td></tr></tbody></table><h4 id=results-158>Results:&nbsp;<a class=headline-hash href=#results-158>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit signless/unsigned integer</td></tr></tbody></table><h3 id=spirvgroupnonuniformballotfindmsb-spirvgroupnonuniformballotfindmsbop><code>spirv.GroupNonUniformBallotFindMSB</code> (spirv::GroupNonUniformBallotFindMSBOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformballotfindmsb-spirvgroupnonuniformballotfindmsbop>¶</a></h3><p><em>Find the most significant bit set to 1 in Value, considering only the
bits in Value required to represent all bits of the group&rsquo;s invocations.
If none of the considered bits is set to 1, the resulting value is
undefined.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBallotFindMSB` $execution_scope $value attr-dict `:` type($value) `,` type($result)
</code></pre><p>Result Type must be a scalar of integer type, whose Signedness operand
is 0.</p><p>Execution is a Scope that identifies the group of invocations affected
by this command. It must be Subgroup.</p><p>Value must be a vector of four components of integer type scalar, whose
Width operand is 32 and whose Signedness operand is 0.</p><p>Value is a set of bitfields where the first invocation is represented in
the lowest bit of the first vector component and the last (up to the
size of the group) is the higher bit number of the last bitmask needed
to represent all bits of the group invocations.</p><h4 id=example-172>Example:&nbsp;<a class=headline-hash href=#example-172>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBallotFindMSB <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%vector</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-44>Attributes:&nbsp;<a class=headline-hash href=#attributes-44>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-161>Operands:&nbsp;<a class=headline-hash href=#operands-161>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>vector of 8/16/32/64-bit signless/unsigned integer values of length 4</td></tr></tbody></table><h4 id=results-159>Results:&nbsp;<a class=headline-hash href=#results-159>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit signless/unsigned integer</td></tr></tbody></table><h3 id=spirvgroupnonuniformballot-spirvgroupnonuniformballotop><code>spirv.GroupNonUniformBallot</code> (spirv::GroupNonUniformBallotOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformballot-spirvgroupnonuniformballotop>¶</a></h3><p><em>Result is a bitfield value combining the Predicate value from all
invocations in the group that execute the same dynamic instance of this
instruction. The bit is set to one if the corresponding invocation is
active and the Predicate for that invocation evaluated to true;
otherwise, it is set to zero.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBallot` $execution_scope $predicate attr-dict `:` type($result)
</code></pre><p>Result Type must be a vector of four components of integer type scalar,
whose Signedness operand is 0.</p><p>Result is a set of bitfields where the first invocation is represented
in the lowest bit of the first vector component and the last (up to the
size of the group) is the higher bit number of the last bitmask needed
to represent all bits of the group invocations.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>Predicate must be a Boolean type.</p><h4 id=example-173>Example:&nbsp;<a class=headline-hash href=#example-173>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBallot <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%predicate</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-45>Attributes:&nbsp;<a class=headline-hash href=#attributes-45>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-162>Operands:&nbsp;<a class=headline-hash href=#operands-162>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>bool</td></tr></tbody></table><h4 id=results-160>Results:&nbsp;<a class=headline-hash href=#results-160>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 8/16/32/64-bit signless/unsigned integer values of length 4</td></tr></tbody></table><h3 id=spirvgroupnonuniformbitwiseand-spirvgroupnonuniformbitwiseandop><code>spirv.GroupNonUniformBitwiseAnd</code> (spirv::GroupNonUniformBitwiseAndOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformbitwiseand-spirvgroupnonuniformbitwiseandop>¶</a></h3><p><em>A bitwise <code>and</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBitwiseAnd` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is ~0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-174>Example:&nbsp;<a class=headline-hash href=#example-174>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseAnd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseAnd <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-46>Attributes:&nbsp;<a class=headline-hash href=#attributes-46>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-163>Operands:&nbsp;<a class=headline-hash href=#operands-163>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-161>Results:&nbsp;<a class=headline-hash href=#results-161>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformbitwiseor-spirvgroupnonuniformbitwiseorop><code>spirv.GroupNonUniformBitwiseOr</code> (spirv::GroupNonUniformBitwiseOrOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformbitwiseor-spirvgroupnonuniformbitwiseorop>¶</a></h3><p><em>A bitwise <code>or</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBitwiseOr` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-175>Example:&nbsp;<a class=headline-hash href=#example-175>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseOr <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseOr <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-47>Attributes:&nbsp;<a class=headline-hash href=#attributes-47>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-164>Operands:&nbsp;<a class=headline-hash href=#operands-164>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-162>Results:&nbsp;<a class=headline-hash href=#results-162>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformbitwisexor-spirvgroupnonuniformbitwisexorop><code>spirv.GroupNonUniformBitwiseXor</code> (spirv::GroupNonUniformBitwiseXorOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformbitwisexor-spirvgroupnonuniformbitwisexorop>¶</a></h3><p><em>A bitwise <code>xor</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBitwiseXor` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-176>Example:&nbsp;<a class=headline-hash href=#example-176>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseXor <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBitwiseXor <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-48>Attributes:&nbsp;<a class=headline-hash href=#attributes-48>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-165>Operands:&nbsp;<a class=headline-hash href=#operands-165>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-163>Results:&nbsp;<a class=headline-hash href=#results-163>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformbroadcast-spirvgroupnonuniformbroadcastop><code>spirv.GroupNonUniformBroadcast</code> (spirv::GroupNonUniformBroadcastOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformbroadcast-spirvgroupnonuniformbroadcastop>¶</a></h3><p><em>Result is the Value of the invocation identified by the id Id to all
active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformBroadcast` $execution_scope operands attr-dict `:` type($value) `,` type($id)
</code></pre><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The type of Value must be the same as Result Type.</p><p>Id must be a scalar of integer type, whose Signedness operand is 0.</p><p>Before version 1.5, Id must come from a constant instruction. Starting
with version 1.5, Id must be dynamically uniform.</p><p>The resulting value is undefined if Id is an inactive invocation, or is
greater than or equal to the size of the group.</p><h4 id=example-177>Example:&nbsp;<a class=headline-hash href=#example-177>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%scalar_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector_value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%id</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBroadcast <span class=s>&#34;Subgroup&#34;</span> <span class=nv>%scalar_value</span><span class=p>,</span> <span class=nv>%id</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformBroadcast <span class=s>&#34;Workgroup&#34;</span> <span class=nv>%vector_value</span><span class=p>,</span> <span class=nv>%id</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-49>Attributes:&nbsp;<a class=headline-hash href=#attributes-49>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-166>Operands:&nbsp;<a class=headline-hash href=#operands-166>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr><tr><td style=text-align:center><code>id</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-164>Results:&nbsp;<a class=headline-hash href=#results-164>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupnonuniformelect-spirvgroupnonuniformelectop><code>spirv.GroupNonUniformElect</code> (spirv::GroupNonUniformElectOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformelect-spirvgroupnonuniformelectop>¶</a></h3><p><em>Result is true only in the active invocation with the lowest id in the
group, otherwise result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformElect` $execution_scope attr-dict `:` type($result)
</code></pre><p>Result Type must be a Boolean type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><h4 id=example-178>Example:&nbsp;<a class=headline-hash href=#example-178>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformElect <span class=p>:</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-50>Attributes:&nbsp;<a class=headline-hash href=#attributes-50>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=results-165>Results:&nbsp;<a class=headline-hash href=#results-165>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool</td></tr></tbody></table><h3 id=spirvgroupnonuniformfadd-spirvgroupnonuniformfaddop><code>spirv.GroupNonUniformFAdd</code> (spirv::GroupNonUniformFAddOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformfadd-spirvgroupnonuniformfaddop>¶</a></h3><p><em>A floating point add group operation of all Value operands contributed
by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformFAdd` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-179>Example:&nbsp;<a class=headline-hash href=#example-179>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFAdd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFAdd <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-51>Attributes:&nbsp;<a class=headline-hash href=#attributes-51>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-167>Operands:&nbsp;<a class=headline-hash href=#operands-167>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-166>Results:&nbsp;<a class=headline-hash href=#results-166>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformfmax-spirvgroupnonuniformfmaxop><code>spirv.GroupNonUniformFMax</code> (spirv::GroupNonUniformFMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformfmax-spirvgroupnonuniformfmaxop>¶</a></h3><p><em>A floating point maximum group operation of all Value operands
contributed by active invocations in by group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformFMax` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is -INF. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined. From the set of Value(s) provided
by active invocations within a subgroup, if for any two Values one of
them is a NaN, the other is chosen. If all Value(s) that are used by the
current invocation are NaN, then the result is an undefined value.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-180>Example:&nbsp;<a class=headline-hash href=#example-180>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMax <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-52>Attributes:&nbsp;<a class=headline-hash href=#attributes-52>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-168>Operands:&nbsp;<a class=headline-hash href=#operands-168>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-167>Results:&nbsp;<a class=headline-hash href=#results-167>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformfmin-spirvgroupnonuniformfminop><code>spirv.GroupNonUniformFMin</code> (spirv::GroupNonUniformFMinOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformfmin-spirvgroupnonuniformfminop>¶</a></h3><p><em>A floating point minimum group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformFMin` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is +INF. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined. From the set of Value(s) provided
by active invocations within a subgroup, if for any two Values one of
them is a NaN, the other is chosen. If all Value(s) that are used by the
current invocation are NaN, then the result is an undefined value.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-181>Example:&nbsp;<a class=headline-hash href=#example-181>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMin <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-53>Attributes:&nbsp;<a class=headline-hash href=#attributes-53>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-169>Operands:&nbsp;<a class=headline-hash href=#operands-169>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-168>Results:&nbsp;<a class=headline-hash href=#results-168>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformfmul-spirvgroupnonuniformfmulop><code>spirv.GroupNonUniformFMul</code> (spirv::GroupNonUniformFMulOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformfmul-spirvgroupnonuniformfmulop>¶</a></h3><p><em>A floating point multiply group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformFMul` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of floating-point type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 1. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type. The method used to
perform the group operation on the contributed Value(s) from active
invocations is implementation defined.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-182>Example:&nbsp;<a class=headline-hash href=#example-182>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMul <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformFMul <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-54>Attributes:&nbsp;<a class=headline-hash href=#attributes-54>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-170>Operands:&nbsp;<a class=headline-hash href=#operands-170>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-169>Results:&nbsp;<a class=headline-hash href=#results-169>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformiadd-spirvgroupnonuniformiaddop><code>spirv.GroupNonUniformIAdd</code> (spirv::GroupNonUniformIAddOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformiadd-spirvgroupnonuniformiaddop>¶</a></h3><p><em>An integer add group operation of all Value operands contributed by
active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformIAdd` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-183>Example:&nbsp;<a class=headline-hash href=#example-183>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformIAdd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformIAdd <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-55>Attributes:&nbsp;<a class=headline-hash href=#attributes-55>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-171>Operands:&nbsp;<a class=headline-hash href=#operands-171>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-170>Results:&nbsp;<a class=headline-hash href=#results-170>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformimul-spirvgroupnonuniformimulop><code>spirv.GroupNonUniformIMul</code> (spirv::GroupNonUniformIMulOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformimul-spirvgroupnonuniformimulop>¶</a></h3><p><em>An integer multiply group operation of all Value operands contributed by
active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformIMul` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 1. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-184>Example:&nbsp;<a class=headline-hash href=#example-184>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformIMul <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformIMul <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-56>Attributes:&nbsp;<a class=headline-hash href=#attributes-56>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-172>Operands:&nbsp;<a class=headline-hash href=#operands-172>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-171>Results:&nbsp;<a class=headline-hash href=#results-171>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformlogicaland-spirvgroupnonuniformlogicalandop><code>spirv.GroupNonUniformLogicalAnd</code> (spirv::GroupNonUniformLogicalAndOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformlogicaland-spirvgroupnonuniformlogicalandop>¶</a></h3><p><em>A logical <code>and</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformLogicalAnd` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is ~0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-185>Example:&nbsp;<a class=headline-hash href=#example-185>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalAnd <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i1</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalAnd <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-57>Attributes:&nbsp;<a class=headline-hash href=#attributes-57>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-173>Operands:&nbsp;<a class=headline-hash href=#operands-173>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-172>Results:&nbsp;<a class=headline-hash href=#results-172>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformlogicalor-spirvgroupnonuniformlogicalorop><code>spirv.GroupNonUniformLogicalOr</code> (spirv::GroupNonUniformLogicalOrOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformlogicalor-spirvgroupnonuniformlogicalorop>¶</a></h3><p><em>A logical <code>or</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformLogicalOr` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-186>Example:&nbsp;<a class=headline-hash href=#example-186>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalOr <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i1</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalOr <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-58>Attributes:&nbsp;<a class=headline-hash href=#attributes-58>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-174>Operands:&nbsp;<a class=headline-hash href=#operands-174>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-173>Results:&nbsp;<a class=headline-hash href=#results-173>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformlogicalxor-spirvgroupnonuniformlogicalxorop><code>spirv.GroupNonUniformLogicalXor</code> (spirv::GroupNonUniformLogicalXorOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformlogicalxor-spirvgroupnonuniformlogicalxorop>¶</a></h3><p><em>A logical <code>xor</code> group operation of all Value operands contributed by active
invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformLogicalXor` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be present.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-187>Example:&nbsp;<a class=headline-hash href=#example-187>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalXor <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i1</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformLogicalXor <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-59>Attributes:&nbsp;<a class=headline-hash href=#attributes-59>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-175>Operands:&nbsp;<a class=headline-hash href=#operands-175>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-174>Results:&nbsp;<a class=headline-hash href=#results-174>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformrotatekhr-spirvgroupnonuniformrotatekhrop><code>spirv.GroupNonUniformRotateKHR</code> (spirv::GroupNonUniformRotateKHROp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformrotatekhr-spirvgroupnonuniformrotatekhrop>¶</a></h3><p><em>Rotate values across invocations within a subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformRotateKHR` $execution_scope $value `,` $delta (`,` `cluster_size` `(` $cluster_size^ `)`)? attr-dict `:` type($value) `,` type($delta) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Return the Value of the invocation whose id within the group is calculated
as follows:</p><p>LocalId = SubgroupLocalInvocationId if Execution is Subgroup or
LocalInvocationId if Execution is Workgroup
RotationGroupSize = ClusterSize when ClusterSize is present, otherwise
RotationGroupSize = SubgroupMaxSize if the Kernel capability is declared
and SubgroupSize if not.
Invocation ID = ( (LocalId + Delta) & (RotationGroupSize - 1) ) +
(LocalId & ~(RotationGroupSize - 1))</p><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The type of Value must be the same as Result Type.</p><p>Delta must be a scalar of integer type, whose Signedness operand is 0.
Delta must be dynamically uniform within Execution.</p><p>Delta is treated as unsigned and the resulting value is undefined if the
selected lane is inactive.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar of
integer type, whose Signedness operand is 0. ClusterSize must come from a
constant instruction. Behavior is undefined unless ClusterSize is at least
1 and a power of 2. If ClusterSize is greater than the declared
SubGroupSize, executing this instruction results in undefined behavior.</p><h4 id=example-188>Example:&nbsp;<a class=headline-hash href=#example-188>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformRotateKHR <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%delta</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformRotateKHR <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=nv>%value</span><span class=p>,</span> <span class=nv>%delta</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     clustersize<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-60>Attributes:&nbsp;<a class=headline-hash href=#attributes-60>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-176>Operands:&nbsp;<a class=headline-hash href=#operands-176>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>delta</code></td><td>8/16/32/64-bit signless/unsigned integer</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit signless/unsigned integer</td></tr></tbody></table><h4 id=results-175>Results:&nbsp;<a class=headline-hash href=#results-175>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformsmax-spirvgroupnonuniformsmaxop><code>spirv.GroupNonUniformSMax</code> (spirv::GroupNonUniformSMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformsmax-spirvgroupnonuniformsmaxop>¶</a></h3><p><em>A signed integer maximum group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformSMax` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is INT_MIN. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-189>Example:&nbsp;<a class=headline-hash href=#example-189>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformSMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformSMax <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>SignedOp</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-61>Attributes:&nbsp;<a class=headline-hash href=#attributes-61>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-177>Operands:&nbsp;<a class=headline-hash href=#operands-177>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-176>Results:&nbsp;<a class=headline-hash href=#results-176>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformsmin-spirvgroupnonuniformsminop><code>spirv.GroupNonUniformSMin</code> (spirv::GroupNonUniformSMinOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformsmin-spirvgroupnonuniformsminop>¶</a></h3><p><em>A signed integer minimum group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformSMin` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is INT_MAX. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-190>Example:&nbsp;<a class=headline-hash href=#example-190>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformSMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformSMin <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>SignedOp</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-62>Attributes:&nbsp;<a class=headline-hash href=#attributes-62>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-178>Operands:&nbsp;<a class=headline-hash href=#operands-178>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-177>Results:&nbsp;<a class=headline-hash href=#results-177>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformshuffledown-spirvgroupnonuniformshuffledownop><code>spirv.GroupNonUniformShuffleDown</code> (spirv::GroupNonUniformShuffleDownOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformshuffledown-spirvgroupnonuniformshuffledownop>¶</a></h3><p><em>Result is the Value of the invocation identified by the current
invocation’s id within the group + Delta.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformShuffleDown` $execution_scope operands attr-dict `:` type($value) `,` type($delta)
</code></pre><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The type of Value must be the same as Result Type.</p><p>Delta must be a scalar of integer type, whose Signedness operand is 0.</p><p>Delta is treated as unsigned and the resulting value is undefined if
Delta is greater than or equal to the size of the group, or if the
current invocation’s id within the group + Delta is either an inactive
invocation or greater than or equal to the size of the group.</p><h4 id=example-191>Example:&nbsp;<a class=headline-hash href=#example-191>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformShuffleDown <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%val</span><span class=p>,</span> <span class=nv>%delta</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-63>Attributes:&nbsp;<a class=headline-hash href=#attributes-63>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-179>Operands:&nbsp;<a class=headline-hash href=#operands-179>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>delta</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-178>Results:&nbsp;<a class=headline-hash href=#results-178>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupnonuniformshuffle-spirvgroupnonuniformshuffleop><code>spirv.GroupNonUniformShuffle</code> (spirv::GroupNonUniformShuffleOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformshuffle-spirvgroupnonuniformshuffleop>¶</a></h3><p><em>Result is the Value of the invocation identified by the id Id.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformShuffle` $execution_scope operands attr-dict `:` type($value) `,` type($id)
</code></pre><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The type of Value must be the same as Result Type.</p><p>Id must be a scalar of integer type, whose Signedness operand is 0.</p><p>The resulting value is undefined if Id is an inactive invocation, or is
greater than or equal to the size of the group.</p><h4 id=example-192>Example:&nbsp;<a class=headline-hash href=#example-192>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformShuffle <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%val</span><span class=p>,</span> <span class=nv>%id</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-64>Attributes:&nbsp;<a class=headline-hash href=#attributes-64>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-180>Operands:&nbsp;<a class=headline-hash href=#operands-180>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>id</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-179>Results:&nbsp;<a class=headline-hash href=#results-179>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformshuffleup-spirvgroupnonuniformshuffleupop><code>spirv.GroupNonUniformShuffleUp</code> (spirv::GroupNonUniformShuffleUpOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformshuffleup-spirvgroupnonuniformshuffleupop>¶</a></h3><p><em>Result is the Value of the invocation identified by the current
invocation’s id within the group - Delta.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformShuffleUp` $execution_scope operands attr-dict `:` type($value) `,` type($delta)
</code></pre><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The type of Value must be the same as Result Type.</p><p>Delta must be a scalar of integer type, whose Signedness operand is 0.</p><p>Delta is treated as unsigned and the resulting value is undefined if
Delta is greater than the current invocation’s id within the group or if
the selected lane is inactive.</p><h4 id=example-193>Example:&nbsp;<a class=headline-hash href=#example-193>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformShuffleUp <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%val</span><span class=p>,</span> <span class=nv>%delta</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-65>Attributes:&nbsp;<a class=headline-hash href=#attributes-65>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-181>Operands:&nbsp;<a class=headline-hash href=#operands-181>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>delta</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-180>Results:&nbsp;<a class=headline-hash href=#results-180>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupnonuniformshufflexor-spirvgroupnonuniformshufflexorop><code>spirv.GroupNonUniformShuffleXor</code> (spirv::GroupNonUniformShuffleXorOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformshufflexor-spirvgroupnonuniformshufflexorop>¶</a></h3><p><em>Result is the Value of the invocation identified by the current
invocation’s id within the group xor’ed with Mask.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformShuffleXor` $execution_scope operands attr-dict `:` type($value) `,` type($mask)
</code></pre><p>Result Type must be a scalar or vector of floating-point type, integer
type, or Boolean type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The type of Value must be the same as Result Type.</p><p>Mask must be a scalar of integer type, whose Signedness operand is 0.</p><p>The resulting value is undefined if current invocation’s id within the
group xor’ed with Mask is an inactive invocation, or is greater than or
equal to the size of the group.</p><h4 id=example-194>Example:&nbsp;<a class=headline-hash href=#example-194>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformShuffleXor <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=nv>%val</span><span class=p>,</span> <span class=nv>%mask</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-66>Attributes:&nbsp;<a class=headline-hash href=#attributes-66>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr></table><h4 id=operands-182>Operands:&nbsp;<a class=headline-hash href=#operands-182>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>mask</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-181>Results:&nbsp;<a class=headline-hash href=#results-181>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvgroupnonuniformumax-spirvgroupnonuniformumaxop><code>spirv.GroupNonUniformUMax</code> (spirv::GroupNonUniformUMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformumax-spirvgroupnonuniformumaxop>¶</a></h3><p><em>An unsigned integer maximum group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformUMax` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose
Signedness operand is 0.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is 0. If Operation is ClusteredReduce,
ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-195>Example:&nbsp;<a class=headline-hash href=#example-195>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformUMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformUMax <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>UnsignedOp</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-67>Attributes:&nbsp;<a class=headline-hash href=#attributes-67>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-183>Operands:&nbsp;<a class=headline-hash href=#operands-183>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-182>Results:&nbsp;<a class=headline-hash href=#results-182>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupnonuniformumin-spirvgroupnonuniformuminop><code>spirv.GroupNonUniformUMin</code> (spirv::GroupNonUniformUMinOp)&nbsp;<a class=headline-hash href=#spirvgroupnonuniformumin-spirvgroupnonuniformuminop>¶</a></h3><p><em>An unsigned integer minimum group operation of all Value operands
contributed by active invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupNonUniformUMin` $execution_scope $group_operation $value (`cluster_size``(` $cluster_size^ `)`)? attr-dict `:` type($value) (`,` type($cluster_size)^)? `-&gt;` type(results)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose
Signedness operand is 0.</p><p>Execution must be Workgroup or Subgroup Scope.</p><p>The identity I for Operation is UINT_MAX. If Operation is
ClusteredReduce, ClusterSize must be specified.</p><p>The type of Value must be the same as Result Type.</p><p>ClusterSize is the size of cluster to use. ClusterSize must be a scalar
of integer type, whose Signedness operand is 0. ClusterSize must come
from a constant instruction. ClusterSize must be at least 1, and must be
a power of 2. If ClusterSize is greater than the declared SubGroupSize,
executing this instruction results in undefined behavior.</p><h4 id=example-196>Example:&nbsp;<a class=headline-hash href=#example-196>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%four</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>4</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%vector</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformUMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>GroupNonUniformUMin <span class=p>&lt;</span>Subgroup<span class=p>&gt;</span> <span class=p>&lt;</span>ClusteredReduce<span class=p>&gt;</span> <span class=nv>%vector</span> cluster_size<span class=p>(</span><span class=nv>%four</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>UnsignedOp</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-68>Attributes:&nbsp;<a class=headline-hash href=#attributes-68>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-184>Operands:&nbsp;<a class=headline-hash href=#operands-184>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>cluster_size</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-183>Results:&nbsp;<a class=headline-hash href=#results-183>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupsmax-spirvgroupsmaxop><code>spirv.GroupSMax</code> (spirv::GroupSMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupsmax-spirvgroupsmaxop>¶</a></h3><p><em>A signed integer maximum group operation specified for all values of X
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupSMax` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is INT_MIN when X is 32 bits wide and
LONG_MIN when X is 64 bits wide.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-197>Example:&nbsp;<a class=headline-hash href=#example-197>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupSMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-69>Attributes:&nbsp;<a class=headline-hash href=#attributes-69>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-185>Operands:&nbsp;<a class=headline-hash href=#operands-185>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-184>Results:&nbsp;<a class=headline-hash href=#results-184>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupsmin-spirvgroupsminop><code>spirv.GroupSMin</code> (spirv::GroupSMinOp)&nbsp;<a class=headline-hash href=#spirvgroupsmin-spirvgroupsminop>¶</a></h3><p><em>A signed integer minimum group operation specified for all values of X
specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupSMin` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is INT_MAX when X is 32 bits wide and
LONG_MAX when X is 64 bits wide.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-198>Example:&nbsp;<a class=headline-hash href=#example-198>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupSMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-70>Attributes:&nbsp;<a class=headline-hash href=#attributes-70>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-186>Operands:&nbsp;<a class=headline-hash href=#operands-186>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-185>Results:&nbsp;<a class=headline-hash href=#results-185>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupumax-spirvgroupumaxop><code>spirv.GroupUMax</code> (spirv::GroupUMaxOp)&nbsp;<a class=headline-hash href=#spirvgroupumax-spirvgroupumaxop>¶</a></h3><p><em>An unsigned integer maximum group operation specified for all values of
X specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupUMax` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is 0.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-199>Example:&nbsp;<a class=headline-hash href=#example-199>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupUMax <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-71>Attributes:&nbsp;<a class=headline-hash href=#attributes-71>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-187>Operands:&nbsp;<a class=headline-hash href=#operands-187>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-186>Results:&nbsp;<a class=headline-hash href=#results-186>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvgroupumin-spirvgroupuminop><code>spirv.GroupUMin</code> (spirv::GroupUMinOp)&nbsp;<a class=headline-hash href=#spirvgroupumin-spirvgroupuminop>¶</a></h3><p><em>An unsigned integer minimum group operation specified for all values of
X specified by invocations in the group.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.GroupUMin` $execution_scope $group_operation operands attr-dict `:` type($x)
</code></pre><p>Behavior is undefined if not all invocations of this module within
Execution reach this point of execution.</p><p>Behavior is undefined unless all invocations within Execution execute
the same dynamic instance of this instruction.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Execution is a Scope. It must be either Workgroup or Subgroup.</p><p>The identity I for Operation is UINT_MAX when X is 32 bits wide and
ULONG_MAX when X is 64 bits wide.</p><p>The type of X must be the same as Result Type.</p><h4 id=example-200>Example:&nbsp;<a class=headline-hash href=#example-200>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>GroupUMin <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Reduce<span class=p>&gt;</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-72>Attributes:&nbsp;<a class=headline-hash href=#attributes-72>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>group_operation</code></td><td>::mlir::spirv::GroupOperationAttr</td><td>valid SPIR-V GroupOperation</td></tr></table><h4 id=operands-188>Operands:&nbsp;<a class=headline-hash href=#operands-188>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>x</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-187>Results:&nbsp;<a class=headline-hash href=#results-187>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirviaddcarry-spirviaddcarryop><code>spirv.IAddCarry</code> (spirv::IAddCarryOp)&nbsp;<a class=headline-hash href=#spirviaddcarry-spirviaddcarryop>¶</a></h3><p><em>Integer addition of Operand 1 and Operand 2, including the carry.</em></p><p>Result Type must be from OpTypeStruct. The struct must have two
members, and the two members must be the same type. The member type
must be a scalar or vector of integer type, whose Signedness operand is
0.</p><p>Operand 1 and Operand 2 must have the same type as the members of Result
Type. These are consumed as unsigned integers.</p><p>Results are computed per component.</p><p>Member 0 of the result gets the low-order bits (full component width) of
the addition.</p><p>Member 1 of the result gets the high-order (carry) bit of the result of
the addition. That is, it gets the value 1 if the addition overflowed
the component width, and 0 otherwise.</p><h4 id=example-201>Example:&nbsp;<a class=headline-hash href=#example-201>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>IAddCarry <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>IAddCarry <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-189>Operands:&nbsp;<a class=headline-hash href=#operands-189>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-188>Results:&nbsp;<a class=headline-hash href=#results-188>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V struct type</td></tr></tbody></table><h3 id=spirviadd-spirviaddop><code>spirv.IAdd</code> (spirv::IAddOp)&nbsp;<a class=headline-hash href=#spirviadd-spirviaddop>¶</a></h3><p><em>Integer addition of Operand 1 and Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IAdd` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h4 id=example-202>Example:&nbsp;<a class=headline-hash href=#example-202>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>IAdd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>IAdd <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-190>Operands:&nbsp;<a class=headline-hash href=#operands-190>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-189>Results:&nbsp;<a class=headline-hash href=#results-189>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirviequal-spirviequalop><code>spirv.IEqual</code> (spirv::IEqualOp)&nbsp;<a class=headline-hash href=#spirviequal-spirviequalop>¶</a></h3><p><em>Integer comparison for equality.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-203>Example:&nbsp;<a class=headline-hash href=#example-203>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>IEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>IEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-191>Operands:&nbsp;<a class=headline-hash href=#operands-191>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-190>Results:&nbsp;<a class=headline-hash href=#results-190>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvimul-spirvimulop><code>spirv.IMul</code> (spirv::IMulOp)&nbsp;<a class=headline-hash href=#spirvimul-spirvimulop>¶</a></h3><p><em>Integer multiplication of Operand 1 and Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IMul` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h4 id=example-204>Example:&nbsp;<a class=headline-hash href=#example-204>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>IMul <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>IMul <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-192>Operands:&nbsp;<a class=headline-hash href=#operands-192>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-191>Results:&nbsp;<a class=headline-hash href=#results-191>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvintelcontrolbarrierarrive-spirvintelcontrolbarrierarriveop><code>spirv.INTEL.ControlBarrierArrive</code> (spirv::INTELControlBarrierArriveOp)&nbsp;<a class=headline-hash href=#spirvintelcontrolbarrierarrive-spirvintelcontrolbarrierarriveop>¶</a></h3><p><em>See extension SPV_INTEL_split_barrier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.ControlBarrierArrive` $execution_scope $memory_scope $memory_semantics attr-dict
</code></pre><p>Indicates that an invocation has arrived at a split control barrier. This
may allow other invocations waiting on the split control barrier to continue
executing.</p><p>When <code>Execution</code> is <code>Workgroup</code> or larger, behavior is undefined unless all
invocations within <code>Execution</code> execute the same dynamic instance of this
instruction. When <code>Execution</code> is <code>Subgroup</code> or <code>Invocation</code>, the behavior of
this instruction in non-uniform control flow is defined by the client API.</p><p>If <code>Semantics</code> is not <code>None</code>, this instruction also serves as the start of a
memory barrier similar to an <code>OpMemoryBarrier</code> instruction with the same
<code>Memory</code> and <code>Semantics</code> operands. This allows atomically specifying both a
control barrier and a memory barrier (that is, without needing two
instructions). If <code>Semantics</code> is <code>None</code>, <code>Memory</code> is ignored.</p><h4 id=example-205>Example:&nbsp;<a class=headline-hash href=#example-205>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ControlBarrierArrive <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>Acquire<span class=err>|</span>UniformMemory<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-73>Attributes:&nbsp;<a class=headline-hash href=#attributes-73>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h3 id=spirvintelcontrolbarrierwait-spirvintelcontrolbarrierwaitop><code>spirv.INTEL.ControlBarrierWait</code> (spirv::INTELControlBarrierWaitOp)&nbsp;<a class=headline-hash href=#spirvintelcontrolbarrierwait-spirvintelcontrolbarrierwaitop>¶</a></h3><p><em>See extension SPV_INTEL_split_barrier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.ControlBarrierWait` $execution_scope $memory_scope $memory_semantics attr-dict
</code></pre><p>Waits for other invocations of this module to arrive at a split control
barrier.</p><p>When <code>Execution</code> is <code>Workgroup</code> or larger, behavior is undefined unless all
invocations within <code>Execution</code> execute the same dynamic instance of this
instruction. When <code>Execution</code> is <code>Subgroup</code> or <code>Invocation</code>, the behavior of
this instruction in non-uniform control flow is defined by the client API.</p><p>If <code>Semantics</code> is not <code>None</code>, this instruction also serves as the end of a
memory barrier similar to an <code>OpMemoryBarrier</code> instruction with the same
<code>Memory</code> and <code>Semantics</code> operands. This ensures that memory accesses issued
before arriving at the split barrier are observed before memory accesses
issued after this instruction. This control is ensured only for memory
accesses issued by this invocation and observed by another invocation
executing within <code>Memory</code> scope. This allows atomically specifying both a
control barrier and a memory barrier (that is, without needing two
instructions). If <code>Semantics</code> is <code>None</code>, <code>Memory</code> is ignored.</p><h4 id=example-206>Example:&nbsp;<a class=headline-hash href=#example-206>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ControlBarrierWait <span class=p>&lt;</span>Workgroup<span class=p>&gt;</span> <span class=p>&lt;</span>Device<span class=p>&gt;</span> <span class=p>&lt;</span>Acquire<span class=err>|</span>UniformMemory<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-74>Attributes:&nbsp;<a class=headline-hash href=#attributes-74>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>execution_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h3 id=spirvintelconvertbf16tof-spirvintelconvertbf16tofop><code>spirv.INTEL.ConvertBF16ToF</code> (spirv::INTELConvertBF16ToFOp)&nbsp;<a class=headline-hash href=#spirvintelconvertbf16tof-spirvintelconvertbf16tofop>¶</a></h3><p><em>See extension SPV_INTEL_bfloat16_conversion</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.ConvertBF16ToF` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Interpret a 16-bit integer as bfloat16 and convert the value numerically to 32-bit floating point type.</p><p>Result Type must be a scalar or vector of floating-point. The component width must be 32 bits.</p><p>Bfloat16 Value must be a scalar or vector of integer type, which is interpreted as a bfloat16 type.
The type must have the same number of components as the Result Type. The component width must be 16 bits.</p><p>Results are computed per component.</p><h4 id=example-207>Example:&nbsp;<a class=headline-hash href=#example-207>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertBF16ToF <span class=nv>%0</span> <span class=p>:</span> <span class=k>i16</span> to <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertBF16ToF <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-193>Operands:&nbsp;<a class=headline-hash href=#operands-193>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Int16 or fixed-length vector of Int16 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-192>Results:&nbsp;<a class=headline-hash href=#results-192>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Float32 or fixed-length vector of Float32 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvintelconvertftobf16-spirvintelconvertftobf16op><code>spirv.INTEL.ConvertFToBF16</code> (spirv::INTELConvertFToBF16Op)&nbsp;<a class=headline-hash href=#spirvintelconvertftobf16-spirvintelconvertftobf16op>¶</a></h3><p><em>See extension SPV_INTEL_bfloat16_conversion</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.ConvertFToBF16` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Convert value numerically from 32-bit floating point to bfloat16,
which is represented as a 16-bit unsigned integer.</p><p>Result Type must be a scalar or vector of integer type.
The component width must be 16 bits. Bit pattern in the Result represents a bfloat16 value.</p><p>Float Value must be a scalar or vector of floating-point type.
It must have the same number of components as Result Type. The component width must be 32 bits.</p><p>Results are computed per component.</p><h4 id=example-208>Example:&nbsp;<a class=headline-hash href=#example-208>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToBF16 <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ConvertFToBF16 <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-194>Operands:&nbsp;<a class=headline-hash href=#operands-194>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Float32 or fixed-length vector of Float32 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-193>Results:&nbsp;<a class=headline-hash href=#results-193>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Int16 or fixed-length vector of Int16 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvintelroundftotf32-spirvintelroundftotf32op><code>spirv.INTEL.RoundFToTF32</code> (spirv::INTELRoundFToTF32Op)&nbsp;<a class=headline-hash href=#spirvintelroundftotf32-spirvintelroundftotf32op>¶</a></h3><p><em>See extension SPV_INTEL_tensor_float32_conversion</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.RoundFToTF32` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Convert value numerically from a 32-bit floating point type to tensor float32,
with rounding to the nearest even.</p><p>Result Type must be a scalar or vector of 32-bit floating-point type.
The component width must be 32 bits. Bit pattern in the Result represents a tensor float32 value.</p><p>Float Value must be a scalar or vector of floating-point type.
It must have the same number of components as Result Type. The component width must be 32 bits.</p><p>Results are computed per component.</p><h4 id=example-209>Example:&nbsp;<a class=headline-hash href=#example-209>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>RoundFToTF32 <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span> to <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>RoundFToTF32 <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>SameOperandsAndResultShape</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-195>Operands:&nbsp;<a class=headline-hash href=#operands-195>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>Float32 or fixed-length vector of Float32 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-194>Results:&nbsp;<a class=headline-hash href=#results-194>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Float32 or fixed-length vector of Float32 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvintelsubgroupblockread-spirvintelsubgroupblockreadop><code>spirv.INTEL.SubgroupBlockRead</code> (spirv::INTELSubgroupBlockReadOp)&nbsp;<a class=headline-hash href=#spirvintelsubgroupblockread-spirvintelsubgroupblockreadop>¶</a></h3><p><em>See extension SPV_INTEL_subgroups</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INTEL.SubgroupBlockRead` $ptr attr-dict `:` type($ptr) `-&gt;` type($value)
</code></pre><p>Reads one or more components of Result data for each invocation in the
subgroup from the specified Ptr as a block operation.</p><p>The data is read strided, so the first value read is:
Ptr[ SubgroupLocalInvocationId ]</p><p>and the second value read is:
Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
etc.</p><p>Result Type may be a scalar or vector type, and its component type must be
equal to the type pointed to by Ptr.</p><p>The type of Ptr must be a pointer type, and must point to a scalar type.</p><pre tabindex=0><code>subgroup-block-read-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockRead`
                            storage-class ssa_use `:` spirv-element-type
</code></pre><h4 id=example-210>Example:&nbsp;<a class=headline-hash href=#example-210>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>INTEL<span class=p>.</span>SubgroupBlockRead <span class=s>&#34;StorageBuffer&#34;</span> <span class=nv>%ptr</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-196>Operands:&nbsp;<a class=headline-hash href=#operands-196>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-195>Results:&nbsp;<a class=headline-hash href=#results-195>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvintelsubgroupblockwrite-spirvintelsubgroupblockwriteop><code>spirv.INTEL.SubgroupBlockWrite</code> (spirv::INTELSubgroupBlockWriteOp)&nbsp;<a class=headline-hash href=#spirvintelsubgroupblockwrite-spirvintelsubgroupblockwriteop>¶</a></h3><p><em>See extension SPV_INTEL_subgroups</em></p><p>Writes one or more components of Data for each invocation in the subgroup
from the specified Ptr as a block operation.</p><p>The data is written strided, so the first value is written to:
Ptr[ SubgroupLocalInvocationId ]</p><p>and the second value written is:
Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
etc.</p><p>The type of Ptr must be a pointer type, and must point to a scalar type.</p><p>The component type of Data must be equal to the type pointed to by Ptr.</p><pre tabindex=0><code>subgroup-block-write-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockWrite`
                  storage-class ssa_use `,` ssa-use `:` spirv-element-type
</code></pre><h4 id=example-211>Example:&nbsp;<a class=headline-hash href=#example-211>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>INTEL<span class=p>.</span>SubgroupBlockWrite <span class=s>&#34;StorageBuffer&#34;</span> <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-197>Operands:&nbsp;<a class=headline-hash href=#operands-197>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvinotequal-spirvinotequalop><code>spirv.INotEqual</code> (spirv::INotEqualOp)&nbsp;<a class=headline-hash href=#spirvinotequal-spirvinotequalop>¶</a></h3><p><em>Integer comparison for inequality.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.INotEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-212>Example:&nbsp;<a class=headline-hash href=#example-212>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>INotEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>INotEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-198>Operands:&nbsp;<a class=headline-hash href=#operands-198>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-196>Results:&nbsp;<a class=headline-hash href=#results-196>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvisubborrow-spirvisubborrowop><code>spirv.ISubBorrow</code> (spirv::ISubBorrowOp)&nbsp;<a class=headline-hash href=#spirvisubborrow-spirvisubborrowop>¶</a></h3><p><em>Result is the unsigned integer subtraction of Operand 2 from Operand 1,
and what it needed to borrow.</em></p><p>Result Type must be from OpTypeStruct. The struct must have two
members, and the two members must be the same type. The member type
must be a scalar or vector of integer type, whose Signedness operand is
0.</p><p>Operand 1 and Operand 2 must have the same type as the members of Result
Type. These are consumed as unsigned integers.</p><p>Results are computed per component.</p><p>Member 0 of the result gets the low-order bits (full component width) of
the subtraction. That is, if Operand 1 is larger than Operand 2, member
0 gets the full value of the subtraction; if Operand 2 is larger than
Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the
component width.</p><p>Member 1 of the result gets 0 if Operand 1 ≥ Operand 2, and gets 1
otherwise.</p><h4 id=example-213>Example:&nbsp;<a class=headline-hash href=#example-213>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>ISubBorrow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>ISubBorrow <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-199>Operands:&nbsp;<a class=headline-hash href=#operands-199>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-197>Results:&nbsp;<a class=headline-hash href=#results-197>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V struct type</td></tr></tbody></table><h3 id=spirvisub-spirvisubop><code>spirv.ISub</code> (spirv::ISubOp)&nbsp;<a class=headline-hash href=#spirvisub-spirvisubop>¶</a></h3><p><em>Integer subtraction of Operand 2 from Operand 1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ISub` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>The resulting value will equal the low-order N bits of the correct
result R, where N is the component width and R is computed with enough
precision to avoid overflow and underflow.</p><p>Results are computed per component.</p><h4 id=example-214>Example:&nbsp;<a class=headline-hash href=#example-214>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>ISub <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ISub <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-200>Operands:&nbsp;<a class=headline-hash href=#operands-200>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-198>Results:&nbsp;<a class=headline-hash href=#results-198>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvimagedrefgather-spirvimagedrefgatherop><code>spirv.ImageDrefGather</code> (spirv::ImageDrefGatherOp)&nbsp;<a class=headline-hash href=#spirvimagedrefgather-spirvimagedrefgatherop>¶</a></h3><p><em>Gathers the requested depth-comparison from four texels.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageDrefGather` $sampled_image `,` $coordinate `,` $dref custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($sampled_image) `,` type($coordinate) `,` type($dref) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of four components of floating-point type
or integer type. Its components must be the same as Sampled Type of the
underlying OpTypeImage (unless that underlying Sampled Type is
OpTypeVoid). It has one component per gathered texel.</p><p>Sampled Image must be an object whose type is OpTypeSampledImage. Its
OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the
underlying OpTypeImage must be 0.</p><p>Coordinate must be a scalar or vector of floating-point type. It
contains (u[, v] &mldr; [, array layer]) as needed by the definition of
Sampled Image.</p><p>Dref is the depth-comparison reference value. It must be a 32-bit
floating-point type scalar.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><h4 id=example-215>Example:&nbsp;<a class=headline-hash href=#example-215>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>ImageDrefGather <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>ImageDrefGather <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>[</span><span class=s>&#34;NonPrivateTexel&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-75>Attributes:&nbsp;<a class=headline-hash href=#attributes-75>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-201>Operands:&nbsp;<a class=headline-hash href=#operands-201>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampled_image</code></td><td>any SPIR-V sampled image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>dref</code></td><td>Float32</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-199>Results:&nbsp;<a class=headline-hash href=#results-199>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 8/16/32/64-bit integer values of length 4 or vector of 16/32/64-bit float values of length 4</td></tr></tbody></table><h3 id=spirvimagefetch-spirvimagefetchop><code>spirv.ImageFetch</code> (spirv::ImageFetchOp)&nbsp;<a class=headline-hash href=#spirvimagefetch-spirvimagefetchop>¶</a></h3><p><em>Fetch a single texel from an image whose Sampled operand is 1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageFetch` $image `,` $coordinate custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($image) `,` type($coordinate) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of four components of floating-point type or
integer type. Its components must be the same as Sampled Type of the underlying
OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).</p><p>Image must be an object whose type is OpTypeImage. Its Dim operand must not be
Cube, and its Sampled operand must be 1.</p><p>Coordinate must be a scalar or vector of integer type. It contains (u[, v] … [,
array layer]) as needed by the definition of Sampled Image.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><h4 id=example-216>Example:&nbsp;<a class=headline-hash href=#example-216>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>ImageFetch <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NeedSampler<span class=p>,</span> R32f<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span>si32<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-76>Attributes:&nbsp;<a class=headline-hash href=#attributes-76>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-202>Operands:&nbsp;<a class=headline-hash href=#operands-202>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>image</code></td><td>any SPIR-V image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-200>Results:&nbsp;<a class=headline-hash href=#results-200>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 16/32/64-bit float values of length 4 or vector of 8/16/32/64-bit integer values of length 4</td></tr></tbody></table><h3 id=spirvimage-spirvimageop><code>spirv.Image</code> (spirv::ImageOp)&nbsp;<a class=headline-hash href=#spirvimage-spirvimageop>¶</a></h3><p><em>Extract the image from a sampled image.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Image` $sampled_image attr-dict `:` type($sampled_image)
</code></pre><p>Result Type must be OpTypeImage.</p><p>Sampled Image must have type OpTypeSampledImage whose Image Type is the
same as Result Type.</p><h4 id=example-217>Example:&nbsp;<a class=headline-hash href=#example-217>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Image <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Cube<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-203>Operands:&nbsp;<a class=headline-hash href=#operands-203>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampled_image</code></td><td>any SPIR-V sampled image type</td></tr></tbody></table><h4 id=results-201>Results:&nbsp;<a class=headline-hash href=#results-201>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V image type</td></tr></tbody></table><h3 id=spirvimagequerysize-spirvimagequerysizeop><code>spirv.ImageQuerySize</code> (spirv::ImageQuerySizeOp)&nbsp;<a class=headline-hash href=#spirvimagequerysize-spirvimagequerysizeop>¶</a></h3><p><em>Query the dimensions of Image, with no level of detail.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageQuerySize` $image attr-dict `:` type($image) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type scalar or vector. The number of
components must be:</p><p>1 for the 1D and Buffer dimensionalities,</p><p>2 for the 2D, Cube, and Rect dimensionalities,</p><p>3 for the 3D dimensionality,</p><p>plus 1 more if the image type is arrayed. This vector is filled in with
(width [, height] [, elements]) where elements is the number of layers
in an image array or the number of cubes in a cube-map array.</p><p>Image must be an object whose type is OpTypeImage. Its Dim operand must
be one of those listed under Result Type, above. Additionally, if its
Dim is 1D, 2D, 3D, or Cube, it must also have either an MS of 1 or a
Sampled of 0 or 2. There is no implicit level-of-detail consumed by this
instruction. See OpImageQuerySizeLod for querying images having level of
detail. This operation is allowed on an image decorated as NonReadable.
See the client API specification for additional image type restrictions.</p><h4 id=example-218>Example:&nbsp;<a class=headline-hash href=#example-218>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>ImageQuerySize <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Dim1D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>ImageQuerySize <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ImageQuerySize <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> Arrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Unknown<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-204>Operands:&nbsp;<a class=headline-hash href=#operands-204>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>image</code></td><td>any SPIR-V image type</td></tr></tbody></table><h4 id=results-202>Results:&nbsp;<a class=headline-hash href=#results-202>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvimageread-spirvimagereadop><code>spirv.ImageRead</code> (spirv::ImageReadOp)&nbsp;<a class=headline-hash href=#spirvimageread-spirvimagereadop>¶</a></h3><p><em>Read a texel from an image without a sampler.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageRead` $image `,` $coordinate custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($image) `,` type($coordinate) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>Result Type must be a scalar or vector of floating-point type or integer
type. It must be a scalar or vector with component type the same as Sampled
Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).</p><p>Image must be an object whose type is OpTypeImage with a Sampled operand of
0 or 2. If the Arrayed operand is 1, then additional capabilities may be
required; e.g., ImageCubeArray, or ImageMSArray.</p><p>Coordinate must be a scalar or vector of floating-point type or integer
type. It contains non-normalized texel coordinates (u[, v] &mldr; [, array
layer]) as needed by the definition of Image. See the client API
specification for handling of coordinates outside the image.</p><p>If the Image Dim operand is SubpassData, Coordinate is relative to the
current fragment location. See the client API specification for more detail
on how these coordinates are applied.</p><p>If the Image Dim operand is not SubpassData, the Image Format must not be
Unknown, unless the StorageImageReadWithoutFormat Capability was declared.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><h4 id=example-219>Example:&nbsp;<a class=headline-hash href=#example-219>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>ImageRead <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> R32f<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span>si32<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-77>Attributes:&nbsp;<a class=headline-hash href=#attributes-77>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-205>Operands:&nbsp;<a class=headline-hash href=#operands-205>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>image</code></td><td>any SPIR-V image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-203>Results:&nbsp;<a class=headline-hash href=#results-203>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvimagesampleexplicitlod-spirvimagesampleexplicitlodop><code>spirv.ImageSampleExplicitLod</code> (spirv::ImageSampleExplicitLodOp)&nbsp;<a class=headline-hash href=#spirvimagesampleexplicitlod-spirvimagesampleexplicitlodop>¶</a></h3><p><em>Sample an image using an explicit level of detail.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageSampleExplicitLod` $sampled_image `,` $coordinate custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($sampled_image) `,` type($coordinate) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of four components of floating-point type
or integer type. Its components must be the same as Sampled Type of the
underlying OpTypeImage (unless that underlying Sampled Type is
OpTypeVoid).</p><p>Sampled Image must be an object whose type is OpTypeSampledImage. Its
OpTypeImage must not have a Dim of Buffer. The MS operand of the
underlying OpTypeImage must be 0.</p><p>Coordinate must be a scalar or vector of floating-point type or integer
type. It contains (u[, v] &mldr; [, array layer]) as needed by the
definition of Sampled Image. Unless the Kernel capability is declared,
it must be floating point. It may be a vector larger than needed, but
all unused components appear after all used components.</p><p>Image Operands encodes what operands follow, as per Image Operands.
Either Lod or Grad image operands must be present.</p><h4 id=example-220>Example:&nbsp;<a class=headline-hash href=#example-220>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>ImageSampleExplicitLod <span class=nv>%image</span><span class=p>,</span> <span class=nv>%coord</span> <span class=p>[</span><span class=s>&#34;Lod&#34;</span><span class=p>](</span><span class=nv>%lod</span><span class=p>)</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NeedSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>ExplicitLodOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>SPIRV_SampleOpInterface</code></p><h4 id=attributes-78>Attributes:&nbsp;<a class=headline-hash href=#attributes-78>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-206>Operands:&nbsp;<a class=headline-hash href=#operands-206>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampled_image</code></td><td>any SPIR-V sampled image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-204>Results:&nbsp;<a class=headline-hash href=#results-204>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 8/16/32/64-bit integer values of length 4 or vector of 16/32/64-bit float values of length 4</td></tr></tbody></table><h3 id=spirvimagesampleimplicitlod-spirvimagesampleimplicitlodop><code>spirv.ImageSampleImplicitLod</code> (spirv::ImageSampleImplicitLodOp)&nbsp;<a class=headline-hash href=#spirvimagesampleimplicitlod-spirvimagesampleimplicitlodop>¶</a></h3><p><em>Sample an image with an implicit level of detail.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageSampleImplicitLod` $sampled_image `,` $coordinate custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($sampled_image) `,` type($coordinate) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its derivative group have executed all
dynamic instances that are program-ordered before X&rsquo;.</p><p>Result Type must be a vector of four components of floating-point type
or integer type. Its components must be the same as Sampled Type of the
underlying OpTypeImage (unless that underlying Sampled Type is
OpTypeVoid).</p><p>Sampled Image must be an object whose type is OpTypeSampledImage. Its
OpTypeImage must not have a Dim of Buffer. The MS operand of the
underlying OpTypeImage must be 0.</p><p>Coordinate must be a scalar or vector of floating-point type. It
contains (u[, v] &mldr; [, array layer]) as needed by the definition of
Sampled Image. It may be a vector larger than needed, but all unused
components appear after all used components.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><p>This instruction is only valid in the Fragment Execution Model. In
addition, it consumes an implicit derivative that can be affected by
code motion.</p><h4 id=example-221>Example:&nbsp;<a class=headline-hash href=#example-221>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>ImageSampleImplicitLod <span class=nv>%image</span><span class=p>,</span> <span class=nv>%coord</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Cube<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NeedSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>ImplicitLodOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>SPIRV_SampleOpInterface</code></p><h4 id=attributes-79>Attributes:&nbsp;<a class=headline-hash href=#attributes-79>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-207>Operands:&nbsp;<a class=headline-hash href=#operands-207>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampled_image</code></td><td>any SPIR-V sampled image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-205>Results:&nbsp;<a class=headline-hash href=#results-205>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 8/16/32/64-bit integer values of length 4 or vector of 16/32/64-bit float values of length 4</td></tr></tbody></table><h3 id=spirvimagesampleprojdrefimplicitlod-spirvimagesampleprojdrefimplicitlodop><code>spirv.ImageSampleProjDrefImplicitLod</code> (spirv::ImageSampleProjDrefImplicitLodOp)&nbsp;<a class=headline-hash href=#spirvimagesampleprojdrefimplicitlod-spirvimagesampleprojdrefimplicitlodop>¶</a></h3><p><em>Sample an image with a project coordinate, doing depth-comparison, with
an implicit level of detail.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageSampleProjDrefImplicitLod` $sampled_image `,` $coordinate `,` $dref custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($sampled_image) `,` type($coordinate) `,` type($dref) ( `,` type($operand_arguments)^ )?
              `-&gt;` type($result)
</code></pre><p>An invocation will not execute a dynamic instance of this instruction
(X&rsquo;) until all invocations in its derivative group have executed all
dynamic instances that are program-ordered before X&rsquo;.</p><p>Result Type must be a scalar of integer type or floating-point type. It
must be the same as Sampled Type of the underlying OpTypeImage.</p><p>Sampled Image must be an object whose type is OpTypeSampledImage. The
Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,
and the Arrayed and MS operands must be 0.</p><p>Coordinate must be a vector of floating-point type. It contains (u[,
v] [, w], q), as needed by the definition of Sampled Image, with the q
component consumed for the projective division. That is, the actual
sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition
of Sampled Image. It may be a vector larger than needed, but all unused
components appear after all used components.</p><p>Dref/q is the depth-comparison reference value. Dref must be a 32-bit
floating-point type scalar.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><p>This instruction is only valid in the Fragment Execution Model. In
addition, it consumes an implicit derivative that can be affected by
code motion.</p><h4 id=example-222>Example:&nbsp;<a class=headline-hash href=#example-222>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>ImageSampleProjDrefImplicitLod <span class=nv>%image</span><span class=p>,</span> <span class=nv>%coord</span><span class=p>,</span> <span class=nv>%dref</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>spirv<span class=p>.</span>sampled_image<span class=p>&lt;!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim2D<span class=p>,</span> IsDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NeedSampler<span class=p>,</span> Unknown<span class=p>&gt;&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;,</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>ImplicitLodOpInterface</code>, <code>InferTypeOpInterface</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>SPIRV_SampleOpInterface</code></p><h4 id=attributes-80>Attributes:&nbsp;<a class=headline-hash href=#attributes-80>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-208>Operands:&nbsp;<a class=headline-hash href=#operands-208>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sampled_image</code></td><td>any SPIR-V sampled image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>dref</code></td><td>Float32</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h4 id=results-206>Results:&nbsp;<a class=headline-hash href=#results-206>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float</td></tr></tbody></table><h3 id=spirvimagewrite-spirvimagewriteop><code>spirv.ImageWrite</code> (spirv::ImageWriteOp)&nbsp;<a class=headline-hash href=#spirvimagewrite-spirvimagewriteop>¶</a></h3><p><em>Write a texel to an image without a sampler.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ImageWrite` $image `,` $coordinate `,` $texel custom&lt;ImageOperands&gt;($image_operands) ( `,` $operand_arguments^ )? attr-dict
              `:` type($image) `,` type($coordinate) `,` type($texel) ( `,` type($operand_arguments)^ )?
</code></pre><p>Image must be an object whose type is OpTypeImage with a Sampled operand
of 0 or 2. If the Arrayed operand is 1, then additional capabilities may
be required; e.g., ImageCubeArray, or ImageMSArray. Its Dim operand
must not be SubpassData.</p><p>Coordinate must be a scalar or vector of floating-point type or integer
type. It contains non-normalized texel coordinates (u[, v] &mldr; [, array
layer]) as needed by the definition of Image. See the client API
specification for handling of coordinates outside the image.</p><p>Texel is the data to write. It must be a scalar or vector with component
type the same as Sampled Type of the OpTypeImage (unless that Sampled
Type is OpTypeVoid).</p><p>The Image Format must not be Unknown, unless the
StorageImageWriteWithoutFormat Capability was declared.</p><p>Image Operands encodes what operands follow, as per Image Operands.</p><h4 id=example-223>Example:&nbsp;<a class=headline-hash href=#example-223>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ImageWrite <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>image<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Dim2D<span class=p>,</span> NoDepth<span class=p>,</span> NonArrayed<span class=p>,</span> SingleSampled<span class=p>,</span> NoSampler<span class=p>,</span> Rgba16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span>si32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-81>Attributes:&nbsp;<a class=headline-hash href=#attributes-81>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>image_operands</code></td><td>::mlir::spirv::ImageOperandsAttr</td><td>valid SPIR-V ImageOperands</td></tr></table><h4 id=operands-209>Operands:&nbsp;<a class=headline-hash href=#operands-209>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>image</code></td><td>any SPIR-V image type</td></tr><tr><td style=text-align:center><code>coordinate</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>texel</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16 or 8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand_arguments</code></td><td>variadic of void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvinboundsptraccesschain-spirvinboundsptraccesschainop><code>spirv.InBoundsPtrAccessChain</code> (spirv::InBoundsPtrAccessChainOp)&nbsp;<a class=headline-hash href=#spirvinboundsptraccesschain-spirvinboundsptraccesschainop>¶</a></h3><p><em>Has the same semantics as OpPtrAccessChain, with the addition that the
resulting pointer is known to point within the base object.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.InBoundsPtrAccessChain` $base_ptr `[` $element ($indices^)? `]` attr-dict `:` type($base_ptr) `,` type($element) (`,` type($indices)^)? `-&gt;` type($result)
</code></pre><h4 id=example-224>Example:&nbsp;<a class=headline-hash href=#example-224>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span> <span class=nf>@inbounds_ptr_access_chain</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>InBoundsPtrAccessChain <span class=nv>%arg0</span><span class=p>[</span><span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;,</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-210>Operands:&nbsp;<a class=headline-hash href=#operands-210>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base_ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>element</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-207>Results:&nbsp;<a class=headline-hash href=#results-207>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvisfinite-spirvisfiniteop><code>spirv.IsFinite</code> (spirv::IsFiniteOp)&nbsp;<a class=headline-hash href=#spirvisfinite-spirvisfiniteop>¶</a></h3><p><em>Result is true if x is an IEEE Finite, otherwise result is false</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IsFinite` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>x must be a scalar or vector of floating-point type. It must have the
same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-225>Example:&nbsp;<a class=headline-hash href=#example-225>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>IsFinite <span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>IsFinite <span class=nv>%1</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-211>Operands:&nbsp;<a class=headline-hash href=#operands-211>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-208>Results:&nbsp;<a class=headline-hash href=#results-208>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvisinf-spirvisinfop><code>spirv.IsInf</code> (spirv::IsInfOp)&nbsp;<a class=headline-hash href=#spirvisinf-spirvisinfop>¶</a></h3><p><em>Result is true if x is an IEEE Inf, otherwise result is false</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IsInf` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>x must be a scalar or vector of floating-point type. It must have the
same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-226>Example:&nbsp;<a class=headline-hash href=#example-226>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>IsInf <span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>IsInf <span class=nv>%1</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-212>Operands:&nbsp;<a class=headline-hash href=#operands-212>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-209>Results:&nbsp;<a class=headline-hash href=#results-209>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvisnan-spirvisnanop><code>spirv.IsNan</code> (spirv::IsNanOp)&nbsp;<a class=headline-hash href=#spirvisnan-spirvisnanop>¶</a></h3><p><em>Result is true if x is an IEEE NaN, otherwise result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.IsNan` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>x must be a scalar or vector of floating-point type. It must have the
same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-227>Example:&nbsp;<a class=headline-hash href=#example-227>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>IsNan <span class=nv>%0</span><span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>IsNan <span class=nv>%1</span><span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-213>Operands:&nbsp;<a class=headline-hash href=#operands-213>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-210>Results:&nbsp;<a class=headline-hash href=#results-210>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvkhrassumetrue-spirvkhrassumetrueop><code>spirv.KHR.AssumeTrue</code> (spirv::KHRAssumeTrueOp)&nbsp;<a class=headline-hash href=#spirvkhrassumetrue-spirvkhrassumetrueop>¶</a></h3><p><em>TBD</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.AssumeTrue` $condition attr-dict
</code></pre><pre tabindex=0><code>assumetruekhr-op ::= `spirv.KHR.AssumeTrue` ssa-use
</code></pre><h4 id=example-228>Example:&nbsp;<a class=headline-hash href=#example-228>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>KHR<span class=p>.</span>AssumeTrue <span class=nv>%arg</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-214>Operands:&nbsp;<a class=headline-hash href=#operands-214>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>bool</td></tr></tbody></table><h3 id=spirvkhrcooperativematrixlength-spirvkhrcooperativematrixlengthop><code>spirv.KHR.CooperativeMatrixLength</code> (spirv::KHRCooperativeMatrixLengthOp)&nbsp;<a class=headline-hash href=#spirvkhrcooperativematrixlength-spirvkhrcooperativematrixlengthop>¶</a></h3><p><em>Queries the number of cooperative matrix components</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.CooperativeMatrixLength` attr-dict `:` $cooperative_matrix_type
</code></pre><p>Number of components of a cooperative matrix type accessible to each
invocation when treated as a composite.</p><p>The type attribute must be a cooperative matrix type.</p><h4 id=example-229>Example:&nbsp;<a class=headline-hash href=#example-229>¶</a></h4><pre tabindex=0><code>%0 = spirv.KHR.CooperativeMatrixLength :
       !spirv.coopmatrix&lt;8x16xi32, Subgroup, MatrixA&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-82>Attributes:&nbsp;<a class=headline-hash href=#attributes-82>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cooperative_matrix_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of any SPIR-V cooperative matrix type</td></tr></table><h4 id=results-211>Results:&nbsp;<a class=headline-hash href=#results-211>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Int32</td></tr></tbody></table><h3 id=spirvkhrcooperativematrixload-spirvkhrcooperativematrixloadop><code>spirv.KHR.CooperativeMatrixLoad</code> (spirv::KHRCooperativeMatrixLoadOp)&nbsp;<a class=headline-hash href=#spirvkhrcooperativematrixload-spirvkhrcooperativematrixloadop>¶</a></h3><p><em>Loads a cooperative matrix through a pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.CooperativeMatrixLoad` $pointer `,` $stride `,` $matrix_layout ( `,` $memory_operand^ )? ( `,` $alignment^ )? attr-dict `:`
              type(operands) `-&gt;` type($result)
</code></pre><p>Load a cooperative matrix through a pointer.</p><p>Result Type is the type of the loaded object. It must be a cooperative
matrix type.</p><p>Pointer is a pointer. Its type must be an OpTypePointer whose Type operand is
a scalar or vector type. If the Shader capability was declared, Pointer must
point into an array and any ArrayStride decoration on Pointer is ignored.</p><p>MemoryLayout specifies how matrix elements are laid out in memory. It must
come from a 32-bit integer constant instruction whose value corresponds to a
Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
description of the layouts and detailed layout-specific rules.</p><p>Stride further qualifies how matrix elements are laid out in memory. It must
be a scalar integer type and its exact semantics depend on MemoryLayout.</p><p>Memory Operand must be a Memory Operand literal. If not present, it is the
same as specifying None.</p><p>NOTE: In earlier versions of the SPIR-V spec, &lsquo;Memory Operand&rsquo; was known
as &lsquo;Memory Access&rsquo;.</p><p>For a given dynamic instance of this instruction, all operands of this
instruction must be the same for all invocations in a given scope instance
(where the scope is the scope the cooperative matrix type was created with).
All invocations in a given scope instance must be active or all must be
inactive.</p><p>TODO: In the SPIR-V spec, <code>stride</code> is an optional argument. We should also
support this optionality in the SPIR-V dialect.</p><h4 id=example-230>Example:&nbsp;<a class=headline-hash href=#example-230>¶</a></h4><pre tabindex=0><code>%0 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, &lt;RowMajor&gt;
     : !spirv.ptr&lt;i32, StorageBuffer&gt;, i32
         -&gt; !spirv.KHR.coopmatrix&lt;16x8xi32, Workgroup, MatrixA&gt;

%1 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, &lt;ColumnMajor&gt;, &lt;Volatile&gt;
     : !spirv.ptr&lt;f32, StorageBuffer&gt;, i64
         -&gt; !spirv.KHR.coopmatrix&lt;8x8xf32, Subgroup, MatrixAcc&gt;
</code></pre><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-83>Attributes:&nbsp;<a class=headline-hash href=#attributes-83>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>matrix_layout</code></td><td>::mlir::spirv::CooperativeMatrixLayoutKHRAttr</td><td>valid SPIR-V Cooperative Matrix Layout (KHR)</td></tr><tr><td><code>memory_operand</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr></table><h4 id=operands-215>Operands:&nbsp;<a class=headline-hash href=#operands-215>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-212>Results:&nbsp;<a class=headline-hash href=#results-212>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V cooperative matrix type</td></tr></tbody></table><h3 id=spirvkhrcooperativematrixmuladd-spirvkhrcooperativematrixmuladdop><code>spirv.KHR.CooperativeMatrixMulAdd</code> (spirv::KHRCooperativeMatrixMulAddOp)&nbsp;<a class=headline-hash href=#spirvkhrcooperativematrixmuladd-spirvkhrcooperativematrixmuladdop>¶</a></h3><p><em>Returns the result of <code>(A x B) + C</code> of matrices A, B, and C</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.CooperativeMatrixMulAdd` $a `,` $b `,` $c ( `,` $matrix_operands^ )? attr-dict `:`
              type($a) `,` type($b) `-&gt;` type($c)
</code></pre><p>Linear-algebraic matrix multiply of A by B and then component-wise add C.
The order of the operations is implementation-dependent. The internal
precision of floating-point operations is defined by the client API. Integer
operations used in the multiplication of A by B are performed at the
precision of the Result Type and the resulting value will equal the
low-order N bits of the correct result R, where N is the result width and R
is computed with enough precision to avoid overflow and underflow if the
SaturatingAccumulation Cooperative Matrix Operand is not present. If the
SaturatingAccumulation Cooperative Matrix Operand is present and overflow or
underflow occurs as part of calculating that intermediate result, the result
of the instruction is undefined. Integer additions of the elements of that
intermediate result with those of C are performed at the precision of Result
Type, are exact, and are saturating if the SaturatingAccumulation
Cooperative Matrix Operand is present, with the signedness of the saturation
being that of the components of Result Type. If the SaturatingAccumulation
Cooperative Matrix Operand is not present then the resulting value will
equal the low-order N bits of the correct result R, where N is the result
width and R is computed with enough precision to avoid overflow and
underflow.</p><p>Result Type must be a cooperative matrix type with M rows and N columns
whose Use must be MatrixAccumulatorKHR.</p><p>A is a cooperative matrix with M rows and K columns whose Use must be
MatrixAKHR.</p><p>B is a cooperative matrix with K rows and N columns whose Use must be
MatrixBKHR.</p><p>C is a cooperative matrix with M rows and N columns whose Use must be
MatrixAccumulatorKHR.</p><p>The values of M, N, and K must be consistent across the result and operands.
This is referred to as an MxNxK matrix multiply.</p><p>A, B, C, and Result Type must have the same scope, and this defines the
scope of the operation. A, B, C, and Result Type need not necessarily have
the same component type, this is defined by the client API.</p><p>If the Component Type of any matrix operand is an integer type, then its
components are treated as signed if the Matrix{A,B,C,Result}SignedComponents
Cooperative Matrix Operand is present and are treated as unsigned otherwise.</p><p>Cooperative Matrix Operands is an optional Cooperative Matrix Operand
literal. If not present, it is the same as specifying the Cooperative Matrix
Operand None.</p><p>For a given dynamic instance of this instruction, all invocations in a given
scope instance must be active or all must be inactive (where the scope is
the scope of the operation).</p><pre tabindex=0><code>cooperative-matrixmuladd-op ::= ssa-id `=` `spirv.KHR.CooperativeMatrixMulAdd`
                          ssa-use `,` ssa-use `,` ssa-use
                          (`&lt;` matrix-operands `&gt;`)? `:`
                          a-cooperative-matrix-type `,`
                          b-cooperative-matrix-type `-&gt;`
                            result-cooperative-matrix-type
</code></pre><h4 id=example-231>Example:&nbsp;<a class=headline-hash href=#example-231>¶</a></h4><pre tabindex=0><code>%0 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC :
  !spirv.coopmatrix&lt;4x4xf32, Subgroup, MatrixA&gt;,
  !spirv.coopmatrix&lt;4x4xf32, Subgroup, MatrixB&gt; -&gt;
    !spirv.coopmatrix&lt;4x4xf32, Subgroup, MatrixAcc&gt;

%1 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC, &lt;ASigned | AccSat&gt; :
  !spirv.coopmatrix&lt;8x16xi32, Subgroup, MatrixA&gt;,
  !spirv.coopmatrix&lt;16x4xi32, Subgroup, MatrixB&gt; -&gt;
    !spirv.coopmatrix&lt;8x4xi32, Subgroup, MatrixAcc&gt;
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-84>Attributes:&nbsp;<a class=headline-hash href=#attributes-84>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>matrix_operands</code></td><td>::mlir::spirv::CooperativeMatrixOperandsKHRAttr</td><td>valid SPIR-V Cooperative Matrix Operands (KHR)</td></tr></table><h4 id=operands-216>Operands:&nbsp;<a class=headline-hash href=#operands-216>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>any SPIR-V cooperative matrix type</td></tr><tr><td style=text-align:center><code>b</code></td><td>any SPIR-V cooperative matrix type</td></tr><tr><td style=text-align:center><code>c</code></td><td>any SPIR-V cooperative matrix type</td></tr></tbody></table><h4 id=results-213>Results:&nbsp;<a class=headline-hash href=#results-213>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V cooperative matrix type</td></tr></tbody></table><h3 id=spirvkhrcooperativematrixstore-spirvkhrcooperativematrixstoreop><code>spirv.KHR.CooperativeMatrixStore</code> (spirv::KHRCooperativeMatrixStoreOp)&nbsp;<a class=headline-hash href=#spirvkhrcooperativematrixstore-spirvkhrcooperativematrixstoreop>¶</a></h3><p><em>Stores a cooperative matrix through a pointer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.CooperativeMatrixStore` $pointer `,` $object `,` $stride `,` $matrix_layout ( `,` $memory_operand^ )? ( `,` $alignment^ )? attr-dict `:`
              type(operands)
</code></pre><p>Store a cooperative matrix through a pointer.
Pointer is a pointer. Its type must be an OpTypePointer whose Type operand
is a scalar or vector type. If the Shader capability was declared, Pointer
must point into an array and any ArrayStride decoration on Pointer is
ignored.</p><p>Object is the object to store. Its type must be an
OpTypeCooperativeMatrixKHR.</p><p>MemoryLayout specifies how matrix elements are laid out in memory. It must
come from a 32-bit integer constant instruction whose value corresponds to a
Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
description of the layouts and detailed layout-specific rules.</p><p>Stride further qualifies how matrix elements are laid out in memory. It must
be a scalar integer type and its exact semantics depend on MemoryLayout.</p><p>Memory Operand must be a Memory Operand literal. If not present, it is the
same as specifying None.</p><p>NOTE: In earlier versions of the SPIR-V spec, &lsquo;Memory Operand&rsquo; was known
as &lsquo;Memory Access&rsquo;.</p><p>For a given dynamic instance of this instruction, all operands of this
instruction must be the same for all invocations in a given scope instance
(where the scope is the scope the cooperative matrix type was created with).
All invocations in a given scope instance must be active or all must be
inactive.</p><p>TODO: In the SPIR-V spec, <code>stride</code> is an optional argument. We should also
support this optionality in the SPIR-V dialect.</p><h4 id=example-232>Example:&nbsp;<a class=headline-hash href=#example-232>¶</a></h4><pre tabindex=0><code>  spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, &lt;RowMajor&gt; :
    !spirv.ptr&lt;i32, StorageBuffer&gt;, !spirv.coopmatrix&lt;16x8xi32, Workgroup, MatrixA&gt;, i32

  spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, &lt;ColumnMajor&gt;, &lt;Volatile&gt; :
    !spirv.ptr&lt;f32, StorageBuffer&gt;, !spirv.coopmatrix&lt;8x8xf32, Subgroup, MatrixAcc&gt;, i64
</code></pre><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-85>Attributes:&nbsp;<a class=headline-hash href=#attributes-85>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>matrix_layout</code></td><td>::mlir::spirv::CooperativeMatrixLayoutKHRAttr</td><td>valid SPIR-V Cooperative Matrix Layout (KHR)</td></tr><tr><td><code>memory_operand</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr></table><h4 id=operands-217>Operands:&nbsp;<a class=headline-hash href=#operands-217>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>object</code></td><td>any SPIR-V cooperative matrix type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvkhrsubgroupballot-spirvkhrsubgroupballotop><code>spirv.KHR.SubgroupBallot</code> (spirv::KHRSubgroupBallotOp)&nbsp;<a class=headline-hash href=#spirvkhrsubgroupballot-spirvkhrsubgroupballotop>¶</a></h3><p><em>See extension SPV_KHR_shader_ballot</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.KHR.SubgroupBallot` $predicate attr-dict `:` type($result)
</code></pre><p>Computes a bitfield value combining the Predicate value from all invocations
in the current Subgroup that execute the same dynamic instance of this
instruction. The bit is set to one if the corresponding invocation is active
and the predicate is evaluated to true; otherwise, it is set to zero.</p><p>Predicate must be a Boolean type.</p><p>Result Type must be a 4 component vector of 32 bit integer types.</p><p>Result is a set of bitfields where the first invocation is represented in bit
0 of the first vector component and the last (up to SubgroupSize) is the
higher bit number of the last bitmask needed to represent all bits of the
subgroup invocations.</p><pre tabindex=0><code>subgroup-ballot-op ::= ssa-id `=` `spirv.KHR.SubgroupBallot`
                            ssa-use `:` `vector` `&lt;` 4 `x` `i32` `&gt;`
</code></pre><h4 id=example-233>Example:&nbsp;<a class=headline-hash href=#example-233>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>KHR<span class=p>.</span>SubgroupBallot <span class=nv>%predicate</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=operands-218>Operands:&nbsp;<a class=headline-hash href=#operands-218>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>bool</td></tr></tbody></table><h4 id=results-214>Results:&nbsp;<a class=headline-hash href=#results-214>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 32-bit integer values of length 4</td></tr></tbody></table><h3 id=spirvkill-spirvkillop><code>spirv.Kill</code> (spirv::KillOp)&nbsp;<a class=headline-hash href=#spirvkill-spirvkillop>¶</a></h3><p><em>Deprecated (use OpTerminateInvocation or OpDemoteToHelperInvocation).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Kill` attr-dict
</code></pre><p>Fragment-shader discard.</p><p>Ceases all further processing in any invocation that executes it: Only
instructions these invocations executed before OpKill have observable
side effects. If this instruction is executed in non-uniform control
flow, all subsequent control flow is non-uniform (for invocations that
continue to execute).</p><p>This instruction must be the last instruction in a block.</p><p>This instruction is only valid in the Fragment Execution Model.</p><h4 id=example-234>Example:&nbsp;<a class=headline-hash href=#example-234>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>Kill
</span></span></code></pre></div><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h3 id=spirvload-spirvloadop><code>spirv.Load</code> (spirv::LoadOp)&nbsp;<a class=headline-hash href=#spirvload-spirvloadop>¶</a></h3><p><em>Load through a pointer.</em></p><p>Result Type is the type of the loaded object. It must be a type with
fixed size; i.e., it cannot be, nor include, any OpTypeRuntimeArray
types.</p><p>Pointer is the pointer to load through. Its type must be an
OpTypePointer whose Type operand is the same as Result Type.</p><p>If present, any Memory Operands must begin with a memory operand
literal. If not present, it is the same as specifying the memory operand
None.</p><pre tabindex=0><code>memory-access ::= `&#34;None&#34;` | `&#34;Volatile&#34;` | `&#34;Aligned&#34;, ` integer-literal
                | `&#34;NonTemporal&#34;`

load-op ::= ssa-id ` = spirv.Load ` storage-class ssa-use
            (`[` memory-access `]`)? ` : ` spirv-element-type
</code></pre><h4 id=example-235>Example:&nbsp;<a class=headline-hash href=#example-235>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span> <span class=p>[</span><span class=s>&#34;Volatile&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Load <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span> <span class=p>[</span><span class=s>&#34;Aligned&#34;</span><span class=p>,</span> <span class=m>4</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-86>Attributes:&nbsp;<a class=headline-hash href=#attributes-86>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_access</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr></table><h4 id=operands-219>Operands:&nbsp;<a class=headline-hash href=#operands-219>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-215>Results:&nbsp;<a class=headline-hash href=#results-215>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvlogicaland-spirvlogicalandop><code>spirv.LogicalAnd</code> (spirv::LogicalAndOp)&nbsp;<a class=headline-hash href=#spirvlogicaland-spirvlogicalandop>¶</a></h3><p><em>Result is true if both Operand 1 and Operand 2 are true. Result is false
if either Operand 1 or Operand 2 are false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.LogicalAnd` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-236>Example:&nbsp;<a class=headline-hash href=#example-236>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalAnd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalAnd <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-220>Operands:&nbsp;<a class=headline-hash href=#operands-220>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-216>Results:&nbsp;<a class=headline-hash href=#results-216>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvlogicalequal-spirvlogicalequalop><code>spirv.LogicalEqual</code> (spirv::LogicalEqualOp)&nbsp;<a class=headline-hash href=#spirvlogicalequal-spirvlogicalequalop>¶</a></h3><p><em>Result is true if Operand 1 and Operand 2 have the same value. Result is
false if Operand 1 and Operand 2 have different values.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.LogicalEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-237>Example:&nbsp;<a class=headline-hash href=#example-237>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-221>Operands:&nbsp;<a class=headline-hash href=#operands-221>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-217>Results:&nbsp;<a class=headline-hash href=#results-217>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvlogicalnotequal-spirvlogicalnotequalop><code>spirv.LogicalNotEqual</code> (spirv::LogicalNotEqualOp)&nbsp;<a class=headline-hash href=#spirvlogicalnotequal-spirvlogicalnotequalop>¶</a></h3><p><em>Result is true if Operand 1 and Operand 2 have different values. Result
is false if Operand 1 and Operand 2 have the same value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.LogicalNotEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-238>Example:&nbsp;<a class=headline-hash href=#example-238>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalNotEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalNotEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-222>Operands:&nbsp;<a class=headline-hash href=#operands-222>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-218>Results:&nbsp;<a class=headline-hash href=#results-218>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvlogicalnot-spirvlogicalnotop><code>spirv.LogicalNot</code> (spirv::LogicalNotOp)&nbsp;<a class=headline-hash href=#spirvlogicalnot-spirvlogicalnotop>¶</a></h3><p><em>Result is true if Operand is false. Result is false if Operand is true.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.LogicalNot` $operand `:` type($operand) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-239>Example:&nbsp;<a class=headline-hash href=#example-239>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalNot <span class=nv>%0</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalNot <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-223>Operands:&nbsp;<a class=headline-hash href=#operands-223>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-219>Results:&nbsp;<a class=headline-hash href=#results-219>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvlogicalor-spirvlogicalorop><code>spirv.LogicalOr</code> (spirv::LogicalOrOp)&nbsp;<a class=headline-hash href=#spirvlogicalor-spirvlogicalorop>¶</a></h3><p><em>Result is true if either Operand 1 or Operand 2 is true. Result is false
if both Operand 1 and Operand 2 are false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.LogicalOr` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 must be the same as Result Type.</p><p>The type of Operand 2 must be the same as Result Type.</p><p>Results are computed per component.</p><h4 id=example-240>Example:&nbsp;<a class=headline-hash href=#example-240>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalOr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>LogicalOr <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-224>Operands:&nbsp;<a class=headline-hash href=#operands-224>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-220>Results:&nbsp;<a class=headline-hash href=#results-220>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvmlirloop-spirvloopop><code>spirv.mlir.loop</code> (spirv::LoopOp)&nbsp;<a class=headline-hash href=#spirvmlirloop-spirvloopop>¶</a></h3><p><em>Define a structured loop.</em></p><p>SPIR-V can explicitly declare structured control-flow constructs using merge
instructions. These explicitly declare a header block before the control
flow diverges and a merge block where control flow subsequently converges.
These blocks delimit constructs that must nest, and can only be entered
and exited in structured ways. See &ldquo;2.11. Structured Control Flow&rdquo; of the
SPIR-V spec for more details.</p><p>Instead of having a <code>spirv.LoopMerge</code> op to directly model loop merge
instruction for indicating the merge and continue target, we use regions
to delimit the boundary of the loop: the merge target is the next op
following the <code>spirv.mlir.loop</code> op and the continue target is the block that
has a back-edge pointing to the entry block inside the <code>spirv.mlir.loop</code>&rsquo;s region.
This way it&rsquo;s easier to discover all blocks belonging to a construct and
it plays nicer with the MLIR system.</p><p>The <code>spirv.mlir.loop</code> region should contain at least four blocks: one entry block,
one loop header block, one loop continue block, one loop merge block.
The entry block should be the first block and it should jump to the loop
header block, which is the second block. The loop merge block should be the
last block. The merge block should only contain a <code>spirv.mlir.merge</code> op.
The continue block should be the second to last block and it should have a
branch to the loop header block. The loop continue block should be the only
block, except the entry block, branching to the header block.</p><p>Values defined inside the loop regions cannot be directly used
outside of them; however, the loop region can yield values. These values are
yielded using a <code>spirv.mlir.merge</code> op and returned as a result of the loop op.</p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-87>Attributes:&nbsp;<a class=headline-hash href=#attributes-87>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>loop_control</code></td><td>::mlir::spirv::LoopControlAttr</td><td>valid SPIR-V LoopControl</td></tr></table><h4 id=results-221>Results:&nbsp;<a class=headline-hash href=#results-221>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=spirvmatrixtimesmatrix-spirvmatrixtimesmatrixop><code>spirv.MatrixTimesMatrix</code> (spirv::MatrixTimesMatrixOp)&nbsp;<a class=headline-hash href=#spirvmatrixtimesmatrix-spirvmatrixtimesmatrixop>¶</a></h3><p><em>Linear-algebraic multiply of LeftMatrix X RightMatrix.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.MatrixTimesMatrix` operands attr-dict `:` type($leftmatrix) `,` type($rightmatrix) `-&gt;` type($result)
</code></pre><p>Result Type must be an OpTypeMatrix whose Column Type is a vector of
floating-point type.</p><p>LeftMatrix must be a matrix whose Column Type is the same as the Column
Type in Result Type.</p><p>RightMatrix must be a matrix with the same Component Type as the
Component Type in Result Type. Its number of columns must equal the
number of columns in Result Type. Its columns must have the same number
of components as the number of columns in LeftMatrix.</p><h4 id=example-241>Example:&nbsp;<a class=headline-hash href=#example-241>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>MatrixTimesMatrix <span class=nv>%matrix_1</span><span class=p>,</span> <span class=nv>%matrix_2</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>3 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-225>Operands:&nbsp;<a class=headline-hash href=#operands-225>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>leftmatrix</code></td><td>any SPIR-V matrix type</td></tr><tr><td style=text-align:center><code>rightmatrix</code></td><td>any SPIR-V matrix type</td></tr></tbody></table><h4 id=results-222>Results:&nbsp;<a class=headline-hash href=#results-222>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V matrix type</td></tr></tbody></table><h3 id=spirvmatrixtimesscalar-spirvmatrixtimesscalarop><code>spirv.MatrixTimesScalar</code> (spirv::MatrixTimesScalarOp)&nbsp;<a class=headline-hash href=#spirvmatrixtimesscalar-spirvmatrixtimesscalarop>¶</a></h3><p><em>Scale a floating-point matrix.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.MatrixTimesScalar` operands attr-dict `:` type($matrix) `,` type($scalar)
</code></pre><p>Result Type must be a matrix type with a float component type.</p><p>The type of Matrix must be the same as Result Type. Each component in
each column in Matrix is multiplied by Scalar.</p><p>Scalar must have the same type as the Component Type in Result Type.</p><h4 id=example-242>Example:&nbsp;<a class=headline-hash href=#example-242>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>MatrixTimesScalar <span class=nv>%matrix</span><span class=p>,</span> <span class=nv>%scalar</span> <span class=p>:</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>3 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> <span class=k>f32</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>3 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-226>Operands:&nbsp;<a class=headline-hash href=#operands-226>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>any SPIR-V matrix type or Cooperative Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>16/32/64-bit float</td></tr></tbody></table><h4 id=results-223>Results:&nbsp;<a class=headline-hash href=#results-223>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V matrix type or Cooperative Matrix of 16/32/64-bit float values</td></tr></tbody></table><h3 id=spirvmatrixtimesvector-spirvmatrixtimesvectorop><code>spirv.MatrixTimesVector</code> (spirv::MatrixTimesVectorOp)&nbsp;<a class=headline-hash href=#spirvmatrixtimesvector-spirvmatrixtimesvectorop>¶</a></h3><p><em>Linear-algebraic Matrix X Vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.MatrixTimesVector` operands attr-dict `:` type($matrix) `,` type($vector) `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of floating-point type.</p><p>Matrix must be an OpTypeMatrix whose Column Type is Result Type.</p><p>Vector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.</p><h4 id=example-243>Example:&nbsp;<a class=headline-hash href=#example-243>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>MatrixTimesVector <span class=nv>%matrix</span><span class=p>,</span> <span class=nv>%vector</span> <span class=p>:</span> 
</span></span><span class=line><span class=cl>    <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>3 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-227>Operands:&nbsp;<a class=headline-hash href=#operands-227>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>Matrix of 16/32/64-bit float values</td></tr><tr><td style=text-align:center><code>vector</code></td><td>fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-224>Results:&nbsp;<a class=headline-hash href=#results-224>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvmemorybarrier-spirvmemorybarrierop><code>spirv.MemoryBarrier</code> (spirv::MemoryBarrierOp)&nbsp;<a class=headline-hash href=#spirvmemorybarrier-spirvmemorybarrierop>¶</a></h3><p><em>Control the order that memory accesses are observed.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.MemoryBarrier` $memory_scope `,` $memory_semantics attr-dict
</code></pre><p>Ensures that memory accesses issued before this instruction will be
observed before memory accesses issued after this instruction. This
control is ensured only for memory accesses issued by this invocation
and observed by another invocation executing within Memory scope. If the
Vulkan memory model is declared, this ordering only applies to memory
accesses that use the NonPrivatePointer memory operand or
NonPrivateTexel image operand.</p><p>Semantics declares what kind of memory is being controlled and what kind
of control to apply.</p><p>To execute both a memory barrier and a control barrier, see
OpControlBarrier.</p><h4 id=example-244>Example:&nbsp;<a class=headline-hash href=#example-244>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>MemoryBarrier <span class=s>&#34;Device&#34;</span><span class=p>,</span> <span class=s>&#34;Acquire|UniformMemory&#34;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-88>Attributes:&nbsp;<a class=headline-hash href=#attributes-88>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_scope</code></td><td>::mlir::spirv::ScopeAttr</td><td>valid SPIR-V Scope</td></tr><tr><td><code>memory_semantics</code></td><td>::mlir::spirv::MemorySemanticsAttr</td><td>valid SPIR-V MemorySemantics</td></tr></table><h3 id=spirvmlirmerge-spirvmergeop><code>spirv.mlir.merge</code> (spirv::MergeOp)&nbsp;<a class=headline-hash href=#spirvmlirmerge-spirvmergeop>¶</a></h3><p><em>A special terminator for merging a structured selection/loop.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.mlir.merge` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>We use <code>spirv.mlir.selection</code>/<code>spirv.mlir.loop</code> for modelling structured selection/loop.
This op is a terminator used inside their regions to mean jumping to the
merge point, which is the next op following the <code>spirv.mlir.selection</code> or
<code>spirv.mlir.loop</code> op. This op does not have a corresponding instruction in the
SPIR-V binary format; it&rsquo;s solely for structural purpose.</p><p>The instruction is also used to yield values from inside the selection/loop region
to the outside, as values that were sunk into the region cannot otherwise escape it.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;SelectionOp, LoopOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-228>Operands:&nbsp;<a class=headline-hash href=#operands-228>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=spirvmodule-spirvmoduleop><code>spirv.module</code> (spirv::ModuleOp)&nbsp;<a class=headline-hash href=#spirvmodule-spirvmoduleop>¶</a></h3><p><em>The top-level op that defines a SPIR-V module</em></p><p>This op defines a SPIR-V module using a MLIR region. The region contains
one block. Module-level operations, including functions definitions,
are all placed in this block.</p><p>Using an op with a region to define a SPIR-V module enables &ldquo;embedding&rdquo;
SPIR-V modules in other dialects in a clean manner: this op guarantees
the validity and serializability of a SPIR-V module and thus serves as
a clear-cut boundary.</p><p>This op takes no operands and generates no results. This op should not
implicitly capture values from the enclosing environment.</p><p>This op has only one region, which only contains one block. The block
has no terminator.</p><pre tabindex=0><code>addressing-model ::= `Logical` | `Physical32` | `Physical64` | ...
memory-model ::= `Simple` | `GLSL450` | `OpenCL` | `Vulkan` | ...
spv-module-op ::= `spirv.module` addressing-model memory-model
                  (requires  spirv-vce-attribute)?
                  (`attributes` attribute-dict)?
                  region
</code></pre><h4 id=example-245>Example:&nbsp;<a class=headline-hash href=#example-245>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>module Logical GLSL450  <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>module Logical Vulkan
</span></span><span class=line><span class=cl>    requires <span class=nv>#spirv.vce</span><span class=p>&lt;</span>v1<span class=p>.</span><span class=m>0</span><span class=p>,</span> <span class=p>[</span>Shader<span class=p>],</span> <span class=p>[</span>SPV_KHR_vulkan_memory_model<span class=p>]&gt;</span>
</span></span><span class=line><span class=cl>    attributes <span class=p>{</span> <span class=nl>some_additional_attr =</span> <span class=p>...</span> <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  spirv<span class=p>.</span><span class=kt>func</span> <span class=nf>@do_nothing</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    spirv<span class=p>.</span>Return
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-89>Attributes:&nbsp;<a class=headline-hash href=#attributes-89>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>addressing_model</code></td><td>::mlir::spirv::AddressingModelAttr</td><td>valid SPIR-V AddressingModel</td></tr><tr><td><code>memory_model</code></td><td>::mlir::spirv::MemoryModelAttr</td><td>valid SPIR-V MemoryModel</td></tr><tr><td><code>vce_triple</code></td><td>::mlir::spirv::VerCapExtAttr</td><td>version-capability-extension attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=spirvnot-spirvnotop><code>spirv.Not</code> (spirv::NotOp)&nbsp;<a class=headline-hash href=#spirvnot-spirvnotop>¶</a></h3><p><em>Complement the bits of Operand.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Not` $operand `:` type($operand) attr-dict
</code></pre><p>Results are computed per component, and within each component, per bit.</p><p>Result Type must be a scalar or vector of integer type.</p><p>Operand&rsquo;s type must be a scalar or vector of integer type. It must
have the same number of components as Result Type. The component width
must equal the component width in Result Type.</p><h4 id=example-246>Example:&nbsp;<a class=headline-hash href=#example-246>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>Not <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Not <span class=nv>%1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-229>Operands:&nbsp;<a class=headline-hash href=#operands-229>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-225>Results:&nbsp;<a class=headline-hash href=#results-225>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvordered-spirvorderedop><code>spirv.Ordered</code> (spirv::OrderedOp)&nbsp;<a class=headline-hash href=#spirvordered-spirvorderedop>¶</a></h3><p><em>Result is true if both x == x and y == y are true, where IEEE comparison
is used, otherwise result is false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Ordered` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>x must be a scalar or vector of floating-point type. It must have the
same number of components as Result Type.</p><p>y must have the same type as x.</p><p>Results are computed per component.</p><h4 id=example-247>Example:&nbsp;<a class=headline-hash href=#example-247>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>Ordered <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>Ordered <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-230>Operands:&nbsp;<a class=headline-hash href=#operands-230>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-226>Results:&nbsp;<a class=headline-hash href=#results-226>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvptraccesschain-spirvptraccesschainop><code>spirv.PtrAccessChain</code> (spirv::PtrAccessChainOp)&nbsp;<a class=headline-hash href=#spirvptraccesschain-spirvptraccesschainop>¶</a></h3><p><em>Has the same semantics as OpAccessChain, with the addition of the
Element operand.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.PtrAccessChain` $base_ptr `[` $element ($indices^)? `]` attr-dict `:` type($base_ptr) `,` type($element) (`,` type($indices)^)? `-&gt;` type($result)
</code></pre><p>Element is used to do an initial dereference of Base: Base is treated as
the address of an element in an array, and a new element address is
computed from Base and Element to become the OpAccessChain Base to
dereference as per OpAccessChain. This computed Base has the same type
as the originating Base.</p><p>To compute the new element address, Element is treated as a signed count
of elements E, relative to the original Base element B, and the address
of element B + E is computed using enough precision to avoid overflow
and underflow. For objects in the Uniform, StorageBuffer, or
PushConstant storage classes, the element&rsquo;s address or location is
calculated using a stride, which will be the Base-type&rsquo;s Array Stride if
the Base type is decorated with ArrayStride. For all other objects, the
implementation calculates the element&rsquo;s address or location.</p><p>With one exception, undefined behavior results when B + E is not an
element in the same array (same innermost array, if array types are
nested) as B. The exception being when B + E = L, where L is the length
of the array: the address computation for element L is done with the
same stride as any other B + E computation that stays within the array.</p><p>Note: If Base is typed to be a pointer to an array and the desired
operation is to select an element of that array, OpAccessChain should be
directly used, as its first Index selects the array element.</p><h4 id=example-248>Example:&nbsp;<a class=headline-hash href=#example-248>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span> <span class=nf>@ptr_access_chain</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>PtrAccessChain <span class=nv>%arg0</span><span class=p>[</span><span class=nv>%arg1</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;,</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkgroup<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-231>Operands:&nbsp;<a class=headline-hash href=#operands-231>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base_ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>element</code></td><td>8/16/32/64-bit integer</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of 8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-227>Results:&nbsp;<a class=headline-hash href=#results-227>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvptrcasttogeneric-spirvptrcasttogenericop><code>spirv.PtrCastToGeneric</code> (spirv::PtrCastToGenericOp)&nbsp;<a class=headline-hash href=#spirvptrcasttogeneric-spirvptrcasttogenericop>¶</a></h3><p><em>Convert a pointer’s Storage Class to Generic.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.PtrCastToGeneric` $pointer attr-dict `:` type($pointer) `to` type($result)
</code></pre><p>Result Type must be an OpTypePointer. Its Storage Class must be Generic.</p><p>Pointer must point to the Workgroup, CrossWorkgroup, or Function Storage
Class.</p><p>Result Type and Pointer must point to the same type.</p><h4 id=example-249>Example:&nbsp;<a class=headline-hash href=#example-249>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>PtrCastToGenericOp <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> CrossWorkGroup<span class=p>&gt;</span> to
</span></span><span class=line><span class=cl>     <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Generic<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-232>Operands:&nbsp;<a class=headline-hash href=#operands-232>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-228>Results:&nbsp;<a class=headline-hash href=#results-228>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvmlirreferenceof-spirvreferenceofop><code>spirv.mlir.referenceof</code> (spirv::ReferenceOfOp)&nbsp;<a class=headline-hash href=#spirvmlirreferenceof-spirvreferenceofop>¶</a></h3><p><em>Reference a specialization constant.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.mlir.referenceof` $spec_const attr-dict `:` type($reference)
</code></pre><p>Specialization constants in module scope are defined using symbol names.
This op generates an SSA value that can be used to refer to the symbol
within function scope for use in ops that expect an SSA value.
This operation has no corresponding SPIR-V instruction; it&rsquo;s merely used
for modelling purpose in the SPIR-V dialect. This op&rsquo;s return type is
the same as the specialization constant.</p><h4 id=example-250>Example:&nbsp;<a class=headline-hash href=#example-250>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>mlir<span class=p>.</span>referenceof <span class=nf>@spec_const</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>TODO Add support for composite specialization constants.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-90>Attributes:&nbsp;<a class=headline-hash href=#attributes-90>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>spec_const</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-229>Results:&nbsp;<a class=headline-hash href=#results-229>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>reference</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvreturn-spirvreturnop><code>spirv.Return</code> (spirv::ReturnOp)&nbsp;<a class=headline-hash href=#spirvreturn-spirvreturnop>¶</a></h3><p><em>Return with no value from a function with void return type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Return` attr-dict
</code></pre><p>This instruction must be the last instruction in a block.</p><h4 id=example-251>Example:&nbsp;<a class=headline-hash href=#example-251>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>Return
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h3 id=spirvreturnvalue-spirvreturnvalueop><code>spirv.ReturnValue</code> (spirv::ReturnValueOp)&nbsp;<a class=headline-hash href=#spirvreturnvalue-spirvreturnvalueop>¶</a></h3><p><em>Return a value from a function.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ReturnValue` $value attr-dict `:` type($value)
</code></pre><p>Value is the value returned, by copy, and must match the Return Type
operand of the OpTypeFunction type of the OpFunction body this return
instruction is in.</p><p>This instruction must be the last instruction in a block.</p><h4 id=example-252>Example:&nbsp;<a class=headline-hash href=#example-252>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>ReturnValue <span class=nv>%0</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-233>Operands:&nbsp;<a class=headline-hash href=#operands-233>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvsconvert-spirvsconvertop><code>spirv.SConvert</code> (spirv::SConvertOp)&nbsp;<a class=headline-hash href=#spirvsconvert-spirvsconvertop>¶</a></h3><p><em>Convert signed width. This is either a truncate or a sign extend.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SConvert` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Signed Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type. The component width
cannot equal the component width in Result Type.</p><p>Results are computed per component.</p><h4 id=example-253>Example:&nbsp;<a class=headline-hash href=#example-253>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>SConvertOp <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span> to <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>SConvertOp <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-234>Operands:&nbsp;<a class=headline-hash href=#operands-234>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-230>Results:&nbsp;<a class=headline-hash href=#results-230>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvsdiv-spirvsdivop><code>spirv.SDiv</code> (spirv::SDivOp)&nbsp;<a class=headline-hash href=#spirvsdiv-spirvsdivop>¶</a></h3><p><em>Signed-integer division of Operand 1 divided by Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SDiv` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h4 id=example-254>Example:&nbsp;<a class=headline-hash href=#example-254>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SDiv <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SDiv <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-235>Operands:&nbsp;<a class=headline-hash href=#operands-235>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-231>Results:&nbsp;<a class=headline-hash href=#results-231>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvsdotaccsat-spirvsdotaccsatop><code>spirv.SDotAccSat</code> (spirv::SDotAccSatOp)&nbsp;<a class=headline-hash href=#spirvsdotaccsat-spirvsdotaccsatop>¶</a></h3><p><em>Signed integer dot product of Vector 1 and Vector 2 and signed
saturating addition of the result with Accumulator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SDotAccSat` $vector1 `,` $vector2 `,` $accumulator ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type whose Width must be greater than or
equal to that of the components of Vector 1 and Vector 2.</p><p>Vector 1 and Vector 2 must have the same type.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type
(enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</p><p>The type of Accumulator must be the same as Result Type.</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of the input vectors are sign-extended to the bit width
of the result&rsquo;s type. The sign-extended input vectors are then
multiplied component-wise and all components of the vector resulting
from the component-wise multiplication are added together. Finally, the
resulting sum is added to the input accumulator. This final addition is
saturating.</p><p>If any of the multiplications or additions, with the exception of the
final accumulation, overflow or underflow, the result of the instruction
is undefined.</p><h4 id=example-255>Example:&nbsp;<a class=headline-hash href=#example-255>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-91>Attributes:&nbsp;<a class=headline-hash href=#attributes-91>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-236>Operands:&nbsp;<a class=headline-hash href=#operands-236>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>accumulator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-232>Results:&nbsp;<a class=headline-hash href=#results-232>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvsdot-spirvsdotop><code>spirv.SDot</code> (spirv::SDotOp)&nbsp;<a class=headline-hash href=#spirvsdot-spirvsdotop>¶</a></h3><p><em>Signed integer dot product of Vector 1 and Vector 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SDot` $vector1 `,` $vector2 ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type whose Width must be greater than or
equal to that of the components of Vector 1 and Vector 2.</p><p>Vector 1 and Vector 2 must have the same type.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type
(enabled by the DotProductInput4x8Bit or DotProductInputAll capability).</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of the input vectors are sign-extended to the bit width
of the result&rsquo;s type. The sign-extended input vectors are then
multiplied component-wise and all components of the vector resulting
from the component-wise multiplication are added together. The resulting
value will equal the low-order N bits of the correct result R, where N
is the result width and R is computed with enough precision to avoid
overflow and underflow.</p><h4 id=example-256>Example:&nbsp;<a class=headline-hash href=#example-256>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-92>Attributes:&nbsp;<a class=headline-hash href=#attributes-92>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-237>Operands:&nbsp;<a class=headline-hash href=#operands-237>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-233>Results:&nbsp;<a class=headline-hash href=#results-233>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvsgreaterthanequal-spirvsgreaterthanequalop><code>spirv.SGreaterThanEqual</code> (spirv::SGreaterThanEqualOp)&nbsp;<a class=headline-hash href=#spirvsgreaterthanequal-spirvsgreaterthanequalop>¶</a></h3><p><em>Signed-integer comparison if Operand 1 is greater than or equal to
Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SGreaterThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-257>Example:&nbsp;<a class=headline-hash href=#example-257>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SGreaterThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SGreaterThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>SignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-238>Operands:&nbsp;<a class=headline-hash href=#operands-238>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-234>Results:&nbsp;<a class=headline-hash href=#results-234>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvsgreaterthan-spirvsgreaterthanop><code>spirv.SGreaterThan</code> (spirv::SGreaterThanOp)&nbsp;<a class=headline-hash href=#spirvsgreaterthan-spirvsgreaterthanop>¶</a></h3><p><em>Signed-integer comparison if Operand 1 is greater than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SGreaterThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-258>Example:&nbsp;<a class=headline-hash href=#example-258>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SGreaterThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SGreaterThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>SignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-239>Operands:&nbsp;<a class=headline-hash href=#operands-239>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-235>Results:&nbsp;<a class=headline-hash href=#results-235>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvslessthanequal-spirvslessthanequalop><code>spirv.SLessThanEqual</code> (spirv::SLessThanEqualOp)&nbsp;<a class=headline-hash href=#spirvslessthanequal-spirvslessthanequalop>¶</a></h3><p><em>Signed-integer comparison if Operand 1 is less than or equal to Operand
2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SLessThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-259>Example:&nbsp;<a class=headline-hash href=#example-259>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SLessThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SLessThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>SignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-240>Operands:&nbsp;<a class=headline-hash href=#operands-240>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-236>Results:&nbsp;<a class=headline-hash href=#results-236>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvslessthan-spirvslessthanop><code>spirv.SLessThan</code> (spirv::SLessThanOp)&nbsp;<a class=headline-hash href=#spirvslessthan-spirvslessthanop>¶</a></h3><p><em>Signed-integer comparison if Operand 1 is less than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SLessThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-260>Example:&nbsp;<a class=headline-hash href=#example-260>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SLessThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SLessThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>SignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-241>Operands:&nbsp;<a class=headline-hash href=#operands-241>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-237>Results:&nbsp;<a class=headline-hash href=#results-237>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvsmod-spirvsmodop><code>spirv.SMod</code> (spirv::SModOp)&nbsp;<a class=headline-hash href=#spirvsmod-spirvsmodop>¶</a></h3><p><em>Signed remainder operation for the remainder whose sign matches the sign
of Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SMod` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 2.</p><h4 id=example-261>Example:&nbsp;<a class=headline-hash href=#example-261>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SMod <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SMod <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-242>Operands:&nbsp;<a class=headline-hash href=#operands-242>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-238>Results:&nbsp;<a class=headline-hash href=#results-238>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvsmulextended-spirvsmulextendedop><code>spirv.SMulExtended</code> (spirv::SMulExtendedOp)&nbsp;<a class=headline-hash href=#spirvsmulextended-spirvsmulextendedop>¶</a></h3><p><em>Result is the full value of the signed integer multiplication of Operand
1 and Operand 2.</em></p><p>Result Type must be from OpTypeStruct. The struct must have two
members, and the two members must be the same type. The member type
must be a scalar or vector of integer type.</p><p>Operand 1 and Operand 2 must have the same type as the members of Result
Type. These are consumed as signed integers.</p><p>Results are computed per component.</p><p>Member 0 of the result gets the low-order bits of the multiplication.</p><p>Member 1 of the result gets the high-order bits of the multiplication.</p><h4 id=example-262>Example:&nbsp;<a class=headline-hash href=#example-262>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>SMulExtended <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>SMulExtended <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-243>Operands:&nbsp;<a class=headline-hash href=#operands-243>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-239>Results:&nbsp;<a class=headline-hash href=#results-239>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V struct type</td></tr></tbody></table><h3 id=spirvsnegate-spirvsnegateop><code>spirv.SNegate</code> (spirv::SNegateOp)&nbsp;<a class=headline-hash href=#spirvsnegate-spirvsnegateop>¶</a></h3><p><em>Signed-integer subtract of Operand from zero.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SNegate` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>Operand&rsquo;s type must be a scalar or vector of integer type. It must
have the same number of components as Result Type. The component width
must equal the component width in Result Type.</p><p>Results are computed per component.</p><h4 id=example-263>Example:&nbsp;<a class=headline-hash href=#example-263>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>SNegate <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>SNegate <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-244>Operands:&nbsp;<a class=headline-hash href=#operands-244>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-240>Results:&nbsp;<a class=headline-hash href=#results-240>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvsrem-spirvsremop><code>spirv.SRem</code> (spirv::SRemOp)&nbsp;<a class=headline-hash href=#spirvsrem-spirvsremop>¶</a></h3><p><em>Signed remainder operation for the remainder whose sign matches the sign
of Operand 1.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SRem` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same number of components as Result
Type. They must have the same component width as Result Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0. Otherwise, the result is the remainder r of Operand
1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
sign of Operand 1.</p><h4 id=example-264>Example:&nbsp;<a class=headline-hash href=#example-264>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>SRem <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>SRem <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-245>Operands:&nbsp;<a class=headline-hash href=#operands-245>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-241>Results:&nbsp;<a class=headline-hash href=#results-241>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvsudotaccsat-spirvsudotaccsatop><code>spirv.SUDotAccSat</code> (spirv::SUDotAccSatOp)&nbsp;<a class=headline-hash href=#spirvsudotaccsat-spirvsudotaccsatop>¶</a></h3><p><em>Mixed-signedness integer dot product of Vector 1 and Vector 2 and signed
saturating addition of the result with Accumulator. Components of Vector
1 are treated as signed, components of Vector 2 are treated as unsigned.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SUDotAccSat` $vector1 `,` $vector2 `,` $accumulator ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type whose Width must be greater than or
equal to that of the components of Vector 1 and Vector 2.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type with
the same number of components and same component Width (enabled by the
DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
and Vector 2 are vectors, the components of Vector 2 must have a
Signedness of 0.</p><p>The type of Accumulator must be the same as Result Type.</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of Vector 1 are sign-extended to the bit width of the
result&rsquo;s type. All components of Vector 2 are zero-extended to the bit
width of the result&rsquo;s type. The sign- or zero-extended input vectors are
then multiplied component-wise and all components of the vector
resulting from the component-wise multiplication are added together.
Finally, the resulting sum is added to the input accumulator. This final
addition is saturating.</p><p>If any of the multiplications or additions, with the exception of the
final accumulation, overflow or underflow, the result of the instruction
is undefined.</p><h4 id=example-265>Example:&nbsp;<a class=headline-hash href=#example-265>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SignedOp</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-93>Attributes:&nbsp;<a class=headline-hash href=#attributes-93>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-246>Operands:&nbsp;<a class=headline-hash href=#operands-246>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>accumulator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-242>Results:&nbsp;<a class=headline-hash href=#results-242>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvsudot-spirvsudotop><code>spirv.SUDot</code> (spirv::SUDotOp)&nbsp;<a class=headline-hash href=#spirvsudot-spirvsudotop>¶</a></h3><p><em>Mixed-signedness integer dot product of Vector 1 and Vector 2.
Components of Vector 1 are treated as signed, components of Vector 2 are
treated as unsigned.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.SUDot` $vector1 `,` $vector2 ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type whose Width must be greater than or
equal to that of the components of Vector 1 and Vector 2.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type with
the same number of components and same component Width (enabled by the
DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
and Vector 2 are vectors, the components of Vector 2 must have a
Signedness of 0.</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of Vector 1 are sign-extended to the bit width of the
result&rsquo;s type. All components of Vector 2 are zero-extended to the bit
width of the result&rsquo;s type. The sign- or zero-extended input vectors are
then multiplied component-wise and all components of the vector
resulting from the component-wise multiplication are added together. The
resulting value will equal the low-order N bits of the correct result R,
where N is the result width and R is computed with enough precision to
avoid overflow and underflow.</p><h4 id=example-266>Example:&nbsp;<a class=headline-hash href=#example-266>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>SUDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SignedOp</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-94>Attributes:&nbsp;<a class=headline-hash href=#attributes-94>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-247>Operands:&nbsp;<a class=headline-hash href=#operands-247>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-243>Results:&nbsp;<a class=headline-hash href=#results-243>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvselect-spirvselectop><code>spirv.Select</code> (spirv::SelectOp)&nbsp;<a class=headline-hash href=#spirvselect-spirvselectop>¶</a></h3><p><em>Select between two objects. Before version 1.4, results are only
computed per component.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Select` operands attr-dict `:` type($condition) `,` type($result)
</code></pre><p>Before version 1.4, Result Type must be a pointer, scalar, or vector.</p><p>The types of Object 1 and Object 2 must be the same as Result Type.</p><p>Condition must be a scalar or vector of Boolean type.</p><p>If Condition is a scalar and true, the result is Object 1. If Condition
is a scalar and false, the result is Object 2.</p><p>If Condition is a vector, Result Type must be a vector with the same
number of components as Condition and the result is a mix of Object 1
and Object 2: When a component of Condition is true, the corresponding
component in the result is taken from Object 1, otherwise it is taken
from Object 2.</p><h4 id=example-267>Example:&nbsp;<a class=headline-hash href=#example-267>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Select <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Select <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i1</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Select <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>SelectLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-248>Operands:&nbsp;<a class=headline-hash href=#operands-248>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>true_value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>false_value</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type</td></tr></tbody></table><h4 id=results-244>Results:&nbsp;<a class=headline-hash href=#results-244>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvmlirselection-spirvselectionop><code>spirv.mlir.selection</code> (spirv::SelectionOp)&nbsp;<a class=headline-hash href=#spirvmlirselection-spirvselectionop>¶</a></h3><p><em>Define a structured selection.</em></p><p>SPIR-V can explicitly declare structured control-flow constructs using merge
instructions. These explicitly declare a header block before the control
flow diverges and a merge block where control flow subsequently converges.
These blocks delimit constructs that must nest, and can only be entered
and exited in structured ways. See &ldquo;2.11. Structured Control Flow&rdquo; of the
SPIR-V spec for more details.</p><p>Instead of having a <code>spirv.SelectionMerge</code> op to directly model selection
merge instruction for indicating the merge target, we use regions to delimit
the boundary of the selection: the merge target is the next op following the
<code>spirv.mlir.selection</code> op. This way it&rsquo;s easier to discover all blocks belonging to
the selection and it plays nicer with the MLIR system.</p><p>The <code>spirv.mlir.selection</code> region should contain at least two blocks: one selection
header block, and one selection merge. The selection header block should be
the first block. The selection merge block should be the last block.
The merge block should only contain a <code>spirv.mlir.merge</code> op.</p><p>Values defined inside the selection regions cannot be directly used
outside of them; however, the selection region can yield values. These values are
yielded using a <code>spirv.mlir.merge</code> op and returned as a result of the selection op.</p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-95>Attributes:&nbsp;<a class=headline-hash href=#attributes-95>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>selection_control</code></td><td>::mlir::spirv::SelectionControlAttr</td><td>valid SPIR-V SelectionControl</td></tr></table><h4 id=results-245>Results:&nbsp;<a class=headline-hash href=#results-245>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=spirvshiftleftlogical-spirvshiftleftlogicalop><code>spirv.ShiftLeftLogical</code> (spirv::ShiftLeftLogicalOp)&nbsp;<a class=headline-hash href=#spirvshiftleftlogical-spirvshiftleftlogicalop>¶</a></h3><p><em>Shift the bits in Base left by the number of bits specified in Shift.
The least-significant bits are zero filled.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ShiftLeftLogical` operands attr-dict `:` type($operand1) `,` type($operand2)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is treated as unsigned. The result is undefined if Shift is
greater than or equal to the bit width of the components of Base.</p><p>The number of components and bit width of Result Type must match those
Base type. All types must be integer types.</p><p>Results are computed per component.</p><h4 id=example-268>Example:&nbsp;<a class=headline-hash href=#example-268>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftLeftLogical <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftLeftLogical <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-249>Operands:&nbsp;<a class=headline-hash href=#operands-249>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-246>Results:&nbsp;<a class=headline-hash href=#results-246>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvshiftrightarithmetic-spirvshiftrightarithmeticop><code>spirv.ShiftRightArithmetic</code> (spirv::ShiftRightArithmeticOp)&nbsp;<a class=headline-hash href=#spirvshiftrightarithmetic-spirvshiftrightarithmeticop>¶</a></h3><p><em>Shift the bits in Base right by the number of bits specified in Shift.
The most-significant bits are filled with the sign bit from Base.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ShiftRightArithmetic` operands attr-dict `:` type($operand1) `,` type($operand2)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is treated as unsigned. The result is undefined if Shift is
greater than or equal to the bit width of the components of Base.</p><p>Results are computed per component.</p><h4 id=example-269>Example:&nbsp;<a class=headline-hash href=#example-269>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftRightArithmetic <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftRightArithmetic <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-250>Operands:&nbsp;<a class=headline-hash href=#operands-250>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-247>Results:&nbsp;<a class=headline-hash href=#results-247>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvshiftrightlogical-spirvshiftrightlogicalop><code>spirv.ShiftRightLogical</code> (spirv::ShiftRightLogicalOp)&nbsp;<a class=headline-hash href=#spirvshiftrightlogical-spirvshiftrightlogicalop>¶</a></h3><p><em>Shift the bits in Base right by the number of bits specified in Shift.
The most-significant bits are zero filled.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ShiftRightLogical` operands attr-dict `:` type($operand1) `,` type($operand2)
</code></pre><p>Result Type must be a scalar or vector of integer type.</p><p>The type of each Base and Shift must be a scalar or vector of integer
type. Base and Shift must have the same number of components. The
number of components and bit width of the type of Base must be the same
as in Result Type.</p><p>Shift is consumed as an unsigned integer. The result is undefined if
Shift is greater than or equal to the bit width of the components of
Base.</p><p>Results are computed per component.</p><h4 id=example-270>Example:&nbsp;<a class=headline-hash href=#example-270>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftRightLogical <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i16</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ShiftRightLogical <span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-251>Operands:&nbsp;<a class=headline-hash href=#operands-251>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-248>Results:&nbsp;<a class=headline-hash href=#results-248>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvspecconstantcomposite-spirvspecconstantcompositeop><code>spirv.SpecConstantComposite</code> (spirv::SpecConstantCompositeOp)&nbsp;<a class=headline-hash href=#spirvspecconstantcomposite-spirvspecconstantcompositeop>¶</a></h3><p><em>Declare a new composite specialization constant.</em></p><p>This op declares a SPIR-V composite specialization constant. This covers
the <code>OpSpecConstantComposite</code> SPIR-V instruction. Scalar constants are
covered by <code>spirv.SpecConstant</code>.</p><p>A constituent of a spec constant composite can be:</p><ul><li>A symbol referring of another spec constant.</li><li>The SSA ID of a non-specialization constant (i.e. defined through
<code>spirv.SpecConstant</code>).</li><li>The SSA ID of a <code>spirv.Undef</code>.</li></ul><pre tabindex=0><code>spv-spec-constant-composite-op ::= `spirv.SpecConstantComposite` symbol-ref-id ` (`
                                   symbol-ref-id (`, ` symbol-ref-id)*
                                   `) :` composite-type
</code></pre><p>where <code>composite-type</code> is some non-scalar type that can be represented in the <code>spv</code>
dialect: <code>spirv.struct</code>, <code>spirv.array</code>, or <code>vector</code>.</p><h4 id=example-271>Example:&nbsp;<a class=headline-hash href=#example-271>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@sc1</span> <span class=p>=</span> <span class=m>1</span>   <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@sc2</span> <span class=p>=</span> <span class=m>2.5</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@sc3</span> <span class=p>=</span> <span class=m>3.5</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstantComposite <span class=nf>@scc</span> <span class=p>(</span><span class=nf>@sc1</span><span class=p>,</span> <span class=nf>@sc2</span><span class=p>,</span> <span class=nf>@sc3</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>TODO Add support for constituents that are:</p><ul><li>regular constants.</li><li>undef.</li><li>spec constant composite.</li></ul><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-96>Attributes:&nbsp;<a class=headline-hash href=#attributes-96>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>constituents</code></td><td>::mlir::ArrayAttr</td><td>symbol ref array attribute</td></tr></table><h3 id=spirvspecconstant-spirvspecconstantop><code>spirv.SpecConstant</code> (spirv::SpecConstantOp)&nbsp;<a class=headline-hash href=#spirvspecconstant-spirvspecconstantop>¶</a></h3><p><em>Declare a new integer-type or floating-point-type scalar specialization
constant.</em></p><p>This op declares a SPIR-V scalar specialization constant. SPIR-V has
multiple constant instructions covering different scalar types:</p><ul><li><code>OpSpecConstantTrue</code> and <code>OpSpecConstantFalse</code> for boolean constants</li><li><code>OpSpecConstant</code> for scalar constants</li></ul><p>Similar as <code>spirv.Constant</code>, this op represents all of the above cases.
<code>OpSpecConstantComposite</code> and <code>OpSpecConstantOp</code> are modelled with
separate ops.</p><pre tabindex=0><code>spv-spec-constant-op ::= `spirv.SpecConstant` symbol-ref-id
                         `spec_id(` integer `)`
                         `=` attribute-value (`:` spirv-type)?
</code></pre><p>where <code>spec_id</code> specifies the SPIR-V SpecId decoration associated with
the op.</p><h4 id=example-272>Example:&nbsp;<a class=headline-hash href=#example-272>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@spec_const1</span> <span class=p>=</span> true
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>SpecConstant <span class=nf>@spec_const2</span> spec_id<span class=p>(</span><span class=m>5</span><span class=p>)</span> <span class=p>=</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code>, <code>Symbol</code></p><h4 id=attributes-97>Attributes:&nbsp;<a class=headline-hash href=#attributes-97>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>default_value</code></td><td>::mlir::TypedAttr</td><td><details><summary>TypedAttr instance</summary><pre><code>This interface is used for attributes that have a type. The type of an
attribute is understood to represent the type of the data contained in the
attribute and is often used as the type of a value with this data.
</code></pre></details></td></tr></table><h3 id=spirvspecconstantoperation-spirvspecconstantoperationop><code>spirv.SpecConstantOperation</code> (spirv::SpecConstantOperationOp)&nbsp;<a class=headline-hash href=#spirvspecconstantoperation-spirvspecconstantoperationop>¶</a></h3><p><em>Declare a new specialization constant that results from doing an operation.</em></p><p>This op declares a SPIR-V specialization constant that results from
doing an operation on other constants (specialization or otherwise).</p><p>In the <code>spv</code> dialect, this op is modelled as follows:</p><pre tabindex=0><code>spv-spec-constant-operation-op ::= `spirv.SpecConstantOperation` `wraps`
                                     generic-spirv-op `:` function-type
</code></pre><p>In particular, an <code>spirv.SpecConstantOperation</code> contains exactly one
region. In turn, that region, contains exactly 2 instructions:</p><ul><li>One of SPIR-V&rsquo;s instructions that are allowed within an
OpSpecConstantOp.</li><li>An <code>spirv.mlir.yield</code> instruction as the terminator.</li></ul><p>The following SPIR-V instructions are valid:</p><ul><li>OpSConvert,</li><li>OpUConvert,</li><li>OpFConvert,</li><li>OpSNegate,</li><li>OpNot,</li><li>OpIAdd,</li><li>OpISub,</li><li>OpIMul,</li><li>OpUDiv,</li><li>OpSDiv,</li><li>OpUMod,</li><li>OpSRem,</li><li>OpSMod</li><li>OpShiftRightLogical,</li><li>OpShiftRightArithmetic,</li><li>OpShiftLeftLogical</li><li>OpBitwiseOr,</li><li>OpBitwiseXor,</li><li>OpBitwiseAnd</li><li>OpVectorShuffle,</li><li>OpCompositeExtract,</li><li>OpCompositeInsert</li><li>OpLogicalOr,</li><li>OpLogicalAnd,</li><li>OpLogicalNot,</li><li>OpLogicalEqual,</li><li>OpLogicalNotEqual</li><li>OpSelect</li><li>OpIEqual,</li><li>OpINotEqual</li><li>OpULessThan,</li><li>OpSLessThan</li><li>OpUGreaterThan,</li><li>OpSGreaterThan</li><li>OpULessThanEqual,</li><li>OpSLessThanEqual</li><li>OpUGreaterThanEqual,</li><li>OpSGreaterThanEqual</li></ul><p>TODO Add capability-specific ops when supported.</p><h4 id=example-273>Example:&nbsp;<a class=headline-hash href=#example-273>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=m>1</span><span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>SpecConstantOperation wraps <span class=s>&#34;spirv.IAdd&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-249>Results:&nbsp;<a class=headline-hash href=#results-249>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=spirvstore-spirvstoreop><code>spirv.Store</code> (spirv::StoreOp)&nbsp;<a class=headline-hash href=#spirvstore-spirvstoreop>¶</a></h3><p><em>Store through a pointer.</em></p><p>Pointer is the pointer to store through. Its type must be an
OpTypePointer whose Type operand is the same as the type of Object.</p><p>Object is the object to store.</p><p>If present, any Memory Operands must begin with a memory operand
literal. If not present, it is the same as specifying the memory operand
None.</p><pre tabindex=0><code>store-op ::= `spirv.Store ` storage-class ssa-use `, ` ssa-use `, `
              (`[` memory-access `]`)? `:` spirv-element-type
</code></pre><h4 id=example-274>Example:&nbsp;<a class=headline-hash href=#example-274>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>FMul <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>[</span><span class=s>&#34;Volatile&#34;</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>Store <span class=s>&#34;Function&#34;</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>[</span><span class=s>&#34;Aligned&#34;</span><span class=p>,</span> <span class=m>4</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-98>Attributes:&nbsp;<a class=headline-hash href=#attributes-98>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>memory_access</code></td><td>::mlir::spirv::MemoryAccessAttr</td><td>valid SPIR-V MemoryAccess</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is positive and whose value is a power of two > 0</td></tr></table><h4 id=operands-252>Operands:&nbsp;<a class=headline-hash href=#operands-252>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>any SPIR-V pointer type</td></tr><tr><td style=text-align:center><code>value</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvtranspose-spirvtransposeop><code>spirv.Transpose</code> (spirv::TransposeOp)&nbsp;<a class=headline-hash href=#spirvtranspose-spirvtransposeop>¶</a></h3><p><em>Transpose a matrix.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Transpose` operands attr-dict `:` type($matrix) `-&gt;` type($result)
</code></pre><p>Result Type must be an OpTypeMatrix.</p><p>Matrix must be an object of type OpTypeMatrix. The number of columns and
the column size of Matrix must be the reverse of those in Result Type.
The types of the scalar components in Matrix and Result Type must be the
same.</p><p>Matrix must have of type of OpTypeMatrix.</p><h4 id=example-275>Example:&nbsp;<a class=headline-hash href=#example-275>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Transpose <span class=nv>%matrix</span><span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>2 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;&gt;</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>3 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-253>Operands:&nbsp;<a class=headline-hash href=#operands-253>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>any SPIR-V matrix type</td></tr></tbody></table><h4 id=results-250>Results:&nbsp;<a class=headline-hash href=#results-250>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V matrix type</td></tr></tbody></table><h3 id=spirvuconvert-spirvuconvertop><code>spirv.UConvert</code> (spirv::UConvertOp)&nbsp;<a class=headline-hash href=#spirvuconvert-spirvuconvertop>¶</a></h3><p><em>Convert unsigned width. This is either a truncate or a zero extend.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UConvert` $operand attr-dict `:` type($operand) `to` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.</p><p>Unsigned Value must be a scalar or vector of integer type. It must have
the same number of components as Result Type. The component width
cannot equal the component width in Result Type.</p><p>Results are computed per component.</p><h4 id=example-276>Example:&nbsp;<a class=headline-hash href=#example-276>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>UConvertOp <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span> to <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>UConvertOp <span class=nv>%2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-254>Operands:&nbsp;<a class=headline-hash href=#operands-254>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-251>Results:&nbsp;<a class=headline-hash href=#results-251>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvudiv-spirvudivop><code>spirv.UDiv</code> (spirv::UDivOp)&nbsp;<a class=headline-hash href=#spirvudiv-spirvudivop>¶</a></h3><p><em>Unsigned-integer division of Operand 1 divided by Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UDiv` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h4 id=example-277>Example:&nbsp;<a class=headline-hash href=#example-277>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>UDiv <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>UDiv <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-255>Operands:&nbsp;<a class=headline-hash href=#operands-255>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h4 id=results-252>Results:&nbsp;<a class=headline-hash href=#results-252>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16 or Cooperative Matrix of 8/16/32/64-bit integer values</td></tr></tbody></table><h3 id=spirvudotaccsat-spirvudotaccsatop><code>spirv.UDotAccSat</code> (spirv::UDotAccSatOp)&nbsp;<a class=headline-hash href=#spirvudotaccsat-spirvudotaccsatop>¶</a></h3><p><em>Unsigned integer dot product of Vector 1 and Vector 2 and unsigned
saturating addition of the result with Accumulator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UDotAccSat` $vector1 `,` $vector2 `,` $accumulator ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type with Signedness of 0 whose Width
must be greater than or equal to that of the components of Vector 1 and
Vector 2.</p><p>Vector 1 and Vector 2 must have the same type.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type with
Signedness of 0 (enabled by the DotProductInput4x8Bit or
DotProductInputAll capability).</p><p>The type of Accumulator must be the same as Result Type.</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of the input vectors are zero-extended to the bit width
of the result&rsquo;s type. The zero-extended input vectors are then
multiplied component-wise and all components of the vector resulting
from the component-wise multiplication are added together. Finally, the
resulting sum is added to the input accumulator. This final addition is
saturating.</p><p>If any of the multiplications or additions, with the exception of the
final accumulation, overflow or underflow, the result of the instruction
is undefined.</p><h4 id=example-278>Example:&nbsp;<a class=headline-hash href=#example-278>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDotAccSat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%acc</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-99>Attributes:&nbsp;<a class=headline-hash href=#attributes-99>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-256>Operands:&nbsp;<a class=headline-hash href=#operands-256>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>accumulator</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-253>Results:&nbsp;<a class=headline-hash href=#results-253>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvudot-spirvudotop><code>spirv.UDot</code> (spirv::UDotOp)&nbsp;<a class=headline-hash href=#spirvudot-spirvudotop>¶</a></h3><p><em>Unsigned integer dot product of Vector 1 and Vector 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UDot` $vector1 `,` $vector2 ( `,` $format^ )? attr-dict `:`
              type($vector1) `-&gt;` type($result)
</code></pre><p>Result Type must be an integer type with Signedness of 0 whose Width
must be greater than or equal to that of the components of Vector 1 and
Vector 2.</p><p>Vector 1 and Vector 2 must have the same type.</p><p>Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
DotProductInput4x8BitPacked capability) or vectors of integer type with
Signedness of 0 (enabled by the DotProductInput4x8Bit or
DotProductInputAll capability).</p><p>When Vector 1 and Vector 2 are scalar integer types, Packed Vector
Format must be specified to select how the integers are to be
interpreted as vectors.</p><p>All components of the input vectors are zero-extended to the bit width
of the result&rsquo;s type. The zero-extended input vectors are then
multiplied component-wise and all components of the vector resulting
from the component-wise multiplication are added together. The resulting
value will equal the low-order N bits of the correct result R, where N
is the result width and R is computed with enough precision to avoid
overflow and underflow.</p><h4 id=example-279>Example:&nbsp;<a class=headline-hash href=#example-279>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=p>&lt;</span>PackedVectorFormat4x8Bit<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> spirv<span class=p>.</span>UDot <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i8</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>UnsignedOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-100>Attributes:&nbsp;<a class=headline-hash href=#attributes-100>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::spirv::PackedVectorFormatAttr</td><td>valid SPIR-V PackedVectorFormat</td></tr></table><h4 id=operands-257>Operands:&nbsp;<a class=headline-hash href=#operands-257>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-254>Results:&nbsp;<a class=headline-hash href=#results-254>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h3 id=spirvugreaterthanequal-spirvugreaterthanequalop><code>spirv.UGreaterThanEqual</code> (spirv::UGreaterThanEqualOp)&nbsp;<a class=headline-hash href=#spirvugreaterthanequal-spirvugreaterthanequalop>¶</a></h3><p><em>Unsigned-integer comparison if Operand 1 is greater than or equal to
Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UGreaterThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-280>Example:&nbsp;<a class=headline-hash href=#example-280>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>UGreaterThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>UGreaterThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-258>Operands:&nbsp;<a class=headline-hash href=#operands-258>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-255>Results:&nbsp;<a class=headline-hash href=#results-255>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvugreaterthan-spirvugreaterthanop><code>spirv.UGreaterThan</code> (spirv::UGreaterThanOp)&nbsp;<a class=headline-hash href=#spirvugreaterthan-spirvugreaterthanop>¶</a></h3><p><em>Unsigned-integer comparison if Operand 1 is greater than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UGreaterThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-281>Example:&nbsp;<a class=headline-hash href=#example-281>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>UGreaterThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>UGreaterThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-259>Operands:&nbsp;<a class=headline-hash href=#operands-259>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-256>Results:&nbsp;<a class=headline-hash href=#results-256>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvulessthanequal-spirvulessthanequalop><code>spirv.ULessThanEqual</code> (spirv::ULessThanEqualOp)&nbsp;<a class=headline-hash href=#spirvulessthanequal-spirvulessthanequalop>¶</a></h3><p><em>Unsigned-integer comparison if Operand 1 is less than or equal to
Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ULessThanEqual` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-282>Example:&nbsp;<a class=headline-hash href=#example-282>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>ULessThanEqual <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ULessThanEqual <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-260>Operands:&nbsp;<a class=headline-hash href=#operands-260>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-257>Results:&nbsp;<a class=headline-hash href=#results-257>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvulessthan-spirvulessthanop><code>spirv.ULessThan</code> (spirv::ULessThanOp)&nbsp;<a class=headline-hash href=#spirvulessthan-spirvulessthanop>¶</a></h3><p><em>Unsigned-integer comparison if Operand 1 is less than Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.ULessThan` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>The type of Operand 1 and Operand 2 must be a scalar or vector of
integer type. They must have the same component width, and they must
have the same number of components as Result Type.</p><p>Results are computed per component.</p><h4 id=example-283>Example:&nbsp;<a class=headline-hash href=#example-283>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>ULessThan <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>ULessThan <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-261>Operands:&nbsp;<a class=headline-hash href=#operands-261>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-258>Results:&nbsp;<a class=headline-hash href=#results-258>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvumod-spirvumodop><code>spirv.UMod</code> (spirv::UModOp)&nbsp;<a class=headline-hash href=#spirvumod-spirvumodop>¶</a></h3><p><em>Unsigned modulo operation of Operand 1 modulo Operand 2.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.UMod` operands attr-dict `:` type($result)
</code></pre><p>Result Type must be a scalar or vector of integer type, whose Signedness
operand is 0.</p><p>The types of Operand 1 and Operand 2 both must be the same as Result
Type.</p><p>Results are computed per component. The resulting value is undefined
if Operand 2 is 0.</p><h4 id=example-284>Example:&nbsp;<a class=headline-hash href=#example-284>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>UMod <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>UMod <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>UnsignedOp</code>, <code>UsableInSpecConstantOp</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-262>Operands:&nbsp;<a class=headline-hash href=#operands-262>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-259>Results:&nbsp;<a class=headline-hash href=#results-259>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvumulextended-spirvumulextendedop><code>spirv.UMulExtended</code> (spirv::UMulExtendedOp)&nbsp;<a class=headline-hash href=#spirvumulextended-spirvumulextendedop>¶</a></h3><p><em>Result is the full value of the unsigned integer multiplication of
Operand 1 and Operand 2.</em></p><p>Result Type must be from OpTypeStruct. The struct must have two
members, and the two members must be the same type. The member type
must be a scalar or vector of integer type, whose Signedness operand is
0.</p><p>Operand 1 and Operand 2 must have the same type as the members of Result
Type. These are consumed as unsigned integers.</p><p>Results are computed per component.</p><p>Member 0 of the result gets the low-order bits of the multiplication.</p><p>Member 1 of the result gets the high-order bits of the multiplication.</p><h4 id=example-285>Example:&nbsp;<a class=headline-hash href=#example-285>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>UMulExtended <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>UMulExtended <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-263>Operands:&nbsp;<a class=headline-hash href=#operands-263>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>8/16/32/64-bit integer or fixed-length vector of 8/16/32/64-bit integer values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-260>Results:&nbsp;<a class=headline-hash href=#results-260>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SPIR-V struct type</td></tr></tbody></table><h3 id=spirvundef-spirvundefop><code>spirv.Undef</code> (spirv::UndefOp)&nbsp;<a class=headline-hash href=#spirvundef-spirvundefop>¶</a></h3><p><em>Make an intermediate object whose value is undefined.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Undef` attr-dict `:` type($result)
</code></pre><p>Result Type is the type of object to make.</p><p>Each consumption of Result <id>yields an arbitrary, possibly different
bit pattern or abstract value resulting in possibly different concrete,
abstract, or opaque values.</p><h4 id=example-286>Example:&nbsp;<a class=headline-hash href=#example-286>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Undef <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Undef <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>struct<span class=p>&lt;!</span>spirv<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-261>Results:&nbsp;<a class=headline-hash href=#results-261>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>void or bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16 or any SPIR-V pointer type or any SPIR-V array type or any SPIR-V runtime array type or any SPIR-V struct type or any SPIR-V cooperative matrix type or any SPIR-V matrix type or any SPIR-V sampled image type or any SPIR-V image type or any SPIR-V tensorArm type</td></tr></tbody></table><h3 id=spirvunordered-spirvunorderedop><code>spirv.Unordered</code> (spirv::UnorderedOp)&nbsp;<a class=headline-hash href=#spirvunordered-spirvunorderedop>¶</a></h3><p><em>Result is true if either x or y is an IEEE NaN, otherwise result is
false.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Unordered` $operand1 `,` $operand2 `:` type($operand1) attr-dict
</code></pre><p>Result Type must be a scalar or vector of Boolean type.</p><p>x must be a scalar or vector of floating-point type. It must have the
same number of components as Result Type.</p><p>y must have the same type as x.</p><p>Results are computed per component.</p><h4 id=example-287>Example:&nbsp;<a class=headline-hash href=#example-287>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> spirv<span class=p>.</span>Unordered <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> spirv<span class=p>.</span>Unordered <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultShape</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-264>Operands:&nbsp;<a class=headline-hash href=#operands-264>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand1</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>operand2</code></td><td>16/32/64-bit float or fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-262>Results:&nbsp;<a class=headline-hash href=#results-262>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool or fixed-length vector of bool values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvunreachable-spirvunreachableop><code>spirv.Unreachable</code> (spirv::UnreachableOp)&nbsp;<a class=headline-hash href=#spirvunreachable-spirvunreachableop>¶</a></h3><p><em>Behavior is undefined if this instruction is executed.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.Unreachable` attr-dict
</code></pre><p>This instruction must be the last instruction in a block.</p><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h3 id=spirvvariable-spirvvariableop><code>spirv.Variable</code> (spirv::VariableOp)&nbsp;<a class=headline-hash href=#spirvvariable-spirvvariableop>¶</a></h3><p><em>Allocate an object in memory, resulting in a pointer to it, which can be
used with OpLoad and OpStore.</em></p><p>Result Type must be an OpTypePointer. Its Type operand is the type of
object in memory.</p><p>Storage Class is the Storage Class of the memory holding the object.
Since the op is used to model function-level variables, the storage class
must be the <code>Function</code> Storage Class.</p><p>Initializer is optional. If Initializer is present, it will be the
initial value of the variable&rsquo;s memory content. Initializer must be an
<id>from a constant instruction or a global (module scope) OpVariable
instruction. Initializer must have the same type as the type pointed to
by Result Type.</p><p>From <code>SPV_KHR_physical_storage_buffer</code>:
If an OpVariable&rsquo;s pointee type is a pointer (or array of pointers) in
PhysicalStorageBuffer storage class, then the variable must be decorated
with exactly one of AliasedPointer or RestrictPointer.</p><pre tabindex=0><code>variable-op ::= ssa-id `=` `spirv.Variable` (`init(` ssa-use `)`)?
                attribute-dict? `:` spirv-pointer-type
</code></pre><p>where <code>init</code> specifies initializer.</p><h4 id=example-288>Example:&nbsp;<a class=headline-hash href=#example-288>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>Constant <span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>:</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>Variable init<span class=p>(</span><span class=nv>%0</span><span class=p>):</span> <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> Function<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> spirv<span class=p>.</span>Variable <span class=p>{</span>aliased_pointer<span class=p>}</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;!</span>spirv<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>,</span> PhysicalStorageBuffer<span class=p>&gt;,</span> Function<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><h4 id=attributes-101>Attributes:&nbsp;<a class=headline-hash href=#attributes-101>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>storage_class</code></td><td>::mlir::spirv::StorageClassAttr</td><td>valid SPIR-V StorageClass</td></tr></table><h4 id=operands-265>Operands:&nbsp;<a class=headline-hash href=#operands-265>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>initializer</code></td><td>any type</td></tr></tbody></table><h4 id=results-263>Results:&nbsp;<a class=headline-hash href=#results-263>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pointer</code></td><td>any SPIR-V pointer type</td></tr></tbody></table><h3 id=spirvvectorextractdynamic-spirvvectorextractdynamicop><code>spirv.VectorExtractDynamic</code> (spirv::VectorExtractDynamicOp)&nbsp;<a class=headline-hash href=#spirvvectorextractdynamic-spirvvectorextractdynamicop>¶</a></h3><p><em>Extract a single, dynamically selected, component of a vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.VectorExtractDynamic` $vector `[` $index `]` attr-dict `:` type($vector) `,` type($index)
</code></pre><p>Result Type must be a scalar type.</p><p>Vector must have a type OpTypeVector whose Component Type is Result
Type.</p><p>Index must be a scalar integer. It is interpreted as a 0-based index of
which component of Vector to extract.</p><p>Behavior is undefined if Index&rsquo;s value is less than zero or greater than
or equal to the number of components in Vector.</p><h4 id=example-289>Example:&nbsp;<a class=headline-hash href=#example-289>¶</a></h4><pre tabindex=0><code>%2 = spirv.VectorExtractDynamic %0[%1] : vector&lt;8xf32&gt;, i32
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-266>Operands:&nbsp;<a class=headline-hash href=#operands-266>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>index</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-264>Results:&nbsp;<a class=headline-hash href=#results-264>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool</td></tr></tbody></table><h3 id=spirvvectorinsertdynamic-spirvvectorinsertdynamicop><code>spirv.VectorInsertDynamic</code> (spirv::VectorInsertDynamicOp)&nbsp;<a class=headline-hash href=#spirvvectorinsertdynamic-spirvvectorinsertdynamicop>¶</a></h3><p><em>Make a copy of a vector, with a single, variably selected, component
modified.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.VectorInsertDynamic` $component `,` $vector `[` $index `]` attr-dict `:` type($vector) `,` type($index)
</code></pre><p>Result Type must be an OpTypeVector.</p><p>Vector must have the same type as Result Type and is the vector that the
non-written components are copied from.</p><p>Component is the value supplied for the component selected by Index. It
must have the same type as the type of components in Result Type.</p><p>Index must be a scalar integer. It is interpreted as a 0-based index of
which component to modify.</p><p>Behavior is undefined if Index&rsquo;s value is less than zero or greater than
or equal to the number of components in Vector.</p><h4 id=example-290>Example:&nbsp;<a class=headline-hash href=#example-290>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%scalar</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> spirv<span class=p>.</span>VectorInsertDynamic <span class=nv>%scalar</span> <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-267>Operands:&nbsp;<a class=headline-hash href=#operands-267>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>component</code></td><td>8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 or bool</td></tr><tr><td style=text-align:center><code>index</code></td><td>8/16/32/64-bit integer</td></tr></tbody></table><h4 id=results-265>Results:&nbsp;<a class=headline-hash href=#results-265>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvvectorshuffle-spirvvectorshuffleop><code>spirv.VectorShuffle</code> (spirv::VectorShuffleOp)&nbsp;<a class=headline-hash href=#spirvvectorshuffle-spirvvectorshuffleop>¶</a></h3><p><em>Select arbitrary components from two vectors to make a new vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.VectorShuffle` attr-dict $components $vector1 `,` $vector2 `:`
              type($vector1) `,` type($vector2) `-&gt;` type($result)
</code></pre><p>Result Type must be an OpTypeVector. The number of components in Result
Type must be the same as the number of Component operands.</p><p>Vector 1 and Vector 2 must both have vector types, with the same
Component Type as Result Type. They do not have to have the same number
of components as Result Type or with each other. They are logically
concatenated, forming a single vector with Vector 1&rsquo;s components
appearing before Vector 2&rsquo;s. The components of this logical vector are
logically numbered with a single consecutive set of numbers from 0 to N</p><ul><li>1, where N is the total number of components.</li></ul><p>Components are these logical numbers (see above), selecting which of the
logically numbered components form the result. Each component is an
unsigned 32-bit integer. They can select the components in any order
and can repeat components. The first component of the result is selected
by the first Component operand, the second component of the result is
selected by the second Component operand, etc. A Component literal may
also be FFFFFFFF, which means the corresponding result component has no
source and is undefined. All Component literals must either be FFFFFFFF
or in [0, N - 1] (inclusive).</p><p>Note: A vector “swizzle” can be done by using the vector for both Vector
operands, or using an OpUndef for one of the Vector operands.</p><h4 id=example-291>Example:&nbsp;<a class=headline-hash href=#example-291>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>VectorShuffle <span class=p>[</span><span class=m>1</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=m>3</span><span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=m>5</span><span class=p>:</span> <span class=k>i32</span><span class=p>]</span> <span class=nv>%vector1</span><span class=p>,</span> <span class=nv>%vector2</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-102>Attributes:&nbsp;<a class=headline-hash href=#attributes-102>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>components</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr></table><h4 id=operands-268>Operands:&nbsp;<a class=headline-hash href=#operands-268>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector1</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>vector2</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr></tbody></table><h4 id=results-266>Results:&nbsp;<a class=headline-hash href=#results-266>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of bool or 8/16/32/64-bit integer or 16/32/64-bit float or BFloat16 values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvvectortimesmatrix-spirvvectortimesmatrixop><code>spirv.VectorTimesMatrix</code> (spirv::VectorTimesMatrixOp)&nbsp;<a class=headline-hash href=#spirvvectortimesmatrix-spirvvectortimesmatrixop>¶</a></h3><p><em>Linear-algebraic Vector X Matrix.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.VectorTimesMatrix` operands attr-dict `:` type($vector) `,` type($matrix) `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of floating-point type.</p><p>Vector must be a vector with the same Component Type as the Component
Type in Result Type. Its number of components must equal the number of
components in each column in Matrix.</p><p>Matrix must be a matrix with the same Component Type as the Component
Type in Result Type. Its number of columns must equal the number of
components in Result Type.</p><h4 id=example-292>Example:&nbsp;<a class=headline-hash href=#example-292>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> spirv<span class=p>.</span>VectorTimesMatrix <span class=nv>%vector</span><span class=p>,</span> <span class=nv>%matrix</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>spirv<span class=p>.</span>matrix<span class=p>&lt;</span><span class=m>4 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-269>Operands:&nbsp;<a class=headline-hash href=#operands-269>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr><tr><td style=text-align:center><code>matrix</code></td><td>Matrix of 16/32/64-bit float values</td></tr></tbody></table><h4 id=results-267>Results:&nbsp;<a class=headline-hash href=#results-267>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>fixed-length vector of 16/32/64-bit float values of length 2/3/4/8/16</td></tr></tbody></table><h3 id=spirvvectortimesscalar-spirvvectortimesscalarop><code>spirv.VectorTimesScalar</code> (spirv::VectorTimesScalarOp)&nbsp;<a class=headline-hash href=#spirvvectortimesscalar-spirvvectortimesscalarop>¶</a></h3><p><em>Scale a floating-point vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.VectorTimesScalar` operands attr-dict `:` `(` type(operands) `)` `-&gt;` type($result)
</code></pre><p>Result Type must be a vector of floating-point type.</p><p>The type of Vector must be the same as Result Type. Each component of
Vector is multiplied by Scalar.</p><p>Scalar must have the same type as the Component Type in Result Type.</p><h4 id=example-293>Example:&nbsp;<a class=headline-hash href=#example-293>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> spirv<span class=p>.</span>VectorTimesScalar <span class=nv>%vector</span><span class=p>,</span> <span class=nv>%scalar</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-270>Operands:&nbsp;<a class=headline-hash href=#operands-270>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>vector of 16/32/64-bit float values of length 2/3/4</td></tr><tr><td style=text-align:center><code>scalar</code></td><td>16/32/64-bit float</td></tr></tbody></table><h4 id=results-268>Results:&nbsp;<a class=headline-hash href=#results-268>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector of 16/32/64-bit float values of length 2/3/4</td></tr></tbody></table><h3 id=spirvmliryield-spirvyieldop><code>spirv.mlir.yield</code> (spirv::YieldOp)&nbsp;<a class=headline-hash href=#spirvmliryield-spirvyieldop>¶</a></h3><p><em>Yields the result computed in <code>spirv.SpecConstantOperation</code>&rsquo;s
region back to the parent op.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `spirv.mlir.yield` attr-dict $operand `:` type($operand)
</code></pre><p>This op is a special terminator whose only purpose is to terminate
an <code>spirv.SpecConstantOperation</code>&rsquo;s enclosed region. It accepts a
single operand produced by the preceeding (and only other) instruction
in its parent block (see SPIRV_SpecConstantOperation for further
details). This op has no corresponding SPIR-V instruction.</p><h4 id=example-294>Example:&nbsp;<a class=headline-hash href=#example-294>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=p>...</span> <span class=p>(</span>some op supported by SPIR<span class=err>-</span>V OpSpecConstantOp<span class=p>)</span>
</span></span><span class=line><span class=cl>spirv<span class=p>.</span>mlir<span class=p>.</span>yield <span class=nv>%0</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;SpecConstantOperationOp></code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryCapabilityInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryMaxVersionInterface</code>, <code>QueryMinVersionInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-271>Operands:&nbsp;<a class=headline-hash href=#operands-271>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/ title="OpInterface definitions"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - OpInterface definitions</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/TOSA/ title="Tensor Operator Set Architecture (TOSA) Dialect">Next - Tensor Operator Set Architecture (TOSA) Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>