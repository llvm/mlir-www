<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'wasmssa' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'wasmssa' Dialect</h1><p>The <code>wasmssa</code> dialect is intended to represent WebAssembly
modules in SSA form for easier manipulation.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#wasmssaabs-wasmssaabsop><code>wasmssa.abs</code> (wasmssa::AbsOp)</a></li><li><a href=#wasmssaadd-wasmssaaddop><code>wasmssa.add</code> (wasmssa::AddOp)</a></li><li><a href=#wasmssaand-wasmssaandop><code>wasmssa.and</code> (wasmssa::AndOp)</a></li><li><a href=#wasmssablock-wasmssablockop><code>wasmssa.block</code> (wasmssa::BlockOp)</a></li><li><a href=#wasmssablock_return-wasmssablockreturnop><code>wasmssa.block_return</code> (wasmssa::BlockReturnOp)</a></li><li><a href=#wasmssabranch_if-wasmssabranchifop><code>wasmssa.branch_if</code> (wasmssa::BranchIfOp)</a></li><li><a href=#wasmssacall-wasmssafunccallop><code>wasmssa.call</code> (wasmssa::FuncCallOp)</a></li><li><a href=#wasmssaceil-wasmssaceilop><code>wasmssa.ceil</code> (wasmssa::CeilOp)</a></li><li><a href=#wasmssaclz-wasmssaclzop><code>wasmssa.clz</code> (wasmssa::ClzOp)</a></li><li><a href=#wasmssaconst-wasmssaconstop><code>wasmssa.const</code> (wasmssa::ConstOp)</a></li><li><a href=#wasmssaconvert_s-wasmssaconvertsop><code>wasmssa.convert_s</code> (wasmssa::ConvertSOp)</a></li><li><a href=#wasmssaconvert_u-wasmssaconvertuop><code>wasmssa.convert_u</code> (wasmssa::ConvertUOp)</a></li><li><a href=#wasmssacopysign-wasmssacopysignop><code>wasmssa.copysign</code> (wasmssa::CopySignOp)</a></li><li><a href=#wasmssactz-wasmssactzop><code>wasmssa.ctz</code> (wasmssa::CtzOp)</a></li><li><a href=#wasmssademote-wasmssademoteop><code>wasmssa.demote</code> (wasmssa::DemoteOp)</a></li><li><a href=#wasmssadiv-wasmssadivop><code>wasmssa.div</code> (wasmssa::DivOp)</a></li><li><a href=#wasmssadiv_si-wasmssadivsiop><code>wasmssa.div_si</code> (wasmssa::DivSIOp)</a></li><li><a href=#wasmssadiv_ui-wasmssadivuiop><code>wasmssa.div_ui</code> (wasmssa::DivUIOp)</a></li><li><a href=#wasmssaeq-wasmssaeqop><code>wasmssa.eq</code> (wasmssa::EqOp)</a></li><li><a href=#wasmssaeqz-wasmssaeqzop><code>wasmssa.eqz</code> (wasmssa::EqzOp)</a></li><li><a href=#wasmssaextend-wasmssaextendlowbitssop><code>wasmssa.extend</code> (wasmssa::ExtendLowBitsSOp)</a></li><li><a href=#wasmssaextend_i32_s-wasmssaextendsi32op><code>wasmssa.extend_i32_s</code> (wasmssa::ExtendSI32Op)</a></li><li><a href=#wasmssaextend_i32_u-wasmssaextendui32op><code>wasmssa.extend_i32_u</code> (wasmssa::ExtendUI32Op)</a></li><li><a href=#wasmssafloor-wasmssafloorop><code>wasmssa.floor</code> (wasmssa::FloorOp)</a></li><li><a href=#wasmssafunc-wasmssafuncop><code>wasmssa.func</code> (wasmssa::FuncOp)</a></li><li><a href=#wasmssage-wasmssageop><code>wasmssa.ge</code> (wasmssa::GeOp)</a></li><li><a href=#wasmssage_si-wasmssagesiop><code>wasmssa.ge_si</code> (wasmssa::GeSIOp)</a></li><li><a href=#wasmssage_ui-wasmssageuiop><code>wasmssa.ge_ui</code> (wasmssa::GeUIOp)</a></li><li><a href=#wasmssaglobal-wasmssaglobalop><code>wasmssa.global</code> (wasmssa::GlobalOp)</a></li><li><a href=#wasmssaglobal_get-wasmssaglobalgetop><code>wasmssa.global_get</code> (wasmssa::GlobalGetOp)</a></li><li><a href=#wasmssagt-wasmssagtop><code>wasmssa.gt</code> (wasmssa::GtOp)</a></li><li><a href=#wasmssagt_si-wasmssagtsiop><code>wasmssa.gt_si</code> (wasmssa::GtSIOp)</a></li><li><a href=#wasmssagt_ui-wasmssagtuiop><code>wasmssa.gt_ui</code> (wasmssa::GtUIOp)</a></li><li><a href=#wasmssaif-wasmssaifop><code>wasmssa.if</code> (wasmssa::IfOp)</a></li><li><a href=#wasmssaimport_func-wasmssafuncimportop><code>wasmssa.import_func</code> (wasmssa::FuncImportOp)</a></li><li><a href=#wasmssaimport_global-wasmssaglobalimportop><code>wasmssa.import_global</code> (wasmssa::GlobalImportOp)</a></li><li><a href=#wasmssaimport_mem-wasmssamemimportop><code>wasmssa.import_mem</code> (wasmssa::MemImportOp)</a></li><li><a href=#wasmssaimport_table-wasmssatableimportop><code>wasmssa.import_table</code> (wasmssa::TableImportOp)</a></li><li><a href=#wasmssale-wasmssaleop><code>wasmssa.le</code> (wasmssa::LeOp)</a></li><li><a href=#wasmssale_si-wasmssalesiop><code>wasmssa.le_si</code> (wasmssa::LeSIOp)</a></li><li><a href=#wasmssale_ui-wasmssaleuiop><code>wasmssa.le_ui</code> (wasmssa::LeUIOp)</a></li><li><a href=#wasmssalocal-wasmssalocalop><code>wasmssa.local</code> (wasmssa::LocalOp)</a></li><li><a href=#wasmssalocal_get-wasmssalocalgetop><code>wasmssa.local_get</code> (wasmssa::LocalGetOp)</a></li><li><a href=#wasmssalocal_set-wasmssalocalsetop><code>wasmssa.local_set</code> (wasmssa::LocalSetOp)</a></li><li><a href=#wasmssalocal_tee-wasmssalocalteeop><code>wasmssa.local_tee</code> (wasmssa::LocalTeeOp)</a></li><li><a href=#wasmssaloop-wasmssaloopop><code>wasmssa.loop</code> (wasmssa::LoopOp)</a></li><li><a href=#wasmssalt-wasmssaltop><code>wasmssa.lt</code> (wasmssa::LtOp)</a></li><li><a href=#wasmssalt_si-wasmssaltsiop><code>wasmssa.lt_si</code> (wasmssa::LtSIOp)</a></li><li><a href=#wasmssalt_ui-wasmssaltuiop><code>wasmssa.lt_ui</code> (wasmssa::LtUIOp)</a></li><li><a href=#wasmssamax-wasmssamaxop><code>wasmssa.max</code> (wasmssa::MaxOp)</a></li><li><a href=#wasmssamemory-wasmssamemop><code>wasmssa.memory</code> (wasmssa::MemOp)</a></li><li><a href=#wasmssamin-wasmssaminop><code>wasmssa.min</code> (wasmssa::MinOp)</a></li><li><a href=#wasmssamul-wasmssamulop><code>wasmssa.mul</code> (wasmssa::MulOp)</a></li><li><a href=#wasmssane-wasmssaneop><code>wasmssa.ne</code> (wasmssa::NeOp)</a></li><li><a href=#wasmssaneg-wasmssanegop><code>wasmssa.neg</code> (wasmssa::NegOp)</a></li><li><a href=#wasmssaor-wasmssaorop><code>wasmssa.or</code> (wasmssa::OrOp)</a></li><li><a href=#wasmssapopcnt-wasmssapopcntop><code>wasmssa.popcnt</code> (wasmssa::PopCntOp)</a></li><li><a href=#wasmssapromote-wasmssapromoteop><code>wasmssa.promote</code> (wasmssa::PromoteOp)</a></li><li><a href=#wasmssareinterpret-wasmssareinterpretop><code>wasmssa.reinterpret</code> (wasmssa::ReinterpretOp)</a></li><li><a href=#wasmssarem_si-wasmssaremsiop><code>wasmssa.rem_si</code> (wasmssa::RemSIOp)</a></li><li><a href=#wasmssarem_ui-wasmssaremuiop><code>wasmssa.rem_ui</code> (wasmssa::RemUIOp)</a></li><li><a href=#wasmssareturn-wasmssareturnop><code>wasmssa.return</code> (wasmssa::ReturnOp)</a></li><li><a href=#wasmssarotl-wasmssarotlop><code>wasmssa.rotl</code> (wasmssa::RotlOp)</a></li><li><a href=#wasmssarotr-wasmssarotrop><code>wasmssa.rotr</code> (wasmssa::RotrOp)</a></li><li><a href=#wasmssashl-wasmssashlop><code>wasmssa.shl</code> (wasmssa::ShLOp)</a></li><li><a href=#wasmssashr_s-wasmssashrsop><code>wasmssa.shr_s</code> (wasmssa::ShRSOp)</a></li><li><a href=#wasmssashr_u-wasmssashruop><code>wasmssa.shr_u</code> (wasmssa::ShRUOp)</a></li><li><a href=#wasmssasqrt-wasmssasqrtop><code>wasmssa.sqrt</code> (wasmssa::SqrtOp)</a></li><li><a href=#wasmssasub-wasmssasubop><code>wasmssa.sub</code> (wasmssa::SubOp)</a></li><li><a href=#wasmssatable-wasmssatableop><code>wasmssa.table</code> (wasmssa::TableOp)</a></li><li><a href=#wasmssatrunc-wasmssatruncop><code>wasmssa.trunc</code> (wasmssa::TruncOp)</a></li><li><a href=#wasmssawrap-wasmssawrapop><code>wasmssa.wrap</code> (wasmssa::WrapOp)</a></li><li><a href=#wasmssaxor-wasmssaxorop><code>wasmssa.xor</code> (wasmssa::XOrOp)</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#externreftype>ExternRefType</a></li><li><a href=#funcreftype>FuncRefType</a></li><li><a href=#limittype>LimitType</a></li><li><a href=#localreftype>LocalRefType</a></li><li><a href=#tabletype>TableType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/WasmSSA/IR/WasmSSAOps.td>source</a></p><h3 id=wasmssaabs-wasmssaabsop><code>wasmssa.abs</code> (wasmssa::AbsOp)&nbsp;<a class=headline-hash href=#wasmssaabs-wasmssaabsop>¶</a></h3><p><em>Floating point absolute value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.abs` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.abs %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaadd-wasmssaaddop><code>wasmssa.add</code> (wasmssa::AddOp)&nbsp;<a class=headline-hash href=#wasmssaadd-wasmssaaddop>¶</a></h3><p><em>Sum two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.add` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.add %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaand-wasmssaandop><code>wasmssa.and</code> (wasmssa::AndOp)&nbsp;<a class=headline-hash href=#wasmssaand-wasmssaandop>¶</a></h3><p><em>Compute the bitwise AND between two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.and` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.and %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssablock-wasmssablockop><code>wasmssa.block</code> (wasmssa::BlockOp)&nbsp;<a class=headline-hash href=#wasmssablock-wasmssablockop>¶</a></h3><p><em>Create a nesting level</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.block` (`(`$inputs^`)` `:` type($inputs))? attr-dict  `:` $body `&gt;` $target
</code></pre><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>LabelLevelOpInterface</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>target</code></td><td>any successor</td></tr></tbody></table><h3 id=wasmssablock_return-wasmssablockreturnop><code>wasmssa.block_return</code> (wasmssa::BlockReturnOp)&nbsp;<a class=headline-hash href=#wasmssablock_return-wasmssablockreturnop>¶</a></h3><p><em>Return from the current block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.block_return` ($inputs^ `:` type($inputs))? attr-dict
</code></pre><p>Marks a return from the current block.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  wasmssa<span class=p>.</span>block_return
</span></span></code></pre></div><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>LabelBranchingOpInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssabranch_if-wasmssabranchifop><code>wasmssa.branch_if</code> (wasmssa::BranchIfOp)&nbsp;<a class=headline-hash href=#wasmssabranch_if-wasmssabranchifop>¶</a></h3><p><em>Jump to target level if condition has non-zero value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.branch_if` $condition `to` `level` $exitLevel (`with` `args`  `(`$inputs^ `:` type($inputs)`)`)?  `else` $elseSuccessor  attr-dict
</code></pre><p>Jump to target level if the condition is has a non-zero value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>wasmssa<span class=p>.</span>branch_if <span class=nv>%a</span> to level <span class=m>0</span> with args<span class=p>(</span><span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> else <span class=nl>^bb1
</span></span></span></code></pre></div><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>LabelBranchingOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>exitLevel</code></td><td>::mlir::IntegerAttr</td><td>32-bit unsigned integer attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>elseSuccessor</code></td><td>any successor</td></tr></tbody></table><h3 id=wasmssacall-wasmssafunccallop><code>wasmssa.call</code> (wasmssa::FuncCallOp)&nbsp;<a class=headline-hash href=#wasmssacall-wasmssafunccallop>¶</a></h3><p><em>Calling a Wasm function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.call` $callee (`(`$operands^`)`)? attr-dict `:` functional-type($operands, $results)
</code></pre><p>Emits a call to a defined function</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span>call <span class=nf>@func_0</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssaceil-wasmssaceilop><code>wasmssa.ceil</code> (wasmssa::CeilOp)&nbsp;<a class=headline-hash href=#wasmssaceil-wasmssaceilop>¶</a></h3><p><em>Ceil rounding of floating point value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ceil` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.ceil %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaclz-wasmssaclzop><code>wasmssa.clz</code> (wasmssa::ClzOp)&nbsp;<a class=headline-hash href=#wasmssaclz-wasmssaclzop>¶</a></h3><p><em>Count leading zeroes of an integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.clz` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.clz %b : i32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssaconst-wasmssaconstop><code>wasmssa.const</code> (wasmssa::ConstOp)&nbsp;<a class=headline-hash href=#wasmssaconst-wasmssaconstop>¶</a></h3><p><em>Operator that represents a constant value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.const` $value attr-dict
</code></pre><p>Defines a constant value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Example of integer constant
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span>const <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Example of floating point constant
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%b</span> <span class=p>=</span> wasmssa<span class=p>.</span>const <span class=m>9.000000e+00</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: <code>ConstantExprOpTrait</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td><details><summary>TypedAttr instance</summary><pre><code>This interface is used for attributes that have a type. The type of an
attribute is understood to represent the type of the data contained in the
attribute and is often used as the type of a value with this data.
</code></pre></details></td></tr></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaconvert_s-wasmssaconvertsop><code>wasmssa.convert_s</code> (wasmssa::ConvertSOp)&nbsp;<a class=headline-hash href=#wasmssaconvert_s-wasmssaconvertsop>¶</a></h3><p>_Convert integer interpreted as 2&rsquo;s complement signed value to floating-point value.</p><pre><code>Consume an integer and produces a floating point value containing the rounded value of the original operand. Rounding is round to nearest, tie to even._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.convert_s` $input `:` type($input) `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.convert_s %b : i32 to f64
```
</code></pre><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaconvert_u-wasmssaconvertuop><code>wasmssa.convert_u</code> (wasmssa::ConvertUOp)&nbsp;<a class=headline-hash href=#wasmssaconvert_u-wasmssaconvertuop>¶</a></h3><p>_Convert integer, interpreted as binary encoded positive value, to floating-point value.</p><pre><code>Consume an integer and produces a floating point value containing the rounded value of the original operand. Rounding is round to nearest, tie to even._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.convert_u` $input `:` type($input) `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.convert_u %b : i32 to f64
```
</code></pre><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssacopysign-wasmssacopysignop><code>wasmssa.copysign</code> (wasmssa::CopySignOp)&nbsp;<a class=headline-hash href=#wasmssacopysign-wasmssacopysignop>¶</a></h3><p><em>Copy sign from one floating point value to the other.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.copysign` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.copysign %b %c : f32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssactz-wasmssactzop><code>wasmssa.ctz</code> (wasmssa::CtzOp)&nbsp;<a class=headline-hash href=#wasmssactz-wasmssactzop>¶</a></h3><p><em>Count trailing zeroes of an integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ctz` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.ctz %b : i32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssademote-wasmssademoteop><code>wasmssa.demote</code> (wasmssa::DemoteOp)&nbsp;<a class=headline-hash href=#wasmssademote-wasmssademoteop>¶</a></h3><p><em>Convert a f64 value to f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.demote` $input `:` type($input) `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.demote %b : f64 to f32
```
</code></pre><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>64-bit float</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float</td></tr></tbody></table><h3 id=wasmssadiv-wasmssadivop><code>wasmssa.div</code> (wasmssa::DivOp)&nbsp;<a class=headline-hash href=#wasmssadiv-wasmssadivop>¶</a></h3><p><em>Division between floating point values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.div` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.div %b %c : f32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssadiv_si-wasmssadivsiop><code>wasmssa.div_si</code> (wasmssa::DivSIOp)&nbsp;<a class=headline-hash href=#wasmssadiv_si-wasmssadivsiop>¶</a></h3><p><em>Divide values interpreted as signed int</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.div_si` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.div_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssadiv_ui-wasmssadivuiop><code>wasmssa.div_ui</code> (wasmssa::DivUIOp)&nbsp;<a class=headline-hash href=#wasmssadiv_ui-wasmssadivuiop>¶</a></h3><p><em>Divide values interpreted as unsigned int</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.div_ui` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.div_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssaeq-wasmssaeqop><code>wasmssa.eq</code> (wasmssa::EqOp)&nbsp;<a class=headline-hash href=#wasmssaeq-wasmssaeqop>¶</a></h3><p><em>Check if two values are equal</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.eq` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.eq %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaeqz-wasmssaeqzop><code>wasmssa.eqz</code> (wasmssa::EqzOp)&nbsp;<a class=headline-hash href=#wasmssaeqz-wasmssaeqzop>¶</a></h3><p><em>Check if the given value is equal to zero</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.eqz` $input`:` type($input) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.eqz %b : i64 -&gt; i32
 ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaextend-wasmssaextendlowbitssop><code>wasmssa.extend</code> (wasmssa::ExtendLowBitsSOp)&nbsp;<a class=headline-hash href=#wasmssaextend-wasmssaextendlowbitssop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.extend` $bitsToTake `low` `bits` `from` $input `:` type($input) attr-dict
</code></pre><p>Extend low bytes of a value to fit a given width.
For instance, signed extension from 8 low bits of the 32-bits integer value
254 (0x000000FE) would produce the value -2 (0xFFFFFFFE).</p><p>This corresponds to the <code>extendnn</code> instruction of Wasm, which shouldn&rsquo;t be
confused with the <code>extend_inn</code> Wasm instruction, for which all input bits
are used and widened to wider output type.
In this operation, input and output types are the same.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span>extend <span class=m>16</span> low bits from <span class=err>%</span><span class=p>[[</span>VAL_0<span class=p>]]:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>bitsToTake</code></td><td>::mlir::IntegerAttr</td><td><details><summary>An Attribute containing a integer value</summary><pre><code>Syntax:
<pre tabindex=0><code>integer-attribute ::= (integer-literal ( `:` (index-type | integer-type) )?)
                      | `true` | `false`
</code></pre><p>An integer attribute is a literal attribute that represents an integral
value of the specified integer or index type. <code>i1</code> integer attributes are
treated as <code>boolean</code> attributes, and use a unique assembly format of either
<code>true</code> or <code>false</code> depending on the value. The default type for non-boolean
integer attributes, if a type is not specified, is signless 64-bit integer.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=m>10</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=m>10</span>    <span class=c>// : i64 is implied here.
</span></span></span><span class=line><span class=cl><span class=c></span>true  <span class=c>// A bool, i.e. i1, value.
</span></span></span><span class=line><span class=cl><span class=c></span>false <span class=c>// A bool, i.e. i1, value.
</span></span></span></code></pre></div><p></code></pre></p></details></td></tr></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssaextend_i32_s-wasmssaextendsi32op><code>wasmssa.extend_i32_s</code> (wasmssa::ExtendSI32Op)&nbsp;<a class=headline-hash href=#wasmssaextend_i32_s-wasmssaextendsi32op>¶</a></h3><p><em>Sign extend i32 to i64.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.extend_i32_s` $input `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.extend_i32_s %b to i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=wasmssaextend_i32_u-wasmssaextendui32op><code>wasmssa.extend_i32_u</code> (wasmssa::ExtendUI32Op)&nbsp;<a class=headline-hash href=#wasmssaextend_i32_u-wasmssaextendui32op>¶</a></h3><p><em>Zero extend i32 to i64.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.extend_i32_u` $input `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.extend_i32_s %b to i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=wasmssafloor-wasmssafloorop><code>wasmssa.floor</code> (wasmssa::FloorOp)&nbsp;<a class=headline-hash href=#wasmssafloor-wasmssafloorop>¶</a></h3><p><em>Floor rounding of floating point value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.floor` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.floor %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssafunc-wasmssafuncop><code>wasmssa.func</code> (wasmssa::FuncOp)&nbsp;<a class=headline-hash href=#wasmssafunc-wasmssafuncop>¶</a></h3><p>Represents a Wasm function definition.</p><p>In Wasm function, locals and function arguments are interchangeable.
They are for instance both accessed using <code>local.get</code> instruction.</p><p>On the other hand, a function type is defined as a pair of tuples of Wasm value types.
To model this, the wasm.func operation has:</p><ul><li><p>A function type that represents the corresponding Wasm type (tuples of value types)</p></li><li><p>Arguments of the entry block of type <code>!wasm&lt;local T></code>, with T the corresponding type
in the function type.</p></li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A simple function with no arguments that returns a float32
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span><span class=kt>func</span> <span class=nf>@my_f32_func</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function that takes a local ref argument
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span><span class=kt>func</span> <span class=nf>@i64_wrap</span><span class=p>(</span><span class=nv>%a</span><span class=p>:</span> <span class=p>!</span>wasmssa<span class=p>&lt;</span><span class=kt>loc</span>al ref to <span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>AffineScope</code>, <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>functionType</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssage-wasmssageop><code>wasmssa.ge</code> (wasmssa::GeOp)&nbsp;<a class=headline-hash href=#wasmssage-wasmssageop>¶</a></h3><p><em>Check if a float value is greater or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ge` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.ge %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssage_si-wasmssagesiop><code>wasmssa.ge_si</code> (wasmssa::GeSIOp)&nbsp;<a class=headline-hash href=#wasmssage_si-wasmssagesiop>¶</a></h3><p><em>Check if a signed integer value is greater or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ge_si` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.ge_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssage_ui-wasmssageuiop><code>wasmssa.ge_ui</code> (wasmssa::GeUIOp)&nbsp;<a class=headline-hash href=#wasmssage_ui-wasmssageuiop>¶</a></h3><p><em>Check if an unsigned integer value is greater or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ge_ui` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.ge_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaglobal-wasmssaglobalop><code>wasmssa.global</code> (wasmssa::GlobalOp)&nbsp;<a class=headline-hash href=#wasmssaglobal-wasmssaglobalop>¶</a></h3><p><em>WebAssembly global value</em></p><p>WebAssembly global variable.
Body contains the initialization instructions for the variable value.
The body must contain only instructions considered <code>const</code> in a webassembly context,
such as <code>wasmssa.const</code> or <code>global.get</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Define a global_var, a mutable i32 global variable equal to 10.
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>global <span class=nf>@global_var</span> <span class=k>i32</span> mutable nested <span class=p>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=err>%</span><span class=p>[[</span>VAL_0<span class=p>:.*]]</span> <span class=p>=</span> wasmssa<span class=p>.</span>const <span class=m>10</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>      wasmssa<span class=p>.</span><span class=kt>return</span> <span class=err>%</span><span class=p>[[</span>VAL_0<span class=p>]]</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AffineScope</code>, <code>AutomaticAllocationScope</code>, <code>ConstantExpressionInitializerOpTrait</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr><tr><td><code>isMutable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssaglobal_get-wasmssaglobalgetop><code>wasmssa.global_get</code> (wasmssa::GlobalGetOp)&nbsp;<a class=headline-hash href=#wasmssaglobal_get-wasmssaglobalgetop>¶</a></h3><p><em>Returns the value of the global passed as argument.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.global_get` $global attr-dict `:` type($global_val)
</code></pre><p>Retrieves the value of the global passed as argument and stores it in a
variable</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Gets the value of `@global_0` and stores its value in %a
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span>global_get <span class=nf>@global_0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>ConstantExprOpTrait</code></p><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>global</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>global_val</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssagt-wasmssagtop><code>wasmssa.gt</code> (wasmssa::GtOp)&nbsp;<a class=headline-hash href=#wasmssagt-wasmssagtop>¶</a></h3><p><em>Check if a float value is greater than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.gt` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.gt %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssagt_si-wasmssagtsiop><code>wasmssa.gt_si</code> (wasmssa::GtSIOp)&nbsp;<a class=headline-hash href=#wasmssagt_si-wasmssagtsiop>¶</a></h3><p><em>Check if a signed integer value is greater than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.gt_si` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.gt_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssagt_ui-wasmssagtuiop><code>wasmssa.gt_ui</code> (wasmssa::GtUIOp)&nbsp;<a class=headline-hash href=#wasmssagt_ui-wasmssagtuiop>¶</a></h3><p><em>Check if an unsigned integer value is greater than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.gt_ui` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.gt_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaif-wasmssaifop><code>wasmssa.if</code> (wasmssa::IfOp)&nbsp;<a class=headline-hash href=#wasmssaif-wasmssaifop>¶</a></h3><p><em>Execute the if region if condition value is non-zero, the else region otherwise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.if` $condition (`(`$inputs^`)` `:` type($inputs))? attr-dict  `:` $if custom&lt;ElseRegion&gt;($else) `&gt;` $target
</code></pre><p>Execute the if region if the condition is non-zero. Otherwise the else region is executed.
The else region can be empty but must return the same datatype as the if region.
If clauses can be nested.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Runs the if clause is %a is non-zero
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>if <span class=nv>%a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c>// Execute if %a is non-zero
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span> else <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=c>// else clause
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>LabelLevelOpInterface</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>target</code></td><td>any successor</td></tr></tbody></table><h3 id=wasmssaimport_func-wasmssafuncimportop><code>wasmssa.import_func</code> (wasmssa::FuncImportOp)&nbsp;<a class=headline-hash href=#wasmssaimport_func-wasmssafuncimportop>¶</a></h3><p><em>Importing a function variable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.import_func` $importName `from` $moduleName `as` $sym_name attr-dict
</code></pre><p>Imports a function from another module</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Imports foo(i32) -&gt; () from the module my_module
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>import_func <span class=s>&#34;foo&#34;</span> from <span class=s>&#34;my_module&#34;</span> as <span class=nf>@func_0</span> <span class=p>{</span><span class=nl>sym_visibility =</span> <span class=s>&#34;nested&#34;</span><span class=p>,</span> <span class=nl>type =</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()}</span>
</span></span></code></pre></div><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>ImportOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>importName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssaimport_global-wasmssaglobalimportop><code>wasmssa.import_global</code> (wasmssa::GlobalImportOp)&nbsp;<a class=headline-hash href=#wasmssaimport_global-wasmssaglobalimportop>¶</a></h3><p><em>Importing a global variable</em></p><p>Imports a global from another module</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Imports the &#34;glob&#34; i32 global from the module my_module as &#34;global_0&#34;
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>import_global <span class=s>&#34;glob&#34;</span> from <span class=s>&#34;my_module&#34;</span> as <span class=nf>@global_0</span> nested <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>ImportOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>importName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr><tr><td><code>isMutable</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssaimport_mem-wasmssamemimportop><code>wasmssa.import_mem</code> (wasmssa::MemImportOp)&nbsp;<a class=headline-hash href=#wasmssaimport_mem-wasmssamemimportop>¶</a></h3><p><em>Importing a memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.import_mem` $importName `from` $moduleName `as` $sym_name attr-dict
</code></pre><p>Import a memory from another module.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Import the memory `mem` from `my_module` as @mem_0
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>import_mem <span class=s>&#34;mem&#34;</span> from <span class=s>&#34;my_module&#34;</span> as <span class=nf>@mem_0</span> <span class=p>{</span><span class=nl>limits =</span> <span class=p>!</span>wasmssa<span class=p>&lt;</span>limit<span class=p>[</span><span class=m>2</span><span class=p>:]&gt;}</span>
</span></span></code></pre></div><p>Interfaces: <code>ImportOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>importName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>limits</code></td><td>::mlir::TypeAttr</td><td>type attribute of Wasm limit type</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssaimport_table-wasmssatableimportop><code>wasmssa.import_table</code> (wasmssa::TableImportOp)&nbsp;<a class=headline-hash href=#wasmssaimport_table-wasmssatableimportop>¶</a></h3><p><em>Importing a table</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.import_table` $importName `from` $moduleName `as` $sym_name attr-dict
</code></pre><p>Import a table from another module.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Import the table `table` from `my_module` as @table_0
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>import_table <span class=s>&#34;table&#34;</span> from <span class=s>&#34;my_module&#34;</span> as <span class=nf>@table_0</span> <span class=p>{</span><span class=nl>type =</span> <span class=p>!</span>wasmssa<span class=p>&lt;</span>tabletype <span class=p>!</span>wasmssa<span class=p>.</span><span class=kt>func</span>ref <span class=p>[</span><span class=m>2</span><span class=p>:]&gt;}</span>
</span></span></code></pre></div><p>Interfaces: <code>ImportOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>moduleName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>importName</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of Wasm table type</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssale-wasmssaleop><code>wasmssa.le</code> (wasmssa::LeOp)&nbsp;<a class=headline-hash href=#wasmssale-wasmssaleop>¶</a></h3><p><em>Check if a float value is less or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.le` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.le %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssale_si-wasmssalesiop><code>wasmssa.le_si</code> (wasmssa::LeSIOp)&nbsp;<a class=headline-hash href=#wasmssale_si-wasmssalesiop>¶</a></h3><p><em>Check if a signed integer value is less or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.le_si` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.le_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssale_ui-wasmssaleuiop><code>wasmssa.le_ui</code> (wasmssa::LeUIOp)&nbsp;<a class=headline-hash href=#wasmssale_ui-wasmssaleuiop>¶</a></h3><p><em>Check if an unsigned integer value is less or equal to another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.le_ui` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.le_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssalocal-wasmssalocalop><code>wasmssa.local</code> (wasmssa::LocalOp)&nbsp;<a class=headline-hash href=#wasmssalocal-wasmssalocalop>¶</a></h3><p><em>Declaration of local variable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.local` `of` `type` $type attr-dict
</code></pre><p>Declares a local variable</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Declares `%a`, a float32 local
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span><span class=kt>loc</span>al of type <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Type of a local variable</td></tr></tbody></table><h3 id=wasmssalocal_get-wasmssalocalgetop><code>wasmssa.local_get</code> (wasmssa::LocalGetOp)&nbsp;<a class=headline-hash href=#wasmssalocal_get-wasmssalocalgetop>¶</a></h3><p><em>Set local to value and return the operand.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.local_get` $localVar `:` type($localVar) attr-dict
</code></pre><p>Gets the value of a local variable and returns a reference to it.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Retrieves a reference to `%a`, a float32 local
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%b</span> <span class=p>=</span> wasmssa<span class=p>.</span><span class=kt>loc</span>al_get <span class=nv>%a</span> <span class=p>:</span> ref to <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>localVar</code></td><td>Type of a local variable</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssalocal_set-wasmssalocalsetop><code>wasmssa.local_set</code> (wasmssa::LocalSetOp)&nbsp;<a class=headline-hash href=#wasmssalocal_set-wasmssalocalsetop>¶</a></h3><p><em>Set local to given value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.local_set` $localVar `:` type($localVar) `to` $value `:` type($value) attr-dict
</code></pre><p>Sets the value of a local variable.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Sets `%d`, to the value of `%c`
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span><span class=kt>loc</span>al_set <span class=nv>%d</span> <span class=p>:</span>  ref to <span class=k>i32</span> to <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>localVar</code></td><td>Type of a local variable</td></tr><tr><td style=text-align:center><code>value</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssalocal_tee-wasmssalocalteeop><code>wasmssa.local_tee</code> (wasmssa::LocalTeeOp)&nbsp;<a class=headline-hash href=#wasmssalocal_tee-wasmssalocalteeop>¶</a></h3><p><em>Set local to value and return the operand.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.local_tee` $localVar `:` type($localVar) `to` $value `:` type($value) attr-dict
</code></pre><p>Sets the value of a local variable and returns it.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Sets `%b`, to the value of `%c` and returns it in %a
</span></span></span><span class=line><span class=cl><span class=c></span> <span class=nv>%a</span> <span class=p>=</span> wasmssa<span class=p>.</span><span class=kt>loc</span>al_tee <span class=nv>%b</span> <span class=p>:</span>  ref to <span class=k>i32</span> to <span class=nv>%c</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>localVar</code></td><td>Type of a local variable</td></tr><tr><td style=text-align:center><code>value</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssaloop-wasmssaloopop><code>wasmssa.loop</code> (wasmssa::LoopOp)&nbsp;<a class=headline-hash href=#wasmssaloop-wasmssaloopop>¶</a></h3><p><em>Create a nesting level similar to Block Op, except that it has itself as a successor.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.loop` (`(`$inputs^`)` `:` type($inputs))? attr-dict  `:` $body `&gt;` $target
</code></pre><p>Traits: <code>Terminator</code></p><p>Interfaces: <code>LabelLevelOpInterface</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h4 id=successors-3>Successors:&nbsp;<a class=headline-hash href=#successors-3>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>target</code></td><td>any successor</td></tr></tbody></table><h3 id=wasmssalt-wasmssaltop><code>wasmssa.lt</code> (wasmssa::LtOp)&nbsp;<a class=headline-hash href=#wasmssalt-wasmssaltop>¶</a></h3><p><em>Check if a float value is less than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.lt` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.lt %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssalt_si-wasmssaltsiop><code>wasmssa.lt_si</code> (wasmssa::LtSIOp)&nbsp;<a class=headline-hash href=#wasmssalt_si-wasmssaltsiop>¶</a></h3><p><em>Check if a signed integer value is less than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.lt_si` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.lt_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssalt_ui-wasmssaltuiop><code>wasmssa.lt_ui</code> (wasmssa::LtUIOp)&nbsp;<a class=headline-hash href=#wasmssalt_ui-wasmssaltuiop>¶</a></h3><p><em>Check if an unsigned integer value is less than another</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.lt_ui` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.lt_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssamax-wasmssamaxop><code>wasmssa.max</code> (wasmssa::MaxOp)&nbsp;<a class=headline-hash href=#wasmssamax-wasmssamaxop>¶</a></h3><p><em>Compute the minimum of two floating point values.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.max` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.max %b %c : f32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssamemory-wasmssamemop><code>wasmssa.memory</code> (wasmssa::MemOp)&nbsp;<a class=headline-hash href=#wasmssamemory-wasmssamemop>¶</a></h3><p><em>WebAssembly memory definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.memory` $sym_name custom&lt;WasmVisibility&gt;($sym_visibility) $limits attr-dict
</code></pre><p>Define a memory to be used by the program.
Multiple memories can be defined in the same module.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Define the `mem_0` memory with defined bounds of 0 -&gt; 65536
</span></span></span><span class=line><span class=cl><span class=c></span>wasmssa<span class=p>.</span>memory <span class=nf>@mem_0</span> <span class=p>!</span>wasmssa<span class=p>&lt;</span>limit<span class=p>[</span><span class=m>0</span><span class=p>:</span><span class=m>65536</span><span class=p>]&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>limits</code></td><td>::mlir::TypeAttr</td><td>type attribute of Wasm limit type</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssamin-wasmssaminop><code>wasmssa.min</code> (wasmssa::MinOp)&nbsp;<a class=headline-hash href=#wasmssamin-wasmssaminop>¶</a></h3><p><em>Compute the minimum of two floating point values.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.min` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.min %b %c : f32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssamul-wasmssamulop><code>wasmssa.mul</code> (wasmssa::MulOp)&nbsp;<a class=headline-hash href=#wasmssamul-wasmssamulop>¶</a></h3><p><em>Multiply two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.mul` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.mul %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssane-wasmssaneop><code>wasmssa.ne</code> (wasmssa::NeOp)&nbsp;<a class=headline-hash href=#wasmssane-wasmssaneop>¶</a></h3><p><em>Check if two values are different</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.ne` $lhs $rhs `:` type($lhs) `-&gt;` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.ne %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaneg-wasmssanegop><code>wasmssa.neg</code> (wasmssa::NegOp)&nbsp;<a class=headline-hash href=#wasmssaneg-wasmssanegop>¶</a></h3><p><em>Floating point negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.neg` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.neg %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssaor-wasmssaorop><code>wasmssa.or</code> (wasmssa::OrOp)&nbsp;<a class=headline-hash href=#wasmssaor-wasmssaorop>¶</a></h3><p><em>Compute the bitwise OR of two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.or` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.or %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssapopcnt-wasmssapopcntop><code>wasmssa.popcnt</code> (wasmssa::PopCntOp)&nbsp;<a class=headline-hash href=#wasmssapopcnt-wasmssapopcntop>¶</a></h3><p><em>Population count of an integer.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.popcnt` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.popcnt %b : i32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssapromote-wasmssapromoteop><code>wasmssa.promote</code> (wasmssa::PromoteOp)&nbsp;<a class=headline-hash href=#wasmssapromote-wasmssapromoteop>¶</a></h3><p><em>Get f64 representation of a f32 value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.promote` $input `:` type($input) `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.promote %b : f32 to f64
 ```
</code></pre><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit floating-point type</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>64-bit floating-point type</td></tr></tbody></table><h3 id=wasmssareinterpret-wasmssareinterpretop><code>wasmssa.reinterpret</code> (wasmssa::ReinterpretOp)&nbsp;<a class=headline-hash href=#wasmssareinterpret-wasmssareinterpretop>¶</a></h3><p><em>Reinterpret the value represented by a bit vector by
bit-casting it to another type of same representation width.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.reinterpret` $input `:` type($input) `as` type($result) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.reinterpret %b : f32 as i32
 ```
</code></pre><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssarem_si-wasmssaremsiop><code>wasmssa.rem_si</code> (wasmssa::RemSIOp)&nbsp;<a class=headline-hash href=#wasmssarem_si-wasmssaremsiop>¶</a></h3><p><em>Calculate the remainder of dividing two integer values as signed integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.rem_si` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.rem_si %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssarem_ui-wasmssaremuiop><code>wasmssa.rem_ui</code> (wasmssa::RemUIOp)&nbsp;<a class=headline-hash href=#wasmssarem_ui-wasmssaremuiop>¶</a></h3><p><em>Calculate the remainder of dividing two integer values as an unsigned integer</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.rem_ui` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.rem_ui %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssareturn-wasmssareturnop><code>wasmssa.return</code> (wasmssa::ReturnOp)&nbsp;<a class=headline-hash href=#wasmssareturn-wasmssareturnop>¶</a></h3><p><em>Return from the current function frame</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>Traits: <code>Terminator</code></p><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=wasmssarotl-wasmssarotlop><code>wasmssa.rotl</code> (wasmssa::RotlOp)&nbsp;<a class=headline-hash href=#wasmssarotl-wasmssarotlop>¶</a></h3><p>_Rotate left.</p><pre><code>Consume an integer and an integer rotate. The first
integer shall be rotated left by N bits, where N is the value of the
second integer._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.rotl` $val `by` $bits `bits` `:` type($val) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.rotl %b by %c bits : i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>bits</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssarotr-wasmssarotrop><code>wasmssa.rotr</code> (wasmssa::RotrOp)&nbsp;<a class=headline-hash href=#wasmssarotr-wasmssarotrop>¶</a></h3><p>_Rotate right.</p><pre><code>Consume an integer, and an integer rotate. The first
integer shall be rotated right by N bits, where N is the value of the
second integer._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.rotr` $val `by` $bits `bits` `:` type($val) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.rotr %b by %c bits : i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>bits</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssashl-wasmssashlop><code>wasmssa.shl</code> (wasmssa::ShLOp)&nbsp;<a class=headline-hash href=#wasmssashl-wasmssashlop>¶</a></h3><p><em>Consume an integer and an integer shift amount. The first
integer shall be shifted left by N bits, where N is the value of the second
integer.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.shl` $val `by` $bits `bits` `:` type($val) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.shl %b by %c bits : i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>bits</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssashr_s-wasmssashrsop><code>wasmssa.shr_s</code> (wasmssa::ShRSOp)&nbsp;<a class=headline-hash href=#wasmssashr_s-wasmssashrsop>¶</a></h3><p>_Arithmetic right shift.</p><pre><code>Consume an integer and an integer shift amount. The first
integer shall be shifted right by N bits, where N is the value of the
second integer.

Vacated bits on the left shall be filled with the sign bit._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.shr_s` $val `by` $bits `bits` `:` type($val) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.shr_s %b by %c bits : i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>bits</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssashr_u-wasmssashruop><code>wasmssa.shr_u</code> (wasmssa::ShRUOp)&nbsp;<a class=headline-hash href=#wasmssashr_u-wasmssashruop>¶</a></h3><p>_Logical right shift.</p><pre><code>Consume an integer, and an integer shift amount. The first
integer shall be shifted right by N bits, where N is the value of the
second integer.

Vacated bits on the left shall be filled with zeroes._
</code></pre><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.shr_u` $val `by` $bits `bits` `:` type($val) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.shr_u %b by %c bits : i64
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>bits</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=wasmssasqrt-wasmssasqrtop><code>wasmssa.sqrt</code> (wasmssa::SqrtOp)&nbsp;<a class=headline-hash href=#wasmssasqrt-wasmssasqrtop>¶</a></h3><p><em>Floating point square root</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.sqrt` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.sqrt %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssasub-wasmssasubop><code>wasmssa.sub</code> (wasmssa::SubOp)&nbsp;<a class=headline-hash href=#wasmssasub-wasmssasubop>¶</a></h3><p><em>Subtract two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.sub` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.sub %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssatable-wasmssatableop><code>wasmssa.table</code> (wasmssa::TableOp)&nbsp;<a class=headline-hash href=#wasmssatable-wasmssatableop>¶</a></h3><p><em>WebAssembly table value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.table` $sym_name custom&lt;WasmVisibility&gt;($sym_visibility) $type attr-dict
</code></pre><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>type attribute of Wasm table type</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=wasmssatrunc-wasmssatruncop><code>wasmssa.trunc</code> (wasmssa::TruncOp)&nbsp;<a class=headline-hash href=#wasmssatrunc-wasmssatruncop>¶</a></h3><p><em>Trunc of floating point value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.trunc` $src`:` type($src) attr-dict
</code></pre><p>Example:</p><pre><code>                                     ```mlir
                                     %a = wasmssa.trunc %b : f32
                                     ```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit float or 64-bit float</td></tr></tbody></table><h3 id=wasmssawrap-wasmssawrapop><code>wasmssa.wrap</code> (wasmssa::WrapOp)&nbsp;<a class=headline-hash href=#wasmssawrap-wasmssawrapop>¶</a></h3><p><em>Cast an i64 to i32 by using a wrapping mechanism: y = x mod 2^32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.wrap` $input `:` type($input) `to` type($result)  attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.wrap %b : i64 to i32
 ```
</code></pre><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=wasmssaxor-wasmssaxorop><code>wasmssa.xor</code> (wasmssa::XOrOp)&nbsp;<a class=headline-hash href=#wasmssaxor-wasmssaxorop>¶</a></h3><p><em>Compute the bitwise XOR of two values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `wasmssa.xor` $lhs $rhs `:` type($lhs) attr-dict
</code></pre><p>Example:</p><pre><code> ```mlir
 %a = wasmssa.xor %b %c : i32
```
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=externreftype>ExternRefType&nbsp;<a class=headline-hash href=#externreftype>¶</a></h3><p><em>Opaque type for external reference</em></p><p>Syntax: <code>!wasmssa.externref</code></p><h3 id=funcreftype>FuncRefType&nbsp;<a class=headline-hash href=#funcreftype>¶</a></h3><p><em>Opaque type for function reference</em></p><p>Syntax: <code>!wasmssa.funcref</code></p><h3 id=limittype>LimitType&nbsp;<a class=headline-hash href=#limittype>¶</a></h3><p><em>Wasm limit type</em></p><p>Syntax:</p><pre tabindex=0><code>!wasmssa.limit&lt;
  uint32_t,   # min
  std::optional&lt;uint32_t&gt;   # max
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>min</td><td style=text-align:center><code>uint32_t</code></td><td></td></tr><tr><td style=text-align:center>max</td><td style=text-align:center><code>std::optional&lt;uint32_t></code></td><td></td></tr></tbody></table><h3 id=localreftype>LocalRefType&nbsp;<a class=headline-hash href=#localreftype>¶</a></h3><p><em>Type of a local variable</em></p><p>Syntax:</p><pre tabindex=0><code>!wasmssa.local&lt;
  ::mlir::Type   # elementType
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>::mlir::Type</code></td><td>32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 128-bit signless integer or Opaque type for function reference or Opaque type for external reference</td></tr></tbody></table><h3 id=tabletype>TableType&nbsp;<a class=headline-hash href=#tabletype>¶</a></h3><p><em>Wasm table type</em></p><p>Syntax:</p><pre tabindex=0><code>!wasmssa.tabletype&lt;
  ::mlir::Type,   # reference
  ::mlir::wasmssa::LimitType   # limit
&gt;
</code></pre><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>reference</td><td style=text-align:center><code>::mlir::Type</code></td><td>Opaque type for function reference or Opaque type for external reference</td></tr><tr><td style=text-align:center>limit</td><td style=text-align:center><code>::mlir::wasmssa::LimitType</code></td><td>Wasm limit type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Vector/ title="'vector' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'vector' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/X86Vector/ title="'x86vector' Dialect">Next - 'x86vector' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>