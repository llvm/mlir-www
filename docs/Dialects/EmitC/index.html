<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'emitc' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/EmitC/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'emitc' Dialect</h1><p><em>Dialect to generate C/C++ from MLIR.</em></p><p>The EmitC dialect allows to convert operations from other MLIR dialects to EmitC
ops. Those can be translated to C/C++ via the Cpp emitter.</p><p>The following convention is followed:</p><ul><li>If template arguments are passed to an <code>emitc.call_opaque</code> operation, C++ is
generated.</li><li>If tensors are used, C++ is generated.</li><li>If multiple return values are used within in a functions or an
<code>emitc.call_opaque</code> operation, C++11 is required.</li><li>If floating-point type template arguments are passed to an <code>emitc.call_opaque</code>
operation, C++20 is required.</li><li>If <code>ssize_t</code> is used, then the code requires the POSIX header <code>sys/types.h</code>
or any of the C++ headers in which the type is defined.</li><li>If <code>_Float16</code> is used, the code requires the support of C additional
floating types.</li><li>If <code>__bf16</code> is used, the code requires a compiler that supports it, such as
GCC or Clang.</li><li>If <code>emitc.array</code> with a dimension of size zero is used, then the code
requires
<a href=https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html>a GCC extension</a>.</li><li>If <code>aligned_alloc</code> is passed to an <code>emitc.call_opaque</code> operation, then C++17
or C11 is required.</li><li>Else the generated code is compatible with C99.</li></ul><p>These restrictions are neither inherent to the EmitC dialect itself nor to the
Cpp emitter and therefore need to be considered while implementing conversions.</p><p>Type conversions are provided for the MLIR type <code>index</code> into the unsigned <code>size_t</code>
type and its signed counterpart <code>ptrdiff_t</code>. Conversions between these two types
are only valid if the <code>index</code>-typed values are within
<code>[PTRDIFF_MIN, PTRDIFF_MAX]</code>.</p><p>After the conversion, C/C++ code can be emitted with <code>mlir-translate</code>. The tool
supports translating MLIR to C/C++ by passing <code>-mlir-to-cpp</code>. Furthermore, code
with variables declared at top can be generated by passing the additional
argument <code>-declare-variables-at-top</code>.</p><p>Besides operations part of the EmitC dialect, the Cpp targets supports
translating the following operations:</p><ul><li>&lsquo;cf&rsquo; Dialect<ul><li><code>cf.br</code></li><li><code>cf.cond_br</code></li></ul></li><li>&lsquo;func&rsquo; Dialect<ul><li><code>func.call</code></li><li><code>func.func</code></li><li><code>func.return</code></li></ul></li></ul><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#emitcadd-emitcaddop><code>emitc.add</code> (emitc::AddOp)</a></li><li><a href=#emitcapply-emitcapplyop><code>emitc.apply</code> (emitc::ApplyOp)</a></li><li><a href=#emitcassign-emitcassignop><code>emitc.assign</code> (emitc::AssignOp)</a></li><li><a href=#emitcbitwise_and-emitcbitwiseandop><code>emitc.bitwise_and</code> (emitc::BitwiseAndOp)</a></li><li><a href=#emitcbitwise_left_shift-emitcbitwiseleftshiftop><code>emitc.bitwise_left_shift</code> (emitc::BitwiseLeftShiftOp)</a></li><li><a href=#emitcbitwise_not-emitcbitwisenotop><code>emitc.bitwise_not</code> (emitc::BitwiseNotOp)</a></li><li><a href=#emitcbitwise_or-emitcbitwiseorop><code>emitc.bitwise_or</code> (emitc::BitwiseOrOp)</a></li><li><a href=#emitcbitwise_right_shift-emitcbitwiserightshiftop><code>emitc.bitwise_right_shift</code> (emitc::BitwiseRightShiftOp)</a></li><li><a href=#emitcbitwise_xor-emitcbitwisexorop><code>emitc.bitwise_xor</code> (emitc::BitwiseXorOp)</a></li><li><a href=#emitccall-emitccallop><code>emitc.call</code> (emitc::CallOp)</a></li><li><a href=#emitccall_opaque-emitccallopaqueop><code>emitc.call_opaque</code> (emitc::CallOpaqueOp)</a></li><li><a href=#emitccast-emitccastop><code>emitc.cast</code> (emitc::CastOp)</a></li><li><a href=#emitcclass-emitcclassop><code>emitc.class</code> (emitc::ClassOp)</a></li><li><a href=#emitccmp-emitccmpop><code>emitc.cmp</code> (emitc::CmpOp)</a></li><li><a href=#emitcconditional-emitcconditionalop><code>emitc.conditional</code> (emitc::ConditionalOp)</a></li><li><a href=#emitcconstant-emitcconstantop><code>emitc.constant</code> (emitc::ConstantOp)</a></li><li><a href=#emitcdeclare_func-emitcdeclarefuncop><code>emitc.declare_func</code> (emitc::DeclareFuncOp)</a></li><li><a href=#emitcdiv-emitcdivop><code>emitc.div</code> (emitc::DivOp)</a></li><li><a href=#emitcexpression-emitcexpressionop><code>emitc.expression</code> (emitc::ExpressionOp)</a></li><li><a href=#emitcfield-emitcfieldop><code>emitc.field</code> (emitc::FieldOp)</a></li><li><a href=#emitcfile-emitcfileop><code>emitc.file</code> (emitc::FileOp)</a></li><li><a href=#emitcfor-emitcforop><code>emitc.for</code> (emitc::ForOp)</a></li><li><a href=#emitcfunc-emitcfuncop><code>emitc.func</code> (emitc::FuncOp)</a></li><li><a href=#emitcget_field-emitcgetfieldop><code>emitc.get_field</code> (emitc::GetFieldOp)</a></li><li><a href=#emitcget_global-emitcgetglobalop><code>emitc.get_global</code> (emitc::GetGlobalOp)</a></li><li><a href=#emitcglobal-emitcglobalop><code>emitc.global</code> (emitc::GlobalOp)</a></li><li><a href=#emitcif-emitcifop><code>emitc.if</code> (emitc::IfOp)</a></li><li><a href=#emitcinclude-emitcincludeop><code>emitc.include</code> (emitc::IncludeOp)</a></li><li><a href=#emitcliteral-emitcliteralop><code>emitc.literal</code> (emitc::LiteralOp)</a></li><li><a href=#emitcload-emitcloadop><code>emitc.load</code> (emitc::LoadOp)</a></li><li><a href=#emitclogical_and-emitclogicalandop><code>emitc.logical_and</code> (emitc::LogicalAndOp)</a></li><li><a href=#emitclogical_not-emitclogicalnotop><code>emitc.logical_not</code> (emitc::LogicalNotOp)</a></li><li><a href=#emitclogical_or-emitclogicalorop><code>emitc.logical_or</code> (emitc::LogicalOrOp)</a></li><li><a href=#emitcmember-emitcmemberop><code>emitc.member</code> (emitc::MemberOp)</a></li><li><a href=#emitcmember_of_ptr-emitcmemberofptrop><code>emitc.member_of_ptr</code> (emitc::MemberOfPtrOp)</a></li><li><a href=#emitcmul-emitcmulop><code>emitc.mul</code> (emitc::MulOp)</a></li><li><a href=#emitcrem-emitcremop><code>emitc.rem</code> (emitc::RemOp)</a></li><li><a href=#emitcreturn-emitcreturnop><code>emitc.return</code> (emitc::ReturnOp)</a></li><li><a href=#emitcsub-emitcsubop><code>emitc.sub</code> (emitc::SubOp)</a></li><li><a href=#emitcsubscript-emitcsubscriptop><code>emitc.subscript</code> (emitc::SubscriptOp)</a></li><li><a href=#emitcswitch-emitcswitchop><code>emitc.switch</code> (emitc::SwitchOp)</a></li><li><a href=#emitcunary_minus-emitcunaryminusop><code>emitc.unary_minus</code> (emitc::UnaryMinusOp)</a></li><li><a href=#emitcunary_plus-emitcunaryplusop><code>emitc.unary_plus</code> (emitc::UnaryPlusOp)</a></li><li><a href=#emitcvariable-emitcvariableop><code>emitc.variable</code> (emitc::VariableOp)</a></li><li><a href=#emitcverbatim-emitcverbatimop><code>emitc.verbatim</code> (emitc::VerbatimOp)</a></li><li><a href=#emitcyield-emitcyieldop><code>emitc.yield</code> (emitc::YieldOp)</a></li></ul></li><li><a href=#attributes-21>Attributes</a><ul><li><a href=#opaqueattr>OpaqueAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#arraytype>ArrayType</a></li><li><a href=#lvaluetype>LValueType</a></li><li><a href=#opaquetype>OpaqueType</a></li><li><a href=#pointertype>PointerType</a></li><li><a href=#ptrdiffttype>PtrDiffTType</a></li><li><a href=#signedsizettype>SignedSizeTType</a></li><li><a href=#sizettype>SizeTType</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#cmppredicate>CmpPredicate</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/EmitC/IR/EmitC.td>source</a></p><h3 id=emitcadd-emitcaddop><code>emitc.add</code> (emitc::AddOp)&nbsp;<a class=headline-hash href=#emitcadd-emitcaddop>¶</a></h3><p><em>Addition operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.add</code> operation the arithmetic operator + (addition) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the addition operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>add <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>add <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%arg3</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v5</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>+</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span><span class=o>*</span> <span class=n>v6</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>+</span> <span class=n>v4</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcapply-emitcapplyop><code>emitc.apply</code> (emitc::ApplyOp)&nbsp;<a class=headline-hash href=#emitcapply-emitcapplyop>¶</a></h3><p><em>Apply operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.apply` $applicableOperator `(` $operand `)` attr-dict `:` functional-type($operand, results)
</code></pre><p>With the <code>emitc.apply</code> operation the operators & (address of) and * (contents of)
can be applied to a single operand.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of applying the &amp; operator.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.apply&#34;</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span><span class=nl>applicableOperator =</span> <span class=s>&#34;&amp;&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>applicableOperator</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>type supported by EmitC or EmitC lvalue type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcassign-emitcassignop><code>emitc.assign</code> (emitc::AssignOp)&nbsp;<a class=headline-hash href=#emitcassign-emitcassignop>¶</a></h3><p><em>Assign operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.assign` $value `:` type($value) `to` $var `:` type($var) attr-dict
</code></pre><p>The <code>emitc.assign</code> operation stores an SSA value to the location designated by an
EmitC variable. This operation doesn&rsquo;t return any value. The assigned value
must be of the same type as the variable being assigned. The operation is
emitted as a C/C++ &lsquo;=&rsquo; operator.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Integer variable
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;foo&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Assign emitted as `... = ...;`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;emitc.assign&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>var</code></td><td>EmitC lvalue type</td></tr><tr><td style=text-align:center><code>value</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_and-emitcbitwiseandop><code>emitc.bitwise_and</code> (emitc::BitwiseAndOp)&nbsp;<a class=headline-hash href=#emitcbitwise_and-emitcbitwiseandop>¶</a></h3><p><em>Bitwise and operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_and</code> operation the bitwise operator & (and) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>&amp;</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_left_shift-emitcbitwiseleftshiftop><code>emitc.bitwise_left_shift</code> (emitc::BitwiseLeftShiftOp)&nbsp;<a class=headline-hash href=#emitcbitwise_left_shift-emitcbitwiseleftshiftop>¶</a></h3><p><em>Bitwise left shift operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_left_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_left_shift</code> operation the bitwise operator &#171;
(left shift) can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_left_shift <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>&lt;&lt;</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_not-emitcbitwisenotop><code>emitc.bitwise_not</code> (emitc::BitwiseNotOp)&nbsp;<a class=headline-hash href=#emitcbitwise_not-emitcbitwisenotop>¶</a></h3><p><em>Bitwise not operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_not</code> operation the bitwise operator ~ (not) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_not <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=o>~</span><span class=n>v1</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_or-emitcbitwiseorop><code>emitc.bitwise_or</code> (emitc::BitwiseOrOp)&nbsp;<a class=headline-hash href=#emitcbitwise_or-emitcbitwiseorop>¶</a></h3><p><em>Bitwise or operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_or</code> operation the bitwise operator | (or)
can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_or <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>|</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_right_shift-emitcbitwiserightshiftop><code>emitc.bitwise_right_shift</code> (emitc::BitwiseRightShiftOp)&nbsp;<a class=headline-hash href=#emitcbitwise_right_shift-emitcbitwiserightshiftop>¶</a></h3><p><em>Bitwise right shift operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_right_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_right_shift</code> operation the bitwise operator &#187;
(right shift) can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_right_shift <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>&gt;&gt;</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcbitwise_xor-emitcbitwisexorop><code>emitc.bitwise_xor</code> (emitc::BitwiseXorOp)&nbsp;<a class=headline-hash href=#emitcbitwise_xor-emitcbitwisexorop>¶</a></h3><p><em>Bitwise xor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.bitwise_xor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.bitwise_xor</code> operation the bitwise operator ^ (xor)
can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>bitwise_xor <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>^</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitccall-emitccallop><code>emitc.call</code> (emitc::CallOp)&nbsp;<a class=headline-hash href=#emitccall-emitccallop>¶</a></h3><p><em>Call operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>emitc.call</code> operation represents a direct call to an <code>emitc.func</code>
that is within the same symbol scope as the call. The operands and result type
of the call must match the specified function type. The callee is encoded as a
symbol reference attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CExpressionInterface</code>, <code>CallOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of type supported by EmitC</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of type supported by EmitC</td></tr></tbody></table><h3 id=emitccall_opaque-emitccallopaqueop><code>emitc.call_opaque</code> (emitc::CallOpaqueOp)&nbsp;<a class=headline-hash href=#emitccall_opaque-emitccallopaqueop>¶</a></h3><p><em>Opaque call operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.call_opaque` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>emitc.call_opaque</code> operation represents a C++ function call. The callee
can be an arbitrary non-empty string. The call allows specifying order
of operands and attributes in the call as follows:</p><ul><li>integer value of index type refers to an operand;</li><li>attribute which will get lowered to constant value in call;</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form defining a call to `foo()`.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;foo&#34;</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.call_opaque&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>callee =</span> <span class=s>&#34;foo&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>args</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>template_args</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of type supported by EmitC</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of type supported by EmitC</td></tr></tbody></table><h3 id=emitccast-emitccastop><code>emitc.cast</code> (emitc::CastOp)&nbsp;<a class=headline-hash href=#emitccast-emitccastop>¶</a></h3><p><em>Cast operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.cast` $source attr-dict `:` type($source) `to` type($dest)
</code></pre><p>The <code>emitc.cast</code> operation performs an explicit type conversion and is emitted
as a C-style cast expression. It can be applied to integer, float, index
and EmitC types.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Cast from `int32_t` to `float`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>cast <span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span> to <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Cast from `void` to `int32_t` pointer
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>cast <span class=nv>%arg1</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;void&#34;</span><span class=p>&gt;&gt;</span> to <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code>, <code>CastOpInterface</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcclass-emitcclassop><code>emitc.class</code> (emitc::ClassOp)&nbsp;<a class=headline-hash href=#emitcclass-emitcclassop>¶</a></h3><p><em>Represents a C++ class definition, encapsulating fields and methods.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.class` (`final` $final_specifier^)? $sym_name attr-dict-with-keyword $body
</code></pre><p>The <code>emitc.class</code> operation defines a C++ class, acting as a container
for its data fields (<code>emitc.field</code>) and methods (<code>emitc.func</code>).
It creates a distinct scope, isolating its contents from the surrounding
MLIR region, similar to how C++ classes encapsulate their internals.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span>class <span class=nf>@modelClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>=</span> <span class=p>{</span><span class=nl>emitc.opaque =</span> <span class=s>&#34;input_tensor&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@execute</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>size_t
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> get_field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> subscript <span class=nv>%1</span><span class=p>[</span><span class=nv>%0</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>emitc<span class=p>.</span>size_t<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c>// Class with a final speciferAdd commentMore actions
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>class final <span class=nf>@modelClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>=</span> <span class=p>{</span><span class=nl>emitc.opaque =</span> <span class=s>&#34;input_tensor&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@execute</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>size_t
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> get_field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> subscript <span class=nv>%1</span><span class=p>[</span><span class=nv>%0</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>emitc<span class=p>.</span>size_t<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AutomaticAllocationScope</code>, <code>HasOnlyGraphRegion</code>, <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>final_specifier</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=emitccmp-emitccmpop><code>emitc.cmp</code> (emitc::CmpOp)&nbsp;<a class=headline-hash href=#emitccmp-emitccmpop>¶</a></h3><p><em>Comparison operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.cmp` $predicate `,` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.cmp</code> operation the comparison operators ==, !=, &lt;, &lt;=, >, >=, &lt;=>
can be applied.</p><p>Its first argument is an attribute that defines the comparison operator:</p><ul><li>equal to (mnemonic: <code>"eq"</code>; integer value: <code>0</code>)</li><li>not equal to (mnemonic: <code>"ne"</code>; integer value: <code>1</code>)</li><li>less than (mnemonic: <code>"lt"</code>; integer value: <code>2</code>)</li><li>less than or equal to (mnemonic: <code>"le"</code>; integer value: <code>3</code>)</li><li>greater than (mnemonic: <code>"gt"</code>; integer value: <code>4</code>)</li><li>greater than or equal to (mnemonic: <code>"ge"</code>; integer value: <code>5</code>)</li><li>three-way-comparison (mnemonic: <code>"three_way"</code>; integer value: <code>6</code>)</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the cmp operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>cmp eq<span class=p>,</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>cmp lt<span class=p>,</span> <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%arg3</span> <span class=p>:</span> 
</span></span><span class=line><span class=cl>    <span class=p>(</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::valarray&lt;float&gt;&#34;</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>      <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::valarray&lt;float&gt;&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::valarray&lt;bool&gt;&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>v5</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>==</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>valarray</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>v6</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>&lt;</span> <span class=n>v4</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::emitc::CmpPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcconditional-emitcconditionalop><code>emitc.conditional</code> (emitc::ConditionalOp)&nbsp;<a class=headline-hash href=#emitcconditional-emitcconditionalop>¶</a></h3><p><em>Conditional (ternary) operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.conditional` operands attr-dict `:` type($result)
</code></pre><p>With the <code>emitc.conditional</code> operation the ternary conditional operator can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>cmp gt<span class=p>,</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%c0</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>10</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%c1</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>11</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>conditional <span class=nv>%0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>&gt;</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=n>v4</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=n>v5</span> <span class=o>=</span> <span class=mi>11</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=n>v6</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>?</span> <span class=nl>v4</span> <span class=p>:</span> <span class=n>v5</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>true_value</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>false_value</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcconstant-emitcconstantop><code>emitc.constant</code> (emitc::ConstantOp)&nbsp;<a class=headline-hash href=#emitcconstant-emitcconstantop>¶</a></h3><p><em>Constant operation</em></p><p>The <code>emitc.constant</code> operation produces an SSA value equal to some constant
specified by an attribute. This can be used to form simple integer and
floating point constants, as well as more exotic things like tensor
constants. The <code>emitc.constant</code> operation also supports the EmitC opaque
attribute and the EmitC opaque type. Since folding is supported,
it should not be used with pointers.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Integer constant
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Constant emitted as `char = CHAR_MIN;`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;CHAR_MIN&#34;</span><span class=p>&gt;}</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;char&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>ConstantLike</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>An opaque attribute or TypedAttr instance</td></tr></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcdeclare_func-emitcdeclarefuncop><code>emitc.declare_func</code> (emitc::DeclareFuncOp)&nbsp;<a class=headline-hash href=#emitcdeclare_func-emitcdeclarefuncop>¶</a></h3><p><em>An operation to declare a function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.declare_func` $sym_name attr-dict
</code></pre><p>The <code>emitc.declare_func</code> operation allows to insert a function declaration for an
<code>emitc.func</code> at a specific position. The operation only requires the &ldquo;callee&rdquo;
of the <code>emitc.func</code> to be specified as an attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span>declare_func <span class=nf>@bar</span>
</span></span><span class=line><span class=cl>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=nf>bar</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>v1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=nf>foo</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>v1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=n>bar</span><span class=p>(</span><span class=n>v1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int32_t</span> <span class=nf>bar</span><span class=p>(</span><span class=kt>int32_t</span> <span class=n>v1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>v1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h3 id=emitcdiv-emitcdivop><code>emitc.div</code> (emitc::DivOp)&nbsp;<a class=headline-hash href=#emitcdiv-emitcdivop>¶</a></h3><p><em>Division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.div` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.div</code> operation the arithmetic operator / (division) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the division operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>div <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>div <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%arg3</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v5</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>/</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>v6</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>/</span> <span class=n>v4</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr></tbody></table><h3 id=emitcexpression-emitcexpressionop><code>emitc.expression</code> (emitc::ExpressionOp)&nbsp;<a class=headline-hash href=#emitcexpression-emitcexpressionop>¶</a></h3><p><em>Expression operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.expression` attr-dict (`noinline` $do_not_inline^)? `:` type($result) $region
</code></pre><p>The <code>emitc.expression</code> operation returns a single SSA value which is yielded by
its single-basic-block region. The operation doesn&rsquo;t take any arguments.</p><p>As the operation is to be emitted as a C expression, the operations within
its body must form a single Def-Use tree of emitc ops whose result is
yielded by a terminating <code>emitc.yield</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r</span> <span class=p>=</span> emitc<span class=p>.</span>expression <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>add <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;foo&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>add <span class=nv>%c</span><span class=p>,</span> <span class=nv>%d</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> emitc<span class=p>.</span>mul <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>yield <span class=nv>%3</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>May be emitted as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int32_t</span> <span class=n>v7</span> <span class=o>=</span> <span class=n>foo</span><span class=p>(</span><span class=n>v1</span> <span class=o>+</span> <span class=n>v2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>v3</span> <span class=o>+</span> <span class=n>v4</span><span class=p>);</span>
</span></span></code></pre></div><p>The operations allowed within expression body are EmitC operations with the
CExpressionInterface interface.</p><p>When specified, the optional <code>do_not_inline</code> indicates that the expression is
to be emitted as seen above, i.e. as the rhs of an EmitC SSA value
definition. Otherwise, the expression may be emitted inline, i.e. directly
at its use.</p><p>Traits: <code>HasOnlyGraphRegion</code>, <code>NoRegionArguments</code>, <code>SingleBlockImplicitTerminator&lt;emitc::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>do_not_inline</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcfield-emitcfieldop><code>emitc.field</code> (emitc::FieldOp)&nbsp;<a class=headline-hash href=#emitcfield-emitcfieldop>¶</a></h3><p><em>A field within a class</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.field` $sym_name `:` $type ($attrs^)? attr-dict
</code></pre><p>The <code>emitc.field</code> operation declares a named field within an <code>emitc.class</code>
operation. The field&rsquo;s type must be an EmitC type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Example with an attribute:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>  <span class=p>{</span><span class=nl>emitc.opaque =</span> <span class=s>&#34;another_feature&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c>// Example with no attribute:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>attrs</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h3 id=emitcfile-emitcfileop><code>emitc.file</code> (emitc::FileOp)&nbsp;<a class=headline-hash href=#emitcfile-emitcfileop>¶</a></h3><p><em>A file container operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.file` $id attr-dict-with-keyword $bodyRegion
</code></pre><p>A <code>file</code> represents a single C/C++ file.</p><p><code>mlir-translate</code> ignores the body of all <code>emitc.file</code> ops
unless the <code>-file-id=id</code> flag is used. With that flag, all <code>emitc.file</code> ops
with matching id are emitted.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span>file <span class=s>&#34;main&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@func_one</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    emitc<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>HasOnlyGraphRegion</code>, <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>RegionKindInterface</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::StringAttr</td><td><details><summary>An Attribute containing a string</summary><pre><code>Syntax:
<pre tabindex=0><code>string-attribute ::= string-literal (`:` type)?
</code></pre><p>A string attribute is an attribute that represents a string literal value.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=err>&amp;</span>quot<span class=err>;</span>An important string<span class=err>&amp;</span>quot<span class=err>;</span>
</span></span><span class=line><span class=cl><span class=err>&amp;</span>quot<span class=err>;</span>string with a type<span class=err>&amp;</span>quot<span class=err>;</span> <span class=p>:</span> <span class=p>!</span>dialect<span class=p>.</span>string
</span></span></code></pre></div><p></code></pre></p></details></td></tr></table><h3 id=emitcfor-emitcforop><code>emitc.for</code> (emitc::ForOp)&nbsp;<a class=headline-hash href=#emitcfor-emitcforop>¶</a></h3><p><em>For operation</em></p><p>The <code>emitc.for</code> operation represents a C loop of the following form:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>T</span> <span class=n>i</span> <span class=o>=</span> <span class=n>lb</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>ub</span><span class=p>;</span> <span class=n>i</span> <span class=o>+=</span> <span class=n>step</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span> <span class=c1>// where T is typeof(lb)
</span></span></span></code></pre></div><p>The operation takes 3 SSA values as operands that represent the lower bound,
upper bound and step respectively, and defines an SSA value for its
induction variable. It has one region capturing the loop body. The induction
variable is represented as an argument of this region. This SSA value is a
signless integer, or an index. The step is a value of same type.</p><p>This operation has no result. The body region must contain exactly one block
that terminates with <code>emitc.yield</code>. Calling ForOp::build will create such a
region and insert the terminator implicitly if none is defined, so will the
parsing even in cases when it is absent from the custom format. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Index case.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>for <span class=nv>%iv</span> <span class=p>=</span> <span class=nv>%lb</span> to <span class=nv>%ub</span> step <span class=nv>%step</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=c>// body
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl><span class=c>// Integer case.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>for <span class=nv>%iv_32</span> <span class=p>=</span> <span class=nv>%lb_32</span> to <span class=nv>%ub_32</span> step <span class=nv>%step_32</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span> <span class=c>// body
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;emitc::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lowerBound</code></td><td>integer, index or opaque type supported by EmitC</td></tr><tr><td style=text-align:center><code>upperBound</code></td><td>integer, index or opaque type supported by EmitC</td></tr><tr><td style=text-align:center><code>step</code></td><td>integer, index or opaque type supported by EmitC</td></tr></tbody></table><h3 id=emitcfunc-emitcfuncop><code>emitc.func</code> (emitc::FuncOp)&nbsp;<a class=headline-hash href=#emitcfunc-emitcfuncop>¶</a></h3><p><em>An operation with a name containing a single <code>SSACFG</code> region</em></p><p>Operations within the function cannot implicitly capture values defined
outside of the function, i.e. Functions are <code>IsolatedFromAbove</code>. All
external references must use function arguments or attributes that establish
a symbolic connection (e.g. symbols referenced by name via a string
attribute like SymbolRefAttr). While the MLIR textual form provides a nice
inline syntax for function arguments, they are internally represented as
“block arguments” to the first block in the region.</p><p>Only dialect attribute names may be specified in the attribute dictionaries
for function arguments, results, or the function itself.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A function with no results:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>call_opaque <span class=s>&#34;bar&#34;</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function with its argument as single result:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function with specifiers attribute:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@example_specifiers_fn_attr</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>            attributes <span class=p>{</span><span class=nl>specifiers =</span> <span class=p>[</span><span class=s>&#34;static&#34;</span><span class=p>,</span><span class=s>&#34;inline&#34;</span><span class=p>]}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;foo&#34;</span> <span class=p>():</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// An external function definition:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span><span class=kt>func</span> private <span class=nf>@extern_func</span><span class=p>(</span><span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    attributes <span class=p>{</span><span class=nl>specifiers =</span> <span class=p>[</span><span class=s>&#34;extern&#34;</span><span class=p>]}</span>
</span></span></code></pre></div><p>Traits: <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>OpAsmOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>specifiers</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=emitcget_field-emitcgetfieldop><code>emitc.get_field</code> (emitc::GetFieldOp)&nbsp;<a class=headline-hash href=#emitcget_field-emitcgetfieldop>¶</a></h3><p><em>Obtain access to a field within a class instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.get_field` $field_name `:` type($result) attr-dict
</code></pre><p>The <code>emitc.get_field</code> operation retrieves the lvalue of a
named field from a given class instance.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> get_field <span class=nf>@fieldName0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>field_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>EmitC array type or EmitC lvalue type</td></tr></tbody></table><h3 id=emitcget_global-emitcgetglobalop><code>emitc.get_global</code> (emitc::GetGlobalOp)&nbsp;<a class=headline-hash href=#emitcget_global-emitcgetglobalop>¶</a></h3><p><em>Obtain access to a global variable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.get_global` $name `:` type($result) attr-dict
</code></pre><p>The <code>emitc.get_global</code> operation retrieves the lvalue of a
named global variable. If the global variable is marked constant, assigning
to that lvalue is undefined.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%x</span> <span class=p>=</span> emitc<span class=p>.</span>get_global <span class=nf>@foo</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%y</span> <span class=p>=</span> emitc<span class=p>.</span>get_global <span class=nf>@bar</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>EmitC array type or EmitC lvalue type</td></tr></tbody></table><h3 id=emitcglobal-emitcglobalop><code>emitc.global</code> (emitc::GlobalOp)&nbsp;<a class=headline-hash href=#emitcglobal-emitcglobalop>¶</a></h3><p><em>A global variable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.global` (`extern` $extern_specifier^)?
              (`static` $static_specifier^)?
              (`const` $const_specifier^)?
              $sym_name
              `:` custom&lt;EmitCGlobalOpTypeAndInitialValue&gt;($type, $initial_value)
              attr-dict
</code></pre><p>The <code>emitc.global</code> operation declares or defines a named global variable.
The backing memory for the variable is allocated statically and described by
the variable&rsquo;s type, which must be an EmitC type.
Optionally, an <code>initial_value</code> can be provided.
Internal linkage can be specified using the <code>static_specifier</code> unit attribute
and external linkage can be specified using the <code>extern_specifier</code> unit attribute.
Note that the default linkage without those two keywords depends on whether
the target is C or C++ and whether the global variable is <code>const</code>.
The global variable can also be marked constant using the <code>const_specifier</code>
unit attribute. Writing to such constant global variables is
undefined.</p><p>The global variable can be accessed by using the <code>emitc.get_global</code> to
retrieve the value for the global variable.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Global variable with an initial value.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>global <span class=nf>@x</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>=</span> dense<span class=p>&lt;</span><span class=m>0.0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Global variable with an initial values.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>global <span class=nf>@x</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3x</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>=</span> dense<span class=p>&lt;[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>]&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Global variable with an opaque initial value.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>global <span class=nf>@x</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;char&#34;</span><span class=p>&gt;</span> <span class=p>=</span> <span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;CHAR_MIN&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// External global variable
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>global extern <span class=nf>@x</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Constant global variable with internal linkage
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>global static const <span class=nf>@x</span> <span class=p>:</span> <span class=nl>i32 =</span> <span class=m>0</span>
</span></span></code></pre></div><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>initial_value</code></td><td>::mlir::Attribute</td><td>An opaque attribute or TypedAttr instance</td></tr><tr><td><code>extern_specifier</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>static_specifier</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>const_specifier</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=emitcif-emitcifop><code>emitc.if</code> (emitc::IfOp)&nbsp;<a class=headline-hash href=#emitcif-emitcifop>¶</a></h3><p><em>If-then-else operation</em></p><p>The <code>emitc.if</code> operation represents an if-then-else construct for
conditionally executing two regions of code. The operand to an if operation
is a boolean value. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span>if <span class=nv>%b</span>  <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> else <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The &ldquo;then&rdquo; region has exactly 1 block. The &ldquo;else&rdquo; region may have 0 or 1
blocks. The blocks are always terminated with <code>emitc.yield</code>, which can be
left out to be inserted implicitly. This operation doesn&rsquo;t produce any
results.</p><p>Traits: <code>NoRegionArguments</code>, <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;emitc::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>RegionBranchOpInterface</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=emitcinclude-emitcincludeop><code>emitc.include</code> (emitc::IncludeOp)&nbsp;<a class=headline-hash href=#emitcinclude-emitcincludeop>¶</a></h3><p><em>Include operation</em></p><p>The <code>emitc.include</code> operation allows to define a source file inclusion via the
<code>#include</code> directive.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form defining the inclusion of `&lt;myheader&gt;`.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>include <span class=p>&lt;</span><span class=s>&#34;myheader.h&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;emitc.include&#34;</span> <span class=p>(){</span><span class=nl>include =</span> <span class=s>&#34;myheader.h&#34;</span><span class=p>,</span> is_standard_include<span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Custom form defining the inclusion of `&#34;myheader&#34;`.
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>include <span class=s>&#34;myheader.h&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;emitc.include&#34;</span> <span class=p>(){</span><span class=nl>include =</span> <span class=s>&#34;myheader.h&#34;</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>include</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>is_standard_include</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=emitcliteral-emitcliteralop><code>emitc.literal</code> (emitc::LiteralOp)&nbsp;<a class=headline-hash href=#emitcliteral-emitcliteralop>¶</a></h3><p><em>Literal operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.literal` $value attr-dict `:` type($result)
</code></pre><p>The <code>emitc.literal</code> operation produces an SSA value equal to some constant
specified by an attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%p0</span> <span class=p>=</span> emitc<span class=p>.</span>literal <span class=s>&#34;M_PI&#34;</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.add&#34;</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%p0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>float</span> <span class=n>v2</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>+</span> <span class=n>M_PI</span><span class=p>;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcload-emitcloadop><code>emitc.load</code> (emitc::LoadOp)&nbsp;<a class=headline-hash href=#emitcload-emitcloadop>¶</a></h3><p><em>Load an lvalue into an SSA value.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.load` $operand attr-dict `:` type($operand)
</code></pre><p>This operation loads the content of a modifiable lvalue into an SSA value.
Modifications of the lvalue executed after the load are not observable on
the produced value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>load <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=n>v1</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>EmitC lvalue type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=emitclogical_and-emitclogicalandop><code>emitc.logical_and</code> (emitc::LogicalAndOp)&nbsp;<a class=headline-hash href=#emitclogical_and-emitclogicalandop>¶</a></h3><p><em>Logical and operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.logical_and` operands attr-dict `:` type(operands)
</code></pre><p>With the <code>emitc.logical_and</code> operation the logical operator && (and) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>logical_and <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>&amp;&amp;</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>1-bit signless integer</td></tr></tbody></table><h3 id=emitclogical_not-emitclogicalnotop><code>emitc.logical_not</code> (emitc::LogicalNotOp)&nbsp;<a class=headline-hash href=#emitclogical_not-emitclogicalnotop>¶</a></h3><p><em>Logical not operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.logical_not` operands attr-dict `:` type(operands)
</code></pre><p>With the <code>emitc.logical_not</code> operation the logical operator ! (negation) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>logical_not <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>v2</span> <span class=o>=</span> <span class=o>!</span><span class=n>v1</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>1-bit signless integer</td></tr></tbody></table><h3 id=emitclogical_or-emitclogicalorop><code>emitc.logical_or</code> (emitc::LogicalOrOp)&nbsp;<a class=headline-hash href=#emitclogical_or-emitclogicalorop>¶</a></h3><p><em>Logical or operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.logical_or` operands attr-dict `:` type(operands)
</code></pre><p>With the <code>emitc.logical_or</code> operation the logical operator || (inclusive or)
can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>logical_or <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>||</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>1-bit signless integer</td></tr></tbody></table><h3 id=emitcmember-emitcmemberop><code>emitc.member</code> (emitc::MemberOp)&nbsp;<a class=headline-hash href=#emitcmember-emitcmemberop>¶</a></h3><p><em>Member operation</em></p><p>With the <code>emitc.member</code> operation the member access operator <code>.</code> can be
applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.member&#34;</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span><span class=nl>member =</span> <span class=s>&#34;a&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;mystruct&#34;</span><span class=p>&gt;&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>member</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>emitc.lvalue of EmitC opaque type values</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>emitc.lvalue of type supported by EmitC values</td></tr></tbody></table><h3 id=emitcmember_of_ptr-emitcmemberofptrop><code>emitc.member_of_ptr</code> (emitc::MemberOfPtrOp)&nbsp;<a class=headline-hash href=#emitcmember_of_ptr-emitcmemberofptrop>¶</a></h3><p><em>Member of pointer operation</em></p><p>With the <code>emitc.member_of_ptr</code> operation the member access operator <code>-></code>
can be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.member_of_ptr&#34;</span> <span class=p>(</span><span class=nv>%arg0</span><span class=p>)</span> <span class=p>{</span><span class=nl>member =</span> <span class=s>&#34;a&#34;</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;mystruct&#34;</span><span class=p>&gt;&gt;&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>member</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>emitc.lvalue of EmitC opaque type or EmitC pointer type values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>emitc.lvalue of type supported by EmitC values</td></tr></tbody></table><h3 id=emitcmul-emitcmulop><code>emitc.mul</code> (emitc::MulOp)&nbsp;<a class=headline-hash href=#emitcmul-emitcmulop>¶</a></h3><p><em>Multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.mul</code> operation the arithmetic operator * (multiplication) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the multiplication operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>mul <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>mul <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%arg3</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v5</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>*</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>v6</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>*</span> <span class=n>v4</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>floating-point type supported by EmitC or integer, index or opaque type supported by EmitC</td></tr></tbody></table><h3 id=emitcrem-emitcremop><code>emitc.rem</code> (emitc::RemOp)&nbsp;<a class=headline-hash href=#emitcrem-emitcremop>¶</a></h3><p><em>Remainder operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.rem` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.rem</code> operation the arithmetic operator % (remainder) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the remainder operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>rem <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v5</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>%</span> <span class=n>v2</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>integer, index or opaque type supported by EmitC</td></tr><tr><td style=text-align:center>«unnamed»</td><td>integer, index or opaque type supported by EmitC</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>integer, index or opaque type supported by EmitC</td></tr></tbody></table><h3 id=emitcreturn-emitcreturnop><code>emitc.return</code> (emitc::ReturnOp)&nbsp;<a class=headline-hash href=#emitcreturn-emitcreturnop>¶</a></h3><p><em>Function return operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.return` attr-dict ($operand^ `:` type($operand))?
</code></pre><p>The <code>emitc.return</code> operation represents a return operation within a function.
The operation takes zero or exactly one operand and produces no results.
The operand number and type must match the signature of the function
that contains the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;FuncOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcsub-emitcsubop><code>emitc.sub</code> (emitc::SubOp)&nbsp;<a class=headline-hash href=#emitcsub-emitcsubop>¶</a></h3><p><em>Subtraction operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.sub</code> operation the arithmetic operator - (subtraction) can
be applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of the substraction operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>sub <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>sub <span class=nv>%arg2</span><span class=p>,</span> <span class=nv>%arg3</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>sub <span class=nv>%arg4</span><span class=p>,</span> <span class=nv>%arg5</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptrdiff_t
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v7</span> <span class=o>=</span> <span class=n>v1</span> <span class=o>-</span> <span class=n>v2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span><span class=o>*</span> <span class=n>v8</span> <span class=o>=</span> <span class=n>v3</span> <span class=o>-</span> <span class=n>v4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>ptrdiff_t</span> <span class=n>v9</span> <span class=o>=</span> <span class=n>v5</span> <span class=o>-</span> <span class=n>v6</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>type supported by EmitC</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcsubscript-emitcsubscriptop><code>emitc.subscript</code> (emitc::SubscriptOp)&nbsp;<a class=headline-hash href=#emitcsubscript-emitcsubscriptop>¶</a></h3><p><em>Subscript operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.subscript` $value `[` $indices `]` attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.subscript</code> operation the subscript operator <code>[]</code> can be applied
to variables or arguments of array, pointer and opaque type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%i</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span><span class=kt>constant</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=nv>%j</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span><span class=kt>constant</span> <span class=m>7</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>subscript <span class=nv>%arg0</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span> <span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>4x8x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>subscript <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%i</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>       <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>EmitC array type or EmitC opaque type or EmitC pointer type</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of type supported by EmitC</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>EmitC lvalue type</td></tr></tbody></table><h3 id=emitcswitch-emitcswitchop><code>emitc.switch</code> (emitc::SwitchOp)&nbsp;<a class=headline-hash href=#emitcswitch-emitcswitchop>¶</a></h3><p><em>Switch operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.switch` $arg `:` type($arg) attr-dict custom&lt;SwitchCases&gt;($cases, $caseRegions) `\n`
              `` `default` $defaultRegion
</code></pre><p>The <code>emitc.switch</code> is a control-flow operation that branches to one of
the given regions based on the values of the argument and the cases.
The operand to a switch operation is a opaque, integral or pointer
wide types.</p><p>The operation always has a &ldquo;default&rdquo; region and any number of case regions
denoted by integer constants. Control-flow transfers to the case region
whose constant value equals the value of the argument. If the argument does
not equal any of the case values, control-flow transfer to the &ldquo;default&rdquo;
region.</p><p>The operation does not return any value. Moreover, case regions must be
explicitly terminated using the <code>emitc.yield</code> operation. Default region is
yielded implicitly.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Example:
</span></span></span><span class=line><span class=cl><span class=c></span>emitc<span class=p>.</span>switch <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>case <span class=m>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;func_b&#34;</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>yield
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>case <span class=m>5</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>call_opaque <span class=s>&#34;func_a&#34;</span> <span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>yield
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>default <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;emitc.constant&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>  emitc<span class=p>.</span>call_opaque <span class=s>&#34;func2&#34;</span> <span class=p>(</span><span class=nv>%3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operations above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>v1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>2</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=n>func_b</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=mi>5</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int32_t</span> <span class=n>v3</span> <span class=o>=</span> <span class=n>func_a</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=o>:</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>float</span> <span class=n>v4</span> <span class=o>=</span> <span class=mf>4.200000000e+01</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>func2</span><span class=p>(</span><span class=n>v4</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;emitc::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>OpAsmOpInterface</code>, <code>RegionBranchOpInterface</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cases</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>integer, index or opaque type supported by EmitC</td></tr></tbody></table><h3 id=emitcunary_minus-emitcunaryminusop><code>emitc.unary_minus</code> (emitc::UnaryMinusOp)&nbsp;<a class=headline-hash href=#emitcunary_minus-emitcunaryminusop>¶</a></h3><p><em>Unary minus operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.unary_minus` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.unary_minus</code> operation the unary operator - (minus) can be
applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>unary_minus <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=o>-</span><span class=n>v1</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcunary_plus-emitcunaryplusop><code>emitc.unary_plus</code> (emitc::UnaryPlusOp)&nbsp;<a class=headline-hash href=#emitcunary_plus-emitcunaryplusop>¶</a></h3><p><em>Unary plus operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.unary_plus` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>With the <code>emitc.unary_plus</code> operation the unary operator + (plus) can be
applied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> emitc<span class=p>.</span>unary_plus <span class=nv>%arg0</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int32_t</span> <span class=n>v2</span> <span class=o>=</span> <span class=o>+</span><span class=n>v1</span><span class=p>;</span>
</span></span></code></pre></div><p>Interfaces: <code>CExpressionInterface</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>type supported by EmitC</td></tr></tbody></table><h3 id=emitcvariable-emitcvariableop><code>emitc.variable</code> (emitc::VariableOp)&nbsp;<a class=headline-hash href=#emitcvariable-emitcvariableop>¶</a></h3><p><em>Variable operation</em></p><p>The <code>emitc.variable</code> operation produces an SSA value equal to some value
specified by an attribute. This can be used to form simple integer and
floating point variables, as well as more exotic things like tensor
variables. The <code>emitc.variable</code> operation also supports the EmitC opaque
attribute and the EmitC opaque type. If further supports the EmitC
pointer type, whereas folding is not supported.
The <code>emitc.variable</code> is emitted as a C/C++ local variable.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Integer variable
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>(){</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Variable emitted as `int32_t* = NULL;`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;NULL&#34;</span><span class=p>&gt;}</span> 
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int32_t&#34;</span><span class=p>&gt;&gt;&gt;</span>
</span></span></code></pre></div><p>Since folding is not supported, it can be used with pointers.
As an example, it is valid to create pointers to <code>variable</code> operations
by using <code>apply</code> operations and pass these to a <code>call</code> operation.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;emitc.variable&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> emitc<span class=p>.</span>apply <span class=s>&#34;&amp;&#34;</span><span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>lvalue<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>emitc<span class=p>.</span>call_opaque <span class=s>&#34;write&#34;</span><span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>:</span> <span class=p>(!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>An opaque attribute or TypedAttr instance</td></tr></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>EmitC array type or EmitC lvalue type</td></tr></tbody></table><h3 id=emitcverbatim-emitcverbatimop><code>emitc.verbatim</code> (emitc::VerbatimOp)&nbsp;<a class=headline-hash href=#emitcverbatim-emitcverbatimop>¶</a></h3><p><em>Verbatim operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.verbatim` $value (`args` $fmtArgs^ `:` type($fmtArgs))? attr-dict
</code></pre><p>The <code>emitc.verbatim</code> operation produces no results and the value is emitted as is
followed by a line break (&rsquo;\n&rsquo; character) during translation.</p><p>Note: Use with caution. This operation can have arbitrary effects on the
semantics of the emitted code. Use semantically more meaningful operations
whenever possible. Additionally this op is <em>NOT</em> intended to be used to
inject large snippets of code.</p><p>This operation can be used in situations where a more suitable operation is
not yet implemented in the dialect or where preprocessor directives
interfere with the structure of the code. One example of this is to declare
the linkage of external symbols to make the generated code usable in both C
and C++ contexts:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>extern</span> <span class=s>&#34;C&#34;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#ifdef __cplusplus
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>If the <code>emitc.verbatim</code> op has operands, then the <code>value</code> is interpreted as
format string, where <code>{}</code> is a placeholder for an operand in their order.
For example, <code>emitc.verbatim "#pragma my src={} dst={}" %src, %dest : i32, i32</code>
would be emitted as <code>#pragma my src=a dst=b</code> if <code>%src</code> became <code>a</code> and
<code>%dest</code> became <code>b</code> in the C code.
<code>{{</code> in the format string is interpreted as a single <code>{</code> and doesn&rsquo;t introduce
a placeholder.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>emitc<span class=p>.</span>verbatim <span class=s>&#34;typedef float f32;&#34;</span>
</span></span><span class=line><span class=cl>emitc<span class=p>.</span>verbatim <span class=s>&#34;#pragma my var={} property&#34;</span> args <span class=nv>%arg</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// Code emitted for the operation above.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=kt>float</span> <span class=n>f32</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#pragma my var=v1 property
</span></span></span></code></pre></div><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>fmtArgs</code></td><td>variadic of type supported by EmitC or EmitC lvalue type</td></tr></tbody></table><h3 id=emitcyield-emitcyieldop><code>emitc.yield</code> (emitc::YieldOp)&nbsp;<a class=headline-hash href=#emitcyield-emitcyieldop>¶</a></h3><p><em>Block termination operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `emitc.yield` attr-dict ($result^ `:` type($result))?
</code></pre><p>The <code>emitc.yield</code> terminates its parent EmitC op&rsquo;s region, optionally yielding
an SSA value. The semantics of how the values are yielded is defined by the
parent operation.
If <code>emitc.yield</code> has an operand, the operand must match the parent operation&rsquo;s
result. If the parent operation defines no values, then the <code>emitc.yield</code>
may be left out in the custom syntax and the builders will insert one
implicitly. Otherwise, it has to be present in the syntax to indicate which
value is yielded.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;ExpressionOp, IfOp, ForOp, SwitchOp></code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>type supported by EmitC</td></tr></tbody></table><h2 id=attributes-21>Attributes&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h2><h3 id=opaqueattr>OpaqueAttr&nbsp;<a class=headline-hash href=#opaqueattr>¶</a></h3><p><em>An opaque attribute</em></p><p>Syntax:</p><pre tabindex=0><code>#emitc.opaque&lt;
  ::llvm::StringRef   # value
&gt;
</code></pre><p>An opaque attribute of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;NULL&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#emitc.opaque</span><span class=p>&lt;</span><span class=s>&#34;nullptr&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>the opaque value</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p><em>EmitC array type</em></p><p>An array data type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Array emitted as `int32_t[10]`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Array emitted as `float[10][20]`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>array<span class=p>&lt;</span><span class=m>10x20x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>shape</td><td style=text-align:center><code>::llvm::ArrayRef&lt;int64_t></code></td><td></td></tr><tr><td style=text-align:center>elementType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=lvaluetype>LValueType&nbsp;<a class=headline-hash href=#lvaluetype>¶</a></h3><p><em>EmitC lvalue type</em></p><p>Syntax:</p><pre tabindex=0><code>!emitc.lvalue&lt;
  Type   # valueType
&gt;
</code></pre><p>Values of this type can be assigned to and their address can be taken.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=opaquetype>OpaqueType&nbsp;<a class=headline-hash href=#opaquetype>¶</a></h3><p><em>EmitC opaque type</em></p><p>Syntax:</p><pre tabindex=0><code>!emitc.opaque&lt;
  ::llvm::StringRef   # value
&gt;
</code></pre><p>An opaque data type of which the value gets emitted as is.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;mytype&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;std::vector&lt;std::string&gt;&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>the opaque value</td></tr></tbody></table><h3 id=pointertype>PointerType&nbsp;<a class=headline-hash href=#pointertype>¶</a></h3><p><em>EmitC pointer type</em></p><p>Syntax:</p><pre tabindex=0><code>!emitc.ptr&lt;
  Type   # pointee
&gt;
</code></pre><p>A pointer data type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Pointer emitted as `int32_t*`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Pointer emitted as `float*`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Pointer emitted as `int*`
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>emitc<span class=p>.</span>ptr<span class=p>&lt;!</span>emitc<span class=p>.</span>opaque<span class=p>&lt;</span><span class=s>&#34;int&#34;</span><span class=p>&gt;&gt;</span>
</span></span></code></pre></div><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>pointee</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><h3 id=ptrdiffttype>PtrDiffTType&nbsp;<a class=headline-hash href=#ptrdiffttype>¶</a></h3><p><em>EmitC signed pointer diff type</em></p><p>Syntax: <code>!emitc.ptrdiff_t</code></p><p>Signed data type as wide as platform-specific pointer types.
In particular, it is as wide as <code>emitc.size_t</code>.
It corresponds to <code>ptrdiff_t</code> found in <code>&lt;stddef.h></code>.</p><h3 id=signedsizettype>SignedSizeTType&nbsp;<a class=headline-hash href=#signedsizettype>¶</a></h3><p><em>EmitC signed size type</em></p><p>Syntax: <code>!emitc.ssize_t</code></p><p>Data type representing all values of <code>emitc.size_t</code>, plus -1.
It corresponds to <code>ssize_t</code> found in <code>&lt;sys/types.h></code>.</p><p>Use of this type causes the code to be non-C99 compliant.</p><h3 id=sizettype>SizeTType&nbsp;<a class=headline-hash href=#sizettype>¶</a></h3><p><em>EmitC unsigned size type</em></p><p>Syntax: <code>!emitc.size_t</code></p><p>Unsigned data type as wide as platform-specific pointer types.
It corresponds to <code>size_t</code> found in <code>&lt;stddef.h></code>.</p><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=cmppredicate>CmpPredicate&nbsp;<a class=headline-hash href=#cmppredicate>¶</a></h3><p><em>Allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>lt</td><td style=text-align:center><code>2</code></td><td>lt</td></tr><tr><td style=text-align:center>le</td><td style=text-align:center><code>3</code></td><td>le</td></tr><tr><td style=text-align:center>gt</td><td style=text-align:center><code>4</code></td><td>gt</td></tr><tr><td style=text-align:center>ge</td><td style=text-align:center><code>5</code></td><td>ge</td></tr><tr><td style=text-align:center>three_way</td><td style=text-align:center><code>6</code></td><td>three_way</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/ title="'dlti' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'dlti' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Func/ title="'func' Dialect">Next - 'func' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>