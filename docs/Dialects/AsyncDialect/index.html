<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'async' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'async' Dialect</h1><p><em>Types and operations for async dialect</em></p><p>This dialect contains operations for modeling asynchronous execution.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#asyncadd_to_group-asyncaddtogroupop><code>async.add_to_group</code> (async::AddToGroupOp)</a></li><li><a href=#asyncawait-asyncawaitop><code>async.await</code> (async::AwaitOp)</a></li><li><a href=#asyncawait_all-asyncawaitallop><code>async.await_all</code> (async::AwaitAllOp)</a></li><li><a href=#asynccall-asynccallop><code>async.call</code> (async::CallOp)</a></li><li><a href=#asynccorobegin-asynccorobeginop><code>async.coro.begin</code> (async::CoroBeginOp)</a></li><li><a href=#asynccoroend-asynccoroendop><code>async.coro.end</code> (async::CoroEndOp)</a></li><li><a href=#asynccorofree-asynccorofreeop><code>async.coro.free</code> (async::CoroFreeOp)</a></li><li><a href=#asynccoroid-asynccoroidop><code>async.coro.id</code> (async::CoroIdOp)</a></li><li><a href=#asynccorosave-asynccorosaveop><code>async.coro.save</code> (async::CoroSaveOp)</a></li><li><a href=#asynccorosuspend-asynccorosuspendop><code>async.coro.suspend</code> (async::CoroSuspendOp)</a></li><li><a href=#asynccreate_group-asynccreategroupop><code>async.create_group</code> (async::CreateGroupOp)</a></li><li><a href=#asyncexecute-asyncexecuteop><code>async.execute</code> (async::ExecuteOp)</a></li><li><a href=#asyncfunc-asyncfuncop><code>async.func</code> (async::FuncOp)</a></li><li><a href=#asyncreturn-asyncreturnop><code>async.return</code> (async::ReturnOp)</a></li><li><a href=#asyncruntimeadd_ref-asyncruntimeaddrefop><code>async.runtime.add_ref</code> (async::RuntimeAddRefOp)</a></li><li><a href=#asyncruntimeadd_to_group-asyncruntimeaddtogroupop><code>async.runtime.add_to_group</code> (async::RuntimeAddToGroupOp)</a></li><li><a href=#asyncruntimeawait-asyncruntimeawaitop><code>async.runtime.await</code> (async::RuntimeAwaitOp)</a></li><li><a href=#asyncruntimeawait_and_resume-asyncruntimeawaitandresumeop><code>async.runtime.await_and_resume</code> (async::RuntimeAwaitAndResumeOp)</a></li><li><a href=#asyncruntimecreate-asyncruntimecreateop><code>async.runtime.create</code> (async::RuntimeCreateOp)</a></li><li><a href=#asyncruntimecreate_group-asyncruntimecreategroupop><code>async.runtime.create_group</code> (async::RuntimeCreateGroupOp)</a></li><li><a href=#asyncruntimedrop_ref-asyncruntimedroprefop><code>async.runtime.drop_ref</code> (async::RuntimeDropRefOp)</a></li><li><a href=#asyncruntimeis_error-asyncruntimeiserrorop><code>async.runtime.is_error</code> (async::RuntimeIsErrorOp)</a></li><li><a href=#asyncruntimeload-asyncruntimeloadop><code>async.runtime.load</code> (async::RuntimeLoadOp)</a></li><li><a href=#asyncruntimenum_worker_threads-asyncruntimenumworkerthreadsop><code>async.runtime.num_worker_threads</code> (async::RuntimeNumWorkerThreadsOp)</a></li><li><a href=#asyncruntimeresume-asyncruntimeresumeop><code>async.runtime.resume</code> (async::RuntimeResumeOp)</a></li><li><a href=#asyncruntimeset_available-asyncruntimesetavailableop><code>async.runtime.set_available</code> (async::RuntimeSetAvailableOp)</a></li><li><a href=#asyncruntimeset_error-asyncruntimeseterrorop><code>async.runtime.set_error</code> (async::RuntimeSetErrorOp)</a></li><li><a href=#asyncruntimestore-asyncruntimestoreop><code>async.runtime.store</code> (async::RuntimeStoreOp)</a></li><li><a href=#asyncyield-asyncyieldop><code>async.yield</code> (async::YieldOp)</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#corohandletype>CoroHandleType</a></li><li><a href=#coroidtype>CoroIdType</a></li><li><a href=#corostatetype>CoroStateType</a></li><li><a href=#grouptype>GroupType</a></li><li><a href=#tokentype>TokenType</a></li><li><a href=#valuetype>ValueType</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Async/IR/AsyncOps.td>source</a></p><h3 id=asyncadd_to_group-asyncaddtogroupop><code>async.add_to_group</code> (async::AddToGroupOp)&nbsp;<a class=headline-hash href=#asyncadd_to_group-asyncaddtogroupop>¶</a></h3><p><em>Adds an async token or value to the group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.add_to_group` $operand `,` $group `:` type($operand) attr-dict
</code></pre><p>The <code>async.add_to_group</code> adds an async token or value to the async group.
Returns the rank of the added element in the group. This rank is fixed
for the group lifetime.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span></code></pre></div><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr><tr><td style=text-align:center><code>group</code></td><td>async group type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rank</code></td><td>index</td></tr></tbody></table><h3 id=asyncawait-asyncawaitop><code>async.await</code> (async::AwaitOp)&nbsp;<a class=headline-hash href=#asyncawait-asyncawaitop>¶</a></h3><p><em>Waits for the argument to become ready</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.await` $operand `:` custom&lt;AwaitResultType&gt;(
              type($operand), type($result)
              ) attr-dict
</code></pre><p>The <code>async.await</code> operation waits until the argument becomes ready, and for
the <code>async.value</code> arguments it unwraps the underlying value</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl>async<span class=p>.</span>await <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>await <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=asyncawait_all-asyncawaitallop><code>async.await_all</code> (async::AwaitAllOp)&nbsp;<a class=headline-hash href=#asyncawait_all-asyncawaitallop>¶</a></h3><p><em>Waits for the all async tokens or values in the group to become ready</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.await_all` $operand attr-dict
</code></pre><p>The <code>async.await_all</code> operation waits until all the tokens or values in the
group become ready.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%1</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> async<span class=p>.</span>add_to_group <span class=nv>%2</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>async<span class=p>.</span>await_all <span class=nv>%0</span>
</span></span></code></pre></div><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async group type</td></tr></tbody></table><h3 id=asynccall-asynccallop><code>async.call</code> (async::CallOp)&nbsp;<a class=headline-hash href=#asynccall-asynccallop>¶</a></h3><p><em>Async call operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.call` $callee `(` $operands `)` attr-dict `:` functional-type($operands, results)
</code></pre><p>The <code>async.call</code> operation represents a direct call to an async function
that is within the same symbol scope as the call. The operands and result
types of the call must match the specified async function type. The callee
is encoded as a symbol reference attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> async<span class=p>.</span>call <span class=nf>@my_add</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallOpInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of async value type or async token type</td></tr></tbody></table><h3 id=asynccorobegin-asynccorobeginop><code>async.coro.begin</code> (async::CoroBeginOp)&nbsp;<a class=headline-hash href=#asynccorobegin-asynccorobeginop>¶</a></h3><p><em>Returns a handle to the coroutine</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.begin` $id attr-dict
</code></pre><p>The <code>async.coro.begin</code> allocates a coroutine frame and returns a handle to
the coroutine.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccoroend-asynccoroendop><code>async.coro.end</code> (async::CoroEndOp)&nbsp;<a class=headline-hash href=#asynccoroend-asynccoroendop>¶</a></h3><p><em>Marks the end of the coroutine in the suspend block</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.end` $handle attr-dict
</code></pre><p>The <code>async.coro.end</code> marks the point where a coroutine needs to return
control back to the caller if it is not an initial invocation of the
coroutine. It the start part of the coroutine is is no-op.</p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccorofree-asynccorofreeop><code>async.coro.free</code> (async::CoroFreeOp)&nbsp;<a class=headline-hash href=#asynccorofree-asynccorofreeop>¶</a></h3><p><em>Deallocates the coroutine frame</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.free` $id `,` $handle attr-dict
</code></pre><p>The <code>async.coro.free</code> deallocates the coroutine frame created by the
async.coro.begin operation.</p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asynccoroid-asynccoroidop><code>async.coro.id</code> (async::CoroIdOp)&nbsp;<a class=headline-hash href=#asynccoroid-asynccoroidop>¶</a></h3><p><em>Returns a switched-resume coroutine identifier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.id` attr-dict
</code></pre><p>The <code>async.coro.id</code> returns a switched-resume coroutine identifier.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>switched-resume coroutine identifier</td></tr></tbody></table><h3 id=asynccorosave-asynccorosaveop><code>async.coro.save</code> (async::CoroSaveOp)&nbsp;<a class=headline-hash href=#asynccorosave-asynccorosaveop>¶</a></h3><p><em>Saves the coroutine state</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.save` $handle attr-dict
</code></pre><p>The <code>async.coro.saves</code> saves the coroutine state.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td>saved coroutine state</td></tr></tbody></table><h3 id=asynccorosuspend-asynccorosuspendop><code>async.coro.suspend</code> (async::CoroSuspendOp)&nbsp;<a class=headline-hash href=#asynccorosuspend-asynccorosuspendop>¶</a></h3><p><em>Suspends the coroutine</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.coro.suspend` $state `,` $suspendDest `,` $resumeDest  `,` $cleanupDest attr-dict
</code></pre><p>The <code>async.coro.suspend</code> suspends the coroutine and transfers control to the
<code>suspend</code> successor. If suspended coroutine later resumed it will transfer
control to the <code>resume</code> successor. If it is destroyed it will transfer
control to the the <code>cleanup</code> successor.</p><p>In switched-resume lowering coroutine can be already in resumed state when
suspend operation is called, in this case control will be transferred to the
<code>resume</code> successor skipping the <code>suspend</code> successor.</p><p>Traits: <code>Terminator</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>state</code></td><td>saved coroutine state</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>suspendDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>resumeDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cleanupDest</code></td><td>any successor</td></tr></tbody></table><h3 id=asynccreate_group-asynccreategroupop><code>async.create_group</code> (async::CreateGroupOp)&nbsp;<a class=headline-hash href=#asynccreate_group-asynccreategroupop>¶</a></h3><p><em>Creates an empty async group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.create_group` $size `:` type($result) attr-dict
</code></pre><p>The <code>async.create_group</code> allocates an empty async group. Async tokens or
values can be added to this group later. The size of the group must be
specified at construction time, and <code>await_all</code> operation will first
wait until the number of added tokens or values reaches the group size.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%size</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl><span class=nv>%group</span> <span class=p>=</span> async<span class=p>.</span>create_group <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>group
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>async<span class=p>.</span>await_all <span class=nv>%group</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>size</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async group type</td></tr></tbody></table><h3 id=asyncexecute-asyncexecuteop><code>async.execute</code> (async::ExecuteOp)&nbsp;<a class=headline-hash href=#asyncexecute-asyncexecuteop>¶</a></h3><p><em>Asynchronous execute operation</em></p><p>The <code>body</code> region attached to the <code>async.execute</code> operation semantically
can be executed concurrently with the successor operation. In the followup
example &ldquo;compute0&rdquo; can be executed concurrently with &ldquo;compute1&rdquo;.</p><p>The actual concurrency semantics depends on the dialect lowering to the
executable format. Fully sequential execution (&ldquo;compute0&rdquo; completes before
&ldquo;compute1&rdquo; starts) is a completely legal execution.</p><p>Because concurrent execution is not guaranteed, it is illegal to create an
implicit dependency from &ldquo;compute1&rdquo; to &ldquo;compute0&rdquo; (e.g. via shared global
state). All dependencies must be made explicit with async execute arguments
(<code>async.token</code> or <code>async.value</code>).</p><p><code>async.execute</code> operation takes <code>async.token</code> dependencies and <code>async.value</code>
operands separately, and starts execution of the attached body region only
when all tokens and values become ready.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dependency</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%value</span> <span class=p>=</span> <span class=p>...</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%token</span><span class=p>,</span> <span class=nv>%results</span> <span class=p>=</span>
</span></span><span class=line><span class=cl>  async<span class=p>.</span>execute <span class=p>[</span><span class=nv>%dependency</span><span class=p>](</span><span class=nv>%value</span> as <span class=nv>%unwrapped</span><span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>             <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;!</span>some<span class=p>.</span>type<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;compute0&#34;</span><span class=p>(</span><span class=nv>%unwrapped</span><span class=p>):</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>some<span class=p>.</span>type
</span></span><span class=line><span class=cl>    async<span class=p>.</span>yield <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>some<span class=p>.</span>type
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;compute1&#34;</span><span class=p>(...)</span> <span class=p>:</span> <span class=p>!</span>some<span class=p>.</span>type
</span></span></code></pre></div><p>In the example above asynchronous execution starts only after dependency
token and value argument become ready. Unwrapped value passed to the
attached body region as an %unwrapped value of f32 type.</p><p>Traits: <code>AttrSizedOperandSegments</code>, <code>AutomaticAllocationScope</code>, <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>RegionBranchOpInterface</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>bodyOperands</code></td><td>variadic of async value type or async token type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>async token type</td></tr><tr><td style=text-align:center><code>bodyResults</code></td><td>variadic of async value type</td></tr></tbody></table><h3 id=asyncfunc-asyncfuncop><code>async.func</code> (async::FuncOp)&nbsp;<a class=headline-hash href=#asyncfunc-asyncfuncop>¶</a></h3><p><em>Async function operation</em></p><p>An async function is like a normal function, but supports non-blocking
await. Internally, async function is lowered to the LLVM coroutinue with
async runtime intrinsic. It can return an async token and/or async values.
The token represents the execution state of async function and can be used
when users want to express dependencies on some side effects, e.g.,
the token becomes available once every thing in the func body is executed.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Async function can&#39;t return void, it always must be some async thing.
</span></span></span><span class=line><span class=cl><span class=c></span>async<span class=p>.</span><span class=kt>func</span> <span class=nf>@async.0</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>token <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Function returns only async value.
</span></span></span><span class=line><span class=cl><span class=c></span>async<span class=p>.</span><span class=kt>func</span> <span class=nf>@async.1</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Implicit token can be added to return types.
</span></span></span><span class=line><span class=cl><span class=c></span>async<span class=p>.</span><span class=kt>func</span> <span class=nf>@async.2</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>async<span class=p>.</span>token<span class=p>,</span> <span class=p>!</span>async<span class=p>.</span>value<span class=p>&lt;</span><span class=k>i32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>OpAsmOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=asyncreturn-asyncreturnop><code>async.return</code> (async::ReturnOp)&nbsp;<a class=headline-hash href=#asyncreturn-asyncreturnop>¶</a></h3><p><em>Async function return operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>The <code>async.return</code> is a special terminator operation for Async function.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>async<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>async<span class=p>.</span>token <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;FuncOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=asyncruntimeadd_ref-asyncruntimeaddrefop><code>async.runtime.add_ref</code> (async::RuntimeAddRefOp)&nbsp;<a class=headline-hash href=#asyncruntimeadd_ref-asyncruntimeaddrefop>¶</a></h3><p><em>Adds a reference to async value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.add_ref` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.add_ref</code> operation adds a reference(s) to async value
(token, value or group).</p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is positive</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimeadd_to_group-asyncruntimeaddtogroupop><code>async.runtime.add_to_group</code> (async::RuntimeAddToGroupOp)&nbsp;<a class=headline-hash href=#asyncruntimeadd_to_group-asyncruntimeaddtogroupop>¶</a></h3><p><em>Adds an async token or value to the group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.add_to_group` $operand `,` $group attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.add_to_group</code> adds an async token or value to the async
group. Returns the rank of the added element in the group.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr><tr><td style=text-align:center><code>group</code></td><td>async group type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rank</code></td><td>index</td></tr></tbody></table><h3 id=asyncruntimeawait-asyncruntimeawaitop><code>async.runtime.await</code> (async::RuntimeAwaitOp)&nbsp;<a class=headline-hash href=#asyncruntimeawait-asyncruntimeawaitop>¶</a></h3><p><em>Blocks the caller thread until the operand becomes available</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.await` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.await</code> operation blocks the caller thread until the
operand becomes available or error.</p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimeawait_and_resume-asyncruntimeawaitandresumeop><code>async.runtime.await_and_resume</code> (async::RuntimeAwaitAndResumeOp)&nbsp;<a class=headline-hash href=#asyncruntimeawait_and_resume-asyncruntimeawaitandresumeop>¶</a></h3><p><em>Awaits the async operand and resumes the coroutine</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.await_and_resume` $operand `,` $handle attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.await_and_resume</code> operation awaits for the operand to
become available or error and resumes the coroutine on a thread managed by
the runtime.</p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asyncruntimecreate-asyncruntimecreateop><code>async.runtime.create</code> (async::RuntimeCreateOp)&nbsp;<a class=headline-hash href=#asyncruntimecreate-asyncruntimecreateop>¶</a></h3><p><em>Creates an async runtime token or value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.create` attr-dict `:` type($result)
</code></pre><p>The <code>async.runtime.create</code> operation creates an async dialect token or
value. Tokens and values are created in the non-ready state.</p><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimecreate_group-asyncruntimecreategroupop><code>async.runtime.create_group</code> (async::RuntimeCreateGroupOp)&nbsp;<a class=headline-hash href=#asyncruntimecreate_group-asyncruntimecreategroupop>¶</a></h3><p><em>Creates an async runtime group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.create_group` $size `:` type($result) attr-dict
</code></pre><p>The <code>async.runtime.create_group</code> operation creates an async dialect group
of the given size. Group created in the empty state.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>size</code></td><td>index</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>async group type</td></tr></tbody></table><h3 id=asyncruntimedrop_ref-asyncruntimedroprefop><code>async.runtime.drop_ref</code> (async::RuntimeDropRefOp)&nbsp;<a class=headline-hash href=#asyncruntimedrop_ref-asyncruntimedroprefop>¶</a></h3><p><em>Drops a reference to async value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.drop_ref` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.drop_ref</code> operation drops a reference(s) to async value
(token, value or group).</p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute whose value is positive</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h3 id=asyncruntimeis_error-asyncruntimeiserrorop><code>async.runtime.is_error</code> (async::RuntimeIsErrorOp)&nbsp;<a class=headline-hash href=#asyncruntimeis_error-asyncruntimeiserrorop>¶</a></h3><p><em>Returns true if token, value or group is in error state</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.is_error` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.is_error</code> operation returns true if the token, value or
group (any of the async runtime values) is in the error state. It is the
caller responsibility to check error state after the call to <code>await</code> or
resuming after <code>await_and_resume</code>.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type or async group type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>is_error</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=asyncruntimeload-asyncruntimeloadop><code>async.runtime.load</code> (async::RuntimeLoadOp)&nbsp;<a class=headline-hash href=#asyncruntimeload-asyncruntimeloadop>¶</a></h3><p><em>Loads the value from the runtime async.value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.load` $storage attr-dict `:` type($storage)
</code></pre><p>The <code>async.runtime.load</code> operation loads the value from the runtime
async.value storage.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>storage</code></td><td>async value type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=asyncruntimenum_worker_threads-asyncruntimenumworkerthreadsop><code>async.runtime.num_worker_threads</code> (async::RuntimeNumWorkerThreadsOp)&nbsp;<a class=headline-hash href=#asyncruntimenum_worker_threads-asyncruntimenumworkerthreadsop>¶</a></h3><p><em>Gets the number of threads in the threadpool from the runtime</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.num_worker_threads` attr-dict `:` type($result)
</code></pre><p>The <code>async.runtime.num_worker_threads</code> operation gets the number of threads
in the threadpool from the runtime.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=asyncruntimeresume-asyncruntimeresumeop><code>async.runtime.resume</code> (async::RuntimeResumeOp)&nbsp;<a class=headline-hash href=#asyncruntimeresume-asyncruntimeresumeop>¶</a></h3><p><em>Resumes the coroutine on a thread managed by the runtime</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.resume` $handle attr-dict
</code></pre><p>The <code>async.runtime.resume</code> operation resumes the coroutine on a thread
managed by the runtime.</p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>coroutine handle</td></tr></tbody></table><h3 id=asyncruntimeset_available-asyncruntimesetavailableop><code>async.runtime.set_available</code> (async::RuntimeSetAvailableOp)&nbsp;<a class=headline-hash href=#asyncruntimeset_available-asyncruntimesetavailableop>¶</a></h3><p><em>Switches token or value to available state</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.set_available` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.set_available</code> operation switches async token or value
state to available.</p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimeset_error-asyncruntimeseterrorop><code>async.runtime.set_error</code> (async::RuntimeSetErrorOp)&nbsp;<a class=headline-hash href=#asyncruntimeset_error-asyncruntimeseterrorop>¶</a></h3><p><em>Switches token or value to error state</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.set_error` $operand attr-dict `:` type($operand)
</code></pre><p>The <code>async.runtime.set_error</code> operation switches async token or value
state to error.</p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>async value type or async token type</td></tr></tbody></table><h3 id=asyncruntimestore-asyncruntimestoreop><code>async.runtime.store</code> (async::RuntimeStoreOp)&nbsp;<a class=headline-hash href=#asyncruntimestore-asyncruntimestoreop>¶</a></h3><p><em>Stores the value into the runtime async.value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.runtime.store` $value `,` $storage attr-dict `:` type($storage)
</code></pre><p>The <code>async.runtime.store</code> operation stores the value into the runtime
async.value storage.</p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>storage</code></td><td>async value type</td></tr></tbody></table><h3 id=asyncyield-asyncyieldop><code>async.yield</code> (async::YieldOp)&nbsp;<a class=headline-hash href=#asyncyield-asyncyieldop>¶</a></h3><p><em>Terminator for Async execute operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `async.yield` ($operands^ `:` type($operands))? attr-dict
</code></pre><p>The <code>async.yield</code> is a special terminator operation for the block inside
<code>async.execute</code> operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;ExecuteOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=corohandletype>CoroHandleType&nbsp;<a class=headline-hash href=#corohandletype>¶</a></h3><p><em>Coroutine handle</em></p><p>Syntax: <code>!async.coro.handle</code></p><p><code>async.coro.handle</code> is a handle to the coroutine (pointer to the coroutine
frame) that can be passed around to resume or destroy the coroutine.</p><h3 id=coroidtype>CoroIdType&nbsp;<a class=headline-hash href=#coroidtype>¶</a></h3><p><em>Switched-resume coroutine identifier</em></p><p>Syntax: <code>!async.coro.id</code></p><p><code>async.coro.id</code> is a type identifying a switched-resume coroutine.</p><h3 id=corostatetype>CoroStateType&nbsp;<a class=headline-hash href=#corostatetype>¶</a></h3><p><em>Saved coroutine state</em></p><p>Syntax: <code>!async.coro.state</code></p><p><code>async.coro.state</code> is a saved coroutine state that should be passed to the
coroutine suspension operation.</p><h3 id=grouptype>GroupType&nbsp;<a class=headline-hash href=#grouptype>¶</a></h3><p><em>Async group type</em></p><p>Syntax: <code>!async.group</code></p><p><code>async.group</code> represent a set of async tokens or values and allows to
execute async operations on all of them together (e.g. wait for the
completion of all/any of them).</p><h3 id=tokentype>TokenType&nbsp;<a class=headline-hash href=#tokentype>¶</a></h3><p><em>Async token type</em></p><p>Syntax: <code>!async.token</code></p><p><code>async.token</code> is a type returned by asynchronous operations, and it becomes
<code>available</code> when the asynchronous operations that created it is completed.</p><h3 id=valuetype>ValueType&nbsp;<a class=headline-hash href=#valuetype>¶</a></h3><p><em>Async value type</em></p><p><code>async.value</code> represents a value returned by asynchronous operations,
which may or may not be available currently, but will be available at some
point in the future.</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>valueType</td><td style=text-align:center><code>Type</code></td><td></td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/ArmSME/ title="'ArmSME' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'ArmSME' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/ title="'bufferization' Dialect">Next - 'bufferization' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>