<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Tensor Operator Set Architecture (TOSA) Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/TOSA/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Tensor Operator Set Architecture (TOSA) Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#rationale>Rationale</a></li><li><a href=#tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness</a><ul><li><a href=#complete>Complete</a></li><li><a href=#minimal>Minimal</a></li><li><a href=#numerical-precision>Numerical Precision</a></li></ul></li><li><a href=#tosa-operator-rationale>TOSA Operator Rationale</a><ul><li><a href=#cond_if-and-while_loop>COND_IF and WHILE_LOOP</a></li></ul></li><li><a href=#using-tosa-in-a-compiler>Using TOSA In A Compiler</a><ul><li><a href=#quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors</a></li></ul></li><li><a href=#operation-definitions>Operation definitions</a><ul><li><a href=#tosaabs-mlirtosaabsop><code>tosa.abs</code> (mlir::tosa::AbsOp)</a></li><li><a href=#tosaadd-mlirtosaaddop><code>tosa.add</code> (mlir::tosa::AddOp)</a></li><li><a href=#tosaapply_scale-mlirtosaapplyscaleop><code>tosa.apply_scale</code> (mlir::tosa::ApplyScaleOp)</a></li><li><a href=#tosaargmax-mlirtosaargmaxop><code>tosa.argmax</code> (mlir::tosa::ArgMaxOp)</a></li><li><a href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop><code>tosa.arithmetic_right_shift</code> (mlir::tosa::ArithmeticRightShiftOp)</a></li><li><a href=#tosaavg_pool2d-mlirtosaavgpool2dop><code>tosa.avg_pool2d</code> (mlir::tosa::AvgPool2dOp)</a></li><li><a href=#tosabitwise_and-mlirtosabitwiseandop><code>tosa.bitwise_and</code> (mlir::tosa::BitwiseAndOp)</a></li><li><a href=#tosabitwise_not-mlirtosabitwisenotop><code>tosa.bitwise_not</code> (mlir::tosa::BitwiseNotOp)</a></li><li><a href=#tosabitwise_or-mlirtosabitwiseorop><code>tosa.bitwise_or</code> (mlir::tosa::BitwiseOrOp)</a></li><li><a href=#tosabitwise_xor-mlirtosabitwisexorop><code>tosa.bitwise_xor</code> (mlir::tosa::BitwiseXorOp)</a></li><li><a href=#tosacast_from_block_scaled-mlirtosacastfromblockscaledop><code>tosa.cast_from_block_scaled</code> (mlir::tosa::CastFromBlockScaledOp)</a></li><li><a href=#tosacast-mlirtosacastop><code>tosa.cast</code> (mlir::tosa::CastOp)</a></li><li><a href=#tosacast_to_block_scaled-mlirtosacasttoblockscaledop><code>tosa.cast_to_block_scaled</code> (mlir::tosa::CastToBlockScaledOp)</a></li><li><a href=#tosaceil-mlirtosaceilop><code>tosa.ceil</code> (mlir::tosa::CeilOp)</a></li><li><a href=#tosaclamp-mlirtosaclampop><code>tosa.clamp</code> (mlir::tosa::ClampOp)</a></li><li><a href=#tosaclz-mlirtosaclzop><code>tosa.clz</code> (mlir::tosa::ClzOp)</a></li><li><a href=#tosaconcat-mlirtosaconcatop><code>tosa.concat</code> (mlir::tosa::ConcatOp)</a></li><li><a href=#tosaconst-mlirtosaconstop><code>tosa.const</code> (mlir::tosa::ConstOp)</a></li><li><a href=#tosaconst_shape-mlirtosaconstshapeop><code>tosa.const_shape</code> (mlir::tosa::ConstShapeOp)</a></li><li><a href=#tosaconv2d-mlirtosaconv2dop><code>tosa.conv2d</code> (mlir::tosa::Conv2DOp)</a></li><li><a href=#tosaconv3d-mlirtosaconv3dop><code>tosa.conv3d</code> (mlir::tosa::Conv3DOp)</a></li><li><a href=#tosacos-mlirtosacosop><code>tosa.cos</code> (mlir::tosa::CosOp)</a></li><li><a href=#tosacustom-mlirtosacustomop><code>tosa.custom</code> (mlir::tosa::CustomOp)</a></li><li><a href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop><code>tosa.depthwise_conv2d</code> (mlir::tosa::DepthwiseConv2DOp)</a></li><li><a href=#tosaequal-mlirtosaequalop><code>tosa.equal</code> (mlir::tosa::EqualOp)</a></li><li><a href=#tosaerf-mlirtosaerfop><code>tosa.erf</code> (mlir::tosa::ErfOp)</a></li><li><a href=#tosaexp-mlirtosaexpop><code>tosa.exp</code> (mlir::tosa::ExpOp)</a></li><li><a href=#tosafft2d-mlirtosafft2dop><code>tosa.fft2d</code> (mlir::tosa::FFT2dOp)</a></li><li><a href=#tosafloor-mlirtosafloorop><code>tosa.floor</code> (mlir::tosa::FloorOp)</a></li><li><a href=#tosagather-mlirtosagatherop><code>tosa.gather</code> (mlir::tosa::GatherOp)</a></li><li><a href=#tosagreater_equal-mlirtosagreaterequalop><code>tosa.greater_equal</code> (mlir::tosa::GreaterEqualOp)</a></li><li><a href=#tosagreater-mlirtosagreaterop><code>tosa.greater</code> (mlir::tosa::GreaterOp)</a></li><li><a href=#tosaidentity-mlirtosaidentityop><code>tosa.identity</code> (mlir::tosa::IdentityOp)</a></li><li><a href=#tosacond_if-mlirtosaifop><code>tosa.cond_if</code> (mlir::tosa::IfOp)</a></li><li><a href=#tosaintdiv-mlirtosaintdivop><code>tosa.intdiv</code> (mlir::tosa::IntDivOp)</a></li><li><a href=#tosalog-mlirtosalogop><code>tosa.log</code> (mlir::tosa::LogOp)</a></li><li><a href=#tosalogical_and-mlirtosalogicalandop><code>tosa.logical_and</code> (mlir::tosa::LogicalAndOp)</a></li><li><a href=#tosalogical_left_shift-mlirtosalogicalleftshiftop><code>tosa.logical_left_shift</code> (mlir::tosa::LogicalLeftShiftOp)</a></li><li><a href=#tosalogical_not-mlirtosalogicalnotop><code>tosa.logical_not</code> (mlir::tosa::LogicalNotOp)</a></li><li><a href=#tosalogical_or-mlirtosalogicalorop><code>tosa.logical_or</code> (mlir::tosa::LogicalOrOp)</a></li><li><a href=#tosalogical_right_shift-mlirtosalogicalrightshiftop><code>tosa.logical_right_shift</code> (mlir::tosa::LogicalRightShiftOp)</a></li><li><a href=#tosalogical_xor-mlirtosalogicalxorop><code>tosa.logical_xor</code> (mlir::tosa::LogicalXorOp)</a></li><li><a href=#tosamatmul-mlirtosamatmulop><code>tosa.matmul</code> (mlir::tosa::MatMulOp)</a></li><li><a href=#tosamatmul_t_block_scaled-mlirtosamatmultblockscaledop><code>tosa.matmul_t_block_scaled</code> (mlir::tosa::MatmulTBlockScaledOp)</a></li><li><a href=#tosamax_pool2d-mlirtosamaxpool2dop><code>tosa.max_pool2d</code> (mlir::tosa::MaxPool2dOp)</a></li><li><a href=#tosamaximum-mlirtosamaximumop><code>tosa.maximum</code> (mlir::tosa::MaximumOp)</a></li><li><a href=#tosaminimum-mlirtosaminimumop><code>tosa.minimum</code> (mlir::tosa::MinimumOp)</a></li><li><a href=#tosamul-mlirtosamulop><code>tosa.mul</code> (mlir::tosa::MulOp)</a></li><li><a href=#tosanegate-mlirtosanegateop><code>tosa.negate</code> (mlir::tosa::NegateOp)</a></li><li><a href=#tosapad-mlirtosapadop><code>tosa.pad</code> (mlir::tosa::PadOp)</a></li><li><a href=#tosapow-mlirtosapowop><code>tosa.pow</code> (mlir::tosa::PowOp)</a></li><li><a href=#tosarfft2d-mlirtosarfft2dop><code>tosa.rfft2d</code> (mlir::tosa::RFFT2dOp)</a></li><li><a href=#tosareciprocal-mlirtosareciprocalop><code>tosa.reciprocal</code> (mlir::tosa::ReciprocalOp)</a></li><li><a href=#tosareduce_all-mlirtosareduceallop><code>tosa.reduce_all</code> (mlir::tosa::ReduceAllOp)</a></li><li><a href=#tosareduce_any-mlirtosareduceanyop><code>tosa.reduce_any</code> (mlir::tosa::ReduceAnyOp)</a></li><li><a href=#tosareduce_max-mlirtosareducemaxop><code>tosa.reduce_max</code> (mlir::tosa::ReduceMaxOp)</a></li><li><a href=#tosareduce_min-mlirtosareduceminop><code>tosa.reduce_min</code> (mlir::tosa::ReduceMinOp)</a></li><li><a href=#tosareduce_product-mlirtosareduceproductop><code>tosa.reduce_product</code> (mlir::tosa::ReduceProductOp)</a></li><li><a href=#tosareduce_sum-mlirtosareducesumop><code>tosa.reduce_sum</code> (mlir::tosa::ReduceSumOp)</a></li><li><a href=#tosarescale-mlirtosarescaleop><code>tosa.rescale</code> (mlir::tosa::RescaleOp)</a></li><li><a href=#tosareshape-mlirtosareshapeop><code>tosa.reshape</code> (mlir::tosa::ReshapeOp)</a></li><li><a href=#tosaresize-mlirtosaresizeop><code>tosa.resize</code> (mlir::tosa::ResizeOp)</a></li><li><a href=#tosareverse-mlirtosareverseop><code>tosa.reverse</code> (mlir::tosa::ReverseOp)</a></li><li><a href=#tosarsqrt-mlirtosarsqrtop><code>tosa.rsqrt</code> (mlir::tosa::RsqrtOp)</a></li><li><a href=#tosascatter-mlirtosascatterop><code>tosa.scatter</code> (mlir::tosa::ScatterOp)</a></li><li><a href=#tosaselect-mlirtosaselectop><code>tosa.select</code> (mlir::tosa::SelectOp)</a></li><li><a href=#tosasigmoid-mlirtosasigmoidop><code>tosa.sigmoid</code> (mlir::tosa::SigmoidOp)</a></li><li><a href=#tosasin-mlirtosasinop><code>tosa.sin</code> (mlir::tosa::SinOp)</a></li><li><a href=#tosaslice-mlirtosasliceop><code>tosa.slice</code> (mlir::tosa::SliceOp)</a></li><li><a href=#tosasub-mlirtosasubop><code>tosa.sub</code> (mlir::tosa::SubOp)</a></li><li><a href=#tosatable-mlirtosatableop><code>tosa.table</code> (mlir::tosa::TableOp)</a></li><li><a href=#tosatanh-mlirtosatanhop><code>tosa.tanh</code> (mlir::tosa::TanhOp)</a></li><li><a href=#tosatile-mlirtosatileop><code>tosa.tile</code> (mlir::tosa::TileOp)</a></li><li><a href=#tosatranspose_conv2d-mlirtosatransposeconv2dop><code>tosa.transpose_conv2d</code> (mlir::tosa::TransposeConv2DOp)</a></li><li><a href=#tosatranspose-mlirtosatransposeop><code>tosa.transpose</code> (mlir::tosa::TransposeOp)</a></li><li><a href=#tosavariable-mlirtosavariableop><code>tosa.variable</code> (mlir::tosa::VariableOp)</a></li><li><a href=#tosavariable_read-mlirtosavariablereadop><code>tosa.variable_read</code> (mlir::tosa::VariableReadOp)</a></li><li><a href=#tosavariable_write-mlirtosavariablewriteop><code>tosa.variable_write</code> (mlir::tosa::VariableWriteOp)</a></li><li><a href=#tosawhile_loop-mlirtosawhileop><code>tosa.while_loop</code> (mlir::tosa::WhileOp)</a></li><li><a href=#tosayield-mlirtosayieldop><code>tosa.yield</code> (mlir::tosa::YieldOp)</a></li></ul></li></ul></nav><h2 id=rationale>Rationale&nbsp;<a class=headline-hash href=#rationale>¶</a></h2><p>The MLIR TOSA dialect implements the
<a href=https://www.mlplatform.org/tosa/tosa_spec.html>TOSA
specification</a>. This document
describes the decision process for how TOSA expresses operators in
high level dialects.</p><p>TOSA was developed after parallel efforts to rationalize the top-down picture
from multiple high-level frameworks, as well as a bottom-up view of different
hardware target concerns (CPU, GPU and NPU), and reflects a set of choices
that attempt to manage both sets of requirements.</p><h2 id=tosa-and-tensor-level-expressiveness>TOSA and Tensor Level Expressiveness&nbsp;<a class=headline-hash href=#tosa-and-tensor-level-expressiveness>¶</a></h2><p>TOSA endeavors to provide an operator set that tries to fulfil the following
expressiveness goals at the <em>tensor level of abstraction</em> :</p><h3 id=complete>Complete&nbsp;<a class=headline-hash href=#complete>¶</a></h3><p>This is driven by the top-down perspective, needing to express as much of
multiple high level frameworks fully in TOSA, as possible. This was originally
done from an operator frequency analysis done upon dozens of high level
networks in different frameworks, to select the most frequently occurring ones
and establish a common set of tensor-level operators that could express them.</p><p>TOSA categorizes its operator set into classes and attempts to address major
functional operations at the tensor level, including compute, reduction,
elementwise transformations, comparison and control flow.</p><h3 id=minimal>Minimal&nbsp;<a class=headline-hash href=#minimal>¶</a></h3><p>This takes the bottom-up approach - keep the TOSA operator set minimal in
order to bound the design of hardware, operator kernels, code generation
strategies and associated considerations that effect the executability of TOSA
content.</p><p>In this regard TOSA seeks to avoid creating compound operators, instead
leaving it to compiler backend to fuse multiple TOSA ops if required. This
choice also benefits the numerical precision goal, since it is easier to fuse the
numerical functionality of successive operators, than to split the numerical
functionality of a compound operator.</p><h3 id=numerical-precision>Numerical Precision&nbsp;<a class=headline-hash href=#numerical-precision>¶</a></h3><p>TOSA began as a means to address operator-level numerical precision for
code generation and hardware development. It therefore incorporates precision
detail into the operator set.</p><p>In this regard, TOSA operators are best understood as a combination of the visible
quantization information embedded within an operation, together with the
functional information about how that information is used, as described in the
specification of the operation.</p><h2 id=tosa-operator-rationale>TOSA Operator Rationale&nbsp;<a class=headline-hash href=#tosa-operator-rationale>¶</a></h2><p>The general basis of selection of the operator set that constitutes TOSA is
described in the TOSA specification document under Section 1.3 Operator
Selection. Explanation of the thinking behind some operators is listed here:</p><h3 id=cond_if-and-while_loop>COND_IF and WHILE_LOOP&nbsp;<a class=headline-hash href=#cond_if-and-while_loop>¶</a></h3><p>Several neural networks express conditional control flow at the tensor level.
A survey of multiple high level frameworks indicated that conditional if and
a loop construct are common in all major frameworks, with some variation.
Since TOSA endeavors to be complete in expressing tensor level functionality
including control flow, it implements these constructs.</p><p>The COND_IF and WHILE_LOOP operators implement such structured control
flow forms and should be lowerable to corresponding ops in the scf dialect.
Since the dialect seeks to remain isomorphic with an external, serialized form,
the decision was to keep these ops in the dialect (as opposed to deferring
completely to scf), and this may be re-evaluated if this turns out to not yield
the expected value.</p><h2 id=using-tosa-in-a-compiler>Using TOSA In A Compiler&nbsp;<a class=headline-hash href=#using-tosa-in-a-compiler>¶</a></h2><p>The TOSA specification describes each operator in functional detail. It is
expected that compilers that use TOSA will use its builders to construct the
operators so that the quantization information for the operator is correctly
generated.</p><p>The functional steps described in the pseudocode of the specification enables
the construction of code generation for that operation, or decisions on the
design of underlying hardware. The functional pseudocode also describes
how the quantization parameters are utilized within the operation.</p><h3 id=quantization-parameters-in-ops-vs-tensors>Quantization Parameters in Ops vs Tensors&nbsp;<a class=headline-hash href=#quantization-parameters-in-ops-vs-tensors>¶</a></h3><p>TOSA uses the quantization parameters embedded in the input and output
tensors to construct the quantization attributes that sit within the operator.
Once these attributes are constructed, the quantization information within
the tensors are no longer necessary for code generation.</p><p>This enables the tensors to be subsequently interpreted simply as contiguous
buffers containing raw data, with no &lsquo;meta information&rsquo; in the form of the
quantization_type. Precision related manipulation of the input or output are
instead described by the operator itself which describes, for example, when
the zero point is applied, or when the scale multiplication is done.</p><p>However, TOSA does <em>not</em> eliminate the existing MLIR QuantOps quantization
type information within the tensors; this leaves the choice of how to handle
quantization information, to later backend code generation steps.</p><p>Maintaining the ability to overlap these different representations of
quantization parameters (i.e. tensor-carried vs op-carried) is an important
capability when considering progressive lowering between uses that expect one
scheme vs the other.</p><h2 id=operation-definitions>Operation definitions&nbsp;<a class=headline-hash href=#operation-definitions>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Tosa/IR/TosaOps.td>source</a></p><h3 id=tosaabs-mlirtosaabsop><code>tosa.abs</code> (mlir::tosa::AbsOp)&nbsp;<a class=headline-hash href=#tosaabs-mlirtosaabsop>¶</a></h3><p><em>Elementwise abs operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.abs` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise absolute value operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%output</span> <span class=p>=</span> tosa<span class=p>.</span>abs<span class=p>(</span><span class=nv>%input1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>21x3x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>21x3x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaadd-mlirtosaaddop><code>tosa.add</code> (mlir::tosa::AddOp)&nbsp;<a class=headline-hash href=#tosaadd-mlirtosaaddop>¶</a></h3><p><em>Elementwise addition operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.add` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise addition of input1 and input2. Axis of size 1 will be broadcast,
as necessary. Rank of input tensors must match.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Elementwise addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%out</span> <span class=p>=</span> tosa<span class=p>.</span>add <span class=nv>%input1</span><span class=p>,</span> <span class=nv>%input2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>12x6x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>12x6x</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>12x6x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Elementwise addition with broadcasting.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%out</span> <span class=p>=</span> tosa<span class=p>.</span>add <span class=nv>%input1</span><span class=p>,</span> <span class=nv>%input2</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>12x6x</span>si32<span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x1x</span>si32<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>12x6x</span>si32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaapply_scale-mlirtosaapplyscaleop><code>tosa.apply_scale</code> (mlir::tosa::ApplyScaleOp)&nbsp;<a class=headline-hash href=#tosaapply_scale-mlirtosaapplyscaleop>¶</a></h3><p><em>Rescale scalar operator for Tosa tensor operators</em></p><p>Applies rescaling for fixed point values. This behavior is replicated in
multiple quantized operations (mul, convolution, rescale, matmul, pooling).</p><p>The commonplace implementation is to use i64 operations to avoid integer
overflow with target specific implementations can use native operations to
avoid wider than necessary types.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>TosaResolvableShapeOperands</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rounding_mode</code></td><td>mlir::tosa::RoundingModeAttr</td><td>Supported rounding modes</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>multiplier</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>shift</code></td><td>signless-integer-8-bit-like</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=tosaargmax-mlirtosaargmaxop><code>tosa.argmax</code> (mlir::tosa::ArgMaxOp)&nbsp;<a class=headline-hash href=#tosaargmax-mlirtosaargmaxop>¶</a></h3><p><em>Perform argmax on the input.</em></p><p>This returns the index with the largest value across the given axis of the
input tensor. If multiple locations have equal values, returns the first
match along the search axis.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop><code>tosa.arithmetic_right_shift</code> (mlir::tosa::ArithmeticRightShiftOp)&nbsp;<a class=headline-hash href=#tosaarithmetic_right_shift-mlirtosaarithmeticrightshiftop>¶</a></h3><p><em>Elementwise Arithmetic Right Shift.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.arithmetic_right_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise arithmetic right shift of input1 by the amount specified in
input2. Axis of size 1 will be broadcast, as necessary. Rank of input tensors
must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>round</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaavg_pool2d-mlirtosaavgpool2dop><code>tosa.avg_pool2d</code> (mlir::tosa::AvgPool2dOp)&nbsp;<a class=headline-hash href=#tosaavg_pool2d-mlirtosaavgpool2dop>¶</a></h3><p><em>Performs average pooling on the input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.avg_pool2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>This performs an average pooling over the given input tensor. A sliding
window of size given by <kernel size>is passed over the input tensor, with
the mean value being placed in the output tensor. When calculating the
average, only the number of valid input tensor values, but not padding, are
used to calculate the divisor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kernel</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr><tr><td><code>acc_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 48-bit signless integer or 16-bit float or 32-bit float</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>output_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosabitwise_and-mlirtosabitwiseandop><code>tosa.bitwise_and</code> (mlir::tosa::BitwiseAndOp)&nbsp;<a class=headline-hash href=#tosabitwise_and-mlirtosabitwiseandop>¶</a></h3><p><em>Bitwise AND operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.bitwise_and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise bitwise AND of input1 and input2. Axis of size 1
will be broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_not-mlirtosabitwisenotop><code>tosa.bitwise_not</code> (mlir::tosa::BitwiseNotOp)&nbsp;<a class=headline-hash href=#tosabitwise_not-mlirtosabitwisenotop>¶</a></h3><p><em>Bitwise NOT operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.bitwise_not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise bitwise NOT of input tensor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_or-mlirtosabitwiseorop><code>tosa.bitwise_or</code> (mlir::tosa::BitwiseOrOp)&nbsp;<a class=headline-hash href=#tosabitwise_or-mlirtosabitwiseorop>¶</a></h3><p><em>Bitwise OR operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.bitwise_or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise bitwise OR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosabitwise_xor-mlirtosabitwisexorop><code>tosa.bitwise_xor</code> (mlir::tosa::BitwiseXorOp)&nbsp;<a class=headline-hash href=#tosabitwise_xor-mlirtosabitwisexorop>¶</a></h3><p><em>Bitwise XOR operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.bitwise_xor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise bitwise XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosacast_from_block_scaled-mlirtosacastfromblockscaledop><code>tosa.cast_from_block_scaled</code> (mlir::tosa::CastFromBlockScaledOp)&nbsp;<a class=headline-hash href=#tosacast_from_block_scaled-mlirtosacastfromblockscaledop>¶</a></h3><p><em>Apply scales from a scale tensor to the values in a value tensor</em></p><p>Apply the scales from a scale tensor to the values in a value tensor, casting
the result to the output type. The block dimension must be the last dimension
of the tensor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>block_size</code></td><td>mlir::tosa::BlockSizeAttr</td><td>Block size for the block_scaled formats</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_data</code></td><td>tosa-conformant tensor of at least rank 1</td></tr><tr><td style=text-align:center><code>input_scale</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_data</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosacast-mlirtosacastop><code>tosa.cast</code> (mlir::tosa::CastOp)&nbsp;<a class=headline-hash href=#tosacast-mlirtosacastop>¶</a></h3><p><em>Cast operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.cast` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Casts a tensor from one data type to another.</p><ul><li>This table is showing the supported conversions from the TOSA Specification.</li><li>The MLIR dialect here can be used to represent other conversions.</li></ul><table><thead><tr><th>Mode</th><th>Input</th><th>Output</th></tr></thead><tbody><tr><td>fp16 to fp32</td><td>float16</td><td>float32</td></tr><tr><td>fp16 to int 16</td><td>float16</td><td>int16</td></tr><tr><td>fp16 to int 32</td><td>float16</td><td>int32</td></tr><tr><td>fp16 to int 8</td><td>float16</td><td>int8</td></tr><tr><td>fp32 to fp16</td><td>float32</td><td>float16</td></tr><tr><td>fp32 to int 16</td><td>float32</td><td>int16</td></tr><tr><td>fp32 to int 32</td><td>float32</td><td>int32</td></tr><tr><td>fp32 to int 8</td><td>float32</td><td>int8</td></tr><tr><td>int 16 to fp16</td><td>int16</td><td>float16</td></tr><tr><td>int 16 to fp32</td><td>int16</td><td>float32</td></tr><tr><td>int 32 to fp16</td><td>int32</td><td>float16</td></tr><tr><td>int 32 to fp32</td><td>int32</td><td>float32</td></tr><tr><td>int 8 to fp16</td><td>int8</td><td>float16</td></tr><tr><td>int 8 to fp32</td><td>int8</td><td>float32</td></tr><tr><td>bool to int 16</td><td>Boolean</td><td>int16</td></tr><tr><td>bool to int 32</td><td>Boolean</td><td>int32</td></tr><tr><td>bool to int 8</td><td>Boolean</td><td>int8</td></tr><tr><td>int 16 to bool</td><td>int16</td><td>Boolean</td></tr><tr><td>int 16 to int 32</td><td>int16</td><td>int32</td></tr><tr><td>int 16 to int 8</td><td>int16</td><td>int8</td></tr><tr><td>int 32 to bool</td><td>int32</td><td>Boolean</td></tr><tr><td>int 32 to int 16</td><td>int32</td><td>int16</td></tr><tr><td>int 32 to int 8</td><td>int32</td><td>int8</td></tr><tr><td>int 8 to bool</td><td>int8</td><td>Boolean</td></tr><tr><td>int 8 to int 16</td><td>int8</td><td>int16</td></tr><tr><td>int 8 to int 32</td><td>int8</td><td>int32</td></tr><tr><td>bf16 to fp32</td><td>bf16</td><td>float32</td></tr><tr><td>bf16 to int 16</td><td>bf16</td><td>int16</td></tr><tr><td>bf16 to int 32</td><td>bf16</td><td>int32</td></tr><tr><td>bf16 to int 8</td><td>bf16</td><td>int8</td></tr><tr><td>fp32 to bf16</td><td>float32</td><td>bf16</td></tr><tr><td>int 16 to bf16</td><td>int16</td><td>bf16</td></tr><tr><td>int 32 to bf16</td><td>int32</td><td>bf16</td></tr><tr><td>int 8 to bf16</td><td>int8</td><td>bf16</td></tr><tr><td>bf16 to fp8e4m3</td><td>bf16</td><td>fp8e4m3</td></tr><tr><td>fp8e4m3 to bf16</td><td>fp8e4m3</td><td>bf16</td></tr><tr><td>bf16 to fp8e5m2</td><td>bf16</td><td>fp8e5m2</td></tr><tr><td>fp8e5m2 to bf16</td><td>fp8e5m2</td><td>bf16</td></tr><tr><td>fp16 to fp8e4m3</td><td>float16</td><td>fp8e4m3</td></tr><tr><td>fp32 to fp8e4m3</td><td>float32</td><td>fp8e4m3</td></tr><tr><td>fp8e4m3 to fp16</td><td>fp8e4m3</td><td>float16</td></tr><tr><td>fp8e4m3 to fp32</td><td>fp8e4m3</td><td>float32</td></tr><tr><td>fp16 to fp8e5m2</td><td>float16</td><td>fp8e5m2</td></tr><tr><td>fp32 to fp8e5m2</td><td>float32</td><td>fp8e5m2</td></tr><tr><td>fp8e5m2 to fp16</td><td>fp8e5m2</td><td>float16</td></tr><tr><td>fp8e5m2 to fp32</td><td>fp8e5m2</td><td>float32</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultShape</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosacast_to_block_scaled-mlirtosacasttoblockscaledop><code>tosa.cast_to_block_scaled</code> (mlir::tosa::CastToBlockScaledOp)&nbsp;<a class=headline-hash href=#tosacast_to_block_scaled-mlirtosacasttoblockscaledop>¶</a></h3><p><em>Calculate scale tensor values per block, output to separate scale and data tensors.</em></p><p>Calculate a scale value per block of input values and use that to calculate
scaled data values from an input tensor. The output tensors are cast to the
specified scale and value types. The block dimension will be the last dimension
of the tensor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>block_size</code></td><td>mlir::tosa::BlockSizeAttr</td><td>Block size for the block_scaled formats</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_data</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_data</code></td><td>tosa-conformant tensor of at least rank 1</td></tr><tr><td style=text-align:center><code>output_scale</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosaceil-mlirtosaceilop><code>tosa.ceil</code> (mlir::tosa::CeilOp)&nbsp;<a class=headline-hash href=#tosaceil-mlirtosaceilop>¶</a></h3><p><em>Elementwise ceil operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.ceil` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise ceiling operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaclamp-mlirtosaclampop><code>tosa.clamp</code> (mlir::tosa::ClampOp)&nbsp;<a class=headline-hash href=#tosaclamp-mlirtosaclampop>¶</a></h3><p><em>Computes clamp(features, min, max).</em></p><p>Clamp to an arbitrary minimum and maximum value.
Maximum and minimum values are specified as values in the range of the
input type.
No zero point subtraction is done to the values, thus to clamp to the zero
point value, the zero point itself should be supplied as the minimum value.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>min_val</code></td><td>::mlir::Attribute</td><td>arbitrary integer attribute or arbitrary float attribute</td></tr><tr><td><code>max_val</code></td><td>::mlir::Attribute</td><td>arbitrary integer attribute or arbitrary float attribute</td></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaclz-mlirtosaclzop><code>tosa.clz</code> (mlir::tosa::ClzOp)&nbsp;<a class=headline-hash href=#tosaclz-mlirtosaclzop>¶</a></h3><p><em>Elementwise count leading zero operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.clz` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise count leading zeros operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaconcat-mlirtosaconcatop><code>tosa.concat</code> (mlir::tosa::ConcatOp)&nbsp;<a class=headline-hash href=#tosaconcat-mlirtosaconcatop>¶</a></h3><p><em>Concatenates tensors along one dimension.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.concat` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Concatenate a list of tensors along a given axis.
No data conversion happens during a concat operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>variadic of tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosaconst-mlirtosaconstop><code>tosa.const</code> (mlir::tosa::ConstOp)&nbsp;<a class=headline-hash href=#tosaconst-mlirtosaconstop>¶</a></h3><p><em>Constant operator.</em></p><p>A node containing constant data for use as the input to an operation. May
hold data in any of the supported data formats.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Generic form
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%out</span> <span class=p>=</span> <span class=s>&#34;tosa.const&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>i32</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>2x3x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>values</code></td><td>::mlir::ElementsAttr</td><td>constant vector/tensor attribute</td></tr></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaconst_shape-mlirtosaconstshapeop><code>tosa.const_shape</code> (mlir::tosa::ConstShapeOp)&nbsp;<a class=headline-hash href=#tosaconst_shape-mlirtosaconstshapeop>¶</a></h3><p><em>Constant Shape operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.const_shape` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>A node containing a constant shape.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Generic form
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%out</span> <span class=p>=</span> <span class=s>&#34;tosa.const_shape&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;</span><span class=m>0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>index</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>tosa<span class=p>.</span>shape<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>TosaResolvableShapeOperands</code>, <code>TosaShapeOperator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>values</code></td><td>::mlir::DenseIntElementsAttr</td><td>index elements attribute</td></tr></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>Shape with static rank and Index element type</td></tr></tbody></table><h3 id=tosaconv2d-mlirtosaconv2dop><code>tosa.conv2d</code> (mlir::tosa::Conv2DOp)&nbsp;<a class=headline-hash href=#tosaconv2d-mlirtosaconv2dop>¶</a></h3><p><em>2D Convolution operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.conv2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs a 2D convolution over the given tensor input, using the weight
tensor. Implementations may choose to skip calculation of multiplies in
the padding area.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>SameVariadicOperandSize</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>dilation</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>acc_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 48-bit signless integer or 16-bit float or 32-bit float</td></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>weight</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>bias</code></td><td>1-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>weight_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosaconv3d-mlirtosaconv3dop><code>tosa.conv3d</code> (mlir::tosa::Conv3DOp)&nbsp;<a class=headline-hash href=#tosaconv3d-mlirtosaconv3dop>¶</a></h3><p><em>3D Convolution operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.conv3d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs a 3D convolution over the given input tensor. Implementations
may choose to skip calculation of multiplies in the padding area.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>SameVariadicOperandSize</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 6 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 3 elements</td></tr><tr><td><code>dilation</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 3 elements</td></tr><tr><td><code>acc_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 48-bit signless integer or 16-bit float or 32-bit float</td></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>5-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>weight</code></td><td>5-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>bias</code></td><td>1-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>weight_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>5-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosacos-mlirtosacosop><code>tosa.cos</code> (mlir::tosa::CosOp)&nbsp;<a class=headline-hash href=#tosacos-mlirtosacosop>¶</a></h3><p><em>Elementwise cos operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.cos` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise cosine operation for values given in radians.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of floating-point values</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of floating-point values</td></tr></tbody></table><h3 id=tosacustom-mlirtosacustomop><code>tosa.custom</code> (mlir::tosa::CustomOp)&nbsp;<a class=headline-hash href=#tosacustom-mlirtosacustomop>¶</a></h3><p><em>Custom operator wrapper for Tosa</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.custom` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Hardware implementing TOSA may choose to add additional custom operators
that are not expressed in the existing TOSA operations. These operators are
not expected to be portable across TOSA implementations. The input and
output signatures must be expressed in the corresponding TOSA node.</p><p><code>operator_name</code> is a string that tells the backend which custom operator is
being called.</p><p><code>domain_name</code> is a string identifier which can help avoid name collisions on
the identifier field.</p><p><code>implementation_attrs</code> is a string which is a backend and identifier specific
set of attributes to the custom operator.</p><p><code>input_list</code> is the set of tensor inputs to the custom operator.</p><p><code>output_list</code> is the list of tensors returned by the operator. The number of operators
is backend specific.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%out</span> <span class=p>=</span> tosa<span class=p>.</span>custom <span class=nv>%in</span> <span class=p>{</span><span class=nl>domain_name =</span> <span class=s>&#34;tosa_mlir_test&#34;</span><span class=p>,</span> <span class=nl>operator_name =</span>
</span></span><span class=line><span class=cl>       <span class=s>&#34;custom_test&#34;</span><span class=p>,</span> <span class=nl>implementation_attrs =</span> <span class=s>&#34;&#34;</span><span class=p>}:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>10x</span><span class=k>i32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>operator_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>domain_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>implementation_attrs</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosadepthwise_conv2d-mlirtosadepthwiseconv2dop><code>tosa.depthwise_conv2d</code> (mlir::tosa::DepthwiseConv2DOp)&nbsp;<a class=headline-hash href=#tosadepthwise_conv2d-mlirtosadepthwiseconv2dop>¶</a></h3><p><em>Depthwise 2D Convolution operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.depthwise_conv2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs 2D convolutions separately over each channel of the given tensor
input, using the weight tensor. Implementations may choose to skip
calculation of multiplies in the padding area.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>SameVariadicOperandSize</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>dilation</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>acc_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 48-bit signless integer or 16-bit float or 32-bit float</td></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>weight</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>bias</code></td><td>1-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>weight_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosaequal-mlirtosaequalop><code>tosa.equal</code> (mlir::tosa::EqualOp)&nbsp;<a class=headline-hash href=#tosaequal-mlirtosaequalop>¶</a></h3><p><em>Returns the truth value of (input1 == input2) element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.equal` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise comparison operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>InferTensorType</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsElementType</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaerf-mlirtosaerfop><code>tosa.erf</code> (mlir::tosa::ErfOp)&nbsp;<a class=headline-hash href=#tosaerf-mlirtosaerfop>¶</a></h3><p><em>Computes gauss error function of input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.erf` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Gauss error function: $ erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt $
For quantized integer data types, the TABLE operator should be used instead
with the following definition. The ERF table has 513 entries each of
16-bit precision and covering the input range -4.0 to +4.0 in steps of 1/64.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaexp-mlirtosaexpop><code>tosa.exp</code> (mlir::tosa::ExpOp)&nbsp;<a class=headline-hash href=#tosaexp-mlirtosaexpop>¶</a></h3><p><em>Elementwise exp operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.exp` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise e to the x operation</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosafft2d-mlirtosafft2dop><code>tosa.fft2d</code> (mlir::tosa::FFT2dOp)&nbsp;<a class=headline-hash href=#tosafft2d-mlirtosafft2dop>¶</a></h3><p><em>Performs FFT2D operation on the input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.fft2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs a batched complex 2D Fast Fourier Transform over the input. The
complex input values are constructed from the corresponding values in the
input_real and input_imag tensors. The resulting values in the output are
split into the output_real and output_imag tensors. No normalization is
applied on either the forward or inverse versions of the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%output_real</span><span class=p>,</span> <span class=nv>%output_imag</span> <span class=p>=</span> tosa<span class=p>.</span>fft2d <span class=nv>%input_real</span><span class=p>,</span> <span class=nv>%input_imag</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>ResultsAreFloatLike</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultShape</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>inverse</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_real</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_imag</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_real</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>output_imag</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosafloor-mlirtosafloorop><code>tosa.floor</code> (mlir::tosa::FloorOp)&nbsp;<a class=headline-hash href=#tosafloor-mlirtosafloorop>¶</a></h3><p><em>Elementwise floor operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.floor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise floor operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosagather-mlirtosagatherop><code>tosa.gather</code> (mlir::tosa::GatherOp)&nbsp;<a class=headline-hash href=#tosagather-mlirtosagatherop>¶</a></h3><p><em>Gather operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.gather` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Generate a tensor for which each element in the output is a subtensor of the
values tensor based on the indices. N is the number of batches, W the number
of indices in each batch, K the range of each index and C the number data
channels for each index.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>indices</code></td><td>tosa-conformant unranked tensor of number values or 2D tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosagreater_equal-mlirtosagreaterequalop><code>tosa.greater_equal</code> (mlir::tosa::GreaterEqualOp)&nbsp;<a class=headline-hash href=#tosagreater_equal-mlirtosagreaterequalop>¶</a></h3><p><em>Returns the truth value of (input1 >= input2) element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.greater_equal` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise comparison operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsElementType</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosagreater-mlirtosagreaterop><code>tosa.greater</code> (mlir::tosa::GreaterOp)&nbsp;<a class=headline-hash href=#tosagreater-mlirtosagreaterop>¶</a></h3><p><em>Returns the truth value of (input1 > input2) element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.greater` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise greater than comparison operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsElementType</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosaidentity-mlirtosaidentityop><code>tosa.identity</code> (mlir::tosa::IdentityOp)&nbsp;<a class=headline-hash href=#tosaidentity-mlirtosaidentityop>¶</a></h3><p><em>Identity operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.identity` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Returns a tensor with the same shape, type, and contents as the input.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosacond_if-mlirtosaifop><code>tosa.cond_if</code> (mlir::tosa::IfOp)&nbsp;<a class=headline-hash href=#tosacond_if-mlirtosaifop>¶</a></h3><p><em>Conditional if operator.</em></p><p>Evaluates a Boolean condition and then takes one of two distinct execution
paths. This implements the semantic If-then-else structure.</p><p>Traits: <code>InferShapedTypeOpAdaptor</code>, <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>InferShapedTypeOpInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaintdiv-mlirtosaintdivop><code>tosa.intdiv</code> (mlir::tosa::IntDivOp)&nbsp;<a class=headline-hash href=#tosaintdiv-mlirtosaintdivop>¶</a></h3><p><em>Integer divide operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.intdiv` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise integer divide of input1 by input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match. The result of the
divide is truncated towards zero. Expected use is for operations on
non-scaled integers. Floating point divide should use RECIPROCAL and MUL.
Quantized integer divide should use TABLE (for 1/x) and MUL.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=tosalog-mlirtosalogop><code>tosa.log</code> (mlir::tosa::LogOp)&nbsp;<a class=headline-hash href=#tosalog-mlirtosalogop>¶</a></h3><p><em>Elementwise log operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.log` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise natural logarithm operation</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosalogical_and-mlirtosalogicalandop><code>tosa.logical_and</code> (mlir::tosa::LogicalAndOp)&nbsp;<a class=headline-hash href=#tosalogical_and-mlirtosalogicalandop>¶</a></h3><p><em>Returns the truth value of input1 AND input2 element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_and` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical AND of input1 and input2. Axis of size 1 will be
broadcast, as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_left_shift-mlirtosalogicalleftshiftop><code>tosa.logical_left_shift</code> (mlir::tosa::LogicalLeftShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_left_shift-mlirtosalogicalleftshiftop>¶</a></h3><p><em>Elementwise Logical Left Shift.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_left_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical left-shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary.
Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosalogical_not-mlirtosalogicalnotop><code>tosa.logical_not</code> (mlir::tosa::LogicalNotOp)&nbsp;<a class=headline-hash href=#tosalogical_not-mlirtosalogicalnotop>¶</a></h3><p><em>Returns the truth value of NOT input1 element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_not` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical NOT of input.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_or-mlirtosalogicalorop><code>tosa.logical_or</code> (mlir::tosa::LogicalOrOp)&nbsp;<a class=headline-hash href=#tosalogical_or-mlirtosalogicalorop>¶</a></h3><p><em>Returns the truth value of x OR y element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_or` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical OR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosalogical_right_shift-mlirtosalogicalrightshiftop><code>tosa.logical_right_shift</code> (mlir::tosa::LogicalRightShiftOp)&nbsp;<a class=headline-hash href=#tosalogical_right_shift-mlirtosalogicalrightshiftop>¶</a></h3><p><em>Elementwise Logical Right Shift.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_right_shift` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical right shift of input1 by the amount specified in input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosalogical_xor-mlirtosalogicalxorop><code>tosa.logical_xor</code> (mlir::tosa::LogicalXorOp)&nbsp;<a class=headline-hash href=#tosalogical_xor-mlirtosalogicalxorop>¶</a></h3><p><em>Returns the truth value of input1 XOR input2 element-wise.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.logical_xor` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise logical XOR of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr></tbody></table><h3 id=tosamatmul-mlirtosamatmulop><code>tosa.matmul</code> (mlir::tosa::MatMulOp)&nbsp;<a class=headline-hash href=#tosamatmul-mlirtosamatmulop>¶</a></h3><p><em>Matrix multiplication operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.matmul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs two dimensional matrix multiplications.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>b</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>a_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>b_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosamatmul_t_block_scaled-mlirtosamatmultblockscaledop><code>tosa.matmul_t_block_scaled</code> (mlir::tosa::MatmulTBlockScaledOp)&nbsp;<a class=headline-hash href=#tosamatmul_t_block_scaled-mlirtosamatmultblockscaledop>¶</a></h3><p><em>Performs two dimensional matrix multiplications using block scaled tensors.</em></p><p>Performs two dimensional matrix multiplications using block scaled tensors. The block
dimension is always the the last dimension of the tensor, so the result is effectively
a matrix multiply of A by the transposed B matrix. If the N dimension of input B is of
size 1, the B matrix will be broadcast.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>block_size</code></td><td>mlir::tosa::BlockSizeAttr</td><td>Block size for the block_scaled formats</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a_data</code></td><td>tosa-conformant unranked tensor of micro-scaling format number values or 3D tensor of micro-scaling format number values</td></tr><tr><td style=text-align:center><code>a_scale</code></td><td>tosa-conformant unranked tensor of micro-scaling format scale number values or 3D tensor of micro-scaling format scale number values</td></tr><tr><td style=text-align:center><code>b_data</code></td><td>tosa-conformant unranked tensor of micro-scaling format number values or 3D tensor of micro-scaling format number values</td></tr><tr><td style=text-align:center><code>b_scale</code></td><td>tosa-conformant unranked tensor of micro-scaling format scale number values or 3D tensor of micro-scaling format scale number values</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_data</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosamax_pool2d-mlirtosamaxpool2dop><code>tosa.max_pool2d</code> (mlir::tosa::MaxPool2dOp)&nbsp;<a class=headline-hash href=#tosamax_pool2d-mlirtosamaxpool2dop>¶</a></h3><p><em>Performs max pooling on the input.</em></p><p>This performs a max pooling over the given input tensor. A sliding window of
size given by <kernel size>is passed over the input tensor, with the
maximum value being placed in the
output tensor.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kernel</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosamaximum-mlirtosamaximumop><code>tosa.maximum</code> (mlir::tosa::MaximumOp)&nbsp;<a class=headline-hash href=#tosamaximum-mlirtosamaximumop>¶</a></h3><p><em>Elementwise Maximum.</em></p><p>Elementwise max of input1 and input2. Axis of size 1 will be broadcast, as
necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaminimum-mlirtosaminimumop><code>tosa.minimum</code> (mlir::tosa::MinimumOp)&nbsp;<a class=headline-hash href=#tosaminimum-mlirtosaminimumop>¶</a></h3><p><em>Elementwise Minimum.</em></p><p>Elementwise minimum of input1 and input2. Axis of size 1
will be broadcast, as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosamul-mlirtosamulop><code>tosa.mul</code> (mlir::tosa::MulOp)&nbsp;<a class=headline-hash href=#tosamul-mlirtosamulop>¶</a></h3><p><em>Multiplication operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.mul` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise multiplication (Hadamard product) of input1 and input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>shift</code></td><td>tosa-conformant unranked tensor of 8-bit signless integer values or tosa-conformant scalar tensor of 8-bit signless integer values</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosanegate-mlirtosanegateop><code>tosa.negate</code> (mlir::tosa::NegateOp)&nbsp;<a class=headline-hash href=#tosanegate-mlirtosanegateop>¶</a></h3><p><em>Elementwise negate operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.negate` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise negation operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input1_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>output_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosapad-mlirtosapadop><code>tosa.pad</code> (mlir::tosa::PadOp)&nbsp;<a class=headline-hash href=#tosapad-mlirtosapadop>¶</a></h3><p><em>Pads a tensor with value specified.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.pad` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Pads a tensor along the borders of each dimension with a supplied value.
Returns a new tensor with the padding included. The pad_const value includes
the zero point if the tensor uses a zero point.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%pad_const</span> <span class=p>=</span> <span class=s>&#34;tosa.const&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;</span><span class=m>3.14</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%padding</span> <span class=p>=</span> tosa<span class=p>.</span>const_shape <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>index</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>tosa<span class=p>.</span>shape<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>tosa<span class=p>.</span>pad <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%padding</span><span class=p>,</span> <span class=nv>%pad_const</span><span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x2x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>tosa<span class=p>.</span>shape<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;)</span>  <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x9x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Example 2:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%pad_const</span> <span class=p>=</span> <span class=s>&#34;tosa.const&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;</span><span class=m>3.14</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%padding</span> <span class=p>=</span> tosa<span class=p>.</span>const_shape <span class=p>{</span><span class=nl>values =</span> dense<span class=p>&lt;[</span><span class=m>-1</span><span class=p>,</span> <span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>,</span> <span class=m>4</span><span class=p>]&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>index</span><span class=p>&gt;}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>tosa<span class=p>.</span>shape<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>tosa<span class=p>.</span>pad <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%padding</span><span class=p>,</span> <span class=nv>%pad_const</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x2x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=p>!</span>tosa<span class=p>.</span>shape<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>&gt;)</span>  <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>?x9x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of at least rank 1</td></tr><tr><td style=text-align:center><code>padding</code></td><td>Shape with static rank and Index element type</td></tr><tr><td style=text-align:center><code>pad_const</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of number values</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosapow-mlirtosapowop><code>tosa.pow</code> (mlir::tosa::PowOp)&nbsp;<a class=headline-hash href=#tosapow-mlirtosapowop>¶</a></h3><p><em>Computes the power of one value to another.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.pow` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise input1 value raised to the power of input2.
Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosarfft2d-mlirtosarfft2dop><code>tosa.rfft2d</code> (mlir::tosa::RFFT2dOp)&nbsp;<a class=headline-hash href=#tosarfft2d-mlirtosarfft2dop>¶</a></h3><p><em>Performs RFFT2D operation on the input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.rfft2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs a batched 2D real-valued Fast Fourier Transform over the input where
the input tensor consists of real values producing complex valued output. The
complex output values will be split into the output_real and output_imag
tensor arguments. RFFT2D takes advantage of Hermitian symmetry to only
calculate the first half of the final output axis. Implementations may choose
to skip calculation of the imaginary values at (0,0), (0,W/2), (H/2,0), and
(H/2, W/2). If the calculation is skipped, the result at that location must be
zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%ouput_real</span><span class=p>,</span> <span class=nv>%output_imag</span> <span class=p>=</span> tosa<span class=p>.</span>rfft2d <span class=nv>%input_real</span> <span class=p>:</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x16x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x9x</span><span class=k>f32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>ResultsAreFloatLike</code>, <code>SameOperandsAndResultElementType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_real</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_real</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>output_imag</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosareciprocal-mlirtosareciprocalop><code>tosa.reciprocal</code> (mlir::tosa::ReciprocalOp)&nbsp;<a class=headline-hash href=#tosareciprocal-mlirtosareciprocalop>¶</a></h3><p><em>Elementwise reciprocal operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reciprocal` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise reciprocal operation. For integer operation, a TABLE should be
used with the appropriate ranges.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosareduce_all-mlirtosareduceallop><code>tosa.reduce_all</code> (mlir::tosa::ReduceAllOp)&nbsp;<a class=headline-hash href=#tosareduce_all-mlirtosareduceallop>¶</a></h3><p><em>Reduce All operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reduce_all` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Reduce a tensor along the given axis with a logical AND operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosareduce_any-mlirtosareduceanyop><code>tosa.reduce_any</code> (mlir::tosa::ReduceAnyOp)&nbsp;<a class=headline-hash href=#tosareduce_any-mlirtosareduceanyop>¶</a></h3><p><em>Reduce Any operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reduce_any` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Reduce a tensor along the given axis with a logical OR operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosareduce_max-mlirtosareducemaxop><code>tosa.reduce_max</code> (mlir::tosa::ReduceMaxOp)&nbsp;<a class=headline-hash href=#tosareduce_max-mlirtosareducemaxop>¶</a></h3><p><em>Reduce Max operator.</em></p><p>Reduce a tensor along the given axis with a maximum operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosareduce_min-mlirtosareduceminop><code>tosa.reduce_min</code> (mlir::tosa::ReduceMinOp)&nbsp;<a class=headline-hash href=#tosareduce_min-mlirtosareduceminop>¶</a></h3><p><em>Reduce Min operator.</em></p><p>Reduce a tensor along the given axis with a minimum operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>nan_mode</code></td><td>mlir::tosa::NanPropagationModeAttr</td><td>Supported NaN propagation strategies</td></tr></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosareduce_product-mlirtosareduceproductop><code>tosa.reduce_product</code> (mlir::tosa::ReduceProductOp)&nbsp;<a class=headline-hash href=#tosareduce_product-mlirtosareduceproductop>¶</a></h3><p><em>Reduce Product operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reduce_product` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Reduce a tensor along the given axis by computing the product of the axis.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosareduce_sum-mlirtosareducesumop><code>tosa.reduce_sum</code> (mlir::tosa::ReduceSumOp)&nbsp;<a class=headline-hash href=#tosareduce_sum-mlirtosareducesumop>¶</a></h3><p><em>Reduce Sum operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reduce_sum` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Reduce a tensor along the given axis by computing the sum of the axis.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosarescale-mlirtosarescaleop><code>tosa.rescale</code> (mlir::tosa::RescaleOp)&nbsp;<a class=headline-hash href=#tosarescale-mlirtosarescaleop>¶</a></h3><p><em>Tosa rescale operator.</em></p><p>RESCALE is defined using an integer multiply, add, and shift.</p><p>Rescale supports two precisions of multiplier: 16-bit and 32-bit. The 32-bit multiplier
version supports two rounding modes to enable simpler lowering of existing frameworks
that use two stage rounding. All arithmetic is designed so that it does not overflow a
64-bit accumulator and that the result fits in 32 bits. In particular, a 48-bit value
cannot be scaled with the 32-bit multiplier because the accumulator would need to have
80 bits.</p><p>The shift and value range are limited to allow a variety of implementations. The limit
of 62 on shift allows the shift to be decomposed as two right shifts of 31.</p><p>Supported rescalings:</p><ul><li>This table is showing the supported conversions from the TOSA Specification.</li><li>The MLIR dialect here can be used to represent other conversions.</li></ul><table><thead><tr><th>Mode</th><th>Input</th><th>Output</th><th>Unsigned input</th><th>Unsigned output</th></tr></thead><tbody><tr><td>signed 16 to 16</td><td>int16</td><td>int16</td><td>false</td><td>false</td></tr><tr><td>signed 16 to 32</td><td>int16</td><td>int32</td><td>false</td><td>false</td></tr><tr><td>signed 16 to 8</td><td>int16</td><td>int8</td><td>false</td><td>false</td></tr><tr><td>signed 32 to 16</td><td>int32</td><td>int16</td><td>false</td><td>false</td></tr><tr><td>signed 32 to 32</td><td>int32</td><td>int32</td><td>false</td><td>false</td></tr><tr><td>signed 32 to 8</td><td>int32</td><td>int8</td><td>false</td><td>false</td></tr><tr><td>signed 8 to 16</td><td>int8</td><td>int16</td><td>false</td><td>false</td></tr><tr><td>signed 8 to 32</td><td>int8</td><td>int32</td><td>false</td><td>false</td></tr><tr><td>signed 8 to 8</td><td>int8</td><td>int8</td><td>false</td><td>false</td></tr><tr><td>signed 48 to 16</td><td>int48</td><td>int16</td><td>false</td><td>false</td></tr><tr><td>signed 48 to 32</td><td>int48</td><td>int32</td><td>false</td><td>false</td></tr><tr><td>signed 48 to 8</td><td>int48</td><td>int8</td><td>false</td><td>false</td></tr><tr><td>unsigned 8 to signed 8</td><td>uint8</td><td>int8</td><td>true</td><td>false</td></tr><tr><td>signed 8 to unsigned 8</td><td>int8</td><td>uint8</td><td>false</td><td>true</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scale32</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>rounding_mode</code></td><td>mlir::tosa::RoundingModeAttr</td><td>Supported rounding modes</td></tr><tr><td><code>per_channel</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>input_unsigned</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>output_unsigned</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>multiplier</code></td><td>1D tensor of 16-bit signless integer or 32-bit signless integer values</td></tr><tr><td style=text-align:center><code>shift</code></td><td>1D tensor of 8-bit signless integer values</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>output_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosareshape-mlirtosareshapeop><code>tosa.reshape</code> (mlir::tosa::ReshapeOp)&nbsp;<a class=headline-hash href=#tosareshape-mlirtosareshapeop>¶</a></h3><p><em>Reshape operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reshape` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Returns a tensor with the same type/values as the input, with a new shape
specified by the shape argument. Reshape may operate on tensors of any rank.
No data conversion happens during a reshape operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>InferTensorType</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>shape</code></td><td>Shape with static rank and Index element type</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosaresize-mlirtosaresizeop><code>tosa.resize</code> (mlir::tosa::ResizeOp)&nbsp;<a class=headline-hash href=#tosaresize-mlirtosaresizeop>¶</a></h3><p><em>Resize operation, supports various resize/upsample modes.</em></p><p>Resizes a tensor. Resize is only allowed in the H and W dimensions.</p><p>The height dimension is scaled by factor (scale_y_n/scale_y_d). The width
dimension is scaled by factor (scale_x_n/scale_x_d).</p><p>The NEAREST_NEIGHBOR mode returns the value of the input tensor closest to
the calculated sample position for both floating-point and integer data
formats.</p><p>Floating-point BILINEAR mode returns a bilinearly interpolated output value
based on the four closest input sample positions.</p><p>For integer BILINEAR interpolation mode, the output value must be scaled by
1/(scale_y_n * scale_x_n) in a following operation to complete the
interpolation (for example with a RESCALE operator).</p><p>The output dimensions can be derived from the input dimensions by inverting
the scale as described in the pseudocode. The [border_y, border_x] values
adjust the output size to allow fractional sampling beyond integer input
position (IH - 1,IW - 1).</p><p>The limit MAX_SCALE is applied to each scale ratio after reduction of the
ratio. Individual scale numerator and denominator values are allowed to be
larger than MAX_SCALE.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mode</code></td><td>mlir::tosa::ResizeModeAttr</td><td>Supported resize/upsampling strategies</td></tr></table><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>scale</code></td><td>Tosa shape type of rank 4</td></tr><tr><td style=text-align:center><code>offset</code></td><td>Tosa shape type of rank 2</td></tr><tr><td style=text-align:center><code>border</code></td><td>Tosa shape type of rank 2</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosareverse-mlirtosareverseop><code>tosa.reverse</code> (mlir::tosa::ReverseOp)&nbsp;<a class=headline-hash href=#tosareverse-mlirtosareverseop>¶</a></h3><p><em>Reverse operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.reverse` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Returns a tensor with the same type/values as the input, with the data
reversed along the given axis. No data conversion happens during a reverse
operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>axis</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosarsqrt-mlirtosarsqrtop><code>tosa.rsqrt</code> (mlir::tosa::RsqrtOp)&nbsp;<a class=headline-hash href=#tosarsqrt-mlirtosarsqrtop>¶</a></h3><p><em>Elementwise 1/sqrt operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.rsqrt` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise reciprocal square root operation. For integer operation, a TABLE
should be used with the appropriate ranges.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosascatter-mlirtosascatterop><code>tosa.scatter</code> (mlir::tosa::ScatterOp)&nbsp;<a class=headline-hash href=#tosascatter-mlirtosascatterop>¶</a></h3><p><em>Scatter operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.scatter` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>The values_out tensor is set to the values_in tensor with data modified as
follows: data from the input tensor is inserted at the positions specified
by the indices tensor. N is the number of batches, W the number of indices
in each batch, K the range of each index and C the number data channels for
each index. It is not permitted to repeat the same output index within a
single SCATTER operation and so each output index occurs at most once. It
follows that K >= W. In use cases that require multiple updates to the same
output position, these must be decomposed into multiple SCATTER operations.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values_in</code></td><td>3-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>indices</code></td><td>tosa-conformant unranked tensor of number values or 2D tensor of 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>input</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values_out</code></td><td>3-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosaselect-mlirtosaselectop><code>tosa.select</code> (mlir::tosa::SelectOp)&nbsp;<a class=headline-hash href=#tosaselect-mlirtosaselectop>¶</a></h3><p><em>Elementwise select operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.select` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise select of the output based on a condition.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input3</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosasigmoid-mlirtosasigmoidop><code>tosa.sigmoid</code> (mlir::tosa::SigmoidOp)&nbsp;<a class=headline-hash href=#tosasigmoid-mlirtosasigmoidop>¶</a></h3><p><em>Computes elementwise sigmoid of input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.sigmoid` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Applies the sigmoid logistic function to each element of the input tensor:
$ sigmoid(x) = \frac{1}{1 + e^{-x}} $.</p><p>For quantized integer data types, the TABLE operator should be used instead.
Each implementation may choose an appropriate TABLE given the scale and zero
point of the input data. Eight or sixteen bit precision tables may be used
based on the input tensor to the sigmoid function.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosasin-mlirtosasinop><code>tosa.sin</code> (mlir::tosa::SinOp)&nbsp;<a class=headline-hash href=#tosasin-mlirtosasinop>¶</a></h3><p><em>Elementwise sin operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.sin` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise sine operation for values given in radians.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of floating-point values</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of floating-point values</td></tr></tbody></table><h3 id=tosaslice-mlirtosasliceop><code>tosa.slice</code> (mlir::tosa::SliceOp)&nbsp;<a class=headline-hash href=#tosaslice-mlirtosasliceop>¶</a></h3><p><em>Slice operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.slice` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Extracts a slice of input1, beginning at the start coordinates,
and extending for size elements in each direction.
No data conversion happens during a slice operation.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of at least rank 1</td></tr><tr><td style=text-align:center><code>start</code></td><td>Shape with static rank and Index element type</td></tr><tr><td style=text-align:center><code>size</code></td><td>Shape with static rank and Index element type</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosasub-mlirtosasubop><code>tosa.sub</code> (mlir::tosa::SubOp)&nbsp;<a class=headline-hash href=#tosasub-mlirtosasubop>¶</a></h3><p><em>Elementwise subtraction operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.sub` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Elementwise subtraction of input1 and input2. Axis of size 1 will be
broadcast as necessary. Rank of input tensors must match.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>input2</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosatable-mlirtosatableop><code>tosa.table</code> (mlir::tosa::TableOp)&nbsp;<a class=headline-hash href=#tosatable-mlirtosatableop>¶</a></h3><p><em>Table lookup operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.table` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Table lookup operation. For int8_t TABLE operation, perform a 256 entry
table lookup returning an int8_t value. For int16_t tables, the int16_t
input is treated as a fixed-point 9.7 value. The most significant 9 bits
are used to index into the table. The fractional 7 bits are used to
interpolate based on table[index] and table[index+1]. For int16_t inputs,
the TABLE operator returns a 16.7 interpolated value in an int32_t. This
value can then be input to the RESCALE operator to scale to the required
output data type. Note that int16_t table has 513 values to handle
table[index+1] when index=511.</p><p>An int16_t to int16_t table lookup can be constructed in TOSA as follows:</p><ul><li>Use the TABLE operator to produce a fixed point 16.7 interpolated result</li><li>Use RESCALE (in_t=int32_t, out_t=int16_t, scale=1&#171;14, shift=21) to
scale the output to int16_t range (or alternate scale as required)</li></ul><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr><tr><td style=text-align:center><code>table</code></td><td>1-d tosa-conformant tensor</td></tr></tbody></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosatanh-mlirtosatanhop><code>tosa.tanh</code> (mlir::tosa::TanhOp)&nbsp;<a class=headline-hash href=#tosatanh-mlirtosatanhop>¶</a></h3><p><em>Computes elementwise hyperbolic tangent of input.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.tanh` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Parameterized hyperbolic tangent: $ tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}} $.</p><p>For quantized integer data types, the TABLE operator should be used instead.
Each implementation may choose an appropriate TABLE given the scale and zero
point of the input data. Eight or sixteen bit precision tables may be used
based on the input tensor to the tanh function.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ResultsBroadcastableShape</code>, <code>SameOperandsAndResultElementType</code>, <code>SameOperandsAndResultRank</code>, <code>SameOperandsAndResultShape</code>, <code>TosaElementwiseOperator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-69>Operands:&nbsp;<a class=headline-hash href=#operands-69>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosatile-mlirtosatileop><code>tosa.tile</code> (mlir::tosa::TileOp)&nbsp;<a class=headline-hash href=#tosatile-mlirtosatileop>¶</a></h3><p><em>Tile operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.tile` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Replicates input1 multiples times along each dimension.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-70>Operands:&nbsp;<a class=headline-hash href=#operands-70>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of at least rank 1</td></tr><tr><td style=text-align:center><code>multiples</code></td><td>Shape with static rank and Index element type</td></tr></tbody></table><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosatranspose_conv2d-mlirtosatransposeconv2dop><code>tosa.transpose_conv2d</code> (mlir::tosa::TransposeConv2DOp)&nbsp;<a class=headline-hash href=#tosatranspose_conv2d-mlirtosatransposeconv2dop>¶</a></h3><p><em>Transpose 2D Convolution operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.transpose_conv2d` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Performs a 2D transposed convolution over the given tensor input, using the
weights tensor. Implementations may choose to skip calculation of multiplies
by zero at fractional input positions.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>SameVariadicOperandSize</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>out_pad</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 4 elements</td></tr><tr><td><code>stride</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute with exactly 2 elements</td></tr><tr><td><code>acc_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of 32-bit signless integer or 48-bit signless integer or 16-bit float or 32-bit float</td></tr><tr><td><code>local_bound</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-71>Operands:&nbsp;<a class=headline-hash href=#operands-71>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>weight</code></td><td>4-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>bias</code></td><td>1-d tosa-conformant tensor</td></tr><tr><td style=text-align:center><code>input_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr><tr><td style=text-align:center><code>weight_zp</code></td><td>tosa-conformant unranked tensor of unsigned integer or signless integer or floating-point values or tosa-conformant scalar tensor of unsigned integer or signless integer or floating-point values</td></tr></tbody></table><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>4-d tosa-conformant tensor</td></tr></tbody></table><h3 id=tosatranspose-mlirtosatransposeop><code>tosa.transpose</code> (mlir::tosa::TransposeOp)&nbsp;<a class=headline-hash href=#tosatranspose-mlirtosatransposeop>¶</a></h3><p><em>Transpose operator.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.transpose` operands attr-dict `:` functional-type(operands, results)
</code></pre><p>Permutes the dimensions of the input tensor input1 based on the perms
argument. Each value in the perms list must be a valid dimension of the
input tensor and may not be repeated.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>InferShapedTypeOpAdaptor</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferShapedTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>ReifyRankedShapedTypeOpInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>perms</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-72>Operands:&nbsp;<a class=headline-hash href=#operands-72>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>tosa-conformant tensor of at least rank 1</td></tr></tbody></table><h3 id=tosavariable-mlirtosavariableop><code>tosa.variable</code> (mlir::tosa::VariableOp)&nbsp;<a class=headline-hash href=#tosavariable-mlirtosavariableop>¶</a></h3><p><em>Defines a variable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.variable` $sym_name
              attr-dict
              custom&lt;VariableOpTypeOrInitialValue&gt;($var_shape, $type, $initial_value)
</code></pre><p>Defines a new TOSA variable. This is a persistent mutable value across multiple
TOSA graph invocations. Modifications are expressed using read/write semantics.</p><p>Traits: <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>Symbol</code>, <code>TosaOpInterface</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>var_shape</code></td><td>::mlir::DenseIntElementsAttr</td><td>index elements attribute</td></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>initial_value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h3 id=tosavariable_read-mlirtosavariablereadop><code>tosa.variable_read</code> (mlir::tosa::VariableReadOp)&nbsp;<a class=headline-hash href=#tosavariable_read-mlirtosavariablereadop>¶</a></h3><p><em>Read_buffer operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.variable_read` $name attr-dict `:` type($output1)
</code></pre><p>Reads the value from a pseudo-buffer resource holding a persistent mutable tensor.</p><p>Traits: <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosavariable_write-mlirtosavariablewriteop><code>tosa.variable_write</code> (mlir::tosa::VariableWriteOp)&nbsp;<a class=headline-hash href=#tosavariable_write-mlirtosavariablewriteop>¶</a></h3><p><em>Write_buffer operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.variable_write` $name attr-dict `,` $input1 `:` type($input1)
</code></pre><p>Assigns a value to the pseudo-buffer resource holding a persistent mutable tensor.</p><p>Traits: <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-73>Operands:&nbsp;<a class=headline-hash href=#operands-73>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input1</code></td><td>tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosawhile_loop-mlirtosawhileop><code>tosa.while_loop</code> (mlir::tosa::WhileOp)&nbsp;<a class=headline-hash href=#tosawhile_loop-mlirtosawhileop>¶</a></h3><p><em>Output = input; While (Cond(output)) {output = Body(output)}</em></p><p>Generates and evaluates a Boolean condition and either executes a loop body
or exits the loop. This action is performed repeatedly after
updating and re-evaluating the Boolean condition every iteration. This
implements the semantic foreach or while iterative loop structure.</p><p>Traits: <code>InferShapedTypeOpAdaptor</code>, <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;YieldOp></code>, <code>SingleBlock</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>InferShapedTypeOpInterface</code>, <code>LoopLikeOpInterface</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><h4 id=operands-74>Operands:&nbsp;<a class=headline-hash href=#operands-74>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output_list</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><h3 id=tosayield-mlirtosayieldop><code>tosa.yield</code> (mlir::tosa::YieldOp)&nbsp;<a class=headline-hash href=#tosayield-mlirtosayieldop>¶</a></h3><p><em>Yield operator</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `tosa.yield` $inputs attr-dict `:` type($inputs)
</code></pre><p>return operation within the conditional and body of
structured control flow. Operation takes variadic operands
but produces no results of its own.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code>, <code>TosaResolvableShapeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>QueryExtensionInterface</code>, <code>QueryProfileInterface</code>, <code>TosaOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-75>Operands:&nbsp;<a class=headline-hash href=#operands-75>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of tosa-conformant tensor of number values</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/SPIR-V/ title="SPIR-V Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - SPIR-V Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Transform/ title="Transform Dialect">Next - Transform Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>