<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'smt' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/SMT/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'smt' Dialect</h1><p><em>A dialect that models satisfiability modulo theories</em></p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#smtand-mlirsmtandop><code>smt.and</code> (mlir::smt::AndOp)</a></li><li><a href=#smtapply_func-mlirsmtapplyfuncop><code>smt.apply_func</code> (mlir::smt::ApplyFuncOp)</a></li><li><a href=#smtarraybroadcast-mlirsmtarraybroadcastop><code>smt.array.broadcast</code> (mlir::smt::ArrayBroadcastOp)</a></li><li><a href=#smtarrayselect-mlirsmtarrayselectop><code>smt.array.select</code> (mlir::smt::ArraySelectOp)</a></li><li><a href=#smtarraystore-mlirsmtarraystoreop><code>smt.array.store</code> (mlir::smt::ArrayStoreOp)</a></li><li><a href=#smtassert-mlirsmtassertop><code>smt.assert</code> (mlir::smt::AssertOp)</a></li><li><a href=#smtbvadd-mlirsmtbvaddop><code>smt.bv.add</code> (mlir::smt::BVAddOp)</a></li><li><a href=#smtbvand-mlirsmtbvandop><code>smt.bv.and</code> (mlir::smt::BVAndOp)</a></li><li><a href=#smtbvashr-mlirsmtbvashrop><code>smt.bv.ashr</code> (mlir::smt::BVAShrOp)</a></li><li><a href=#smtbvcmp-mlirsmtbvcmpop><code>smt.bv.cmp</code> (mlir::smt::BVCmpOp)</a></li><li><a href=#smtbvconcat-mlirsmtconcatop><code>smt.bv.concat</code> (mlir::smt::ConcatOp)</a></li><li><a href=#smtbvconstant-mlirsmtbvconstantop><code>smt.bv.constant</code> (mlir::smt::BVConstantOp)</a></li><li><a href=#smtbvextract-mlirsmtextractop><code>smt.bv.extract</code> (mlir::smt::ExtractOp)</a></li><li><a href=#smtbvlshr-mlirsmtbvlshrop><code>smt.bv.lshr</code> (mlir::smt::BVLShrOp)</a></li><li><a href=#smtbvmul-mlirsmtbvmulop><code>smt.bv.mul</code> (mlir::smt::BVMulOp)</a></li><li><a href=#smtbvneg-mlirsmtbvnegop><code>smt.bv.neg</code> (mlir::smt::BVNegOp)</a></li><li><a href=#smtbvnot-mlirsmtbvnotop><code>smt.bv.not</code> (mlir::smt::BVNotOp)</a></li><li><a href=#smtbvor-mlirsmtbvorop><code>smt.bv.or</code> (mlir::smt::BVOrOp)</a></li><li><a href=#smtbvrepeat-mlirsmtrepeatop><code>smt.bv.repeat</code> (mlir::smt::RepeatOp)</a></li><li><a href=#smtbvsdiv-mlirsmtbvsdivop><code>smt.bv.sdiv</code> (mlir::smt::BVSDivOp)</a></li><li><a href=#smtbvshl-mlirsmtbvshlop><code>smt.bv.shl</code> (mlir::smt::BVShlOp)</a></li><li><a href=#smtbvsmod-mlirsmtbvsmodop><code>smt.bv.smod</code> (mlir::smt::BVSModOp)</a></li><li><a href=#smtbvsrem-mlirsmtbvsremop><code>smt.bv.srem</code> (mlir::smt::BVSRemOp)</a></li><li><a href=#smtbvudiv-mlirsmtbvudivop><code>smt.bv.udiv</code> (mlir::smt::BVUDivOp)</a></li><li><a href=#smtbvurem-mlirsmtbvuremop><code>smt.bv.urem</code> (mlir::smt::BVURemOp)</a></li><li><a href=#smtbvxor-mlirsmtbvxorop><code>smt.bv.xor</code> (mlir::smt::BVXOrOp)</a></li><li><a href=#smtbv2int-mlirsmtbv2intop><code>smt.bv2int</code> (mlir::smt::BV2IntOp)</a></li><li><a href=#smtcheck-mlirsmtcheckop><code>smt.check</code> (mlir::smt::CheckOp)</a></li><li><a href=#smtconstant-mlirsmtboolconstantop><code>smt.constant</code> (mlir::smt::BoolConstantOp)</a></li><li><a href=#smtdeclare_fun-mlirsmtdeclarefunop><code>smt.declare_fun</code> (mlir::smt::DeclareFunOp)</a></li><li><a href=#smtdistinct-mlirsmtdistinctop><code>smt.distinct</code> (mlir::smt::DistinctOp)</a></li><li><a href=#smteq-mlirsmteqop><code>smt.eq</code> (mlir::smt::EqOp)</a></li><li><a href=#smtexists-mlirsmtexistsop><code>smt.exists</code> (mlir::smt::ExistsOp)</a></li><li><a href=#smtforall-mlirsmtforallop><code>smt.forall</code> (mlir::smt::ForallOp)</a></li><li><a href=#smtimplies-mlirsmtimpliesop><code>smt.implies</code> (mlir::smt::ImpliesOp)</a></li><li><a href=#smtintabs-mlirsmtintabsop><code>smt.int.abs</code> (mlir::smt::IntAbsOp)</a></li><li><a href=#smtintadd-mlirsmtintaddop><code>smt.int.add</code> (mlir::smt::IntAddOp)</a></li><li><a href=#smtintcmp-mlirsmtintcmpop><code>smt.int.cmp</code> (mlir::smt::IntCmpOp)</a></li><li><a href=#smtintconstant-mlirsmtintconstantop><code>smt.int.constant</code> (mlir::smt::IntConstantOp)</a></li><li><a href=#smtintdiv-mlirsmtintdivop><code>smt.int.div</code> (mlir::smt::IntDivOp)</a></li><li><a href=#smtintmod-mlirsmtintmodop><code>smt.int.mod</code> (mlir::smt::IntModOp)</a></li><li><a href=#smtintmul-mlirsmtintmulop><code>smt.int.mul</code> (mlir::smt::IntMulOp)</a></li><li><a href=#smtintsub-mlirsmtintsubop><code>smt.int.sub</code> (mlir::smt::IntSubOp)</a></li><li><a href=#smtint2bv-mlirsmtint2bvop><code>smt.int2bv</code> (mlir::smt::Int2BVOp)</a></li><li><a href=#smtite-mlirsmtiteop><code>smt.ite</code> (mlir::smt::IteOp)</a></li><li><a href=#smtnot-mlirsmtnotop><code>smt.not</code> (mlir::smt::NotOp)</a></li><li><a href=#smtor-mlirsmtorop><code>smt.or</code> (mlir::smt::OrOp)</a></li><li><a href=#smtpop-mlirsmtpopop><code>smt.pop</code> (mlir::smt::PopOp)</a></li><li><a href=#smtpush-mlirsmtpushop><code>smt.push</code> (mlir::smt::PushOp)</a></li><li><a href=#smtreset-mlirsmtresetop><code>smt.reset</code> (mlir::smt::ResetOp)</a></li><li><a href=#smtset_logic-mlirsmtsetlogicop><code>smt.set_logic</code> (mlir::smt::SetLogicOp)</a></li><li><a href=#smtsolver-mlirsmtsolverop><code>smt.solver</code> (mlir::smt::SolverOp)</a></li><li><a href=#smtxor-mlirsmtxorop><code>smt.xor</code> (mlir::smt::XOrOp)</a></li><li><a href=#smtyield-mlirsmtyieldop><code>smt.yield</code> (mlir::smt::YieldOp)</a></li></ul></li><li><a href=#attributes-13>Attributes</a><ul><li><a href=#bitvectorattr>BitVectorAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#arraytype>ArrayType</a></li><li><a href=#bitvectortype>BitVectorType</a></li><li><a href=#booltype>BoolType</a></li><li><a href=#inttype>IntType</a></li><li><a href=#smtfunctype>SMTFuncType</a></li><li><a href=#sorttype>SortType</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#bvcmppredicate>BVCmpPredicate</a></li><li><a href=#intpredicate>IntPredicate</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/SMT/IR/SMT.td>source</a></p><h3 id=smtand-mlirsmtandop><code>smt.and</code> (mlir::smt::AndOp)&nbsp;<a class=headline-hash href=#smtand-mlirsmtandop>¶</a></h3><p><em>A boolean conjunction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.and` $inputs attr-dict
</code></pre><p>This operation performs a boolean conjunction.
The semantics are equivalent to the &lsquo;and&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.7.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtapply_func-mlirsmtapplyfuncop><code>smt.apply_func</code> (mlir::smt::ApplyFuncOp)&nbsp;<a class=headline-hash href=#smtapply_func-mlirsmtapplyfuncop>¶</a></h3><p><em>Apply a function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.apply_func` $func `(` $args `)` attr-dict `:` qualified(type($func))
</code></pre><p>This operation performs a function application as described in the
<a href=https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf>SMT-LIB 2.7 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>func</code></td><td></td></tr><tr><td style=text-align:center><code>args</code></td><td>variadic of any non-function SMT value type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any non-function SMT value type</td></tr></tbody></table><h3 id=smtarraybroadcast-mlirsmtarraybroadcastop><code>smt.array.broadcast</code> (mlir::smt::ArrayBroadcastOp)&nbsp;<a class=headline-hash href=#smtarraybroadcast-mlirsmtarraybroadcastop>¶</a></h3><p><em>Construct an array with the given value stored at every index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.broadcast` $value attr-dict `:` qualified(type($result))
</code></pre><p>This operation represents a broadcast of the &lsquo;value&rsquo; operand to all indices
of the array. It is equivalent to</p><pre tabindex=0><code>%0 = smt.declare_fun &#34;array&#34; : !smt.array&lt;[!smt.int -&gt; !smt.bool]&gt;
%1 = smt.forall [&#34;idx&#34;] {
^bb0(%idx: !smt.int):
  %2 = smt.array.select %0[%idx] : !smt.array&lt;[!smt.int -&gt; !smt.bool]&gt;
  %3 = smt.eq %value, %2 : !smt.bool
  smt.yield %3 : !smt.bool
}
smt.assert %1
// return %0
</code></pre><p>In SMT-LIB, this is frequently written as
<code>((as const (Array Int Bool)) value)</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtarrayselect-mlirsmtarrayselectop><code>smt.array.select</code> (mlir::smt::ArraySelectOp)&nbsp;<a class=headline-hash href=#smtarrayselect-mlirsmtarrayselectop>¶</a></h3><p><em>Get the value stored in the array at the given index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.select` $array `[` $index `]` attr-dict `:` qualified(type($array))
</code></pre><p>This operation is retuns the value stored in the given array at the given
index. The semantics are equivalent to the <code>select</code> operator defined in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.7.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>array</code></td><td></td></tr><tr><td style=text-align:center><code>index</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtarraystore-mlirsmtarraystoreop><code>smt.array.store</code> (mlir::smt::ArrayStoreOp)&nbsp;<a class=headline-hash href=#smtarraystore-mlirsmtarraystoreop>¶</a></h3><p><em>Stores a value at a given index and returns the new array</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.array.store` $array `[` $index `]` `,` $value attr-dict `:` qualified(type($array))
</code></pre><p>This operation returns a new array which is the same as the &lsquo;array&rsquo; operand
except that the value at the given &lsquo;index&rsquo; is changed to the given &lsquo;value&rsquo;.
The semantics are equivalent to the &lsquo;store&rsquo; operator described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.7.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>array</code></td><td></td></tr><tr><td style=text-align:center><code>index</code></td><td>any SMT value type</td></tr><tr><td style=text-align:center><code>value</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtassert-mlirsmtassertop><code>smt.assert</code> (mlir::smt::AssertOp)&nbsp;<a class=headline-hash href=#smtassert-mlirsmtassertop>¶</a></h3><p><em>Assert that a boolean expression holds</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.assert` $input attr-dict
</code></pre><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h3 id=smtbvadd-mlirsmtbvaddop><code>smt.bv.add</code> (mlir::smt::BVAddOp)&nbsp;<a class=headline-hash href=#smtbvadd-mlirsmtbvaddop>¶</a></h3><p><em>Equivalent to bvadd in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.add` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs addition. The semantics are
equivalent to the <code>bvadd</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvand-mlirsmtbvandop><code>smt.bv.and</code> (mlir::smt::BVAndOp)&nbsp;<a class=headline-hash href=#smtbvand-mlirsmtbvandop>¶</a></h3><p><em>Equivalent to bvand in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.and` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise AND. The semantics are
equivalent to the <code>bvand</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvashr-mlirsmtbvashrop><code>smt.bv.ashr</code> (mlir::smt::BVAShrOp)&nbsp;<a class=headline-hash href=#smtbvashr-mlirsmtbvashrop>¶</a></h3><p><em>Equivalent to bvashr in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.ashr` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs arithmetic shift right. The semantics are
equivalent to the <code>bvashr</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvcmp-mlirsmtbvcmpop><code>smt.bv.cmp</code> (mlir::smt::BVCmpOp)&nbsp;<a class=headline-hash href=#smtbvcmp-mlirsmtbvcmpop>¶</a></h3><p><em>Compare bit-vectors interpreted as signed or unsigned</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.cmp` $pred $lhs `,` $rhs attr-dict `:` qualified(type($lhs))
</code></pre><p>This operation compares bit-vector values, interpreting them as signed or
unsigned values depending on the predicate. The semantics are equivalent to
the <code>bvslt</code>, <code>bvsle</code>, <code>bvsgt</code>, <code>bvsge</code>, <code>bvult</code>, <code>bvule</code>, <code>bvugt</code>, or
<code>bvuge</code> operator defined in the SMT-LIB 2.7 standard depending on the
specified predicate. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>mlir::smt::BVCmpPredicateAttr</td><td>smt bit-vector comparison predicate</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvconcat-mlirsmtconcatop><code>smt.bv.concat</code> (mlir::smt::ConcatOp)&nbsp;<a class=headline-hash href=#smtbvconcat-mlirsmtconcatop>¶</a></h3><p><em>Bit-vector concatenation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.concat` $lhs `,` $rhs attr-dict `:` qualified(type(operands))
</code></pre><p>This operation concatenates bit-vector values with semantics equivalent to
the <code>concat</code> operator defined in the SMT-LIB 2.7 standard. More precisely in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Note that the following equivalences hold:</p><ul><li><code>smt.bv.concat %a, %b : !smt.bv&lt;4>, !smt.bv&lt;4></code> is equivalent to
<code>(concat a b)</code> in SMT-LIB</li><li><code>(= (concat #xf #x0) #xf0)</code></li></ul><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvconstant-mlirsmtbvconstantop><code>smt.bv.constant</code> (mlir::smt::BVConstantOp)&nbsp;<a class=headline-hash href=#smtbvconstant-mlirsmtbvconstantop>¶</a></h3><p><em>Produce a constant bit-vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.constant` qualified($value) attr-dict
</code></pre><p>This operation produces an SSA value equal to the bit-vector constant
specified by the &lsquo;value&rsquo; attribute.
Refer to the <code>BitVectorAttr</code> documentation for more information about
the semantics of bit-vector constants, their format, and associated sort.
The result type always matches the attribute&rsquo;s type.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%c92_bv8</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>92</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%c5_bv4</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span><span class=kt>constant</span> <span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>5</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code>, <code>FirstAttrDerivedResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>mlir::smt::BitVectorAttr</td><td><details><summary></summary><pre><code>This attribute represents a constant value of the `(_ BitVec width)` sort as
described in the [SMT bit-vector
theory](https://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml).
<p>The constant is as #bX (binary) or #xX (hexadecimal) in SMT-LIB
where X is the value in the corresponding format without any further
prefixing. Here, the bit-vector constant is given as a regular non-negative
integer literal and the associated bit-vector type indicating the bit-width.</p>
<p>Examples:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#smt.bv</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=m>5</span><span class=err>&amp;</span>gt<span class=err>;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=err>&amp;</span>lt<span class=err>;</span><span class=m>4</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span><span class=line><span class=cl><span class=nv>#smt.bv</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=m>92</span><span class=err>&amp;</span>gt<span class=err>;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=err>&amp;</span>lt<span class=err>;</span><span class=m>8</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span></code></pre></div><p>The explicit type-suffix is mandatory to uniquely represent the attribute,
i.e., this attribute should always be used in the extended form (using the
<code>quantified</code> keyword in the operation assembly format string).</p><p>The bit-width must be greater than zero (i.e., at least one digit has to be
present).</code></pre></p></details></td></tr></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvextract-mlirsmtextractop><code>smt.bv.extract</code> (mlir::smt::ExtractOp)&nbsp;<a class=headline-hash href=#smtbvextract-mlirsmtextractop>¶</a></h3><p><em>Bit-vector extraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.extract` $input `from` $lowBit attr-dict `:` functional-type($input, $result)
</code></pre><p>This operation extracts the range of bits starting at the &rsquo;lowBit&rsquo; index
(inclusive) up to the &rsquo;lowBit&rsquo; + result-width index (exclusive). The
semantics are equivalent to the <code>extract</code> operator defined in the SMT-LIB
2.7 standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Note that <code>smt.bv.extract %bv from 2 : (!smt.bv&lt;32>) -> !smt.bv&lt;16></code> is
equivalent to <code>((_ extract 17 2) bv)</code>, i.e., the SMT-LIB operator takes the
low and high indices where both are inclusive. The following equivalence
holds: <code>(= ((_ extract 3 0) #x0f) #xf)</code></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lowBit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvlshr-mlirsmtbvlshrop><code>smt.bv.lshr</code> (mlir::smt::BVLShrOp)&nbsp;<a class=headline-hash href=#smtbvlshr-mlirsmtbvlshrop>¶</a></h3><p><em>Equivalent to bvlshr in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.lshr` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs logical shift right. The semantics are
equivalent to the <code>bvlshr</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvmul-mlirsmtbvmulop><code>smt.bv.mul</code> (mlir::smt::BVMulOp)&nbsp;<a class=headline-hash href=#smtbvmul-mlirsmtbvmulop>¶</a></h3><p><em>Equivalent to bvmul in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.mul` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs multiplication. The semantics are
equivalent to the <code>bvmul</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvneg-mlirsmtbvnegop><code>smt.bv.neg</code> (mlir::smt::BVNegOp)&nbsp;<a class=headline-hash href=#smtbvneg-mlirsmtbvnegop>¶</a></h3><p><em>Equivalent to bvneg in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.neg` $input attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement unary minus. The semantics are
equivalent to the <code>bvneg</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvnot-mlirsmtbvnotop><code>smt.bv.not</code> (mlir::smt::BVNotOp)&nbsp;<a class=headline-hash href=#smtbvnot-mlirsmtbvnotop>¶</a></h3><p><em>Equivalent to bvnot in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.not` $input attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise negation. The semantics are
equivalent to the <code>bvnot</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvor-mlirsmtbvorop><code>smt.bv.or</code> (mlir::smt::BVOrOp)&nbsp;<a class=headline-hash href=#smtbvor-mlirsmtbvorop>¶</a></h3><p><em>Equivalent to bvor in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.or` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise OR. The semantics are
equivalent to the <code>bvor</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvrepeat-mlirsmtrepeatop><code>smt.bv.repeat</code> (mlir::smt::RepeatOp)&nbsp;<a class=headline-hash href=#smtbvrepeat-mlirsmtrepeatop>¶</a></h3><p><em>Repeated bit-vector concatenation of one value</em></p><p>This operation is a shorthand for repeated concatenation of the same
bit-vector value, i.e.,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>5</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// is the same as
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>4</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>concat <span class=nv>%a</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// or also 
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>bv<span class=p>.</span>repeat <span class=m>4</span> times <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>smt<span class=p>.</span>bv<span class=p>.</span>concat <span class=nv>%0</span><span class=p>,</span> <span class=nv>%a</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>16</span><span class=p>&gt;,</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>The semantics are equivalent to the <code>repeat</code> operator defined in the SMT-LIB
2.7 standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsdiv-mlirsmtbvsdivop><code>smt.bv.sdiv</code> (mlir::smt::BVSDivOp)&nbsp;<a class=headline-hash href=#smtbvsdiv-mlirsmtbvsdivop>¶</a></h3><p><em>Equivalent to bvsdiv in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.sdiv` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed division. The semantics are
equivalent to the <code>bvsdiv</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvshl-mlirsmtbvshlop><code>smt.bv.shl</code> (mlir::smt::BVShlOp)&nbsp;<a class=headline-hash href=#smtbvshl-mlirsmtbvshlop>¶</a></h3><p><em>Equivalent to bvshl in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.shl` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs shift left. The semantics are
equivalent to the <code>bvshl</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsmod-mlirsmtbvsmodop><code>smt.bv.smod</code> (mlir::smt::BVSModOp)&nbsp;<a class=headline-hash href=#smtbvsmod-mlirsmtbvsmodop>¶</a></h3><p><em>Equivalent to bvsmod in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.smod` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed remainder (sign follows divisor). The semantics are
equivalent to the <code>bvsmod</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvsrem-mlirsmtbvsremop><code>smt.bv.srem</code> (mlir::smt::BVSRemOp)&nbsp;<a class=headline-hash href=#smtbvsrem-mlirsmtbvsremop>¶</a></h3><p><em>Equivalent to bvsrem in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.srem` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs two&rsquo;s complement signed remainder (sign follows dividend). The semantics are
equivalent to the <code>bvsrem</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvudiv-mlirsmtbvudivop><code>smt.bv.udiv</code> (mlir::smt::BVUDivOp)&nbsp;<a class=headline-hash href=#smtbvudiv-mlirsmtbvudivop>¶</a></h3><p><em>Equivalent to bvudiv in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.udiv` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs unsigned division (rounded towards zero). The semantics are
equivalent to the <code>bvudiv</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvurem-mlirsmtbvuremop><code>smt.bv.urem</code> (mlir::smt::BVURemOp)&nbsp;<a class=headline-hash href=#smtbvurem-mlirsmtbvuremop>¶</a></h3><p><em>Equivalent to bvurem in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.urem` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs unsigned remainder. The semantics are
equivalent to the <code>bvurem</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbvxor-mlirsmtbvxorop><code>smt.bv.xor</code> (mlir::smt::BVXOrOp)&nbsp;<a class=headline-hash href=#smtbvxor-mlirsmtbvxorop>¶</a></h3><p><em>Equivalent to bvxor in SMT-LIB</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv.xor` $lhs `,` $rhs attr-dict `:` qualified(type($result))
</code></pre><p>This operation performs bitwise exclusive OR. The semantics are
equivalent to the <code>bvxor</code> operator defined in the SMT-LIB 2.7
standard. More precisely in the
<a href=https://smtlib.cs.uiowa.edu/Theories/FixedSizeBitVectors.smt2>theory of FixedSizeBitVectors</a>
and the
<a href=https://smtlib.cs.uiowa.edu/Logics/QF_BV.smt2>QF_BV logic</a>
describing closed quantifier-free formulas over the theory of fixed-size
bit-vectors.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtbv2int-mlirsmtbv2intop><code>smt.bv2int</code> (mlir::smt::BV2IntOp)&nbsp;<a class=headline-hash href=#smtbv2int-mlirsmtbv2intop>¶</a></h3><p><em>Convert an SMT bit-vector to an SMT integer.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.bv2int` $input (`signed` $is_signed^)? attr-dict `:`
              qualified(type($input))
</code></pre><p>Create an integer from the bit-vector argument <code>input</code>. If <code>is_signed</code> is
present, the bit-vector is treated as two&rsquo;s complement signed. Otherwise,
it is treated as an unsigned integer in the range [0..2^N-1], where N is
the number of bits in <code>input</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>is_signed</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtcheck-mlirsmtcheckop><code>smt.check</code> (mlir::smt::CheckOp)&nbsp;<a class=headline-hash href=#smtcheck-mlirsmtcheckop>¶</a></h3><p><em>Check if the current set of assertions is satisfiable</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.check` attr-dict `sat` $satRegion `unknown` $unknownRegion `unsat` $unsatRegion
              (`-&gt;` qualified(type($results))^ )?
</code></pre><p>This operation checks if all the assertions in the solver defined by the
nearest ancestor operation of type <code>smt.solver</code> are consistent. The outcome
an be &lsquo;satisfiable&rsquo;, &lsquo;unknown&rsquo;, or &lsquo;unsatisfiable&rsquo; and the corresponding
region will be executed. It is the corresponding construct to the
<code>check-sat</code> in SMT-LIB.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> smt<span class=p>.</span>check sat <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c1_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c1_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> unknown <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c0_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> unsat <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span></code></pre></div><p>Traits: <code>NoRegionArguments</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=smtconstant-mlirsmtboolconstantop><code>smt.constant</code> (mlir::smt::BoolConstantOp)&nbsp;<a class=headline-hash href=#smtconstant-mlirsmtboolconstantop>¶</a></h3><p><em>Produce a constant boolean</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.constant` $value attr-dict
</code></pre><p>Produces the constant expressions &rsquo;true&rsquo; and &lsquo;false&rsquo; as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.7.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtdeclare_fun-mlirsmtdeclarefunop><code>smt.declare_fun</code> (mlir::smt::DeclareFunOp)&nbsp;<a class=headline-hash href=#smtdeclare_fun-mlirsmtdeclarefunop>¶</a></h3><p><em>Declare a symbolic value of a given sort</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.declare_fun` ($namePrefix^)? attr-dict `:` qualified(type($result))
</code></pre><p>This operation declares a symbolic value just as the <code>declare-const</code> and
<code>declare-fun</code> statements in SMT-LIB 2.7. The result type determines the SMT
sort of the symbolic value. The returned value can then be used to refer to
the symbolic value instead of using the identifier like in SMT-LIB.</p><p>The optionally provided string will be used as a prefix for the newly
generated identifier (useful for easier readability when exporting to
SMT-LIB). Each <code>declare</code> will always provide a unique new symbolic value
even if the identifier strings are the same.</p><p>Note that there does not exist a separate operation equivalent to
SMT-LIBs <code>define-fun</code> since</p><pre tabindex=0><code>(define-fun f (a Int) Int (-a))
</code></pre><p>is only syntactic sugar for</p><pre tabindex=0><code>%f = smt.declare_fun : !smt.func&lt;(!smt.int) !smt.int&gt;
%0 = smt.forall {
^bb0(%arg0: !smt.int):
  %1 = smt.apply_func %f(%arg0) : !smt.func&lt;(!smt.int) !smt.int&gt;
  %2 = smt.int.neg %arg0
  %3 = smt.eq %1, %2 : !smt.int
  smt.yield %3 : !smt.bool
}
smt.assert %0
</code></pre><p>Note that this operation cannot be marked as Pure since two operations (even
with the same identifier string) could then be CSEd, leading to incorrect
behavior.</p><p>Interfaces: <code>OpAsmOpInterface</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>namePrefix</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtdistinct-mlirsmtdistinctop><code>smt.distinct</code> (mlir::smt::DistinctOp)&nbsp;<a class=headline-hash href=#smtdistinct-mlirsmtdistinctop>¶</a></h3><p><em>Returns true iff all operands are not identical to any other</em></p><p>This operation compares the operands and returns true iff all operands are
not identical to any of the other operands. The semantics are equivalent to
the <code>distinct</code> operator defined in the SMT-LIB Standard 2.7 in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.</p><p>Any SMT sort/type is allowed for the operands and it supports a variadic
number of operands, but requires at least two. This is because the
<code>distinct</code> operator is annotated with <code>:pairwise</code> which means that
<code>distinct a b c d</code> is equivalent to</p><pre tabindex=0><code>and (distinct a b) (distinct a c) (distinct a d)
    (distinct b c) (distinct b d)
    (distinct c d)
</code></pre><p>where <code>and</code> is annotated <code>:left-assoc</code>, i.e., it can be further rewritten to</p><pre tabindex=0><code>(and (and (and (and (and (distinct a b)
                         (distinct a c))
                    (distinct a d))
               (distinct b c))
          (distinct b d))
     (distinct c d)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any non-function SMT value type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smteq-mlirsmteqop><code>smt.eq</code> (mlir::smt::EqOp)&nbsp;<a class=headline-hash href=#smteq-mlirsmteqop>¶</a></h3><p><em>Returns true iff all operands are identical</em></p><p>This operation compares the operands and returns true iff all operands are
identical. The semantics are equivalent to the <code>=</code> operator defined in the
SMT-LIB Standard 2.7 in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.</p><p>Any SMT sort/type is allowed for the operands and it supports a variadic
number of operands, but requires at least two. This is because the <code>=</code>
operator is annotated with <code>:chainable</code> which means that <code>= a b c d</code> is
equivalent to <code>and (= a b) (= b c) (= c d)</code> where <code>and</code> is annotated
<code>:left-assoc</code>, i.e., it can be further rewritten to
<code>and (and (= a b) (= b c)) (= c d)</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any non-function SMT value type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtexists-mlirsmtexistsop><code>smt.exists</code> (mlir::smt::ExistsOp)&nbsp;<a class=headline-hash href=#smtexists-mlirsmtexistsop>¶</a></h3><p><em>Exists quantifier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.exists` ($boundVarNames^)? (`no_pattern` $noPattern^)? (`weight` $weight^)?
              attr-dict-with-keyword $body (`patterns` $patterns^)?
</code></pre><p>This operation represents the exists quantifier as described in the
<a href=https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf>SMT-LIB 2.7 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>The operation specifies the name prefixes (as an optional attribute) and
types (as the types of the block arguments of the regions) of bound
variables that may be used in the &lsquo;body&rsquo; of the operation. If a &lsquo;patterns&rsquo;
region is specified, the block arguments must match the ones of the &lsquo;body&rsquo;
region and (other than there) must be used at least once in the &lsquo;patterns&rsquo;
region. It may also not contain any operations that bind variables, such as
quantifiers. While the &lsquo;body&rsquo; region must always yield exactly one
<code>!smt.bool</code>-typed value, the &lsquo;patterns&rsquo; region can yield an arbitrary number
(but at least one) of SMT values.</p><p>The bound variables can be any SMT type except of functions, since SMT only
supports first-order logic.</p><p>The &rsquo;no_patterns&rsquo; attribute is only allowed when no &lsquo;patterns&rsquo; region is
specified and forbids the solver to generate and use patterns for this
quantifier.</p><p>The &lsquo;weight&rsquo; attribute indicates the importance of this quantifier being
instantiated compared to other quantifiers that may be present. The default
value is zero.</p><p>Both the &rsquo;no_patterns&rsquo; and &lsquo;weight&rsquo; attributes are annotations to the
quantifiers body term. Annotations and attributes are described in the
standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
adding custom attributes to provide solvers with additional metadata, e.g.,
hints such as above mentioned attributes. They are not part of the standard
themselves, but supported by common SMT solvers (e.g., Z3).</p><p>Traits: <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>weight</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>noPattern</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>boundVarNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtforall-mlirsmtforallop><code>smt.forall</code> (mlir::smt::ForallOp)&nbsp;<a class=headline-hash href=#smtforall-mlirsmtforallop>¶</a></h3><p><em>Forall quantifier</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.forall` ($boundVarNames^)? (`no_pattern` $noPattern^)? (`weight` $weight^)?
              attr-dict-with-keyword $body (`patterns` $patterns^)?
</code></pre><p>This operation represents the forall quantifier as described in the
<a href=https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf>SMT-LIB 2.7 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>The operation specifies the name prefixes (as an optional attribute) and
types (as the types of the block arguments of the regions) of bound
variables that may be used in the &lsquo;body&rsquo; of the operation. If a &lsquo;patterns&rsquo;
region is specified, the block arguments must match the ones of the &lsquo;body&rsquo;
region and (other than there) must be used at least once in the &lsquo;patterns&rsquo;
region. It may also not contain any operations that bind variables, such as
quantifiers. While the &lsquo;body&rsquo; region must always yield exactly one
<code>!smt.bool</code>-typed value, the &lsquo;patterns&rsquo; region can yield an arbitrary number
(but at least one) of SMT values.</p><p>The bound variables can be any SMT type except of functions, since SMT only
supports first-order logic.</p><p>The &rsquo;no_patterns&rsquo; attribute is only allowed when no &lsquo;patterns&rsquo; region is
specified and forbids the solver to generate and use patterns for this
quantifier.</p><p>The &lsquo;weight&rsquo; attribute indicates the importance of this quantifier being
instantiated compared to other quantifiers that may be present. The default
value is zero.</p><p>Both the &rsquo;no_patterns&rsquo; and &lsquo;weight&rsquo; attributes are annotations to the
quantifiers body term. Annotations and attributes are described in the
standard in sections 3.4, and 3.6 (specifically 3.6.5). SMT-LIB allows
adding custom attributes to provide solvers with additional metadata, e.g.,
hints such as above mentioned attributes. They are not part of the standard
themselves, but supported by common SMT solvers (e.g., Z3).</p><p>Traits: <code>RecursiveMemoryEffects</code>, <code>RecursivelySpeculatableImplTrait</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>weight</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>noPattern</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>boundVarNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtimplies-mlirsmtimpliesop><code>smt.implies</code> (mlir::smt::ImpliesOp)&nbsp;<a class=headline-hash href=#smtimplies-mlirsmtimpliesop>¶</a></h3><p><em>Boolean implication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.implies` $lhs `,` $rhs attr-dict
</code></pre><p>This operation performs a boolean implication. The semantics are equivalent
to the &lsquo;=>&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.7.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintabs-mlirsmtintabsop><code>smt.int.abs</code> (mlir::smt::IntAbsOp)&nbsp;<a class=headline-hash href=#smtintabs-mlirsmtintabsop>¶</a></h3><p><em>The absolute value of an Int</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.abs` $input attr-dict
</code></pre><p>This operation represents the absolute value function for the <code>Int</code> sort.
The semantics are equivalent to the <code>abs</code> operator as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintadd-mlirsmtintaddop><code>smt.int.add</code> (mlir::smt::IntAddOp)&nbsp;<a class=headline-hash href=#smtintadd-mlirsmtintaddop>¶</a></h3><p><em>Integer addition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.add` $inputs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer addition.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintcmp-mlirsmtintcmpop><code>smt.int.cmp</code> (mlir::smt::IntCmpOp)&nbsp;<a class=headline-hash href=#smtintcmp-mlirsmtintcmpop>¶</a></h3><p><em>Integer comparison</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.cmp` $pred $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents the comparison of (infinite-precision) integers.
The semantics are equivalent to the <code>&lt;= (le)</code>, <code>&lt; (lt)</code>, <code>>= (ge)</code>, or
<code>> (gt)</code> operator depending on the predicate (indicated in parentheses) as
described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>mlir::smt::IntPredicateAttr</td><td>smt comparison predicate for integers</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintconstant-mlirsmtintconstantop><code>smt.int.constant</code> (mlir::smt::IntConstantOp)&nbsp;<a class=headline-hash href=#smtintconstant-mlirsmtintconstantop>¶</a></h3><p><em>Produce a constant (infinite-precision) integer</em></p><p>This operation represents (infinite-precision) integer literals of the <code>Int</code>
sort. The set of values for the sort <code>Int</code> consists of all numerals and
all terms of the form <code>-n</code>where n is a numeral other than 0. For more
information refer to the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintdiv-mlirsmtintdivop><code>smt.int.div</code> (mlir::smt::IntDivOp)&nbsp;<a class=headline-hash href=#smtintdiv-mlirsmtintdivop>¶</a></h3><p><em>Integer division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.div` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer division.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintmod-mlirsmtintmodop><code>smt.int.mod</code> (mlir::smt::IntModOp)&nbsp;<a class=headline-hash href=#smtintmod-mlirsmtintmodop>¶</a></h3><p><em>Integer remainder</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.mod` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer remainder.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintmul-mlirsmtintmulop><code>smt.int.mul</code> (mlir::smt::IntMulOp)&nbsp;<a class=headline-hash href=#smtintmul-mlirsmtintmulop>¶</a></h3><p><em>Integer multiplication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.mul` $inputs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer multiplication.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtintsub-mlirsmtintsubop><code>smt.int.sub</code> (mlir::smt::IntSubOp)&nbsp;<a class=headline-hash href=#smtintsub-mlirsmtintsubop>¶</a></h3><p><em>Integer subtraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int.sub` $lhs `,` $rhs attr-dict
</code></pre><p>This operation represents (infinite-precision) integer subtraction.
The semantics are equivalent to the corresponding operator described in
the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td></td></tr><tr><td style=text-align:center><code>rhs</code></td><td></td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtint2bv-mlirsmtint2bvop><code>smt.int2bv</code> (mlir::smt::Int2BVOp)&nbsp;<a class=headline-hash href=#smtint2bv-mlirsmtint2bvop>¶</a></h3><p><em>Convert an integer to an inferred-width bitvector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.int2bv` $input attr-dict `:` qualified(type($result))
</code></pre><p>Designed to lower directly to an operation of the same name in Z3. The Z3
C API describes the semantics as follows:
Create an n bit bit-vector from the integer argument t1.
The resulting bit-vector has n bits, where the i&rsquo;th bit (counting from 0
to n-1) is 1 if (t1 div 2^i) mod 2 is 1.
The node t1 must have integer sort.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtite-mlirsmtiteop><code>smt.ite</code> (mlir::smt::IteOp)&nbsp;<a class=headline-hash href=#smtite-mlirsmtiteop>¶</a></h3><p><em>An if-then-else function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.ite` $cond `,` $thenValue `,` $elseValue attr-dict `:` qualified(type($result))
</code></pre><p>This operation returns its second operand or its third operand depending on
whether its first operand is true or not. The semantics are equivalent to
the <code>ite</code> operator defined in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
2.7 standard.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td></td></tr><tr><td style=text-align:center><code>thenValue</code></td><td>any SMT value type</td></tr><tr><td style=text-align:center><code>elseValue</code></td><td>any SMT value type</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any SMT value type</td></tr></tbody></table><h3 id=smtnot-mlirsmtnotop><code>smt.not</code> (mlir::smt::NotOp)&nbsp;<a class=headline-hash href=#smtnot-mlirsmtnotop>¶</a></h3><p><em>A boolean negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.not` $input attr-dict
</code></pre><p>This operation performs a boolean negation. The semantics are equivalent to
the &rsquo;not&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a> of the SMT-LIB
Standard 2.7.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td></td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtor-mlirsmtorop><code>smt.or</code> (mlir::smt::OrOp)&nbsp;<a class=headline-hash href=#smtor-mlirsmtorop>¶</a></h3><p><em>A boolean disjunction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.or` $inputs attr-dict
</code></pre><p>This operation performs a boolean disjunction.
The semantics are equivalent to the &lsquo;or&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.7.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtpop-mlirsmtpopop><code>smt.pop</code> (mlir::smt::PopOp)&nbsp;<a class=headline-hash href=#smtpop-mlirsmtpopop>¶</a></h3><p><em>Pop a given number of levels from the assertion stack</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.pop` $count attr-dict
</code></pre><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h3 id=smtpush-mlirsmtpushop><code>smt.push</code> (mlir::smt::PushOp)&nbsp;<a class=headline-hash href=#smtpush-mlirsmtpushop>¶</a></h3><p><em>Push a given number of levels onto the assertion stack</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.push` $count attr-dict
</code></pre><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h3 id=smtreset-mlirsmtresetop><code>smt.reset</code> (mlir::smt::ResetOp)&nbsp;<a class=headline-hash href=#smtreset-mlirsmtresetop>¶</a></h3><p><em>Reset the solver</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.reset` attr-dict
</code></pre><h3 id=smtset_logic-mlirsmtsetlogicop><code>smt.set_logic</code> (mlir::smt::SetLogicOp)&nbsp;<a class=headline-hash href=#smtset_logic-mlirsmtsetlogicop>¶</a></h3><p><em>Set the logic for the SMT solver</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.set_logic` $logic attr-dict
</code></pre><p>Traits: <code>HasParent&lt;smt::SolverOp></code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>logic</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=smtsolver-mlirsmtsolverop><code>smt.solver</code> (mlir::smt::SolverOp)&nbsp;<a class=headline-hash href=#smtsolver-mlirsmtsolverop>¶</a></h3><p><em>Create a solver instance within a lifespan</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.solver` `(` $inputs `)` attr-dict `:` functional-type($inputs, $results) $bodyRegion
</code></pre><p>This operation defines an SMT context with a solver instance. SMT operations
are only valid when being executed between the start and end of the region
of this operation. Any invocation outside is undefined. However, they do not
have to be direct children of this operation. For example, it is allowed to
have SMT operations in a <code>func.func</code> which is only called from within this
region. No SMT value may enter or exit the lifespan of this region (such
that no value created from another SMT context can be used in this scope and
the solver can deallocate all state required to keep track of SMT values at
the end).</p><p>As a result, the region is comparable to an entire SMT-LIB script, but
allows for concrete operations and control-flow. Concrete values may be
passed in and returned to influence the computations after the <code>smt.solver</code>
operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span><span class=p>:</span><span class=nl>2 =</span> smt<span class=p>.</span>solver <span class=p>(</span><span class=nv>%in</span><span class=p>)</span> <span class=p>{</span>smt<span class=p>.</span>some_attr<span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i8</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%c</span> <span class=p>=</span> smt<span class=p>.</span>declare_fun <span class=s>&#34;c&#34;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bool
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>assert <span class=nv>%c</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> smt<span class=p>.</span>check sat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c1_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c1_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unknown <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c0_i32</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c0_i32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> unsat <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c</span><span class=m>-1</span><span class=nl>_i32 =</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>-1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    smt<span class=p>.</span>yield <span class=nv>%c</span><span class=m>-1</span>_i32 <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  smt<span class=p>.</span>yield <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;smt::YieldOp></code>, <code>SingleBlock</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of any non-smt type</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any non-smt type</td></tr></tbody></table><h3 id=smtxor-mlirsmtxorop><code>smt.xor</code> (mlir::smt::XOrOp)&nbsp;<a class=headline-hash href=#smtxor-mlirsmtxorop>¶</a></h3><p><em>A boolean exclusive OR</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.xor` $inputs attr-dict
</code></pre><p>This operation performs a boolean exclusive OR.
The semantics are equivalent to the &lsquo;xor&rsquo; operator in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Core.smt2>Core theory</a>.
of the SMT-LIB Standard 2.7.</p><pre><code>It supports a variadic number of operands, but requires at least two.
This is because the operator is annotated with the `:left-assoc` attribute
which means that `op a b c` is equivalent to `(op (op a b) c)`.
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td></td></tr></tbody></table><h3 id=smtyield-mlirsmtyieldop><code>smt.yield</code> (mlir::smt::YieldOp)&nbsp;<a class=headline-hash href=#smtyield-mlirsmtyieldop>¶</a></h3><p><em>Terminator operation for various regions of SMT operations</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `smt.yield` ($values^ `:` qualified(type($values)))? attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;smt::SolverOp, smt::CheckOp, smt::ForallOp, smt::ExistsOp></code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table><h2 id=attributes-13>Attributes&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h2><h3 id=bitvectorattr>BitVectorAttr&nbsp;<a class=headline-hash href=#bitvectorattr>¶</a></h3><p>This attribute represents a constant value of the <code>(_ BitVec width)</code> sort as
described in the
<a href=https://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml>SMT bit-vector
theory</a>.</p><p>The constant is as #bX (binary) or #xX (hexadecimal) in SMT-LIB
where X is the value in the corresponding format without any further
prefixing. Here, the bit-vector constant is given as a regular non-negative
integer literal and the associated bit-vector type indicating the bit-width.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>5</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>4</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>#smt.bv</span><span class=p>&lt;</span><span class=m>92</span><span class=p>&gt;</span> <span class=p>:</span> <span class=p>!</span>smt<span class=p>.</span>bv<span class=p>&lt;</span><span class=m>8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>The explicit type-suffix is mandatory to uniquely represent the attribute,
i.e., this attribute should always be used in the extended form (using the
<code>quantified</code> keyword in the operation assembly format string).</p><p>The bit-width must be greater than zero (i.e., at least one digit has to be
present).</p><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::APInt</code></td><td></td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=arraytype>ArrayType&nbsp;<a class=headline-hash href=#arraytype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.array&lt;
  mlir::Type,   # domainType
  mlir::Type   # rangeType
&gt;
</code></pre><p>This type represents the <code>(Array X Y)</code> sort, where X and Y are any
sort/type, as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/ArraysEx.smt2>SMT ArrayEx theory</a> of
the SMT-LIB standard 2.7.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>domainType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr><tr><td style=text-align:center>rangeType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=bitvectortype>BitVectorType&nbsp;<a class=headline-hash href=#bitvectortype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.bv&lt;
  int64_t   # width
&gt;
</code></pre><p>This type represents the <code>(_ BitVec width)</code> sort as described in the
<a href=https://smtlib.cs.uiowa.edu/theories-FixedSizeBitVectors.shtml>SMT bit-vector
theory</a>.</p><p>The bit-width must be strictly greater than zero.</p><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>width</td><td style=text-align:center><code>int64_t</code></td><td></td></tr></tbody></table><h3 id=booltype>BoolType&nbsp;<a class=headline-hash href=#booltype>¶</a></h3><p>Syntax: <code>!smt.bool</code></p><h3 id=inttype>IntType&nbsp;<a class=headline-hash href=#inttype>¶</a></h3><p>Syntax: <code>!smt.int</code></p><p>This type represents the <code>Int</code> sort as described in the
<a href=https://smtlib.cs.uiowa.edu/Theories/Ints.smt2>SMT Ints theory</a> of the
SMT-LIB 2.7 standard.</p><h3 id=smtfunctype>SMTFuncType&nbsp;<a class=headline-hash href=#smtfunctype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.func&lt;
  ::llvm::ArrayRef&lt;mlir::Type&gt;,   # domainTypes
  mlir::Type   # rangeType
&gt;
</code></pre><p>This type represents the SMT function sort as described in the
<a href=https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf>SMT-LIB 2.7 standard</a>.
It is part of the language itself rather than a theory or logic.</p><p>A function in SMT can have an arbitrary domain size, but always has exactly
one range sort.</p><p>Since SMT only supports first-order logic, it is not possible to nest
function types.</p><p>Example: <code>!smt.func&lt;(!smt.bool, !smt.int) !smt.bool></code> is equivalent to
<code>((Bool Int) Bool)</code> in SMT-LIB.</p><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>domainTypes</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td>domain types</td></tr><tr><td style=text-align:center>rangeType</td><td style=text-align:center><code>mlir::Type</code></td><td></td></tr></tbody></table><h3 id=sorttype>SortType&nbsp;<a class=headline-hash href=#sorttype>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>!smt.sort&lt;
  mlir::StringAttr,   # identifier
  ::llvm::ArrayRef&lt;mlir::Type&gt;   # sortParams
&gt;
</code></pre><p>This type represents uninterpreted sorts. The usage of a type like
<code>!smt.sort&lt;"sort_name"[!smt.bool, !smt.sort&lt;"other_sort">]></code> implies a
<code>declare-sort sort_name 2</code> and a <code>declare-sort other_sort 0</code> in SMT-LIB.
This type represents concrete use-sites of such declared sorts, in this
particular case it would be equivalent to <code>(sort_name Bool other_sort)</code> in
SMT-LIB. More details about the semantics can be found in the
<a href=https://smt-lib.org/papers/smt-lib-reference-v2.7-r2025-02-05.pdf>SMT-LIB 2.7 standard</a>.</p><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>identifier</td><td style=text-align:center><code>mlir::StringAttr</code></td><td></td></tr><tr><td style=text-align:center>sortParams</td><td style=text-align:center><code>::llvm::ArrayRef&lt;mlir::Type></code></td><td>sort parameters</td></tr></tbody></table><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=bvcmppredicate>BVCmpPredicate&nbsp;<a class=headline-hash href=#bvcmppredicate>¶</a></h3><p><em>Smt bit-vector comparison predicate</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>slt</td><td style=text-align:center><code>0</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>1</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>2</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>3</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>4</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>5</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>6</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>7</code></td><td>uge</td></tr></tbody></table><h3 id=intpredicate>IntPredicate&nbsp;<a class=headline-hash href=#intpredicate>¶</a></h3><p><em>Smt comparison predicate for integers</em></p><h4 id=cases-1>Cases:&nbsp;<a class=headline-hash href=#cases-1>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>lt</td><td style=text-align:center><code>0</code></td><td>lt</td></tr><tr><td style=text-align:center>le</td><td style=text-align:center><code>1</code></td><td>le</td></tr><tr><td style=text-align:center>gt</td><td style=text-align:center><code>2</code></td><td>gt</td></tr><tr><td style=text-align:center>ge</td><td style=text-align:center><code>3</code></td><td>ge</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Shard/ title="'shard' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'shard' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/ title="'sparse_tensor' Dialect">Next - 'sparse_tensor' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>