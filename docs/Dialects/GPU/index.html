<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'gpu' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/GPU/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'gpu' Dialect</h1><p>Note: this dialect is more likely to change than others in the near future; use
with caution.</p><p>This dialect provides middle-level abstractions for launching GPU kernels
following a programming model similar to that of CUDA or OpenCL. It provides
abstractions for kernel invocations (and may eventually provide those for device
management) that are not present at the lower level (e.g., as LLVM IR intrinsics
for GPUs). Its goal is to abstract away device- and driver-specific
manipulations to launch a GPU kernel and provide a simple path towards GPU
execution from MLIR. It may be targeted, for example, by DSLs using MLIR. The
dialect uses <code>gpu</code> as its canonical prefix.</p><p>This dialect also abstracts away primitives commonly available in GPU code, such
as with <code>gpu.thread_id</code> (an operation that returns the ID of threads within
a thread block/workgroup along a given dimension). While the compilation
pipelines documented below expect such code to live inside a <code>gpu.module</code> and
<code>gpu.func</code>, these intrinsic wrappers may be used outside of this context.</p><p>Intrinsic-wrapping operations should not expect that they have a parent of type
<code>gpu.func</code>. However, operations that deal in compiling and launching GPU functions,
like <code>gpu.launch_func</code> or <code>gpu.binary</code> may assume that the dialect&rsquo;s full layering
is being used.</p><p><nav id=TableOfContents><ul><li><a href=#gpu-address-spaces>GPU address spaces</a></li><li><a href=#memory-attribution>Memory attribution</a></li><li><a href=#gpu-compilation>GPU Compilation</a><ul><li><a href=#compilation-overview>Compilation overview</a></li><li><a href=#default-nvvm-compilation-pipeline-gpu-lower-to-nvvm-pipeline>Default NVVM Compilation Pipeline: gpu-lower-to-nvvm-pipeline</a></li><li><a href=#module-serialization>Module serialization</a></li><li><a href=#offloading-llvm-translation>Offloading LLVM translation</a></li><li><a href=#the-binary-operation>The binary operation</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#gpuall_reduce-gpuallreduceop><code>gpu.all_reduce</code> (gpu::AllReduceOp)</a></li><li><a href=#gpualloc-gpuallocop><code>gpu.alloc</code> (gpu::AllocOp)</a></li><li><a href=#gpubarrier-gpubarrierop><code>gpu.barrier</code> (gpu::BarrierOp)</a></li><li><a href=#gpubinary-gpubinaryop><code>gpu.binary</code> (gpu::BinaryOp)</a></li><li><a href=#gpublock_dim-gpublockdimop><code>gpu.block_dim</code> (gpu::BlockDimOp)</a></li><li><a href=#gpublock_id-gpublockidop><code>gpu.block_id</code> (gpu::BlockIdOp)</a></li><li><a href=#gpucluster_block_id-gpuclusterblockidop><code>gpu.cluster_block_id</code> (gpu::ClusterBlockIdOp)</a></li><li><a href=#gpucluster_dim_blocks-gpuclusterdimblocksop><code>gpu.cluster_dim_blocks</code> (gpu::ClusterDimBlocksOp)</a></li><li><a href=#gpucluster_dim-gpuclusterdimop><code>gpu.cluster_dim</code> (gpu::ClusterDimOp)</a></li><li><a href=#gpucluster_id-gpuclusteridop><code>gpu.cluster_id</code> (gpu::ClusterIdOp)</a></li><li><a href=#gpucreate_2to4_spmat-gpucreate2to4spmatop><code>gpu.create_2to4_spmat</code> (gpu::Create2To4SpMatOp)</a></li><li><a href=#gpucreate_bsr-gpucreatebsrop><code>gpu.create_bsr</code> (gpu::CreateBsrOp)</a></li><li><a href=#gpucreate_coo_aos-gpucreatecooaosop><code>gpu.create_coo_aos</code> (gpu::CreateCooAoSOp)</a></li><li><a href=#gpucreate_coo-gpucreatecooop><code>gpu.create_coo</code> (gpu::CreateCooOp)</a></li><li><a href=#gpucreate_csc-gpucreatecscop><code>gpu.create_csc</code> (gpu::CreateCscOp)</a></li><li><a href=#gpucreate_csr-gpucreatecsrop><code>gpu.create_csr</code> (gpu::CreateCsrOp)</a></li><li><a href=#gpucreate_dn_tensor-gpucreatedntensorop><code>gpu.create_dn_tensor</code> (gpu::CreateDnTensorOp)</a></li><li><a href=#gpudealloc-gpudeallocop><code>gpu.dealloc</code> (gpu::DeallocOp)</a></li><li><a href=#gpudestroy_dn_tensor-gpudestroydntensorop><code>gpu.destroy_dn_tensor</code> (gpu::DestroyDnTensorOp)</a></li><li><a href=#gpudestroy_sp_mat-gpudestroyspmatop><code>gpu.destroy_sp_mat</code> (gpu::DestroySpMatOp)</a></li><li><a href=#gpudynamic_shared_memory-gpudynamicsharedmemoryop><code>gpu.dynamic_shared_memory</code> (gpu::DynamicSharedMemoryOp)</a></li><li><a href=#gpufunc-gpugpufuncop><code>gpu.func</code> (gpu::GPUFuncOp)</a></li><li><a href=#gpumodule-gpugpumoduleop><code>gpu.module</code> (gpu::GPUModuleOp)</a></li><li><a href=#gpuglobal_id-gpuglobalidop><code>gpu.global_id</code> (gpu::GlobalIdOp)</a></li><li><a href=#gpugrid_dim-gpugriddimop><code>gpu.grid_dim</code> (gpu::GridDimOp)</a></li><li><a href=#gpuhost_register-gpuhostregisterop><code>gpu.host_register</code> (gpu::HostRegisterOp)</a></li><li><a href=#gpuhost_unregister-gpuhostunregisterop><code>gpu.host_unregister</code> (gpu::HostUnregisterOp)</a></li><li><a href=#gpulane_id-gpulaneidop><code>gpu.lane_id</code> (gpu::LaneIdOp)</a></li><li><a href=#gpulaunch_func-gpulaunchfuncop><code>gpu.launch_func</code> (gpu::LaunchFuncOp)</a></li><li><a href=#gpulaunch-gpulaunchop><code>gpu.launch</code> (gpu::LaunchOp)</a></li><li><a href=#gpumemcpy-gpumemcpyop><code>gpu.memcpy</code> (gpu::MemcpyOp)</a></li><li><a href=#gpumemset-gpumemsetop><code>gpu.memset</code> (gpu::MemsetOp)</a></li><li><a href=#gpunum_subgroups-gpunumsubgroupsop><code>gpu.num_subgroups</code> (gpu::NumSubgroupsOp)</a></li><li><a href=#gpuprintf-gpuprintfop><code>gpu.printf</code> (gpu::PrintfOp)</a></li><li><a href=#gpureturn-gpureturnop><code>gpu.return</code> (gpu::ReturnOp)</a></li><li><a href=#gpurotate-gpurotateop><code>gpu.rotate</code> (gpu::RotateOp)</a></li><li><a href=#gpusddmm_buffer_size-gpusddmmbuffersizeop><code>gpu.sddmm_buffer_size</code> (gpu::SDDMMBufferSizeOp)</a></li><li><a href=#gpusddmm-gpusddmmop><code>gpu.sddmm</code> (gpu::SDDMMOp)</a></li><li><a href=#gpuset_csr_pointers-gpusetcsrpointersop><code>gpu.set_csr_pointers</code> (gpu::SetCsrPointersOp)</a></li><li><a href=#gpuset_default_device-gpusetdefaultdeviceop><code>gpu.set_default_device</code> (gpu::SetDefaultDeviceOp)</a></li><li><a href=#gpushuffle-gpushuffleop><code>gpu.shuffle</code> (gpu::ShuffleOp)</a></li><li><a href=#gpuspgemm_copy-gpuspgemmcopyop><code>gpu.spgemm_copy</code> (gpu::SpGEMMCopyOp)</a></li><li><a href=#gpuspgemm_create_descr-gpuspgemmcreatedescrop><code>gpu.spgemm_create_descr</code> (gpu::SpGEMMCreateDescrOp)</a></li><li><a href=#gpuspgemm_destroy_descr-gpuspgemmdestroydescrop><code>gpu.spgemm_destroy_descr</code> (gpu::SpGEMMDestroyDescrOp)</a></li><li><a href=#gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop><code>gpu.spgemm_work_estimation_or_compute</code> (gpu::SpGEMMWorkEstimationOrComputeOp)</a></li><li><a href=#gpuspmm_buffer_size-gpuspmmbuffersizeop><code>gpu.spmm_buffer_size</code> (gpu::SpMMBufferSizeOp)</a></li><li><a href=#gpuspmm-gpuspmmop><code>gpu.spmm</code> (gpu::SpMMOp)</a></li><li><a href=#gpuspmv_buffer_size-gpuspmvbuffersizeop><code>gpu.spmv_buffer_size</code> (gpu::SpMVBufferSizeOp)</a></li><li><a href=#gpuspmv-gpuspmvop><code>gpu.spmv</code> (gpu::SpMVOp)</a></li><li><a href=#gpuspmat_get_size-gpuspmatgetsizeop><code>gpu.spmat_get_size</code> (gpu::SpMatGetSizeOp)</a></li><li><a href=#gpusubgroup_broadcast-gpusubgroupbroadcastop><code>gpu.subgroup_broadcast</code> (gpu::SubgroupBroadcastOp)</a></li><li><a href=#gpusubgroup_id-gpusubgroupidop><code>gpu.subgroup_id</code> (gpu::SubgroupIdOp)</a></li><li><a href=#gpusubgroup_mma_compute-gpusubgroupmmacomputeop><code>gpu.subgroup_mma_compute</code> (gpu::SubgroupMmaComputeOp)</a></li><li><a href=#gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop><code>gpu.subgroup_mma_constant_matrix</code> (gpu::SubgroupMmaConstantMatrixOp)</a></li><li><a href=#gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop><code>gpu.subgroup_mma_elementwise</code> (gpu::SubgroupMmaElementwiseOp)</a></li><li><a href=#gpusubgroup_mma_extract_thread_local-gpusubgroupmmaextractthreadlocalop><code>gpu.subgroup_mma_extract_thread_local</code> (gpu::SubgroupMmaExtractThreadLocalOp)</a></li><li><a href=#gpusubgroup_mma_insert_thread_local-gpusubgroupmmainsertthreadlocalop><code>gpu.subgroup_mma_insert_thread_local</code> (gpu::SubgroupMmaInsertThreadLocalOp)</a></li><li><a href=#gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop><code>gpu.subgroup_mma_load_matrix</code> (gpu::SubgroupMmaLoadMatrixOp)</a></li><li><a href=#gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop><code>gpu.subgroup_mma_store_matrix</code> (gpu::SubgroupMmaStoreMatrixOp)</a></li><li><a href=#gpusubgroup_reduce-gpusubgroupreduceop><code>gpu.subgroup_reduce</code> (gpu::SubgroupReduceOp)</a></li><li><a href=#gpusubgroup_size-gpusubgroupsizeop><code>gpu.subgroup_size</code> (gpu::SubgroupSizeOp)</a></li><li><a href=#gputerminator-gputerminatorop><code>gpu.terminator</code> (gpu::TerminatorOp)</a></li><li><a href=#gputhread_id-gputhreadidop><code>gpu.thread_id</code> (gpu::ThreadIdOp)</a></li><li><a href=#gpuwait-gpuwaitop><code>gpu.wait</code> (gpu::WaitOp)</a></li><li><a href=#gpuwarp_execute_on_lane_0-gpuwarpexecuteonlane0op><code>gpu.warp_execute_on_lane_0</code> (gpu::WarpExecuteOnLane0Op)</a></li><li><a href=#gpuyield-gpuyieldop><code>gpu.yield</code> (gpu::YieldOp)</a></li></ul></li></ul></nav><h2 id=gpu-address-spaces>GPU address spaces&nbsp;<a class=headline-hash href=#gpu-address-spaces>¶</a></h2><p>The GPU dialect exposes the <code>gpu.address_space</code> attribute, which currently has
three values: <code>global</code>, <code>workgroup</code>, and <code>private</code>.</p><p>These address spaces represent the types of buffer commonly seen in GPU compilation.
<code>global</code> memory is memory that resides in the GPU&rsquo;s global memory. <code>workgroup</code>
memory is a limited, per-workgroup resource: all threads in a workgroup/thread
block access the same values in <code>workgroup</code> memory. Finally, <code>private</code> memory is
used to represent <code>alloca</code>-like buffers that are private to a single thread/workitem.</p><p>These address spaces may be used as the <code>memorySpace</code> attribute on <code>memref</code> values.
The <code>gpu.module</code>/<code>gpu.func</code> compilation pipeline will lower such memory space
usages to the correct address spaces on target platforms. Memory attributions should be
created with the correct memory space on the memref.</p><h2 id=memory-attribution>Memory attribution&nbsp;<a class=headline-hash href=#memory-attribution>¶</a></h2><p>Memory buffers are defined at the function level, either in &ldquo;gpu.launch&rdquo; or in
&ldquo;gpu.func&rdquo; ops. This encoding makes it clear where the memory belongs and makes
the lifetime of the memory visible. The memory is only accessible while the
kernel is launched/the function is currently invoked. The latter is more strict
than actual GPU implementations but using static memory at the function level is
just for convenience. It is also always possible to pass pointers to the
workgroup memory into other functions, provided they expect the correct memory
space.</p><p>The buffers are considered live throughout the execution of the GPU function
body. The absence of memory attribution syntax means that the function does not
require special buffers. Rationale: although the underlying models declare
memory buffers at the module level, we chose to do it at the function level to
provide some structuring for the lifetime of those buffers; this avoids the
incentive to use the buffers for communicating between different kernels or
launches of the same kernel, which should be done through function arguments
instead; we chose not to use <code>alloca</code>-style approach that would require more
complex lifetime analysis following the principles of MLIR that promote
structure and representing analysis results in the IR.</p><h2 id=gpu-compilation>GPU Compilation&nbsp;<a class=headline-hash href=#gpu-compilation>¶</a></h2><h3 id=compilation-overview>Compilation overview&nbsp;<a class=headline-hash href=#compilation-overview>¶</a></h3><p>The compilation process in the GPU dialect has two main stages: GPU module
serialization and offloading operations translation. Together these stages can
produce GPU binaries and the necessary code to execute them.</p><p>An example of how the compilation workflow look is:</p><pre tabindex=0><code>mlir-opt example.mlir                   \
  --pass-pipeline=&#34;builtin.module(      \
    gpu-kernel-outlining,               \ # Outline gpu.launch body to a kernel.
    nvvm-attach-target{chip=sm_90 O=3}, \ # Attach an NVVM target to a gpu.module op.
    gpu.module(convert-gpu-to-nvvm),    \ # Convert GPU to NVVM.
    gpu-to-llvm,                        \ # Convert GPU to LLVM.
    gpu-module-to-binary                \ # Serialize GPU modules to binaries.
  )&#34; -o example-nvvm.mlir
mlir-translate example-nvvm.mlir        \
  --mlir-to-llvmir                      \ # Obtain the translated LLVM IR.
  -o example.ll
</code></pre><p>This compilation process expects all GPU code to live in a <code>gpu.module</code> and
expects all kernels to be <code>gpu.func</code> operations. Non-kernel functions, like
device library calls, may be defined using <code>func.func</code> or other non-GPU dialect
operations. This permits downstream systems to use these wrappers without
requiring them to use the GPU dialect&rsquo;s function operations, which might not include
information those systems want to have as intrinsic values on their functions.
Additionally, this allows for using <code>func.func</code> for device-side library functions
in <code>gpu.module</code>s.</p><h3 id=default-nvvm-compilation-pipeline-gpu-lower-to-nvvm-pipeline>Default NVVM Compilation Pipeline: gpu-lower-to-nvvm-pipeline&nbsp;<a class=headline-hash href=#default-nvvm-compilation-pipeline-gpu-lower-to-nvvm-pipeline>¶</a></h3><p>The <code>gpu-lower-to-nvvm-pipeline</code> compilation pipeline serves as the default way
for NVVM target compilation within MLIR. This pipeline operates by lowering
primary dialects (arith, memref, scf, vector, gpu, and nvgpu) to NVVM target. It
begins by lowering GPU code region(s) to the specified NVVM compilation target
and subsequently handles the host code.</p><p>This pipeline specifically requires explicitly parallel IR and doesn&rsquo;t do GPU
parallelization. To enable parallelism, necessary transformations must be
applied before utilizing this pipeline.</p><p>It&rsquo;s designed to provide a generic solution for NVVM targets, generating NVVM
and LLVM dialect code compatible with <code>mlir-runner</code> or execution engine.</p><h4 id=example>Example:&nbsp;<a class=headline-hash href=#example>¶</a></h4><p>Here&rsquo;s a snippet illustrating the use of primary dialects, including arith,
within GPU code execution:</p><pre tabindex=0><code>func.func @main() {
    %c2 = arith.constant 2 : index
    %c1 = arith.constant 1 : index
    gpu.launch
        blocks(%0, %1, %2) in (%3 = %c1, %4 = %c1, %5 = %c1)
        threads(%6, %7, %8) in (%9 = %c2, %10 = %c1, %11 = %c1) {
        gpu.printf &#34;Hello from %d\n&#34;, %6 : index
        gpu.terminator
    }
    return
}
</code></pre><p>The <code>gpu-lower-to-nvvm</code> pipeline compiles this input code to NVVM format as
below. It provides customization options like specifying SM capability, PTX
version, and optimization level. Once compiled, the resulting IR is ready for
execution using <code>mlir-runner</code>. Alternatively, it can be translated into
LLVM, expanding its utility within the system.</p><pre tabindex=0><code>mlir-opt example.mlir -gpu-lower-to-nvvm-pipeline = &#34;cubin-chip=sm_90a cubin-features=+ptx80 opt-level=3&#34;
</code></pre><h3 id=module-serialization>Module serialization&nbsp;<a class=headline-hash href=#module-serialization>¶</a></h3><p>Attributes implementing the GPU Target Attribute Interface handle the
serialization process and are called Target attributes. These attributes can be
attached to GPU Modules indicating the serialization scheme to compile the
module into a binary string.</p><p>The <code>gpu-module-to-binary</code> pass searches for all nested GPU modules and
serializes the module using the target attributes attached to the module,
producing a binary with an object for every target.</p><p>Example:</p><pre tabindex=0><code>// Input:
gpu.module @kernels [#nvvm.target&lt;chip = &#34;sm_90&#34;&gt;, #nvvm.target&lt;chip = &#34;sm_60&#34;&gt;] {
  ...
}
// mlir-opt --gpu-module-to-binary:
gpu.binary @kernels [
  #gpu.object&lt;#nvvm.target&lt;chip = &#34;sm_90&#34;&gt;, &#34;sm_90 cubin&#34;&gt;,
  #gpu.object&lt;#nvvm.target&lt;chip = &#34;sm_60&#34;&gt;, &#34;sm_60 cubin&#34;&gt;
]
</code></pre><h3 id=offloading-llvm-translation>Offloading LLVM translation&nbsp;<a class=headline-hash href=#offloading-llvm-translation>¶</a></h3><p>Attributes implementing the GPU Offloading LLVM Translation Attribute Interface
handle the translation of GPU binaries and kernel launches into LLVM
instructions and are called Offloading attributes. These attributes are
attached to GPU binary operations.</p><p>During the LLVM translation process, GPU binaries get translated using the
scheme provided by the Offloading attribute, translating the GPU binary into
LLVM instructions. Meanwhile, Kernel launches are translated by searching the
appropriate binary and invoking the procedure provided by the Offloading
attribute in the binary for translating kernel launches into LLVM instructions.</p><p>Example:</p><pre tabindex=0><code>// Input:
// Binary with multiple objects but selecting the second one for embedding.
gpu.binary @binary &lt;#gpu.select_object&lt;#rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;&gt;&gt; [
    #gpu.object&lt;#nvvm.target, &#34;NVPTX&#34;&gt;,
    #gpu.object&lt;#rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;, &#34;AMDGPU&#34;&gt;
  ]
llvm.func @foo() {
  ...
  // Launching a kernel inside the binary.
  gpu.launch_func @binary::@func blocks in (%0, %0, %0)
                                 threads in (%0, %0, %0) : i64
                                 dynamic_shared_memory_size %2
                                 args(%1 : i32, %1 : i32)
  ...
}
// mlir-translate --mlir-to-llvmir:
@binary_bin_cst = internal constant [6 x i8] c&#34;AMDGPU&#34;, align 8
@binary_func_kernel_name = private unnamed_addr constant [7 x i8] c&#34;func\00&#34;, align 1
@binary_module = internal global ptr null
@llvm.global_ctors = appending global [1 x {i32, ptr, ptr}] [{i32 123, ptr @binary_load, ptr null}]
@llvm.global_dtors = appending global [1 x {i32, ptr, ptr}] [{i32 123, ptr @binary_unload, ptr null}]
define internal void @binary_load() section &#34;.text.startup&#34; {
entry:
  %0 = call ptr @mgpuModuleLoad(ptr @binary_bin_cst)
  store ptr %0, ptr @binary_module
  ...
}
define internal void @binary_unload() section &#34;.text.startup&#34; {
entry:
  %0 = load ptr, ptr @binary_module, align 8
  call void @mgpuModuleUnload(ptr %0)
  ...
}
...
define void @foo() {
  ...
  %module = load ptr, ptr @binary_module, align 8
  %kernel = call ptr @mgpuModuleGetFunction(ptr %module, ptr @binary_func_kernel_name)
  call void @mgpuLaunchKernel(ptr %kernel, ...) ; Launch the kernel
  ...
  call void @mgpuModuleUnload(ptr %module)
  ...
}
...
</code></pre><h3 id=the-binary-operation>The binary operation&nbsp;<a class=headline-hash href=#the-binary-operation>¶</a></h3><p>From a semantic point of view, GPU binaries allow the implementation of many
concepts, from simple object files to fat binaries. By default, the binary
operation uses the <code>#gpu.select_object</code> offloading attribute; this attribute
embeds a single object in the binary as a global string, see the attribute docs
for more information.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/GPU/IR/GPUOps.td>source</a></p><h3 id=gpuall_reduce-gpuallreduceop><code>gpu.all_reduce</code> (gpu::AllReduceOp)&nbsp;<a class=headline-hash href=#gpuall_reduce-gpuallreduceop>¶</a></h3><p><em>Reduce values among workgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.all_reduce` custom&lt;AllReduceOperation&gt;($op) $value
              (`uniform` $uniform^)? $body attr-dict
              `:` functional-type(operands, results)
</code></pre><p>The <code>all_reduce</code> op reduces the value of every work item across a local
workgroup. The result is equal for all work items of a workgroup.</p><p>For example, both</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce add <span class=nv>%0</span> <span class=p>{}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>all_reduce <span class=nv>%0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=nl>^bb</span><span class=p>(</span><span class=nv>%lhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=nv>%sum</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;gpu.yield&#34;</span><span class=p>(</span><span class=nv>%sum</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span></code></pre></div><p>compute the sum of each work item&rsquo;s %0 value. The first version specifies
the accumulation as operation, whereas the second version specifies the
accumulation as code region. The reduction operation must be one of:</p><ul><li>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>,
<code>or</code>, <code>xor</code></li><li>Floating point types: <code>add</code>, <code>mul</code>, <code>minnumf</code>, <code>maxnumf</code>, <code>minimumf</code>,
<code>maximumf</code></li></ul><p>If <code>uniform</code> flag is set either none or all work items of a workgroup
need to execute this op in convergence.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>op</code></td><td>::mlir::gpu::AllReduceOperationAttr</td><td>built-in reduction operations supported by gpu.allreduce.</td></tr><tr><td><code>uniform</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Integer or Float</td></tr></tbody></table><h3 id=gpualloc-gpuallocop><code>gpu.alloc</code> (gpu::AllocOp)&nbsp;<a class=headline-hash href=#gpualloc-gpuallocop>¶</a></h3><p><em>GPU memory allocation operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.alloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) (` ` `host_shared` $hostShared^)? ` `
              `(` $dynamicSizes `)` (`` `[` $symbolOperands^ `]`)? attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.alloc</code> operation allocates a region of memory on the GPU. It is
similar to the <code>memref.alloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it also returns a !gpu.async.token.</p><p>If the <code>host_shared</code> keyword is present, the memory will be allocated in a
memory accessible both on host and on device.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%memref</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>alloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> host_shared <span class=p>(</span><span class=nv>%width</span><span class=p>)</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>64x?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>hostShared</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dynamicSizes</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>symbolOperands</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpubarrier-gpubarrierop><code>gpu.barrier</code> (gpu::BarrierOp)&nbsp;<a class=headline-hash href=#gpubarrier-gpubarrierop>¶</a></h3><p><em>Synchronizes all work items of a workgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.barrier` attr-dict
</code></pre><p>The <code>barrier</code> op synchronizes all work items of a workgroup. It is used
to coordinate communication between the work items of the workgroup.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>barrier
</span></span></code></pre></div><p>waits until all work items in the workgroup have reached this point
and all memory accesses made by these work items prior to the op are
visible to all work items in the workgroup. Data hazards between work items
accessing the same memory can be avoided by synchronizing work items
in-between these accesses.</p><p>Either none or all work items of a workgroup need to execute this op
in convergence.</p><h3 id=gpubinary-gpubinaryop><code>gpu.binary</code> (gpu::BinaryOp)&nbsp;<a class=headline-hash href=#gpubinary-gpubinaryop>¶</a></h3><p><em>An Op for storing serialized GPU binary objects.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.binary` $sym_name custom&lt;OffloadingHandler&gt;($offloadingHandler) attr-dict $objects
</code></pre><p>GPU binaries provide a semantic mechanism for storing GPU objects,
e.g. the result of compiling a GPU module to an object file.</p><p>This operation has 3 arguments:</p><ul><li>The name of the binary.</li><li>An optional attribute implementing the offloading LLVM translation interface.</li><li>An array of GPU object attributes.</li></ul><p>During translation, the offloading attribute will be called for translating
GPU <code>binary</code> and <code>launch_func</code> operations. The default offloading handler is:
<code>#gpu.select_object</code>, this handler selects the first object from the array
and embeds it as a string.</p><p>Examples:</p><pre tabindex=0><code>  // Selects the first object.
  gpu.binary @myobject [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]
  // Uses the `#foo.my_handler` for handling the binary during translation.
  gpu.binary @myobject &lt;#foo.my_handler&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;...&gt;]
  // Selects the object with the `#rocdl.target` target attribute.
  gpu.binary @myobject &lt;#gpu.select_object&lt;#rocdl.target&gt;&gt; [#gpu.object&lt;...&gt;, #gpu.object&lt;#rocdl.target, ...&gt;]
</code></pre><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>offloadingHandler</code></td><td>::mlir::Attribute</td><td>any attribute with the `OffloadingTranslationAttrTrait` trait.</td></tr><tr><td><code>objects</code></td><td>::mlir::ArrayAttr</td><td>an array of GPU object attributes with at least 1 elements</td></tr></table><h3 id=gpublock_dim-gpublockdimop><code>gpu.block_dim</code> (gpu::BlockDimOp)&nbsp;<a class=headline-hash href=#gpublock_dim-gpublockdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.block_dim` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the number of threads in the thread block (aka the block size) along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
</span></span></code></pre></div><p>If <code>known_block_size</code> is set on an this operation&rsquo;s enclosing <code>gpu.func</code>,
or <code>gpu.known_block_size</code> is set on an enclosing <code>FunctionOpInterface</code>
implementor, or if the enclosing <code>gpu.launch</code> specifies a constant size for
<code>dimension</code>&rsquo;s blocks, these contextual facts may be used to infer that this
operation has a constant value, though such a transformation will not be
performed by canonicalization or the default constant folder. Executions which
cause that constant-value assumption to be false incur undefined behavior.</p><p>If <code>upper_bound</code> is set, executions where the bblock size along <code>dimension</code>
exceeds <code>upper_bound</code> cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpublock_id-gpublockidop><code>gpu.block_id</code> (gpu::BlockIdOp)&nbsp;<a class=headline-hash href=#gpublock_id-gpublockidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.block_id` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the block id, i.e. the index of the current block within the grid
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, or if one can be inferred from <code>known_grid_size</code>-type
annotations in context, executions where the block index in <code>dimension</code> would
be greater than or equal to that bound cause undefined behavior. <code>upper_bound</code>
takes priority over bounds inferrable from context.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_block_id-gpuclusterblockidop><code>gpu.cluster_block_id</code> (gpu::ClusterBlockIdOp)&nbsp;<a class=headline-hash href=#gpucluster_block_id-gpuclusterblockidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_block_id` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the block id within the cluster along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cBlockIdY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_block_id y
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an
environment where the number of thread blocks per cluster along <code>dimension</code>
is greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxClusterDim</code> (currently 8).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_dim_blocks-gpuclusterdimblocksop><code>gpu.cluster_dim_blocks</code> (gpu::ClusterDimBlocksOp)&nbsp;<a class=headline-hash href=#gpucluster_dim_blocks-gpuclusterdimblocksop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_dim_blocks` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the number of thread blocks in the cluster along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cDimBlocksX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim_blocks <span class=p>x</span>
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an
environment where the thread blocks per cluster is greater than <code>upper_bound</code>
causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxClusterDim</code> (currently 8).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_dim-gpuclusterdimop><code>gpu.cluster_dim</code> (gpu::ClusterDimOp)&nbsp;<a class=headline-hash href=#gpucluster_dim-gpuclusterdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_dim` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the number of cluster identifiers per grid along
the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cDimX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim <span class=p>x</span>
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an
environment where the clusters per grid is greater than <code>upper_bound</code> causes
undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucluster_id-gpuclusteridop><code>gpu.cluster_id</code> (gpu::ClusterIdOp)&nbsp;<a class=headline-hash href=#gpucluster_id-gpuclusteridop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.cluster_id` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the cluster id, i.e. the index of the current cluster within the
grid along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cIdY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id y
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, then executing (a lowering of) this operation in an
environment where the number of clusters in the grid along <code>dimension</code> is
greater than <code>upper_bound</code> causes undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpucreate_2to4_spmat-gpucreate2to4spmatop><code>gpu.create_2to4_spmat</code> (gpu::Create2To4SpMatOp)&nbsp;<a class=headline-hash href=#gpucreate_2to4_spmat-gpucreate2to4spmatop>¶</a></h3><p><em>Create sparse matrix with 2:4 sparsity operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_2to4_spmat` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              `{` $pruneFlag `}` $rows `,` $cols `,` $memref attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.create_2to4_spmat</code> operation initializes a sparse matrix in dense
format with 2:4 sparsity.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_2to4_spmat async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=p>{</span>PRUNE_AND_CHECK<span class=p>}</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%mem</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pruneFlag</code></td><td>::mlir::gpu::Prune2To4SpMatFlagAttr</td><td>pruning strategy for 2:4 sparse matrix</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spMat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_bsr-gpucreatebsrop><code>gpu.create_bsr</code> (gpu::CreateBsrOp)&nbsp;<a class=headline-hash href=#gpucreate_bsr-gpucreatebsrop>¶</a></h3><p><em>Create sparse matrix in BSR format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_bsr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $brows `,` $bcols `,` $bnnz `,` $rBlockSize `,` $cBlockSize `,`
              $bRowPos `,` $bColIdxs `,` $values attr-dict
              `:` type($bRowPos) `,` type($bColIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_bsr</code> operation initializes a sparse matrix in BSR format
with the given sizes for the matrix and blocks from the given position,
index, and values buffers. The buffers must already be copied from the
host to the device prior to using this operation. The operation returns
a handle to the sparse matrix descriptor.</p><p>The BSR format is similar to CSR, where the column indices represent
two-dimensional blocks instead of a single matrix entry. Note that this
operation (currently) only supports storage with <strong>square</strong> blocks,
i.e., <code>rBlockSize == cBlockSize</code>.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_bsr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=nv>%brows</span><span class=p>,</span> <span class=nv>%bcols</span><span class=p>,</span> <span class=nv>%bnnz</span><span class=p>,</span> <span class=nv>%rBlockSize</span><span class=p>,</span> <span class=nv>%cBlockSize</span><span class=p>,</span>
</span></span><span class=line><span class=cl>   <span class=nv>%bRowPos</span><span class=p>,</span> <span class=nv>%bColIdxs</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>brows</code></td><td>index</td></tr><tr><td style=text-align:center><code>bcols</code></td><td>index</td></tr><tr><td style=text-align:center><code>bnnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rBlockSize</code></td><td>index</td></tr><tr><td style=text-align:center><code>cBlockSize</code></td><td>index</td></tr><tr><td style=text-align:center><code>bRowPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>bColIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_coo_aos-gpucreatecooaosop><code>gpu.create_coo_aos</code> (gpu::CreateCooAoSOp)&nbsp;<a class=headline-hash href=#gpucreate_coo_aos-gpucreatecooaosop>¶</a></h3><p><em>Create sparse matrix in COO format operation (AoS)</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_coo_aos` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $idxs `,` $values attr-dict
              `:` type($idxs) `,` type($values)
</code></pre><p>The <code>gpu.create_coo_aos</code> operation initializes a sparse matrix in COO format
with the given sizes from the given index and values buffers. The buffers
must already be copied from the host to the device prior to using this
operation. The operation returns a handle to the sparse matrix descriptor.
Unlike the default <code>gpu.create_coo</code> operation, this operation builds the
COO format from a single index buffer in AoS format (note that this
feature has been deprecated in cuSparse 11.2).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_coo_aos async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%idxs</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>idxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_coo-gpucreatecooop><code>gpu.create_coo</code> (gpu::CreateCooOp)&nbsp;<a class=headline-hash href=#gpucreate_coo-gpucreatecooop>¶</a></h3><p><em>Create sparse matrix in COO format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_coo` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $rowIdxs `,` $colIdxs `,` $values attr-dict
              `:` type($rowIdxs) `,` type($colIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_coo</code> operation initializes a sparse matrix in COO format
with the given sizes from the given index and values buffers. The buffers
must already be copied from the host to the device prior to using this
operation. The operation returns a handle to the sparse matrix descriptor.
Note that this operation builds the COO in SoA format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_coo async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%rowIdx</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%colIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rowIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>colIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_csc-gpucreatecscop><code>gpu.create_csc</code> (gpu::CreateCscOp)&nbsp;<a class=headline-hash href=#gpucreate_csc-gpucreatecscop>¶</a></h3><p><em>Create sparse matrix in CSC format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_csc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $colPos `,` $rowIdxs `,` $values attr-dict
              `:` type($colPos) `,` type($rowIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_csc</code> operation initializes a sparse matrix in CSC format
with the given sizes from the given position, index, and values buffers.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>The CSC format has exactly the same memory layout as its transpose
in CSR format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_csc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%colPos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%rowIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>colPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>rowIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_csr-gpucreatecsrop><code>gpu.create_csr</code> (gpu::CreateCsrOp)&nbsp;<a class=headline-hash href=#gpucreate_csr-gpucreatecsrop>¶</a></h3><p><em>Create sparse matrix in CSR format operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_csr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $rows `,` $cols `,` $nnz `,` $rowPos `,` $colIdxs `,` $values attr-dict
              `:` type($rowPos) `,` type($colIdxs) `,` type($values)
</code></pre><p>The <code>gpu.create_csr</code> operation initializes a sparse matrix in CSR format
with the given sizes from the given position, index, and values buffers.
The buffers must already be copied from the host to the device prior to
using this operation. The operation returns a handle to the sparse
matrix descriptor.</p><p>The CSR format has exactly the same memory layout as its transpose
in CSC format (and vice versa).</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%spmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_csr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%rowPos</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=nv>%colIdx</span><span class=p>,</span> <span class=nv>%values</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>rowPos</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>colIdxs</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpucreate_dn_tensor-gpucreatedntensorop><code>gpu.create_dn_tensor</code> (gpu::CreateDnTensorOp)&nbsp;<a class=headline-hash href=#gpucreate_dn_tensor-gpucreatedntensorop>¶</a></h3><p><em>Create dense tensor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.create_dn_tensor` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $memref `,` $dims attr-dict `:` type($dims) `into` type($memref)
</code></pre><p>The <code>gpu.create_dn_tensor</code> operation initializes a dense tensor from
the given values buffer and sizes. The buffer must already be copied
from the host to the device prior to using this operation. The
operation returns a handle to the dense tensor descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%dmat</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>create_dn_tensor async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%mem</span><span class=p>,</span> <span class=nv>%dims</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span> into <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>dims</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dnTensor</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudealloc-gpudeallocop><code>gpu.dealloc</code> (gpu::DeallocOp)&nbsp;<a class=headline-hash href=#gpudealloc-gpudeallocop>¶</a></h3><p><em>GPU memory deallocation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.dealloc` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $memref attr-dict `:` type($memref)
</code></pre><p>The <code>gpu.dealloc</code> operation frees the region of memory referenced by a
memref which was originally created by the <code>gpu.alloc</code> operation. It is
similar to the <code>memref.dealloc</code> op, but supports asynchronous GPU execution.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>dealloc async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%memref</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>8x64x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>memref</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudestroy_dn_tensor-gpudestroydntensorop><code>gpu.destroy_dn_tensor</code> (gpu::DestroyDnTensorOp)&nbsp;<a class=headline-hash href=#gpudestroy_dn_tensor-gpudestroydntensorop>¶</a></h3><p><em>Destroy dense tensor operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.destroy_dn_tensor` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnTensor attr-dict
</code></pre><p>The <code>gpu.destroy_dn_tensor</code> operation releases all resources of a dense
tensor represented by a handle that was previously created by a
<code>gpu.create_dn_tensor</code> operation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>destroy_dn_tensor async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnTensor</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnTensor</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudestroy_sp_mat-gpudestroyspmatop><code>gpu.destroy_sp_mat</code> (gpu::DestroySpMatOp)&nbsp;<a class=headline-hash href=#gpudestroy_sp_mat-gpudestroyspmatop>¶</a></h3><p><em>Destroy sparse matrix operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.destroy_sp_mat` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) $spmat attr-dict
</code></pre><p>The <code>gpu.destroy_sp_mat</code> operation releases all resources of a sparse
matrix represented by a handle that was previously created by a
one of the sparse matrix creation operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>destroy_sp_mat async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmat</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpudynamic_shared_memory-gpudynamicsharedmemoryop><code>gpu.dynamic_shared_memory</code> (gpu::DynamicSharedMemoryOp)&nbsp;<a class=headline-hash href=#gpudynamic_shared_memory-gpudynamicsharedmemoryop>¶</a></h3><p><em>Get the memref for dynamic shared memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.dynamic_shared_memory` attr-dict `:` type($resultMemref)
</code></pre><p>This operation provides a memref pointer to the start of dynamic shared
memory, often referred to as workgroup memory. It&rsquo;s important to note that
this dynamic shared memory needs to be allocated at kernel launch. One can
conveniently utilize the <code>dynamic_shared_memory_size</code> parameter of
<code>gpu.launch</code> for this purpose.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>dynamic<span class=p>.</span>shared<span class=p>.</span>memory <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%c8192</span><span class=p>][]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>                        to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> <span class=kt>memref</span><span class=p>.</span>view <span class=nv>%0</span><span class=p>[</span><span class=nv>%c16384</span><span class=p>][]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i8</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>                        to <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x64x</span><span class=k>f32</span><span class=p>,</span> <span class=nv>#gpu.address_space</span><span class=p>&lt;</span>workgroup<span class=p>&gt;&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>resultMemref</code></td><td>1D memref of 8-bit signless integer values</td></tr></tbody></table><h3 id=gpufunc-gpugpufuncop><code>gpu.func</code> (gpu::GPUFuncOp)&nbsp;<a class=headline-hash href=#gpufunc-gpugpufuncop>¶</a></h3><p><em>Function executable on a GPU</em></p><p>Defines a function that can be executed on a GPU. This supports memory
attribution and its body has a particular execution model.</p><p>GPU functions are either kernels (as indicated by the <code>kernel</code> attribute) or
regular functions. The former can be launched from the host side, while the
latter are device side only.</p><p>The memory attribution defines SSA values that correspond to memory buffers
allocated in the memory hierarchy of the GPU (see below).</p><p>The operation has one attached region that corresponds to the body of the
function. The region arguments consist of the function arguments without
modification, followed by buffers defined in memory annotations. The body of
a GPU function, when launched, is executed by multiple work items. There are
no guarantees on the order in which work items execute, or on the connection
between them. In particular, work items are not necessarily executed in
lock-step. Synchronization ops such as &ldquo;gpu.barrier&rdquo; should be used to
coordinate work items. Declarations of GPU functions, i.e. not having the
body region, are not supported.</p><p>A function may optionally be annotated with the block and/or grid sizes
that will be used when it is launched using the <code>known_block_size</code> and
<code>known_grid_size</code> attributes, respectively. If set, these attributes must
be arrays of three 32-bit integers giving the x, y, and z launch dimensions.
Launching a kernel that has these annotations, or that calls a function with
these annotations, using a block size or grid size other than what is specified
is undefined behavior. These attributes may be set on non-<code>gpu.func</code> functions
by using <code>gpu.known_block_size</code> or <code>gpu.known_grid_size</code>, but this carries
the risk that they will de discarded.</p><p>Syntax:</p><pre tabindex=0><code>op ::= `gpu.func` symbol-ref-id `(` argument-list `)` (`-&gt;`
function-result-list)?
       memory-attribution `kernel`? function-attributes? region

memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>    kernel
</span></span><span class=line><span class=cl>    attributes <span class=p>{</span>qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  gpu<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The generic form illustrates the concept</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=s>&#34;gpu.func&#34;</span><span class=p>(</span><span class=nv>%arg</span><span class=p>:</span> <span class=k>index</span><span class=p>)</span> <span class=p>{</span>sym_name<span class=p>:</span> <span class=s>&#34;foo&#34;</span><span class=p>,</span> kernel<span class=p>,</span> qux<span class=p>:</span> <span class=s>&#34;quux&#34;</span><span class=p>}</span> <span class=p>({</span>
</span></span><span class=line><span class=cl><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;):</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;gpu.return&#34;</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>})</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><p>Note the non-default memory spaces used in memref types in memory
attribution.</p><p>Traits: <code>AffineScope</code>, <code>AutomaticAllocationScope</code>, <code>HasParent&lt;GPUModuleOp></code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>workgroup_attrib_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>private_attrib_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>known_block_size</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute with 3 elements (if present)</td></tr><tr><td><code>known_grid_size</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute with 3 elements (if present)</td></tr></table><h3 id=gpumodule-gpugpumoduleop><code>gpu.module</code> (gpu::GPUModuleOp)&nbsp;<a class=headline-hash href=#gpumodule-gpugpumoduleop>¶</a></h3><p><em>A top level compilation unit containing code to be run on a GPU.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.module` $sym_name
              (`&lt;` $offloadingHandler^ `&gt;`)?
              ($targets^)?
              attr-dict-with-keyword $bodyRegion
</code></pre><p>GPU module contains code that is intended to be run on a GPU. A host device
can launch this code through a gpu.launc_func that creates a fully
qualified symbol through the gpu.module&rsquo;s symbol and a gpu.func symbol
contained in the gpu.module.</p><p>The module&rsquo;s top-level scope is modeled by a single region with a single
block. GPU modules are required to have a name that is used for symbol
resolution by the gpu.launch_func operation.</p><p>Using an op with a region to define a GPU module enables &ldquo;embedding&rdquo; GPU
modules with SIMT execution models in other dialects in a clean manner and
allows filtering of code regions to execute passes on only code intended to
or not intended to be run on the separate device.</p><p>Modules can contain zero or more target attributes. These attributes encode
how to transform modules into binary strings and are used by the
<code>gpu-module-to-binary</code> pass to transform modules into GPU binaries.</p><p>Modules can contain an optional <code>OffloadingTranslationAttr</code> attribute. This
attribute will be used during the <code>gpu-module-to-binary</code> pass to specify the
<code>OffloadingTranslationAttr</code> used when creating the <code>gpu.binary</code> operation.</p><pre tabindex=0><code>gpu.module @symbol_name {
  gpu.func {}
    ...
}
// Module with offloading handler and target attributes.
gpu.module @symbol_name2 &lt;#gpu.select_object&lt;1&gt;&gt; [
    #nvvm.target,
    #rocdl.target&lt;chip = &#34;gfx90a&#34;&gt;] {
  gpu.func {}
    ...
}
</code></pre><p>Traits: <code>HasDefaultDLTIDataLayout</code>, <code>HasOnlyGraphRegion</code>, <code>IsolatedFromAbove</code>, <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SingleBlock</code>, <code>SymbolTable</code></p><p>Interfaces: <code>DataLayoutOpInterface</code>, <code>RegionKindInterface</code>, <code>Symbol</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>targets</code></td><td>::mlir::ArrayAttr</td><td>array of GPU target attributes with at least 1 elements</td></tr><tr><td><code>offloadingHandler</code></td><td>::mlir::Attribute</td><td>any attribute with the `OffloadingTranslationAttrTrait` trait.</td></tr></table><h3 id=gpuglobal_id-gpuglobalidop><code>gpu.global_id</code> (gpu::GlobalIdOp)&nbsp;<a class=headline-hash href=#gpuglobal_id-gpuglobalidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.global_id` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the unique global workitem/thread id, i.e., the unique index of the
current workitem/thread within all workgroups / grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%gidX</span> <span class=p>=</span> gpu<span class=p>.</span>global_id <span class=p>x</span>
</span></span><span class=line><span class=cl><span class=nv>%gidX</span> <span class=p>=</span> gpu<span class=p>.</span>global_id <span class=p>x</span> upper_bound <span class=m>65536</span>
</span></span></code></pre></div><p>The <code>upper_bound</code> attribute defines an upper bound analogously to the ones on
<code>thread_id</code> and <code>block_id</code>. If one is not set, the bound may be inferred from
a combination of <code>known_block_size</code> and <code>known_grid_size</code>-type annotations.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpugrid_dim-gpugriddimop><code>gpu.grid_dim</code> (gpu::GridDimOp)&nbsp;<a class=headline-hash href=#gpugrid_dim-gpugriddimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.grid_dim` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the number of thread blocks in the grid along the x, y, or z
<code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z
</span></span></code></pre></div><p>If <code>known_grid_size</code> is set on an this operation&rsquo;s enclosing <code>gpu.func</code>,
or <code>gpu.known_grid_size</code> is set on an enclosing <code>FunctionOpInterface</code>
implementor, or if the enclosing <code>gpu.launch</code> specifies a constant size for
<code>dimension</code>&rsquo;s grid length, these contextual facts may be used to infer that this
operation has a constant value, though such a transformation will not be
performed by canonicalization or the default constant folder. Executions which
cause that constant-value assumption to be false incur undefined behavior.</p><p>If <code>upper_bound</code> is set, executions where the grid size in <code>dimension</code> would
exceed <code>upper_bound</code> cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuhost_register-gpuhostregisterop><code>gpu.host_register</code> (gpu::HostRegisterOp)&nbsp;<a class=headline-hash href=#gpuhost_register-gpuhostregisterop>¶</a></h3><p><em>Registers a memref for access from device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.host_register` $value attr-dict `:` type($value)
</code></pre><p>This op maps the provided host buffer into the device address space.</p><p>This operation may not be supported in every environment, there is not yet a
way to check at runtime whether this feature is supported.</p><p>Writes from the host are guaranteed to be visible to device kernels that are
launched afterwards. Writes from the device are guaranteed to be visible on
the host after synchronizing with the device kernel completion.</p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>unranked.memref of any type values</td></tr></tbody></table><h3 id=gpuhost_unregister-gpuhostunregisterop><code>gpu.host_unregister</code> (gpu::HostUnregisterOp)&nbsp;<a class=headline-hash href=#gpuhost_unregister-gpuhostunregisterop>¶</a></h3><p><em>Unregisters a memref for access from device.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.host_unregister` $value attr-dict `:` type($value)
</code></pre><p>This op unmaps the provided host buffer from the device address space.</p><p>This operation may not be supported in every environment, there is not yet a
way to check at runtime whether this feature is supported.</p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>unranked.memref of any type values</td></tr></tbody></table><h3 id=gpulane_id-gpulaneidop><code>gpu.lane_id</code> (gpu::LaneIdOp)&nbsp;<a class=headline-hash href=#gpulane_id-gpulaneidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.lane_id` (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the lane id within the subgroup (warp/wave).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%laneId</span> <span class=p>=</span> gpu<span class=p>.</span>lane_id
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, executions with more than <code>upper_bound</code> lanes per
subgroup cause undefined behavior. In the abscence of <code>upper_bound</code>,
the lane id is still assumed to be non-negative and less than the
target-independent <code>kMaxSubgroupSize</code> (currently 128).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpulaunch_func-gpulaunchfuncop><code>gpu.launch_func</code> (gpu::LaunchFuncOp)&nbsp;<a class=headline-hash href=#gpulaunch_func-gpulaunchfuncop>¶</a></h3><p><em>Launches a function as a GPU kernel</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.launch_func` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              (`&lt;` $asyncObject^ `:` type($asyncObject) `&gt;`)?
              $kernel
              ( `clusters` `in` ` ` `(` $clusterSizeX^ `,` $clusterSizeY `,` $clusterSizeZ `)` )?
              `blocks` `in` ` ` `(` $gridSizeX `,` $gridSizeY `,` $gridSizeZ `)`
              `threads` `in` ` ` `(` $blockSizeX `,` $blockSizeY `,` $blockSizeZ `)`
              custom&lt;LaunchDimType&gt;(type($gridSizeX), ref($clusterSizeX), type($clusterSizeX), type($clusterSizeY), type($clusterSizeZ))
              (`dynamic_shared_memory_size` $dynamicSharedMemorySize^)?
              custom&lt;LaunchFuncOperands&gt;($kernelOperands, type($kernelOperands)) attr-dict
</code></pre><p>Launch a kernel function on the specified grid of thread blocks.
<code>gpu.launch</code> operations are lowered to <code>gpu.launch_func</code> operations by
outlining the kernel body into a function in a dedicated module, which
reflects the separate compilation process. The kernel function is required
to have the <code>gpu.kernel</code> attribute. The module containing the kernel
function is required to be a gpu.module. And finally, the module containing
the kernel module (which thus cannot be the top-level module) is required
to have the <code>gpu.container_module</code> attribute. The <code>gpu.launch_func</code>
operation has a symbol attribute named <code>kernel</code> to identify the fully
specified kernel function to launch (both the gpu.module and func).</p><p>The <code>gpu.launch_func</code> supports async dependencies: the kernel does not start
executing until the ops producing those async dependencies have completed.</p><p>By the default, the host implicitly blocks until kernel execution has
completed. If the <code>async</code> keyword is present, the host does not block but
instead a <code>!gpu.async.token</code> is returned. Other async GPU ops can take this
token as dependency.</p><p>The operation requires at least the grid and block sizes along the x,y,z
dimensions as arguments. When a lower-dimensional kernel is required,
unused sizes must be explicitly set to <code>1</code>.</p><p>The remaining operands are optional. The first optional operand corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The remaining operands if present are passed as arguments to the kernel
function.</p><p>The <code>gpu.launch_func</code> also supports kernel launching with clusters if
supported by the target architecture. The cluster size can be set by
<code>clusterSizeX</code>, <code>clusterSizeY</code>, and <code>clusterSizeZ</code> arguments. When these
arguments are present, the Op launches a kernel that clusters the given
thread blocks. This feature is exclusive to certain architectures.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module attributes <span class=p>{</span>gpu<span class=p>.</span>container_module<span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// This module creates a separate compilation unit for the GPU compiler.
</span></span></span><span class=line><span class=cl><span class=c></span>  gpu<span class=p>.</span>module <span class=nf>@kernels</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@kernel_1</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>        attributes <span class=p>{</span> <span class=nl>nvvm.kernel =</span> true <span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c>// Operations that produce block/thread IDs and dimensions are
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=c>// injected when outlining the `gpu.launch` body to a function called
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=c>// by `gpu.launch_func`.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%tIdY</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id y
</span></span><span class=line><span class=cl>      <span class=nv>%tIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%bDimX</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%bDimY</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%bDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%bIdX</span> <span class=p>=</span> gpu<span class=p>.</span>block_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%bIdY</span> <span class=p>=</span> gpu<span class=p>.</span>block_id y
</span></span><span class=line><span class=cl>      <span class=nv>%bIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>block_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%gDimX</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%gDimY</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%gDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>grid_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=c>// (Optional)  Cluster size only for support architectures
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nv>%cIdX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%cIdY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id y
</span></span><span class=line><span class=cl>      <span class=nv>%cIdZ</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_id z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=nv>%cDimX</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim <span class=p>x</span>
</span></span><span class=line><span class=cl>      <span class=nv>%cDimY</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim y
</span></span><span class=line><span class=cl>      <span class=nv>%cDimZ</span> <span class=p>=</span> gpu<span class=p>.</span>cluster_dim z
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%arg1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>wait async
</span></span><span class=line><span class=cl>  gpu<span class=p>.</span>launch_func
</span></span><span class=line><span class=cl>      async                           <span class=c>// (Optional) Don&#39;t block host, return token.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=p>[</span><span class=nv>%t0</span><span class=p>]</span>                           <span class=c>// (Optional) Execute only after %t0 has completed.
</span></span></span><span class=line><span class=cl><span class=c></span>      <span class=nf>@kernels</span><span class=p>::</span><span class=nf>@kernel_1</span>             <span class=c>// Kernel function.
</span></span></span><span class=line><span class=cl><span class=c></span>      clusters in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>  <span class=c>// (Optional) Cluster size only for support architectures.
</span></span></span><span class=line><span class=cl><span class=c></span>      blocks in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>    <span class=c>// Grid size.
</span></span></span><span class=line><span class=cl><span class=c></span>      threads in <span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>)</span>   <span class=c>// Block size.
</span></span></span><span class=line><span class=cl><span class=c></span>      dynamic_shared_memory_size <span class=nv>%s</span>   <span class=c>// (Optional) Amount of dynamic shared
</span></span></span><span class=line><span class=cl><span class=c></span>                                      <span class=c>// memory to allocate for a workgroup.
</span></span></span><span class=line><span class=cl><span class=c></span>      args<span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span>               <span class=c>// (Optional) Kernel arguments.
</span></span></span><span class=line><span class=cl><span class=c></span>           <span class=nv>%arg1</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kernel</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeX</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeY</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>clusterSizeZ</code></td><td>index or 32-bit signless integer or 64-bit signless integer</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>kernelOperands</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>asyncObject</code></td><td>any type</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpulaunch-gpulaunchop><code>gpu.launch</code> (gpu::LaunchOp)&nbsp;<a class=headline-hash href=#gpulaunch-gpulaunchop>¶</a></h3><p><em>GPU kernel launch operation</em></p><p>Launch a kernel on the specified grid of thread blocks. The body of the
kernel is defined by the single region that this operation contains. The
operation takes an optional list of async dependencies followed by six
operands and an optional operand.</p><p>The <code>async</code> keyword indicates the kernel should be launched asynchronously;
the operation returns a new !gpu.async.token when the keyword is specified.
The kernel launched does not start executing until the ops producing its
async dependencies (optional operands) have completed.</p><p>The first three operands (following any async dependencies) are grid sizes
along the x,y,z dimensions and the following three are block sizes along the
x,y,z dimensions. When a lower-dimensional kernel is required, unused sizes
must be explicitly set to <code>1</code>. The last operand is optional and corresponds
to the amount of dynamic shared memory a kernel&rsquo;s workgroup should be
allocated; when this operand is not present, a zero size is assumed.</p><p>The body region has at least <em>twelve</em> arguments, or <em>eighteen</em> if cluster
dimensions are present, grouped as follows:</p><ul><li>three optional arguments that contain cluster identifiers along x,y,z
dimensions;</li><li>three arguments that contain block identifiers along x,y,z dimensions;</li><li>three arguments that contain thread identifiers along x,y,z dimensions;</li><li>operands of the <code>gpu.launch</code> operation as is (i.e. the operands for
grid and block sizes).</li><li>a variadic number of Workgroup memory attributions.</li><li>a variadic number of Private memory attributions.</li></ul><p>The <code>function</code> and <code>module</code> attributes are optional and specifies
the kernel name and a module in which the kernel should be outlined.</p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.launch` (`async` (`[` ssa-id-list `]`)? )?
                         ( `clusters` `(` ssa-id-list `)` `in` ssa-reassignment )?
                         `blocks` `(` ssa-id-list `)` `in` ssa-reassignment
                         `threads` `(` ssa-id-list `)` `in` ssa-reassignment
                         (dynamic_shared_memory_size ssa-use)?
                         (`module(` symbol-ref-id `)`)?
                         (`function(` symbol-ref-id `)`)?
                         memory-attribution
                         region attr-dict?
ssa-reassignment ::= `(` ssa-id `=` ssa-use (`,` ssa-id `=` ssa-use)* `)`
memory-attribution ::= (`workgroup` `(` ssa-id-and-type-list `)`)?
                       (`private` `(` ssa-id-and-type-list `)`)?
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// immediately usable inside body region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%val1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic syntax explains how the pretty syntax maps to the IR structure.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=s>&#34;gpu.launch&#34;</span><span class=p>(</span><span class=nv>%cst</span><span class=p>,</span> <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span>  <span class=c>// Grid sizes.
</span></span></span><span class=line><span class=cl><span class=c></span>             <span class=nv>%cst</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>,</span> <span class=nv>%c1</span><span class=p>)</span>   <span class=c>// Block sizes.
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=err>/</span><span class=p>*</span>attributes<span class=p>*</span><span class=err>/</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c>// All sizes and identifiers have &#34;index&#34; size.
</span></span></span><span class=line><span class=cl><span class=c></span>    <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=c>// The operation passes block and thread identifiers, followed by grid and
</span></span></span><span class=line><span class=cl><span class=c>// block sizes.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nl>^bb0</span><span class=p>(</span><span class=nv>%bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%num_bx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_by</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_bz</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span>
</span></span><span class=line><span class=cl>     <span class=nv>%num_tx</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_ty</span> <span class=p>:</span> <span class=k>index</span><span class=p>,</span> <span class=nv>%num_tz</span> <span class=p>:</span> <span class=k>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> <span class=s>&#34;memref.load&#34;</span><span class=p>(</span><span class=nv>%val1</span><span class=p>,</span> <span class=nv>%bx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Launch with memory attributions.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           workgroup<span class=p>(</span><span class=nv>%workgroup</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>           private<span class=p>(</span><span class=nv>%private</span><span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>1x</span><span class=k>f32</span><span class=p>,</span> <span class=m>5</span><span class=p>&gt;)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Block and thread identifiers, as well as block/grid sizes are
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// immediately usable inside body region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=c>// Assuming %val1 is defined outside the gpu.launch region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%workgroup</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>f32</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Launch with clusters.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>launch clusters<span class=p>(</span><span class=nv>%cx</span><span class=p>,</span> <span class=nv>%cy</span><span class=p>,</span> <span class=nv>%cz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_cx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_cy</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_cz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%6</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%7</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Cluster, block and thread identifiers, as well as cluster/block/grid
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=c>// sizes are immediately usable inside body region.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%cx</span><span class=p>,</span> <span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Launch with module and function attributes.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>launch blocks<span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%by</span><span class=p>,</span> <span class=nv>%bz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_bx</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%sz_by</span> <span class=p>=</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%sz_bz</span> <span class=p>=</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           threads<span class=p>(</span><span class=nv>%tx</span><span class=p>,</span> <span class=nv>%ty</span><span class=p>,</span> <span class=nv>%tz</span><span class=p>)</span> in <span class=p>(</span><span class=nv>%sz_tx</span> <span class=p>=</span> <span class=nv>%3</span><span class=p>,</span> <span class=nv>%sz_ty</span> <span class=p>=</span> <span class=nv>%4</span><span class=p>,</span> <span class=nv>%sz_tz</span> <span class=p>=</span> <span class=nv>%5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>           module<span class=p>(</span><span class=nf>@kernel_module</span><span class=p>)</span> <span class=kt>func</span>tion<span class=p>(</span><span class=nf>@kernel_func</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=s>&#34;some_op&#34;</span><span class=p>(</span><span class=nv>%bx</span><span class=p>,</span> <span class=nv>%tx</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>index</span><span class=p>,</span> <span class=k>index</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>  <span class=nv>%42</span> <span class=p>=</span> load <span class=nv>%val1</span><span class=p>[</span><span class=nv>%bx</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Rationale: using operation/block arguments gives analyses a clear way of
understanding that a value has additional semantics (e.g., we will need to
know what value corresponds to threadIdx.x for coalescing). We can recover
these properties by analyzing the operations producing values, but it is
easier just to have that information by construction.</p><p>Traits: <code>AffineScope</code>, <code>AttrSizedOperandSegments</code>, <code>AutomaticAllocationScope</code>, <code>RecursiveMemoryEffects</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code>, <code>InferIntRangeInterface</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>module</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>function</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>gridSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>gridSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>blockSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>clusterSizeX</code></td><td>index</td></tr><tr><td style=text-align:center><code>clusterSizeY</code></td><td>index</td></tr><tr><td style=text-align:center><code>clusterSizeZ</code></td><td>index</td></tr><tr><td style=text-align:center><code>dynamicSharedMemorySize</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemcpy-gpumemcpyop><code>gpu.memcpy</code> (gpu::MemcpyOp)&nbsp;<a class=headline-hash href=#gpumemcpy-gpumemcpyop>¶</a></h3><p><em>GPU memcpy operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.memcpy` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $src `:` type($dst)`,` type($src) attr-dict
</code></pre><p>The <code>gpu.memcpy</code> operation copies the content of one memref to another.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memcpy async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>src</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpumemset-gpumemsetop><code>gpu.memset</code> (gpu::MemsetOp)&nbsp;<a class=headline-hash href=#gpumemset-gpumemsetop>¶</a></h3><p><em>GPU memset operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.memset` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dst`,` $value `:` type($dst)`,` type($value) attr-dict
</code></pre><p>The <code>gpu.memset</code> operation sets the content of memref to a scalar value.</p><p>The op does not execute before all async dependencies have finished
executing.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>memset async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>,</span> <span class=m>1</span><span class=p>&gt;,</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dst</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>value</code></td><td>any type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpunum_subgroups-gpunumsubgroupsop><code>gpu.num_subgroups</code> (gpu::NumSubgroupsOp)&nbsp;<a class=headline-hash href=#gpunum_subgroups-gpunumsubgroupsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.num_subgroups` (`upper_bound` $upper_bound^)? attr-dict `:` type($result)
</code></pre><p>Returns the number of subgroups within a workgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%numSg</span> <span class=p>=</span> gpu<span class=p>.</span>num_subgroups <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, executions with more than <code>upper_bound</code> subgroups
per workgroup cause undefined behavior. There is a default upper bound of
<code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpuprintf-gpuprintfop><code>gpu.printf</code> (gpu::PrintfOp)&nbsp;<a class=headline-hash href=#gpuprintf-gpuprintfop>¶</a></h3><p><em>Device-side printf, as in CUDA or OpenCL, for debugging</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.printf` $format attr-dict (`,` $args^ `:` type($args))?
</code></pre><p><code>gpu.printf</code> takes a literal format string <code>format</code> and an arbitrary number of
scalar arguments that should be printed.</p><p>The format string is a C-style printf string, subject to any restrictions
imposed by one&rsquo;s target platform.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>format</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of integer or index or floating-point</td></tr></tbody></table><h3 id=gpureturn-gpureturnop><code>gpu.return</code> (gpu::ReturnOp)&nbsp;<a class=headline-hash href=#gpureturn-gpureturnop>¶</a></h3><p><em>Terminator for GPU functions.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.return` attr-dict ($operands^ `:` type($operands))?
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.func</code>
functions. The operands to the <code>gpu.return</code> are the result values returned
by an invocation of the <code>gpu.func</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;GPUFuncOp></code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=gpurotate-gpurotateop><code>gpu.rotate</code> (gpu::RotateOp)&nbsp;<a class=headline-hash href=#gpurotate-gpurotateop>¶</a></h3><p><em>Rotate values within a subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.rotate` $value `,` $offset `,` $width attr-dict `:` type($value)
</code></pre><p>The &ldquo;rotate&rdquo; op moves values across lanes in a subgroup (a.k.a., local
invocations) within the same subgroup. The <code>width</code> attribute specifies the
number of lanes that participate in the rotation, and must be uniform across
all participating lanes. Further, the first <code>width</code> lanes of the subgroup
must be active.</p><p><code>width</code> must be a power of two, and <code>offset</code> must be in the range
<code>[0, width)</code>.</p><p>Return the <code>rotateResult</code> of the invocation whose id within the group is
calculated as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>Invocation <span class=nl>ID =</span> <span class=p>((</span>LaneId <span class=err>+</span> offset<span class=p>)</span> <span class=err>&amp;</span> <span class=p>(</span>width <span class=err>-</span> <span class=m>1</span><span class=p>))</span> <span class=err>+</span> <span class=p>(</span>LaneId <span class=err>&amp;</span> <span class=err>~</span><span class=p>(</span>width <span class=err>-</span> <span class=m>1</span><span class=p>))</span>
</span></span></code></pre></div><p>Returns the <code>rotateResult</code> and <code>true</code> if the current lane id is smaller than
<code>width</code>, and poison value and <code>false</code> otherwise.</p><p>example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>rotate <span class=nv>%0</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=m>16</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>For lane <code>k</code>, returns the value from lane <code>(k + cst1) % width</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td><code>width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is a power of two > 0</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rotateResult</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=gpusddmm_buffer_size-gpusddmmbuffersizeop><code>gpu.sddmm_buffer_size</code> (gpu::SDDMMBufferSizeOp)&nbsp;<a class=headline-hash href=#gpusddmm_buffer_size-gpusddmmbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SDDMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.sddmm_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $spmatC attr-dict `into` $computeType
</code></pre><p>The <code>gpu.sddmm_buffer_size</code> operation returns the buffer size required
to perform the SDDMM operation on the given sparse and dense matrices.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SDDMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%buffersz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>sddmm_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%spmatC</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnmatA</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpusddmm-gpusddmmop><code>gpu.sddmm</code> (gpu::SDDMMOp)&nbsp;<a class=headline-hash href=#gpusddmm-gpusddmmop>¶</a></h3><p><em>SDDMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.sddmm` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $dnmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $buffer attr-dict `:` type($buffer) `into` $computeType
</code></pre><p>The <code>gpu.sddmm</code> operation performs the SDDMM operation on the given sparse and
dense matrices, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SDDMM. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>sddmm async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%dnmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%buffer</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>dnmatA</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuset_csr_pointers-gpusetcsrpointersop><code>gpu.set_csr_pointers</code> (gpu::SetCsrPointersOp)&nbsp;<a class=headline-hash href=#gpuset_csr_pointers-gpusetcsrpointersop>¶</a></h3><p><em>SpGEMM get size operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.set_csr_pointers` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmat `,` $positions `,` $coordinates `,` $values attr-dict
              `:` type($positions) `,` type($coordinates) `,` type($values)
</code></pre><p>The <code>gpu.set_csr_pointers</code> assigns the given positions, coordinates,
and values buffer that reside on the device directly to the given sparse
matrix descriptor in csr format.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>set_csr_pointers async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%positions</span><span class=p>,</span> <span class=nv>%coordinates</span><span class=p>,</span> <span class=nv>%values</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>index</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>positions</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>values</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuset_default_device-gpusetdefaultdeviceop><code>gpu.set_default_device</code> (gpu::SetDefaultDeviceOp)&nbsp;<a class=headline-hash href=#gpuset_default_device-gpusetdefaultdeviceop>¶</a></h3><p><em>Set default GPU for operations after this by index</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.set_default_device` attr-dict $devIndex
</code></pre><p>Operation that sets the current default GPU, using a zero-based index
into the set of GPUs on the system. The default GPU setting may be
thread-local.</p><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>devIndex</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=gpushuffle-gpushuffleop><code>gpu.shuffle</code> (gpu::ShuffleOp)&nbsp;<a class=headline-hash href=#gpushuffle-gpushuffleop>¶</a></h3><p><em>Shuffles values within a subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.shuffle` $mode $value `,` $offset `,` $width attr-dict `:` type($value)
</code></pre><p>The &ldquo;shuffle&rdquo; op moves values across lanes in a subgroup (a.k.a., local
invocation) within the same subgroup. The <code>width</code> argument specifies the
number of lanes that participate in the shuffle, and must be uniform
across all lanes. Further, the first <code>width</code> lanes of the subgroup must
be active.</p><p>The intepretation of the <code>offset</code> arguments depends on the selected
<code>mode</code>.</p><p>Returns the <code>shuffleResult</code> and <code>true</code> if the current lane id is smaller
than <code>width</code>, and an unspecified value and <code>false</code> otherwise.</p><p><code>xor</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle xor <span class=nv>%0</span><span class=p>,</span> <span class=nv>%offset</span><span class=p>,</span> <span class=nv>%width</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>For lane <code>k</code>, returns the value <code>%0</code> from lane <code>k ^ offset</code>. Every lane
trades value with exactly one other lane.</p><p><code>down</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cst1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle down <span class=nv>%0</span><span class=p>,</span> <span class=nv>%cst1</span><span class=p>,</span> <span class=nv>%width</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>For lane <code>k</code>, returns the value from lane <code>(k + cst1)</code>. If <code>(k + cst1)</code> is
bigger than or equal to <code>width</code>, the value is poison and <code>valid</code> is <code>false</code>.</p><p><code>up</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cst1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%5</span><span class=p>,</span> <span class=nv>%6</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle up <span class=nv>%0</span><span class=p>,</span> <span class=nv>%cst1</span><span class=p>,</span> <span class=nv>%width</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>For lane <code>k</code>, returns the value from lane <code>(k - cst1)</code>. If <code>(k - cst1)</code> is
smaller than <code>0</code>, the value is poison and <code>valid</code> is <code>false</code>.</p><p><code>idx</code> example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%cst0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nv>%7</span><span class=p>,</span> <span class=nv>%8</span> <span class=p>=</span> gpu<span class=p>.</span>shuffle idx <span class=nv>%0</span><span class=p>,</span> <span class=nv>%cst0</span><span class=p>,</span> <span class=nv>%width</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Broadcasts the value from lane 0 to all lanes.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mode</code></td><td>::mlir::gpu::ShuffleModeAttr</td><td>Indexing modes supported by gpu.shuffle.</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>width</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>shuffleResult</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr><tr><td style=text-align:center><code>valid</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=gpuspgemm_copy-gpuspgemmcopyop><code>gpu.spgemm_copy</code> (gpu::SpGEMMCopyOp)&nbsp;<a class=headline-hash href=#gpuspgemm_copy-gpuspgemmcopyop>¶</a></h3><p><em>SpGEMM copy operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_copy` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $spmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $desc attr-dict `:` $computeType
</code></pre><p>The <code>gpu.spgemm_copy</code> operation copies the sparse matrix result of
a SpGEMM computation.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>spgemm_copy <span class=nv>%spmatA</span><span class=p>,</span> <span class=nv>%spmatB</span><span class=p>,</span> <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%spgemmDesc</span><span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatB</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_create_descr-gpuspgemmcreatedescrop><code>gpu.spgemm_create_descr</code> (gpu::SpGEMMCreateDescrOp)&nbsp;<a class=headline-hash href=#gpuspgemm_create_descr-gpuspgemmcreatedescrop>¶</a></h3><p><em>SpGEMM Create Descr operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_create_descr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              attr-dict
</code></pre><p>The <code>gpu.spgemm_create_descr</code> creates a descriptor for the SpGEMM operation.
The descriptor describes the SpGEMM operation and stores the internal data
throughout the computation. It needs to be passed as an argument to
spgemm_* operations.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%desc</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_create_descr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_destroy_descr-gpuspgemmdestroydescrop><code>gpu.spgemm_destroy_descr</code> (gpu::SpGEMMDestroyDescrOp)&nbsp;<a class=headline-hash href=#gpuspgemm_destroy_descr-gpuspgemmdestroydescrop>¶</a></h3><p><em>SpGEMM Destroy Descr operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_destroy_descr` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $desc attr-dict
</code></pre><p>The <code>gpu.spgemm_destroy_descr</code> destroys the SpGEMM operation descriptor.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_destroy_descr async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%desc</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop><code>gpu.spgemm_work_estimation_or_compute</code> (gpu::SpGEMMWorkEstimationOrComputeOp)&nbsp;<a class=headline-hash href=#gpuspgemm_work_estimation_or_compute-gpuspgemmworkestimationorcomputeop>¶</a></h3><p><em>SpGEMM work estimation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spgemm_work_estimation_or_compute` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              `{` $kind `}` $spmatA (`{` $modeA^ `}`)? `,` $spmatB (`{` $modeB^ `}`)? `,` $spmatC `,` $desc `,` $bufferSz `,` $buffer  attr-dict `:` $computeType `into` type($buffer)
</code></pre><p>The <code>gpu.spgemm_work_estimation_or_compute</code> is used to call
cusparseSpGEMM_workEstimation or cusparseSpGEMM_compute. Both of them are
for both determining the buffer size and performing the actual computation.
The operation expects handles returned by previous sparse operations to
construct an environment and the operands for SpGEMM.
The buffer must have been allocated on the device.</p><p>C&rsquo; = alpha * op(A) * op(B) + beta * C</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bufferSz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spgemm_work_estimation_or_compute async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=p>{</span>COMPUTE<span class=p>}</span>
</span></span><span class=line><span class=cl>                      <span class=nv>%desc</span><span class=p>,</span> <span class=nv>%spmatA</span><span class=p>{</span>NON_TRANSPOSE<span class=p>},</span> <span class=nv>%spmatB</span><span class=p>{</span>NON_TRANSPOSE<span class=p>},</span>
</span></span><span class=line><span class=cl>                      <span class=nv>%spmatC</span><span class=p>,</span> <span class=nv>%spgemmDesc</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>,</span> <span class=nv>%alloc</span><span class=p>:</span> <span class=k>f32</span> into
</span></span><span class=line><span class=cl>                      <span class=kt>memref</span><span class=p>&lt;</span><span class=m>0</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>kind</code></td><td>::mlir::gpu::SpGEMMWorkEstimationOrComputeKindAttr</td><td>choose whether spgemm_work_estimation_or_compute does work estimation or compute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>desc</code></td><td>SpGEMM operation handle type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatB</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>spmatC</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSzNew</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmm_buffer_size-gpuspmmbuffersizeop><code>gpu.spmm_buffer_size</code> (gpu::SpMMBufferSizeOp)&nbsp;<a class=headline-hash href=#gpuspmm_buffer_size-gpuspmmbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SpMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmm_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $dnmatC attr-dict `:` type($bufferSzs) `into` $computeType
</code></pre><p>The <code>gpu.spmm_buffer_size</code> operation returns the buffer size required
to perform the SpMM operation on the given sparse and dense matrix.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SpMM.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%bufferszs</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmm_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatC</span> <span class=p>:</span> <span class=k>i64</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedResultSegments</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatC</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSzs</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmm-gpuspmmop><code>gpu.spmm</code> (gpu::SpMMOp)&nbsp;<a class=headline-hash href=#gpuspmm-gpuspmmop>¶</a></h3><p><em>SpMM operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmm` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnmatB (`{` $modeB^ `}`)? `,` $dnmatC `,` $buffers attr-dict `:` type($buffers) `into` $computeType
</code></pre><p>The <code>gpu.spmm</code> operation performs the SpMM operation on the given sparse and
dense matrix, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SpMM. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmm async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatB</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnmatC</span><span class=p>,</span> <span class=nv>%buffers</span> <span class=p>:</span> type<span class=p>(</span><span class=err>$</span>buffers<span class=p>)</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>modeB</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnmatB</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnmatC</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>buffers</code></td><td>variadic of memref of any type values</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmv_buffer_size-gpuspmvbuffersizeop><code>gpu.spmv_buffer_size</code> (gpu::SpMVBufferSizeOp)&nbsp;<a class=headline-hash href=#gpuspmv_buffer_size-gpuspmvbuffersizeop>¶</a></h3><p><em>Precompute buffersize for SpMV operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmv_buffer_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnX `,` $dnY attr-dict  `into` $computeType
</code></pre><p>The <code>gpu.spmv_buffer_size</code> operation returns the buffer size required
to perform the SpMV operation on the given sparse matrix and dense vectors.
The operation expects handles returned by previous sparse operations
to construct an environment and the operands for SpMV.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%buffersz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmv_buffer_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnX</span><span class=p>,</span> <span class=nv>%dnY</span> into <span class=k>f32</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnX</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnY</code></td><td>dense tensor handle type</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>bufferSz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmv-gpuspmvop><code>gpu.spmv</code> (gpu::SpMVOp)&nbsp;<a class=headline-hash href=#gpuspmv-gpuspmvop>¶</a></h3><p><em>SpMV operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmv` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmatA (`{` $modeA^ `}`)? `,` $dnX `,` $dnY `,` $buffer attr-dict `:` type($buffer) `into` $computeType
</code></pre><p>The <code>gpu.spmv</code> operation performs the SpMV operation on the given sparse matrix,
dense vectors, and buffer. The operation expects handles returned by previous
sparse operations to construct an environment and the operands for SpMV. The
buffer must have been allocated on the device.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a !gpu.async.token in addition to the environment.</p><p>The matrix arguments can also be associated with one of the following
operators: NON_TRANSPOSE, TRANSPOSE, CONJUGATE_TRANSPOSE. The default value
is NON_TRANSPOSE.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmv async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatA</span><span class=p>{</span>TRANSPOSE<span class=p>},</span> <span class=nv>%dnX</span><span class=p>,</span> <span class=nv>%dnY</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>f64</span><span class=p>&gt;</span> into <span class=k>bf16</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modeA</code></td><td>::mlir::gpu::TransposeModeAttr</td><td>transpose mode of sparse matrix supported by sparse tensor ops</td></tr><tr><td><code>computeType</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmatA</code></td><td>sparse matrix handle type</td></tr><tr><td style=text-align:center><code>dnX</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>dnY</code></td><td>dense tensor handle type</td></tr><tr><td style=text-align:center><code>buffer</code></td><td>memref of any type values</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuspmat_get_size-gpuspmatgetsizeop><code>gpu.spmat_get_size</code> (gpu::SpMatGetSizeOp)&nbsp;<a class=headline-hash href=#gpuspmat_get_size-gpuspmatgetsizeop>¶</a></h3><p><em>SpMat get size operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.spmat_get_size` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies)
              $spmat attr-dict
</code></pre><p>The <code>gpu.spmat_get_size</code> operation retrieves the number of rows, number of
columns, and number of non-zero elements of a sparse matrix.</p><p>If the <code>async</code> keyword is present, the op is executed asynchronously (i.e.
it does not block until the execution has finished on the device). In
that case, it returns a <code>!gpu.async.token</code> in addition to the environment.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%rows</span><span class=p>,</span> <span class=nv>%cols</span><span class=p>,</span> <span class=nv>%nnz</span><span class=p>,</span> <span class=nv>%token</span> <span class=p>=</span> gpu<span class=p>.</span>spmat_get_size async <span class=p>[</span><span class=nv>%dep</span><span class=p>]</span> <span class=nv>%spmatC</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr><tr><td style=text-align:center><code>spmat</code></td><td>sparse matrix handle type</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rows</code></td><td>index</td></tr><tr><td style=text-align:center><code>cols</code></td><td>index</td></tr><tr><td style=text-align:center><code>nnz</code></td><td>index</td></tr><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpusubgroup_broadcast-gpusubgroupbroadcastop><code>gpu.subgroup_broadcast</code> (gpu::SubgroupBroadcastOp)&nbsp;<a class=headline-hash href=#gpusubgroup_broadcast-gpusubgroupbroadcastop>¶</a></h3><p><em>Broadcasts a value from the specific lane across subgroup</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_broadcast` $src `,` $broadcast_type ($lane^)? attr-dict `:` type($result)
</code></pre><p>Broadcasts a value from one lane to all active lanes in a subgroup. The
result is guaranteed to be uniform across the active lanes in subgroup.</p><p>The possible broadcast types are:</p><ul><li><code>first_active_lane</code> - broadcasts the value from the first active lane
in the subgroup.</li><li><code>specific_lane</code> - broadcasts from the specified lane. The lane index
must be uniform and within the subgroup size. The result is poison if the
lane index is invalid, non subgroup-uniform, or if the source lane is not
active.</li></ul><p>Traits: <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>broadcast_type</code></td><td>::mlir::gpu::BroadcastTypeAttr</td><td>a lane to broadcast from</td></tr></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>any type</td></tr><tr><td style=text-align:center><code>lane</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=gpusubgroup_id-gpusubgroupidop><code>gpu.subgroup_id</code> (gpu::SubgroupIdOp)&nbsp;<a class=headline-hash href=#gpusubgroup_id-gpusubgroupidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_id` (`upper_bound` $upper_bound^)? attr-dict `:` type($result)
</code></pre><p>Returns the subgroup id, i.e., the index of the current subgroup within the
workgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%sgId</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_id <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>Executions where there are more than <code>upper_bound</code> subgroups per workgroup
cause undefined behavior. There is an implicit upper bound of <code>kMaxDim</code>
(currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gpusubgroup_mma_compute-gpusubgroupmmacomputeop><code>gpu.subgroup_mma_compute</code> (gpu::SubgroupMmaComputeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_compute-gpusubgroupmmacomputeop>¶</a></h3><p><em>GPU warp synchronous matrix multiply accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_compute` $opA`,` $opB`,` $opC attr-dict `:` type($opA)`,` type($opB) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_compute</code> operation performs a matrix-multiply accumulate (mma)
operation using all the threads in a subgroup.</p><p>This operation takes three <code>!gpu.mma_matrix</code>s as arguments: these hold <code>A</code>,
<code>B</code> and <code>C</code>operands for the mma operation. The operation performed is represented
as <code>C += A * B</code>. The op returns a <code>!gpu.mma_matrix</code> which contains the result of
the operation held by all threads in a subgroup. <code>a_transpose</code> or
<code>b_transpose</code> if present, signify that the respective operand was loaded in a
transposed manner. The transpose operands are required to map to correct
underlying intrisics but they currently do not seem to affect correctness
even if they are absent given that the operands were loaded correctly using
the <code>transpose</code> attribute in <code>gpu.subgroup_mma_load_matrix</code> op.</p><p>For integer types, the <code>A</code> and <code>B</code> matrices carry their signedness with their
types. The accumulator type is expected to be signless and imply a signed integer
with a greater width than the other two operands.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_load_matrix</code> ops.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%D</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_compute_matrix <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span><span class=p>,</span> <span class=nv>%C</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;BOp&#34;</span><span class=p>&gt;&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>a_transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>b_transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>opA</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float values</td></tr><tr><td style=text-align:center><code>opB</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 16-bit float or 32-bit float or 64-bit float values</td></tr><tr><td style=text-align:center><code>opC</code></td><td>gpu.mma_matrix of 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float values</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop><code>gpu.subgroup_mma_constant_matrix</code> (gpu::SubgroupMmaConstantMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_constant_matrix-gpusubgroupmmaconstantmatrixop>¶</a></h3><p><em>GPU warp synchronous constant matrix</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_constant_matrix` $value attr-dict `:` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_constant_matrix</code> creates a <code>!gpu.mma_matrix</code> with
constant elements.</p><p>The operation takes a scalar input and return a <code>!gpu.mma_matrix</code> where
each element of is equal to the operand constant. The destination
mma_matrix type must have elememt type equal to the constant type. Since
the layout of <code>!gpu.mma_matrix</code> is opaque this only support setting all the
elements to the same value.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%a</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl> <span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_constant_matrix <span class=nv>%b</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>   <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f32</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>8-bit signed integer or 8-bit unsigned integer or 32-bit signless integer or 16-bit float or 32-bit float</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop><code>gpu.subgroup_mma_elementwise</code> (gpu::SubgroupMmaElementwiseOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_elementwise-gpusubgroupmmaelementwiseop>¶</a></h3><p><em>GPU warp elementwise operation on a matrix</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_elementwise` $opType $args attr-dict `:` functional-type($args, $res)
</code></pre><p>The <code>gpu.subgroup_mma_elementwise</code> takes <code>!gpu.mma_matrix</code> inputs and
compute a new <code>!gpu.mma_matrix</code> by applying an elementwise operation to each
element.</p><p>Since the operation is elementwise and the matrix type must match, the
matrix elements are processed independently of the matrix layout.</p><p>This op is meant to be used along with <code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span>  <span class=nv>%A</span><span class=p>,</span> <span class=nv>%B</span> <span class=p>{</span> <span class=nl>opType =</span> <span class=s>&#34;ADD&#34;</span> <span class=p>}</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=p>(!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>  <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>opType</code></td><td>::mlir::gpu::MMAElementwiseOpAttr</td><td>elementwise operation to apply to mma matrix</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of MMAMatrix type</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_extract_thread_local-gpusubgroupmmaextractthreadlocalop><code>gpu.subgroup_mma_extract_thread_local</code> (gpu::SubgroupMmaExtractThreadLocalOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_extract_thread_local-gpusubgroupmmaextractthreadlocalop>¶</a></h3><p><em>Extract a value from GPU warp by invocation and indices</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_extract_thread_local` $matrix`[`$indices`]` attr-dict `:` type($matrix) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_extract_thread_local</code> operation extracts a value from <code>!gpu.mma_matrix</code>
that is stored at subgroup level.</p><p>This operation takes <code>!gpu.mma_matrix</code> as its first operand. It is the source
matrix across a subgroup. The op returns a scalar value stored in the invocation
in the subgroup.</p><p>Since <code>matrix</code> is packed into the the threads within a subgroup, <code>indices</code> are
the indices into the values stored by each thread. That is, an index of 0 (or [0, 0])
does not necessarily refer to the first element of the matrix, but the first element
that a particular thread holds.</p><p>The mapping of matrix elements to threads is not defined by this operation and may
not be defined by some lowerings (such as the lowering to SPIR-V). However, if the
size of the subgroup is S, then <code>subgroup_mma_extract_thread_local</code> at each index in
<code>[0, (M * N) / S)</code> will have the entire matrix extracted across the subgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%c0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl><span class=nv>%val</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_extract_thread_local <span class=nv>%m</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f32</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>MMAMatrix type</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>Integer or Float</td></tr></tbody></table><h3 id=gpusubgroup_mma_insert_thread_local-gpusubgroupmmainsertthreadlocalop><code>gpu.subgroup_mma_insert_thread_local</code> (gpu::SubgroupMmaInsertThreadLocalOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_insert_thread_local-gpusubgroupmmainsertthreadlocalop>¶</a></h3><p><em>Insert a value into GPU warp by invocation and indices</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_insert_thread_local` $value`,` $matrix`[`$indices`]` attr-dict `:` type($value)`,` type($matrix) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_insert_thread_local</code> operation inserts a value to <code>!gpu.mma_matrix</code>
that is stored at subgroup level.</p><p>This operation takes scalar value as its first operand and <code>!gpu.mma_matrix</code>
as its second operand. The op inserts the scalar value to the matrix.</p><p>Since <code>matrix</code> is packed into the the threads within a subgroup, <code>indices</code> are
the indices into the values stored by each thread. That is, an index of 0 (or [0, 0])
does not necessarily refer to the first element of the matrix, but the first element
that a particular thread holds.</p><p>The mapping of matrix elements to threads is not defined by this operation and may
not be defined by some lowerings (such as the lowering to SPIR-V). However, if the
size of the subgroup is S, then <code>subgroup_mma_insert_thread_local</code> at each index in
<code>[0, (M * N) / S)</code> will have the entire matrix inserted across the subgroup.</p><p>The op returns <code>!gpu.mma_matrix</code> with the updated value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%c0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl><span class=nv>%s0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_insert_thread_local <span class=nv>%val</span><span class=p>,</span> <span class=nv>%m</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=k>f16</span><span class=p>,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        <span class=p>-&gt;</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float</td></tr><tr><td style=text-align:center><code>matrix</code></td><td>MMAMatrix type</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop><code>gpu.subgroup_mma_load_matrix</code> (gpu::SubgroupMmaLoadMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_load_matrix-gpusubgroupmmaloadmatrixop>¶</a></h3><p><em>GPU warp synchronous matrix load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_load_matrix` $srcMemref`[`$indices`]` attr-dict `:` type($srcMemref) `-&gt;` type($res)
</code></pre><p>The <code>gpu.subgroup_mma_load_matrix</code> operation loads a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a memref as its first operand: it is the source matrix
from which data is to be loaded. The op returns a <code>!gpu.mma_matrix</code>. The
source memref can be in global memory or shared memory. The load address is
determined using <code>indices</code>. The matrix being loaded into is the result. The
<code>leadDimension</code> attribute specifies the leading dimension size of the source
matrix which eventually allows the lowering to determine the size of each
row. If the <code>transpose</code> attribute is present then the op does a transposed load.</p><p>For integer types, the resulting <code>!gpu.mma_matrix</code> type needs to specify the
signedness of the data if the matrix type is an <code>A</code> or <code>B</code> operand for
<code>gpu.subgroup_mma_compute</code>.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_store_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl> <span class=nv>%0</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_mma_load_matrix src<span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span><span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;,</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;AOp&#34;</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>leadDimension</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcMemref</code></td><td>memref of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float or vector of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float values of ranks 1 values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>MMAMatrix type</td></tr></tbody></table><h3 id=gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop><code>gpu.subgroup_mma_store_matrix</code> (gpu::SubgroupMmaStoreMatrixOp)&nbsp;<a class=headline-hash href=#gpusubgroup_mma_store_matrix-gpusubgroupmmastorematrixop>¶</a></h3><p><em>GPU warp synchronous matrix store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_mma_store_matrix` $src`,` $dstMemref`[`$indices`]` attr-dict `:` type($src)`,` type($dstMemref)
</code></pre><p>The <code>gpu.subgroup_mma_store_matrix</code> operation stores a matrix collectively
using all the threads in a subgroup.</p><p>This operation takes a <code>!gpu.mma_matrix</code> and a memref as operands.
<code>!gpu.mma_matrix</code> is the source value containing the data to be stored into the
destination memref which can be in global or shared memory. The store address
is determined using the indices provided. The <code>leadDimension</code> attribute
specifies the leading dimension of the destination matrix. If the
<code>transpose</code> attribute is present then the op does a transposed store.</p><p>This op is often meant to be used along with <code>gpu.subgroup_mma_load_matrix</code> and
<code>gpu.subgroup_mma_compute</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>subgroup_mma_store_matrix <span class=nv>%D</span><span class=p>,</span> <span class=nv>%sg</span><span class=p>[</span><span class=nv>%i</span><span class=p>,</span><span class=nv>%j</span><span class=p>]</span> <span class=p>:</span> <span class=p>{</span> <span class=nl>leadDimension =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>mma_matrix<span class=p>&lt;</span><span class=m>16x16x</span><span class=k>f16</span><span class=p>,</span> <span class=s>&#34;COp&#34;</span><span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>32x32x</span><span class=k>f16</span><span class=p>,</span> <span class=m>3</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>MemoryEffectOpInterface (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</code></p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>leadDimension</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>gpu.mma_matrix of 8-bit signed integer or 8-bit unsigned integer or 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float values</td></tr><tr><td style=text-align:center><code>dstMemref</code></td><td>memref of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float or vector of 8-bit signless integer or 32-bit signless integer or 16-bit float or 32-bit float or 64-bit float values of ranks 1 values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h3 id=gpusubgroup_reduce-gpusubgroupreduceop><code>gpu.subgroup_reduce</code> (gpu::SubgroupReduceOp)&nbsp;<a class=headline-hash href=#gpusubgroup_reduce-gpusubgroupreduceop>¶</a></h3><p><em>Reduce values among subgroup.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_reduce` custom&lt;AllReduceOperation&gt;($op) $value
              (`uniform` $uniform^)?
              (`cluster` `(` `size` `=` $cluster_size^ (`,` `stride` `=` $cluster_stride^)? `)`)?
              attr-dict
              `:` functional-type(operands, results)
</code></pre><p>The <code>subgroup_reduce</code> op reduces the values of lanes (work items) across a
subgroup.</p><p>The subgroup is divided into clusters starting at lane index 0. Within each
cluster, there are <code>size</code> lanes, and the lane index advances by <code>stride</code>.
A reduction is done for each cluster in parallel: every lane in the cluster
is reduced, and the result is equal for all lanes in the cluster. If <code>size</code>
is omitted, there is a single cluster covering the entire subgroup. If
<code>stride</code> is omitted, the stride is 1 (the cluster&rsquo;s lanes are contiguous).</p><p>When the reduced value is of a vector type, each vector element is reduced
independently. Only 1-d vector types are allowed.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_reduce add <span class=nv>%a</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_reduce add <span class=nv>%b</span> <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_reduce add <span class=nv>%c</span> cluster<span class=p>(</span><span class=nl>size =</span> <span class=m>4</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_reduce add <span class=nv>%c</span> cluster<span class=p>(</span><span class=nl>size =</span> <span class=m>4</span><span class=p>,</span> <span class=nl>stride =</span> <span class=m>2</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span></code></pre></div><p>If <code>uniform</code> flag is set either none or all lanes of a subgroup need to execute
this op in convergence.</p><p>The reduction operation must be one of:</p><ul><li>Integer types: <code>add</code>, <code>mul</code>, <code>minui</code>, <code>minsi</code>, <code>maxui</code>, <code>maxsi</code>, <code>and</code>,
<code>or</code>, <code>xor</code></li><li>Floating point types: <code>add</code>, <code>mul</code>, <code>minnumf</code>, <code>maxnumf</code>, <code>minimumf</code>,
<code>maximumf</code></li></ul><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>op</code></td><td>::mlir::gpu::AllReduceOperationAttr</td><td>built-in reduction operations supported by gpu.allreduce.</td></tr><tr><td><code>uniform</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>cluster_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cluster_stride</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>Integer or Float or fixed-length vector of Integer or Float values of ranks 1</td></tr></tbody></table><h3 id=gpusubgroup_size-gpusubgroupsizeop><code>gpu.subgroup_size</code> (gpu::SubgroupSizeOp)&nbsp;<a class=headline-hash href=#gpusubgroup_size-gpusubgroupsizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.subgroup_size` (`upper_bound` $upper_bound^)? attr-dict `:` type($result)
</code></pre><p>Returns the number of threads within a subgroup.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%sgSz</span> <span class=p>=</span> gpu<span class=p>.</span>subgroup_size <span class=p>:</span> <span class=k>index</span>
</span></span></code></pre></div><p>Executions where the number of threads per subgroup exceed <code>upper_bound</code> cause
undefined behavior. When no <code>upper_bound</code> is specified, range analyses and
similar machinery assume the default bound of <code>kMaxSubgroupSize</code>, currently
128.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=gputerminator-gputerminatorop><code>gpu.terminator</code> (gpu::TerminatorOp)&nbsp;<a class=headline-hash href=#gputerminator-gputerminatorop>¶</a></h3><p><em>Terminator for GPU launch regions.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.terminator` attr-dict
</code></pre><p>A terminator operation for regions that appear in the body of <code>gpu.launch</code>
operation. These regions are not expected to return any value so the
terminator takes no operands.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;LaunchOp></code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h3 id=gputhread_id-gputhreadidop><code>gpu.thread_id</code> (gpu::ThreadIdOp)&nbsp;<a class=headline-hash href=#gputhread_id-gputhreadidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.thread_id` $dimension (`upper_bound` $upper_bound^)? attr-dict
</code></pre><p>Returns the thread id, i.e. the index of the current thread within the block
along the x, y, or z <code>dimension</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tIdX</span> <span class=p>=</span> gpu<span class=p>.</span>thread_id <span class=p>x</span>
</span></span></code></pre></div><p>If <code>upper_bound</code> is set, or if one can be inferred from <code>known_block_size</code>-type
annotations in context, executions where the thread index would be greater
than or equal to that bound cause undefined behavior.</p><p>There is an implicit upper bound of <code>kMaxDim</code> (currently uint32_t::max).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dimension</code></td><td>::mlir::gpu::DimensionAttr</td><td>a dimension, either 'x', 'y', or 'z'</td></tr><tr><td><code>upper_bound</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=gpuwait-gpuwaitop><code>gpu.wait</code> (gpu::WaitOp)&nbsp;<a class=headline-hash href=#gpuwait-gpuwaitop>¶</a></h3><p><em>Wait for async gpu ops to complete.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.wait` custom&lt;AsyncDependencies&gt;(type($asyncToken), $asyncDependencies) attr-dict
</code></pre><p>This op synchronizes the host or the device with a list of dependent ops.</p><p>If the op contains the <code>async</code> keyword, it returns a new async token which
is synchronized with the op arguments. This new token is merely a shortcut
to the argument list, and one could replace the uses of the result with the
arguments for the same effect. The async version of this op is primarily
used to make each async token have a single use during lowering and
thereby make forks in async execution explicit. Example usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t2</span> <span class=p>=</span> gpu<span class=p>.</span>wait async <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c>// gpu.baz doesn&#39;t run until gpu.foo and gpu.bar have both completed, just
</span></span></span><span class=line><span class=cl><span class=c>// as if the async dependencies were [%t0, %t1].
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%t3</span> <span class=p>=</span> gpu<span class=p>.</span>baz async <span class=p>[</span><span class=nv>%t2</span><span class=p>]</span>
</span></span></code></pre></div><p>If the op does not contain the <code>async</code> keyword, it does not return a new
async token but blocks until all ops producing the async dependency tokens
finished execution. All dependent memory operations are visible to the host
once this op completes. Example usage:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%t0</span> <span class=p>=</span> gpu<span class=p>.</span>foo async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=nv>%t1</span> <span class=p>=</span> gpu<span class=p>.</span>bar async <span class=p>:</span> <span class=p>!</span>gpu<span class=p>.</span>async<span class=p>.</span>token
</span></span><span class=line><span class=cl><span class=c>// The gpu.wait op blocks until gpu.foo and gpu.bar have completed.
</span></span></span><span class=line><span class=cl><span class=c></span>gpu<span class=p>.</span>wait <span class=p>[</span><span class=nv>%t0</span><span class=p>,</span> <span class=nv>%t1</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: <code>GPU_AsyncOpInterface</code></p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncDependencies</code></td><td>variadic of async token type</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>asyncToken</code></td><td>async token type</td></tr></tbody></table><h3 id=gpuwarp_execute_on_lane_0-gpuwarpexecuteonlane0op><code>gpu.warp_execute_on_lane_0</code> (gpu::WarpExecuteOnLane0Op)&nbsp;<a class=headline-hash href=#gpuwarp_execute_on_lane_0-gpuwarpexecuteonlane0op>¶</a></h3><p><em>Executes operations in the associated region on thread #0 of aSPMD program</em></p><p><code>warp_execute_on_lane_0</code> is an operation used to bridge the gap between
vector programming and SPMD programming model like GPU SIMT. It allows to
trivially convert a region of vector code meant to run on a multiple threads
into a valid SPMD region and then allows incremental transformation to
distribute vector operations on the threads.</p><p>Any code present in the region would only be executed on first thread/lane
based on the <code>laneid</code> operand. The <code>laneid</code> operand is an integer ID between
[0, <code>warp_size</code>). The <code>warp_size</code> attribute indicates the number of lanes in
a warp.</p><p>Operands are vector values distributed on all lanes that may be used by
the single lane execution. The matching region argument is a vector of all
the values of those lanes available to the single active lane. The
distributed dimension is implicit based on the shape of the operand and
argument. the properties of the distribution may be described by extra
attributes (e.g. affine map).</p><p>Return values are distributed on all lanes using laneId as index. The
vector is distributed based on the shape ratio between the vector type of
the yield and the result type.
If the shapes are the same this means the value is broadcasted to all lanes.
In the future the distribution can be made more explicit using affine_maps
and will support having multiple Ids.</p><p>Therefore the <code>warp_execute_on_lane_0</code> operations allow to implicitly copy
between lane0 and the lanes of the warp. When distributing a vector
from lane0 to all the lanes, the data are distributed in a block cyclic way.
For example <code>vector&lt;64xf32></code> gets distributed on 32 threads and map to
<code>vector&lt;2xf32></code> where thread 0 contains vector[0] and vector[1].</p><p>During lowering values passed as operands and return value need to be
visible to different lanes within the warp. This would usually be done by
going through memory.</p><p>The region is <em>not</em> isolated from above. For values coming from the parent
region not going through operands only the lane 0 value will be accesible so
it generally only make sense for uniform values.</p><p>Example:</p><pre tabindex=0><code>// Execute in parallel on all threads/lanes.
gpu.warp_execute_on_lane_0 (%laneid)[32] {
  // Serial code running only on thread/lane 0.
  ...
}
// Execute in parallel on all threads/lanes.
</code></pre><p>This may be lowered to an scf.if region as below:</p><pre tabindex=0><code>  // Execute in parallel on all threads/lanes.
  %cnd = arith.cmpi eq, %laneid, %c0 : index
  scf.if %cnd {
    // Serial code running only on thread/lane 0.
    ...
  }
  // Execute in parallel on all threads/lanes.
</code></pre><p>When the region has operands and/or return values:</p><pre tabindex=0><code>// Execute in parallel on all threads/lanes.
%0 = gpu.warp_execute_on_lane_0(%laneid)[32]
args(%v0 : vector&lt;4xi32&gt;) -&gt; (vector&lt;1xf32&gt;) {
^bb0(%arg0 : vector&lt;128xi32&gt;) :
  // Serial code running only on thread/lane 0.
  ...
  gpu.yield %1 : vector&lt;32xf32&gt;
}
// Execute in parallel on all threads/lanes.
</code></pre><p>values at the region boundary would go through memory:</p><pre tabindex=0><code>// Execute in parallel on all threads/lanes.
...
// Store the data from each thread into memory and Synchronization.
%tmp0 = memreg.alloc() : memref&lt;128xf32&gt;
%tmp1 = memreg.alloc() : memref&lt;32xf32&gt;
%cnd = arith.cmpi eq, %laneid, %c0 : index
vector.store %v0, %tmp0[%laneid] : memref&lt;128xf32&gt;, vector&lt;4xf32&gt;
some_synchronization_primitive
scf.if %cnd {
  // Serialized code running only on thread 0.
  // Load the data from all the threads into a register from thread 0. This
  // allow threads 0 to access data from all the threads.
  %arg0 = vector.load %tmp0[%c0] : memref&lt;128xf32&gt;, vector&lt;128xf32&gt;
  ...
  // Store the data from thread 0 into memory.
  vector.store %1, %tmp1[%c0] : memref&lt;32xf32&gt;, vector&lt;32xf32&gt;
}
// Synchronization and load the data in a block cyclic way so that the
// vector is distributed on all threads.
some_synchronization_primitive
%0 = vector.load %tmp1[%laneid] : memref&lt;32xf32&gt;, vector&lt;32xf32&gt;
// Execute in parallel on all threads/lanes.
</code></pre><p>Traits: <code>RecursiveMemoryEffects</code>, <code>SingleBlockImplicitTerminator&lt;gpu::YieldOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>RegionBranchOpInterface</code></p><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>warp_size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>laneid</code></td><td>index</td></tr><tr><td style=text-align:center><code>args</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=gpuyield-gpuyieldop><code>gpu.yield</code> (gpu::YieldOp)&nbsp;<a class=headline-hash href=#gpuyield-gpuyieldop>¶</a></h3><p><em>GPU yield operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `gpu.yield` attr-dict ($values^ `:` type($values))?
</code></pre><p><code>gpu.yield</code> is a special terminator operation for blocks inside regions
in gpu ops. It returns values to the immediately enclosing gpu op.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>gpu<span class=p>.</span>yield <span class=nv>%f0</span><span class=p>,</span> <span class=nv>%f1</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=k>f32</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>variadic of any type</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Func/ title="'func' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'func' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/IndexOps/ title="'index' Dialect">Next - 'index' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>