<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'pdl_interp' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'pdl_interp' Dialect</h1><p><em>Interpreted pattern execution dialect</em></p><p>The PDL Interpreter dialect provides a lower level abstraction compared to
the PDL dialect, and is targeted towards low level optimization and
interpreter code generation. The dialect operations encapsulates
low-level pattern match and rewrite &ldquo;primitives&rdquo;, such as navigating the
IR (Operation::getOperand), creating new operations (OpBuilder::create),
etc. Many of the operations within this dialect also fuse branching control
flow with some form of a predicate comparison operation. This type of fusion
reduces the amount of work that an interpreter must do when executing.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#pdl_interpapply_constraint-pdl_interpapplyconstraintop><code>pdl_interp.apply_constraint</code> (pdl_interp::ApplyConstraintOp)</a></li><li><a href=#pdl_interpapply_rewrite-pdl_interpapplyrewriteop><code>pdl_interp.apply_rewrite</code> (pdl_interp::ApplyRewriteOp)</a></li><li><a href=#pdl_interpare_equal-pdl_interpareequalop><code>pdl_interp.are_equal</code> (pdl_interp::AreEqualOp)</a></li><li><a href=#pdl_interpbranch-pdl_interpbranchop><code>pdl_interp.branch</code> (pdl_interp::BranchOp)</a></li><li><a href=#pdl_interpcheck_attribute-pdl_interpcheckattributeop><code>pdl_interp.check_attribute</code> (pdl_interp::CheckAttributeOp)</a></li><li><a href=#pdl_interpcheck_operand_count-pdl_interpcheckoperandcountop><code>pdl_interp.check_operand_count</code> (pdl_interp::CheckOperandCountOp)</a></li><li><a href=#pdl_interpcheck_operation_name-pdl_interpcheckoperationnameop><code>pdl_interp.check_operation_name</code> (pdl_interp::CheckOperationNameOp)</a></li><li><a href=#pdl_interpcheck_result_count-pdl_interpcheckresultcountop><code>pdl_interp.check_result_count</code> (pdl_interp::CheckResultCountOp)</a></li><li><a href=#pdl_interpcheck_type-pdl_interpchecktypeop><code>pdl_interp.check_type</code> (pdl_interp::CheckTypeOp)</a></li><li><a href=#pdl_interpcheck_types-pdl_interpchecktypesop><code>pdl_interp.check_types</code> (pdl_interp::CheckTypesOp)</a></li><li><a href=#pdl_interpcontinue-pdl_interpcontinueop><code>pdl_interp.continue</code> (pdl_interp::ContinueOp)</a></li><li><a href=#pdl_interpcreate_attribute-pdl_interpcreateattributeop><code>pdl_interp.create_attribute</code> (pdl_interp::CreateAttributeOp)</a></li><li><a href=#pdl_interpcreate_operation-pdl_interpcreateoperationop><code>pdl_interp.create_operation</code> (pdl_interp::CreateOperationOp)</a></li><li><a href=#pdl_interpcreate_range-pdl_interpcreaterangeop><code>pdl_interp.create_range</code> (pdl_interp::CreateRangeOp)</a></li><li><a href=#pdl_interpcreate_type-pdl_interpcreatetypeop><code>pdl_interp.create_type</code> (pdl_interp::CreateTypeOp)</a></li><li><a href=#pdl_interpcreate_types-pdl_interpcreatetypesop><code>pdl_interp.create_types</code> (pdl_interp::CreateTypesOp)</a></li><li><a href=#pdl_interperase-pdl_interperaseop><code>pdl_interp.erase</code> (pdl_interp::EraseOp)</a></li><li><a href=#pdl_interpextract-pdl_interpextractop><code>pdl_interp.extract</code> (pdl_interp::ExtractOp)</a></li><li><a href=#pdl_interpfinalize-pdl_interpfinalizeop><code>pdl_interp.finalize</code> (pdl_interp::FinalizeOp)</a></li><li><a href=#pdl_interpforeach-pdl_interpforeachop><code>pdl_interp.foreach</code> (pdl_interp::ForEachOp)</a></li><li><a href=#pdl_interpfunc-pdl_interpfuncop><code>pdl_interp.func</code> (pdl_interp::FuncOp)</a></li><li><a href=#pdl_interpget_attribute-pdl_interpgetattributeop><code>pdl_interp.get_attribute</code> (pdl_interp::GetAttributeOp)</a></li><li><a href=#pdl_interpget_attribute_type-pdl_interpgetattributetypeop><code>pdl_interp.get_attribute_type</code> (pdl_interp::GetAttributeTypeOp)</a></li><li><a href=#pdl_interpget_defining_op-pdl_interpgetdefiningopop><code>pdl_interp.get_defining_op</code> (pdl_interp::GetDefiningOpOp)</a></li><li><a href=#pdl_interpget_operand-pdl_interpgetoperandop><code>pdl_interp.get_operand</code> (pdl_interp::GetOperandOp)</a></li><li><a href=#pdl_interpget_operands-pdl_interpgetoperandsop><code>pdl_interp.get_operands</code> (pdl_interp::GetOperandsOp)</a></li><li><a href=#pdl_interpget_result-pdl_interpgetresultop><code>pdl_interp.get_result</code> (pdl_interp::GetResultOp)</a></li><li><a href=#pdl_interpget_results-pdl_interpgetresultsop><code>pdl_interp.get_results</code> (pdl_interp::GetResultsOp)</a></li><li><a href=#pdl_interpget_users-pdl_interpgetusersop><code>pdl_interp.get_users</code> (pdl_interp::GetUsersOp)</a></li><li><a href=#pdl_interpget_value_type-pdl_interpgetvaluetypeop><code>pdl_interp.get_value_type</code> (pdl_interp::GetValueTypeOp)</a></li><li><a href=#pdl_interpis_not_null-pdl_interpisnotnullop><code>pdl_interp.is_not_null</code> (pdl_interp::IsNotNullOp)</a></li><li><a href=#pdl_interprecord_match-pdl_interprecordmatchop><code>pdl_interp.record_match</code> (pdl_interp::RecordMatchOp)</a></li><li><a href=#pdl_interpreplace-pdl_interpreplaceop><code>pdl_interp.replace</code> (pdl_interp::ReplaceOp)</a></li><li><a href=#pdl_interpswitch_attribute-pdl_interpswitchattributeop><code>pdl_interp.switch_attribute</code> (pdl_interp::SwitchAttributeOp)</a></li><li><a href=#pdl_interpswitch_operand_count-pdl_interpswitchoperandcountop><code>pdl_interp.switch_operand_count</code> (pdl_interp::SwitchOperandCountOp)</a></li><li><a href=#pdl_interpswitch_operation_name-pdl_interpswitchoperationnameop><code>pdl_interp.switch_operation_name</code> (pdl_interp::SwitchOperationNameOp)</a></li><li><a href=#pdl_interpswitch_result_count-pdl_interpswitchresultcountop><code>pdl_interp.switch_result_count</code> (pdl_interp::SwitchResultCountOp)</a></li><li><a href=#pdl_interpswitch_type-pdl_interpswitchtypeop><code>pdl_interp.switch_type</code> (pdl_interp::SwitchTypeOp)</a></li><li><a href=#pdl_interpswitch_types-pdl_interpswitchtypesop><code>pdl_interp.switch_types</code> (pdl_interp::SwitchTypesOp)</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/PDLInterp/IR/PDLInterpOps.td>source</a></p><h3 id=pdl_interpapply_constraint-pdl_interpapplyconstraintop><code>pdl_interp.apply_constraint</code> (pdl_interp::ApplyConstraintOp)&nbsp;<a class=headline-hash href=#pdl_interpapply_constraint-pdl_interpapplyconstraintop>¶</a></h3><p><em>Apply a constraint to a set of positional values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.apply_constraint` $name `(` $args `:` type($args) `)` (`:` type($results)^)? attr-dict
              `-&gt;` successors
</code></pre><p><code>pdl_interp.apply_constraint</code> operations apply a generic constraint, that
has been registered with the interpreter, with a given set of positional
values.
The constraint function may return any number of results.
On success, this operation branches to the true destination,
otherwise the false destination is taken. This behavior can be reversed
by setting the attribute <code>isNegated</code> to true.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Apply `myConstraint` to the entities defined by `input`, `attr`, and
</span></span></span><span class=line><span class=cl><span class=c>// `op`.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>apply_constraint <span class=s>&#34;myConstraint&#34;</span><span class=p>(</span><span class=nv>%input</span><span class=p>,</span> <span class=nv>%attr</span><span class=p>,</span> <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>attribute<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>Terminator</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>isNegated</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of pdl type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of pdl type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpapply_rewrite-pdl_interpapplyrewriteop><code>pdl_interp.apply_rewrite</code> (pdl_interp::ApplyRewriteOp)&nbsp;<a class=headline-hash href=#pdl_interpapply_rewrite-pdl_interpapplyrewriteop>¶</a></h3><p><em>Invoke and apply an externally registered rewrite method</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.apply_rewrite` $name (`(` $args^ `:` type($args) `)`)? (`:` type($results)^)? attr-dict
</code></pre><p><code>pdl_interp.apply_rewrite</code> operations invoke an external rewriter that has
been registered with the interpreter to perform the rewrite after a
successful match. The rewrite is passed a set of positional arguments. The
rewrite function may return any number of results.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Rewriter operating solely on the root operation.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span><span class=p>(</span><span class=nv>%root</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Rewriter operating solely on the root operation and return an attribute.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%attr</span> <span class=p>=</span> pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span><span class=p>(</span><span class=nv>%root</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>attribute
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Rewriter operating on the root operation along with additional arguments
</span></span></span><span class=line><span class=cl><span class=c>// from the matcher.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>apply_rewrite <span class=s>&#34;rewriter&#34;</span><span class=p>(</span><span class=nv>%root</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>,</span> <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span>
</span></span></code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of pdl type</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>variadic of pdl type</td></tr></tbody></table><h3 id=pdl_interpare_equal-pdl_interpareequalop><code>pdl_interp.are_equal</code> (pdl_interp::AreEqualOp)&nbsp;<a class=headline-hash href=#pdl_interpare_equal-pdl_interpareequalop>¶</a></h3><p><em>Check if two positional values or ranges are equivalent</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.are_equal` operands `:` type($lhs) attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.are_equal</code> operations compare two positional values for
equality. On success, this operation branches to the true destination,
otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>are_equal <span class=nv>%result1</span><span class=p>,</span> <span class=nv>%result2</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>pdl type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>pdl type</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpbranch-pdl_interpbranchop><code>pdl_interp.branch</code> (pdl_interp::BranchOp)&nbsp;<a class=headline-hash href=#pdl_interpbranch-pdl_interpbranchop>¶</a></h3><p><em>General branch operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.branch` $dest attr-dict
</code></pre><p><code>pdl_interp.branch</code> operations expose general branch functionality to the
interpreter, and are generally used to branch from one pattern match
sequence to another.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>branch <span class=nl>^dest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_attribute-pdl_interpcheckattributeop><code>pdl_interp.check_attribute</code> (pdl_interp::CheckAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_attribute-pdl_interpcheckattributeop>¶</a></h3><p><em>Check the value of an <code>Attribute</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_attribute` $attribute `is` $constantValue attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_attribute</code> operations compare the value of a given
attribute with a constant value. On success, this operation branches to the
true destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>check_attribute <span class=nv>%attr</span> is <span class=m>10</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>constantValue</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attribute</code></td><td>PDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=successors-3>Successors:&nbsp;<a class=headline-hash href=#successors-3>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_operand_count-pdl_interpcheckoperandcountop><code>pdl_interp.check_operand_count</code> (pdl_interp::CheckOperandCountOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_operand_count-pdl_interpcheckoperandcountop>¶</a></h3><p><em>Check the number of operands of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_operand_count` `of` $inputOp `is` (`at_least` $compareAtLeast^)? $count attr-dict
              `-&gt;` successors
</code></pre><p><code>pdl_interp.check_operand_count</code> operations compare the number of operands
of a given operation value with a constant. The comparison is either exact
or at_least, with the latter used to compare against a minimum number of
expected operands. On success, this operation branches to the true
destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Check for exact equality.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>check_operand_count of <span class=nv>%op</span> is <span class=m>2</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl></span><span class=c>// Check for at least N operands.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>check_operand_count of <span class=nv>%op</span> is at_least <span class=m>2</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr><tr><td><code>compareAtLeast</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-4>Successors:&nbsp;<a class=headline-hash href=#successors-4>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_operation_name-pdl_interpcheckoperationnameop><code>pdl_interp.check_operation_name</code> (pdl_interp::CheckOperationNameOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_operation_name-pdl_interpcheckoperationnameop>¶</a></h3><p><em>Check the OperationName of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_operation_name` `of` $inputOp `is` $name attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_operation_name</code> operations compare the name of a given
operation with a known name. On success, this operation branches to the true
destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>check_operation_name of <span class=nv>%op</span> is <span class=s>&#34;foo.op&#34;</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-5>Successors:&nbsp;<a class=headline-hash href=#successors-5>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_result_count-pdl_interpcheckresultcountop><code>pdl_interp.check_result_count</code> (pdl_interp::CheckResultCountOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_result_count-pdl_interpcheckresultcountop>¶</a></h3><p><em>Check the number of results of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_result_count` `of` $inputOp `is` (`at_least` $compareAtLeast^)? $count attr-dict
              `-&gt;` successors
</code></pre><p><code>pdl_interp.check_result_count</code> operations compare the number of results
of a given operation value with a constant. The comparison is either exact
or at_least, with the latter used to compare against a minimum number of
expected results. On success, this operation branches to the true
destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Check for exact equality.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>check_result_count of <span class=nv>%op</span> is <span class=m>2</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span><span class=line><span class=cl><span class=nl>
</span></span></span><span class=line><span class=cl><span class=nl></span><span class=c>// Check for at least N results.
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>check_result_count of <span class=nv>%op</span> is at_least <span class=m>2</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr><tr><td><code>compareAtLeast</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-6>Successors:&nbsp;<a class=headline-hash href=#successors-6>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_type-pdl_interpchecktypeop><code>pdl_interp.check_type</code> (pdl_interp::CheckTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_type-pdl_interpchecktypeop>¶</a></h3><p><em>Compare a type to a known value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_type` $value `is` $type attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_type</code> operations compare a type with a statically known
type. On success, this operation branches to the true destination, otherwise
the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>check_type <span class=nv>%type</span> is <span class=k>i32</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h4 id=successors-7>Successors:&nbsp;<a class=headline-hash href=#successors-7>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcheck_types-pdl_interpchecktypesop><code>pdl_interp.check_types</code> (pdl_interp::CheckTypesOp)&nbsp;<a class=headline-hash href=#pdl_interpcheck_types-pdl_interpchecktypesop>¶</a></h3><p><em>Compare a range of types to a range of known values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.check_types` $value `are` $types attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.check_types</code> operations compare a range of types with a
statically known range of types. On success, this operation branches
to the true destination, otherwise the false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>check_types <span class=nv>%type</span> are <span class=p>[</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>]</span> <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>types</code></td><td>::mlir::ArrayAttr</td><td>type array attribute</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>range of PDL handle to an <code>mlir::Type</code> values</td></tr></tbody></table><h4 id=successors-8>Successors:&nbsp;<a class=headline-hash href=#successors-8>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpcontinue-pdl_interpcontinueop><code>pdl_interp.continue</code> (pdl_interp::ContinueOp)&nbsp;<a class=headline-hash href=#pdl_interpcontinue-pdl_interpcontinueop>¶</a></h3><p><em>Breaks the current iteration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.continue` attr-dict
</code></pre><p><code>pdl_interp.continue</code> operation breaks the current iteration within the
<code>pdl_interp.foreach</code> region and continues with the next iteration from
the beginning of the region.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>continue
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;ForEachOp></code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h3 id=pdl_interpcreate_attribute-pdl_interpcreateattributeop><code>pdl_interp.create_attribute</code> (pdl_interp::CreateAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_attribute-pdl_interpcreateattributeop>¶</a></h3><p><em>Create an interpreter handle to a constant <code>Attribute</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.create_attribute` $value attr-dict-with-keyword
</code></pre><p><code>pdl_interp.create_attribute</code> operations generate a handle within the
interpreter for a specific constant attribute value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%attr</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_attribute <span class=m>10</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attribute</code></td><td>PDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=pdl_interpcreate_operation-pdl_interpcreateoperationop><code>pdl_interp.create_operation</code> (pdl_interp::CreateOperationOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_operation-pdl_interpcreateoperationop>¶</a></h3><p><em>Create an instance of a specific <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.create_operation` $name (`(` $inputOperands^ `:` type($inputOperands) `)`)? ``
              custom&lt;CreateOperationOpAttributes&gt;($inputAttributes, $inputAttributeNames)
              custom&lt;CreateOperationOpResults&gt;($inputResultTypes, type($inputResultTypes),
              $inferredResultTypes)
              attr-dict
</code></pre><p><code>pdl_interp.create_operation</code> operations create an <code>Operation</code> instance with
the specified attributes, operands, and result types. See <code>pdl.operation</code>
for a more detailed description on the general interpretation of the arguments
to this operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create an instance of a `foo.op` operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span> <span class=p>{</span><span class=s>&#34;attrA&#34;</span> <span class=p>=</span> <span class=nv>%attr0</span><span class=p>}</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=nv>%type</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>type<span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Create an instance of a `foo.op` operation that has inferred result types
</span></span></span><span class=line><span class=cl><span class=c>// (using the InferTypeOpInterface).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_operation <span class=s>&#34;foo.op&#34;</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>)</span> <span class=p>{</span><span class=s>&#34;attrA&#34;</span> <span class=p>=</span> <span class=nv>%attr0</span><span class=p>}</span> <span class=p>-&gt;</span> <span class=p>&lt;</span>inferred<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>inputAttributeNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>inferredResultTypes</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOperands</code></td><td>variadic of single element or range of PDL handle for an <code>mlir::Value</code></td></tr><tr><td style=text-align:center><code>inputAttributes</code></td><td>variadic of PDL handle to an <code>mlir::Attribute</code></td></tr><tr><td style=text-align:center><code>inputResultTypes</code></td><td>variadic of single element or range of PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>resultOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h3 id=pdl_interpcreate_range-pdl_interpcreaterangeop><code>pdl_interp.create_range</code> (pdl_interp::CreateRangeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_range-pdl_interpcreaterangeop>¶</a></h3><p><em>Construct a range of PDL entities</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.create_range` ($arguments^ `:` type($arguments))?
              custom&lt;RangeType&gt;(ref(type($arguments)), type($result))
              attr-dict
</code></pre><p><code>pdl_interp.create_range</code> operations construct a range from a given set of PDL
entities, which all share the same underlying element type. For example, a
<code>!pdl.range&lt;value></code> may be constructed from a list of <code>!pdl.value</code>
or <code>!pdl.range&lt;value></code> entities.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Construct a range of values.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%valueRange</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_range <span class=nv>%inputValue</span><span class=p>,</span> <span class=nv>%inputRange</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Construct a range of types.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%typeRange</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_range <span class=nv>%inputType</span><span class=p>,</span> <span class=nv>%inputRange</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>type<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>type<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Construct an empty range of types.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%valueRange</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_range <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>type<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arguments</code></td><td>variadic of pdl type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>range of PDL handle to an <code>mlir::Type</code> or PDL handle for an <code>mlir::Value</code> values</td></tr></tbody></table><h3 id=pdl_interpcreate_type-pdl_interpcreatetypeop><code>pdl_interp.create_type</code> (pdl_interp::CreateTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_type-pdl_interpcreatetypeop>¶</a></h3><p><em>Create an interpreter handle to a constant <code>Type</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.create_type` $value attr-dict
</code></pre><p><code>pdl_interp.create_type</code> operations generate a handle within the interpreter
for a specific constant type value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>create_type <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h3 id=pdl_interpcreate_types-pdl_interpcreatetypesop><code>pdl_interp.create_types</code> (pdl_interp::CreateTypesOp)&nbsp;<a class=headline-hash href=#pdl_interpcreate_types-pdl_interpcreatetypesop>¶</a></h3><p><em>Create an interpreter handle to a range of constant <code>Type</code>s</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.create_types` $value attr-dict
</code></pre><p><code>pdl_interp.create_types</code> operations generate a handle within the
interpreter for a specific range of constant type values.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>create_types <span class=p>[</span><span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>]</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::ArrayAttr</td><td>type array attribute</td></tr></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>range of PDL handle to an <code>mlir::Type</code> values</td></tr></tbody></table><h3 id=pdl_interperase-pdl_interperaseop><code>pdl_interp.erase</code> (pdl_interp::EraseOp)&nbsp;<a class=headline-hash href=#pdl_interperase-pdl_interperaseop>¶</a></h3><p><em>Mark an operation as <code>erased</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.erase` $inputOp attr-dict
</code></pre><p><code>pdl.erase</code> operations are used to specify that an operation should be
marked as erased. The semantics of this operation correspond with the
<code>eraseOp</code> method on a <code>PatternRewriter</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>erase <span class=nv>%root</span>
</span></span></code></pre></div><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h3 id=pdl_interpextract-pdl_interpextractop><code>pdl_interp.extract</code> (pdl_interp::ExtractOp)&nbsp;<a class=headline-hash href=#pdl_interpextract-pdl_interpextractop>¶</a></h3><p><em>Extract the item at the specified index in a range</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.extract` $index `of` $range `:` type($result) attr-dict
</code></pre><p><code>pdl_interp.extract</code> operations are used to extract an item from a range
at the specified index. If the index is out of range, returns null.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Extract the value at index 1 from a range of values.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%ops</span> <span class=p>=</span> pdl_interp<span class=p>.</span>extract <span class=m>1</span> of <span class=nv>%values</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>range</code></td><td>range of pdl type values</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>pdl type</td></tr></tbody></table><h3 id=pdl_interpfinalize-pdl_interpfinalizeop><code>pdl_interp.finalize</code> (pdl_interp::FinalizeOp)&nbsp;<a class=headline-hash href=#pdl_interpfinalize-pdl_interpfinalizeop>¶</a></h3><p><em>Finalize a pattern match or rewrite sequence</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.finalize` attr-dict
</code></pre><p><code>pdl_interp.finalize</code> is used to denote the termination of a match or
rewrite sequence.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>finalize
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h3 id=pdl_interpforeach-pdl_interpforeachop><code>pdl_interp.foreach</code> (pdl_interp::ForEachOp)&nbsp;<a class=headline-hash href=#pdl_interpforeach-pdl_interpforeachop>¶</a></h3><p><em>Iterates over a range of values or ranges</em></p><p><code>pdl_interp.foreach</code> iteratively selects an element from a range of values
and executes the region until pdl.continue is reached.</p><p>In the bytecode interpreter, this operation is implemented by looping over
the values and, for each selection, running the bytecode until we reach
pdl.continue. This may result in multiple matches being reported. Note
that the input range is mutated (popped from).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>foreach <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation in <span class=nv>%ops</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  pdl_interp<span class=p>.</span>continue
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>-&gt;</span> <span class=nl>^next
</span></span></span></code></pre></div><p>Traits: <code>Terminator</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>values</code></td><td>range of pdl type values</td></tr></tbody></table><h4 id=successors-9>Successors:&nbsp;<a class=headline-hash href=#successors-9>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>successor</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpfunc-pdl_interpfuncop><code>pdl_interp.func</code> (pdl_interp::FuncOp)&nbsp;<a class=headline-hash href=#pdl_interpfunc-pdl_interpfuncop>¶</a></h3><p><em>PDL Interpreter Function Operation</em></p><p><code>pdl_interp.func</code> operations act as interpreter functions. These are
callable SSA-region operations that contain other interpreter operations.
Interpreter functions are used for both the matching and the rewriting
portion of the interpreter.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span><span class=kt>func</span> <span class=nf>@rewriter</span><span class=p>(</span><span class=nv>%root</span><span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>create_operation <span class=s>&#34;foo.new_operation&#34;</span>
</span></span><span class=line><span class=cl>  pdl_interp<span class=p>.</span>erase <span class=nv>%root</span>
</span></span><span class=line><span class=cl>  pdl_interp<span class=p>.</span>finalize
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of function type</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h3 id=pdl_interpget_attribute-pdl_interpgetattributeop><code>pdl_interp.get_attribute</code> (pdl_interp::GetAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_attribute-pdl_interpgetattributeop>¶</a></h3><p><em>Get a specified attribute value from an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_attribute` $name `of` $inputOp attr-dict
</code></pre><p><code>pdl_interp.get_attribute</code> operations try to get a specific attribute from
an operation. If the operation does not have that attribute, a null value is
returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%attr</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_attribute <span class=s>&#34;attr&#34;</span> of <span class=nv>%op</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attribute</code></td><td>PDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=pdl_interpget_attribute_type-pdl_interpgetattributetypeop><code>pdl_interp.get_attribute_type</code> (pdl_interp::GetAttributeTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_attribute_type-pdl_interpgetattributetypeop>¶</a></h3><p><em>Get the result type of a specified <code>Attribute</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_attribute_type` `of` $value attr-dict
</code></pre><p><code>pdl_interp.get_attribute_type</code> operations get the resulting type of a
specific attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%type</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_attribute_type of <span class=nv>%attr</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>PDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h3 id=pdl_interpget_defining_op-pdl_interpgetdefiningopop><code>pdl_interp.get_defining_op</code> (pdl_interp::GetDefiningOpOp)&nbsp;<a class=headline-hash href=#pdl_interpget_defining_op-pdl_interpgetdefiningopop>¶</a></h3><p><em>Get the defining operation of a <code>Value</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_defining_op` `of` $value `:` type($value) attr-dict
</code></pre><p><code>pdl_interp.get_defining_op</code> operations try to get the defining operation
of a specific value or range of values. In the case of range, the defining
op of the first value is returned. If the value is not an operation result
or range of operand results, null is returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%op</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_defining_op of <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h3 id=pdl_interpget_operand-pdl_interpgetoperandop><code>pdl_interp.get_operand</code> (pdl_interp::GetOperandOp)&nbsp;<a class=headline-hash href=#pdl_interpget_operand-pdl_interpgetoperandop>¶</a></h3><p><em>Get a specified operand from an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_operand` $index `of` $inputOp attr-dict
</code></pre><p><code>pdl_interp.get_operand</code> operations try to get a specific operand from an
operation If the operation does not have an operand for the given index, a
null value is returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%operand</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_operand <span class=m>1</span> of <span class=nv>%op</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h3 id=pdl_interpget_operands-pdl_interpgetoperandsop><code>pdl_interp.get_operands</code> (pdl_interp::GetOperandsOp)&nbsp;<a class=headline-hash href=#pdl_interpget_operands-pdl_interpgetoperandsop>¶</a></h3><p><em>Get a specified operand group from an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_operands` ($index^)? `of` $inputOp `:` type($value) attr-dict
</code></pre><p><code>pdl_interp.get_operands</code> operations try to get a specific operand
group from an operation. If the expected result is a single Value, null is
returned if the operand group is not of size 1. If a range is expected,
null is returned if the operand group is invalid. If no index is provided,
the returned operand group corresponds to all operands of the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Get the first group of operands from an operation, and expect a single
</span></span></span><span class=line><span class=cl><span class=c>// element.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%operand</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_operands <span class=m>0</span> of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get the first group of operands from an operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%operands</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_operands <span class=m>0</span> of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get all of the operands from an operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%operands</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_operands of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h3 id=pdl_interpget_result-pdl_interpgetresultop><code>pdl_interp.get_result</code> (pdl_interp::GetResultOp)&nbsp;<a class=headline-hash href=#pdl_interpget_result-pdl_interpgetresultop>¶</a></h3><p><em>Get a specified result from an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_result` $index `of` $inputOp attr-dict
</code></pre><p><code>pdl_interp.get_result</code> operations try to get a specific result from an
operation. If the operation does not have a result for the given index, a
null value is returned.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_result <span class=m>1</span> of <span class=nv>%op</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h3 id=pdl_interpget_results-pdl_interpgetresultsop><code>pdl_interp.get_results</code> (pdl_interp::GetResultsOp)&nbsp;<a class=headline-hash href=#pdl_interpget_results-pdl_interpgetresultsop>¶</a></h3><p><em>Get a specified result group from an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_results` ($index^)? `of` $inputOp `:` type($value) attr-dict
</code></pre><p><code>pdl_interp.get_results</code> operations try to get a specific result group
from an operation. If the expected result is a single Value, null is
returned if the result group is not of size 1. If a range is expected,
null is returned if the result group is invalid. If no index is provided,
the returned operand group corresponds to all results of the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Get the first group of results from an operation, and expect a single
</span></span></span><span class=line><span class=cl><span class=c>// element.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%result</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_results <span class=m>0</span> of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get the first group of results from an operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%results</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_results <span class=m>0</span> of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get all of the results from an operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%results</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_results of <span class=nv>%op</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>index</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h3 id=pdl_interpget_users-pdl_interpgetusersop><code>pdl_interp.get_users</code> (pdl_interp::GetUsersOp)&nbsp;<a class=headline-hash href=#pdl_interpget_users-pdl_interpgetusersop>¶</a></h3><p><em>Get the users of a <code>Value</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_users` `of` $value `:` type($value) attr-dict
</code></pre><p><code>pdl_interp.get_users</code> extracts the users that accept this value. In the
case of a range, the union of users of the all the values are returned,
similarly to ResultRange::getUsers.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Get all the users of a single value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%ops</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_users of <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get all the users of the first value in a range.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%ops</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_users of <span class=nv>%values</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>value<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operations</code></td><td>range of PDL handle to an <code>mlir::Operation *</code> values</td></tr></tbody></table><h3 id=pdl_interpget_value_type-pdl_interpgetvaluetypeop><code>pdl_interp.get_value_type</code> (pdl_interp::GetValueTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpget_value_type-pdl_interpgetvaluetypeop>¶</a></h3><p><em>Get the result type of a specified <code>Value</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.get_value_type` `of` $value `:` type($result) attr-dict
</code></pre><p><code>pdl_interp.get_value_type</code> operations get the resulting type of a specific
value or range thereof.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Get the type of a single value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%type</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_value_type of <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>type
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Get the types of a value range.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%type</span> <span class=p>=</span> pdl_interp<span class=p>.</span>get_value_type of <span class=nv>%values</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>range<span class=p>&lt;</span>type<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>single element or range of PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h3 id=pdl_interpis_not_null-pdl_interpisnotnullop><code>pdl_interp.is_not_null</code> (pdl_interp::IsNotNullOp)&nbsp;<a class=headline-hash href=#pdl_interpis_not_null-pdl_interpisnotnullop>¶</a></h3><p><em>Check if a positional value is non-null</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.is_not_null` $value `:` type($value) attr-dict `-&gt;` successors
</code></pre><p><code>pdl_interp.is_not_null</code> operations check that a positional value or range
exists. For ranges, this does not mean that the range was simply empty. On
success, this operation branches to the true destination. Otherwise, the
false destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>is_not_null <span class=nv>%value</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>value <span class=p>-&gt;</span> <span class=nl>^matchDest</span><span class=p>,</span> <span class=nl>^failureDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>pdl type</td></tr></tbody></table><h4 id=successors-10>Successors:&nbsp;<a class=headline-hash href=#successors-10>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interprecord_match-pdl_interprecordmatchop><code>pdl_interp.record_match</code> (pdl_interp::RecordMatchOp)&nbsp;<a class=headline-hash href=#pdl_interprecord_match-pdl_interprecordmatchop>¶</a></h3><p><em>Record the metadata for a successful pattern match</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.record_match` $rewriter (`(` $inputs^ `:` type($inputs) `)`)? `:`
              `benefit` `(` $benefit `)` `,`
              (`generatedOps` `(` $generatedOps^ `)` `,`)?
              `loc` `(` `[` $matchedOps `]` `)`
              (`,` `root` `(` $rootKind^ `)`)? attr-dict `-&gt;` $dest
</code></pre><p><code>pdl_interp.record_match</code> operations record a successful pattern match with
the interpreter and branch to the next part of the matcher. The metadata
recorded by these operations correspond to a specific <code>pdl.pattern</code>, as well
as what values were used during that match that should be propagated to the
rewriter.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>record_match <span class=nf>@rewriters</span><span class=p>::</span>myRewriter<span class=p>(</span><span class=nv>%root</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>operation<span class=p>)</span> <span class=p>:</span> benefit<span class=p>(</span><span class=m>1</span><span class=p>),</span> <span class=kt>loc</span><span class=p>([</span><span class=nv>%root</span><span class=p>,</span> <span class=nv>%op1</span><span class=p>]),</span> root<span class=p>(</span><span class=s>&#34;foo.op&#34;</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^nextDest
</span></span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code>, <code>Terminator</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rewriter</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td><code>rootKind</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>generatedOps</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>benefit</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute whose value is non-negative</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputs</code></td><td>variadic of pdl type</td></tr><tr><td style=text-align:center><code>matchedOps</code></td><td>variadic of PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-11>Successors:&nbsp;<a class=headline-hash href=#successors-11>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpreplace-pdl_interpreplaceop><code>pdl_interp.replace</code> (pdl_interp::ReplaceOp)&nbsp;<a class=headline-hash href=#pdl_interpreplace-pdl_interpreplaceop>¶</a></h3><p><em>Mark an operation as <code>replace</code>d</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.replace` $inputOp `with` ` ` `(` ($replValues^ `:` type($replValues))? `)`
              attr-dict
</code></pre><p><code>pdl_interp.replaced</code> operations are used to specify that an operation
should be marked as replaced. The semantics of this operation correspond
with the <code>replaceOp</code> method on a <code>PatternRewriter</code>. The set of replacement
values must match the number of results specified by the operation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Replace root node with 2 values:
</span></span></span><span class=line><span class=cl><span class=c></span>pdl_interp<span class=p>.</span>replace <span class=nv>%root</span> with <span class=p>(</span><span class=nv>%val0</span><span class=p>,</span> <span class=nv>%val1</span> <span class=p>:</span> <span class=p>!</span>pdl<span class=p>.</span>type<span class=p>,</span> <span class=p>!</span>pdl<span class=p>.</span>type<span class=p>)</span>
</span></span></code></pre></div><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr><tr><td style=text-align:center><code>replValues</code></td><td>variadic of single element or range of PDL handle for an <code>mlir::Value</code></td></tr></tbody></table><h3 id=pdl_interpswitch_attribute-pdl_interpswitchattributeop><code>pdl_interp.switch_attribute</code> (pdl_interp::SwitchAttributeOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_attribute-pdl_interpswitchattributeop>¶</a></h3><p><em>Switch on the value of an <code>Attribute</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_attribute` $attribute `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_attribute</code> operations compare the value of a given
attribute with a set of constant attributes. If the value matches one of the
provided case values the destination for that case value is taken, otherwise
the default destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_attribute <span class=nv>%attr</span> to <span class=p>[</span><span class=m>10</span><span class=p>,</span> true<span class=p>](</span><span class=err>^</span><span class=m>10</span>Dest<span class=p>,</span> <span class=nl>^trueDest</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attribute</code></td><td>PDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=successors-12>Successors:&nbsp;<a class=headline-hash href=#successors-12>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_operand_count-pdl_interpswitchoperandcountop><code>pdl_interp.switch_operand_count</code> (pdl_interp::SwitchOperandCountOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_operand_count-pdl_interpswitchoperandcountop>¶</a></h3><p><em>Switch on the operand count of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_operand_count` `of` $inputOp `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_operand_count</code> operations compare the operand count of a
given operation with a set of potential counts. If the value matches one of
the provided case values the destination for that case value is taken,
otherwise the default destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_operand_count of <span class=nv>%op</span> to <span class=p>[</span><span class=m>10</span><span class=p>,</span> <span class=m>2</span><span class=p>]</span> <span class=p>-&gt;</span> <span class=err>^</span><span class=m>10</span>Dest<span class=p>,</span> <span class=err>^</span><span class=m>2</span>Dest<span class=p>,</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-13>Successors:&nbsp;<a class=headline-hash href=#successors-13>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_operation_name-pdl_interpswitchoperationnameop><code>pdl_interp.switch_operation_name</code> (pdl_interp::SwitchOperationNameOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_operation_name-pdl_interpswitchoperationnameop>¶</a></h3><p><em>Switch on the OperationName of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_operation_name` `of` $inputOp `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_operation_name</code> operations compare the name of a given
operation with a set of known names. If the value matches one of the
provided case values the destination for that case value is taken, otherwise
the default destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_operation_name of <span class=nv>%op</span> to <span class=p>[</span><span class=s>&#34;foo.op&#34;</span><span class=p>,</span> <span class=s>&#34;bar.op&#34;</span><span class=p>](</span><span class=nl>^fooDest</span><span class=p>,</span> <span class=nl>^barDest</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-14>Successors:&nbsp;<a class=headline-hash href=#successors-14>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_result_count-pdl_interpswitchresultcountop><code>pdl_interp.switch_result_count</code> (pdl_interp::SwitchResultCountOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_result_count-pdl_interpswitchresultcountop>¶</a></h3><p><em>Switch on the result count of an <code>Operation</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_result_count` `of` $inputOp `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_result_count</code> operations compare the result count of a
given operation with a set of potential counts. If the value matches one of
the provided case values the destination for that case value is taken,
otherwise the default destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_result_count of <span class=nv>%op</span> to <span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>2</span><span class=p>](</span><span class=err>^</span><span class=m>0</span>Dest<span class=p>,</span> <span class=err>^</span><span class=m>2</span>Dest<span class=p>)</span> <span class=p>-&gt;</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::DenseIntElementsAttr</td><td>32-bit signless integer elements attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inputOp</code></td><td>PDL handle to an <code>mlir::Operation *</code></td></tr></tbody></table><h4 id=successors-15>Successors:&nbsp;<a class=headline-hash href=#successors-15>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_type-pdl_interpswitchtypeop><code>pdl_interp.switch_type</code> (pdl_interp::SwitchTypeOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_type-pdl_interpswitchtypeop>¶</a></h3><p><em>Switch on a <code>Type</code> value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_type` $value `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_type</code> operations compare a type with a set of statically
known types. If the value matches one of the provided case values the
destination for that case value is taken, otherwise the default destination
is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_type <span class=nv>%type</span> to <span class=p>[</span><span class=k>i32</span><span class=p>,</span> <span class=k>i64</span><span class=p>]</span> <span class=p>-&gt;</span> <span class=nl>^i32Dest</span><span class=p>,</span> <span class=nl>^i64Dest</span><span class=p>,</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::ArrayAttr</td><td>type array attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>PDL handle to an <code>mlir::Type</code></td></tr></tbody></table><h4 id=successors-16>Successors:&nbsp;<a class=headline-hash href=#successors-16>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><h3 id=pdl_interpswitch_types-pdl_interpswitchtypesop><code>pdl_interp.switch_types</code> (pdl_interp::SwitchTypesOp)&nbsp;<a class=headline-hash href=#pdl_interpswitch_types-pdl_interpswitchtypesop>¶</a></h3><p><em>Switch on a range of <code>Type</code> values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `pdl_interp.switch_types` $value `to` $caseValues `(` $cases `)` attr-dict `-&gt;` $defaultDest
</code></pre><p><code>pdl_interp.switch_types</code> operations compare a range of types with a set of
statically known ranges. If the value matches one of the provided case
values the destination for that case value is taken, otherwise the default
destination is taken.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>pdl_interp<span class=p>.</span>switch_types <span class=nv>%type</span> is <span class=p>[[</span><span class=k>i32</span><span class=p>],</span> <span class=p>[</span><span class=k>i64</span><span class=p>,</span> <span class=k>i64</span><span class=p>]]</span> <span class=p>-&gt;</span> <span class=nl>^i32Dest</span><span class=p>,</span> <span class=nl>^i64Dest</span><span class=p>,</span> <span class=nl>^defaultDest
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>caseValues</code></td><td>::mlir::ArrayAttr</td><td>type-array array attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>range of PDL handle to an <code>mlir::Type</code> values</td></tr></tbody></table><h4 id=successors-17>Successors:&nbsp;<a class=headline-hash href=#successors-17>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>cases</code></td><td>any successor</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/ title="ODS Documentation"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - ODS Documentation</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/PDLOps/ title="'pdl' Dialect">Next - 'pdl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>