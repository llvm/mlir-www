<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'nvvm' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'nvvm' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#nvvmbarwarpsync-nvvmsyncwarpop><code>nvvm.bar.warp.sync</code> (NVVM::SyncWarpOp)</a></li><li><a href=#nvvmbarrier-nvvmbarrierop><code>nvvm.barrier</code> (NVVM::BarrierOp)</a></li><li><a href=#nvvmbarrierarrive-nvvmbarrierarriveop><code>nvvm.barrier.arrive</code> (NVVM::BarrierArriveOp)</a></li><li><a href=#nvvmbarrier0-nvvmbarrier0op><code>nvvm.barrier0</code> (NVVM::Barrier0Op)</a></li><li><a href=#nvvmbreakpoint-nvvmbreakpoint><code>nvvm.breakpoint</code> (NVVM::Breakpoint)</a></li><li><a href=#nvvmclusterarrive-nvvmclusterarriveop><code>nvvm.cluster.arrive</code> (NVVM::ClusterArriveOp)</a></li><li><a href=#nvvmclusterarriverelaxed-nvvmclusterarriverelaxedop><code>nvvm.cluster.arrive.relaxed</code> (NVVM::ClusterArriveRelaxedOp)</a></li><li><a href=#nvvmclusterwait-nvvmclusterwaitop><code>nvvm.cluster.wait</code> (NVVM::ClusterWaitOp)</a></li><li><a href=#nvvmconvertbf16x2tof8x2-nvvmconvertbf16x2tof8x2op><code>nvvm.convert.bf16x2.to.f8x2</code> (NVVM::ConvertBF16x2ToF8x2Op)</a></li><li><a href=#nvvmconvertf16x2tof8x2-nvvmconvertf16x2tof8x2op><code>nvvm.convert.f16x2.to.f8x2</code> (NVVM::ConvertF16x2ToF8x2Op)</a></li><li><a href=#nvvmconvertf32x2tof6x2-nvvmconvertf32x2tof6x2op><code>nvvm.convert.f32x2.to.f6x2</code> (NVVM::ConvertF32x2ToF6x2Op)</a></li><li><a href=#nvvmconvertf32x2tof8x2-nvvmconvertf32x2tof8x2op><code>nvvm.convert.f32x2.to.f8x2</code> (NVVM::ConvertF32x2ToF8x2Op)</a></li><li><a href=#nvvmconvertfloattotf32-nvvmconvertfloattotf32op><code>nvvm.convert.float.to.tf32</code> (NVVM::ConvertFloatToTF32Op)</a></li><li><a href=#nvvmcpasyncbulkcommitgroup-nvvmcpasyncbulkcommitgroupop><code>nvvm.cp.async.bulk.commit.group</code> (NVVM::CpAsyncBulkCommitGroupOp)</a></li><li><a href=#nvvmcpasyncbulkglobalsharedcta-nvvmcpasyncbulksharedctatoglobalop><code>nvvm.cp.async.bulk.global.shared.cta</code> (NVVM::CpAsyncBulkSharedCTAToGlobalOp)</a></li><li><a href=#nvvmcpasyncbulkprefetch-nvvmcpasyncbulkprefetchop><code>nvvm.cp.async.bulk.prefetch</code> (NVVM::CpAsyncBulkPrefetchOp)</a></li><li><a href=#nvvmcpasyncbulksharedclusterglobal-nvvmcpasyncbulkglobaltosharedclusterop><code>nvvm.cp.async.bulk.shared.cluster.global</code> (NVVM::CpAsyncBulkGlobalToSharedClusterOp)</a></li><li><a href=#nvvmcpasyncbulksharedclustersharedcta-nvvmcpasyncbulksharedctatosharedclusterop><code>nvvm.cp.async.bulk.shared.cluster.shared.cta</code> (NVVM::CpAsyncBulkSharedCTAToSharedClusterOp)</a></li><li><a href=#nvvmcpasyncbulktensorglobalsharedcta-nvvmcpasyncbulktensorsharedctatoglobalop><code>nvvm.cp.async.bulk.tensor.global.shared.cta</code> (NVVM::CpAsyncBulkTensorSharedCTAToGlobalOp)</a></li><li><a href=#nvvmcpasyncbulktensorprefetch-nvvmcpasyncbulktensorprefetchop><code>nvvm.cp.async.bulk.tensor.prefetch</code> (NVVM::CpAsyncBulkTensorPrefetchOp)</a></li><li><a href=#nvvmcpasyncbulktensorreduce-nvvmcpasyncbulktensorreduceop><code>nvvm.cp.async.bulk.tensor.reduce</code> (NVVM::CpAsyncBulkTensorReduceOp)</a></li><li><a href=#nvvmcpasyncbulktensorsharedclusterglobal-nvvmcpasyncbulktensorglobaltosharedclusterop><code>nvvm.cp.async.bulk.tensor.shared.cluster.global</code> (NVVM::CpAsyncBulkTensorGlobalToSharedClusterOp)</a></li><li><a href=#nvvmcpasyncbulkwait_group-nvvmcpasyncbulkwaitgroupop><code>nvvm.cp.async.bulk.wait_group</code> (NVVM::CpAsyncBulkWaitGroupOp)</a></li><li><a href=#nvvmcpasynccommitgroup-nvvmcpasynccommitgroupop><code>nvvm.cp.async.commit.group</code> (NVVM::CpAsyncCommitGroupOp)</a></li><li><a href=#nvvmcpasyncmbarrierarrive-nvvmcpasyncmbarrierarriveop><code>nvvm.cp.async.mbarrier.arrive</code> (NVVM::CpAsyncMBarrierArriveOp)</a></li><li><a href=#nvvmcpasyncmbarrierarriveshared-nvvmcpasyncmbarrierarrivesharedop><code>nvvm.cp.async.mbarrier.arrive.shared</code> (NVVM::CpAsyncMBarrierArriveSharedOp)</a></li><li><a href=#nvvmcpasyncsharedglobal-nvvmcpasyncop><code>nvvm.cp.async.shared.global</code> (NVVM::CpAsyncOp)</a></li><li><a href=#nvvmcpasyncwaitgroup-nvvmcpasyncwaitgroupop><code>nvvm.cp.async.wait.group</code> (NVVM::CpAsyncWaitGroupOp)</a></li><li><a href=#nvvmdotaccumulate2way-nvvmdotaccumulate2wayop><code>nvvm.dot.accumulate.2way</code> (NVVM::DotAccumulate2WayOp)</a></li><li><a href=#nvvmdotaccumulate4way-nvvmdotaccumulate4wayop><code>nvvm.dot.accumulate.4way</code> (NVVM::DotAccumulate4WayOp)</a></li><li><a href=#nvvmelectsync-nvvmelectsyncop><code>nvvm.elect.sync</code> (NVVM::ElectSyncOp)</a></li><li><a href=#nvvmexit-nvvmexit><code>nvvm.exit</code> (NVVM::Exit)</a></li><li><a href=#nvvmfencembarrierinit-nvvmfencembarrierinitop><code>nvvm.fence.mbarrier.init</code> (NVVM::FenceMbarrierInitOp)</a></li><li><a href=#nvvmfenceproxy-nvvmfenceproxyop><code>nvvm.fence.proxy</code> (NVVM::FenceProxyOp)</a></li><li><a href=#nvvmfenceproxyacquire-nvvmfenceproxyacquireop><code>nvvm.fence.proxy.acquire</code> (NVVM::FenceProxyAcquireOp)</a></li><li><a href=#nvvmfenceproxyrelease-nvvmfenceproxyreleaseop><code>nvvm.fence.proxy.release</code> (NVVM::FenceProxyReleaseOp)</a></li><li><a href=#nvvmfencesccluster-nvvmfencescclusterop><code>nvvm.fence.sc.cluster</code> (NVVM::FenceScClusterOp)</a></li><li><a href=#nvvmgriddepcontrollaunchdependents-nvvmgriddepcontrollaunchdependentsop><code>nvvm.griddepcontrol.launch.dependents</code> (NVVM::GriddepcontrolLaunchDependentsOp)</a></li><li><a href=#nvvmgriddepcontrolwait-nvvmgriddepcontrolwaitop><code>nvvm.griddepcontrol.wait</code> (NVVM::GriddepcontrolWaitOp)</a></li><li><a href=#nvvminline_ptx-nvvminlineptxop><code>nvvm.inline_ptx</code> (NVVM::InlinePtxOp)</a></li><li><a href=#nvvmldmatrix-nvvmldmatrixop><code>nvvm.ldmatrix</code> (NVVM::LdMatrixOp)</a></li><li><a href=#nvvmmapa-nvvmmapaop><code>nvvm.mapa</code> (NVVM::MapaOp)</a></li><li><a href=#nvvmmatchsync-nvvmmatchsyncop><code>nvvm.match.sync</code> (NVVM::MatchSyncOp)</a></li><li><a href=#nvvmmbarrierarrive-nvvmmbarrierarriveop><code>nvvm.mbarrier.arrive</code> (NVVM::MBarrierArriveOp)</a></li><li><a href=#nvvmmbarrierarriveexpect_tx-nvvmmbarrierarriveexpecttxop><code>nvvm.mbarrier.arrive.expect_tx</code> (NVVM::MBarrierArriveExpectTxOp)</a></li><li><a href=#nvvmmbarrierarriveexpect_txshared-nvvmmbarrierarriveexpecttxsharedop><code>nvvm.mbarrier.arrive.expect_tx.shared</code> (NVVM::MBarrierArriveExpectTxSharedOp)</a></li><li><a href=#nvvmmbarrierarrivenocomplete-nvvmmbarrierarrivenocompleteop><code>nvvm.mbarrier.arrive.nocomplete</code> (NVVM::MBarrierArriveNocompleteOp)</a></li><li><a href=#nvvmmbarrierarrivenocompleteshared-nvvmmbarrierarrivenocompletesharedop><code>nvvm.mbarrier.arrive.nocomplete.shared</code> (NVVM::MBarrierArriveNocompleteSharedOp)</a></li><li><a href=#nvvmmbarrierarriveshared-nvvmmbarrierarrivesharedop><code>nvvm.mbarrier.arrive.shared</code> (NVVM::MBarrierArriveSharedOp)</a></li><li><a href=#nvvmmbarrierinit-nvvmmbarrierinitop><code>nvvm.mbarrier.init</code> (NVVM::MBarrierInitOp)</a></li><li><a href=#nvvmmbarrierinitshared-nvvmmbarrierinitsharedop><code>nvvm.mbarrier.init.shared</code> (NVVM::MBarrierInitSharedOp)</a></li><li><a href=#nvvmmbarrierinval-nvvmmbarrierinvalop><code>nvvm.mbarrier.inval</code> (NVVM::MBarrierInvalOp)</a></li><li><a href=#nvvmmbarrierinvalshared-nvvmmbarrierinvalsharedop><code>nvvm.mbarrier.inval.shared</code> (NVVM::MBarrierInvalSharedOp)</a></li><li><a href=#nvvmmbarriertestwait-nvvmmbarriertestwaitop><code>nvvm.mbarrier.test.wait</code> (NVVM::MBarrierTestWaitOp)</a></li><li><a href=#nvvmmbarriertestwaitshared-nvvmmbarriertestwaitsharedop><code>nvvm.mbarrier.test.wait.shared</code> (NVVM::MBarrierTestWaitSharedOp)</a></li><li><a href=#nvvmmbarriertry_waitparity-nvvmmbarriertrywaitparityop><code>nvvm.mbarrier.try_wait.parity</code> (NVVM::MBarrierTryWaitParityOp)</a></li><li><a href=#nvvmmbarriertry_waitparityshared-nvvmmbarriertrywaitparitysharedop><code>nvvm.mbarrier.try_wait.parity.shared</code> (NVVM::MBarrierTryWaitParitySharedOp)</a></li><li><a href=#nvvmmmasync-nvvmmmaop><code>nvvm.mma.sync</code> (NVVM::MmaOp)</a></li><li><a href=#nvvmprefetch-nvvmprefetchop><code>nvvm.prefetch</code> (NVVM::PrefetchOp)</a></li><li><a href=#nvvmprefetchtensormap-nvvmprefetchtensormapop><code>nvvm.prefetch.tensormap</code> (NVVM::PrefetchTensorMapOp)</a></li><li><a href=#nvvmrcpapproxftzf-nvvmrcpapproxftzf32op><code>nvvm.rcp.approx.ftz.f</code> (NVVM::RcpApproxFtzF32Op)</a></li><li><a href=#nvvmreadptxsregclock-nvvmclockop><code>nvvm.read.ptx.sreg.clock</code> (NVVM::ClockOp)</a></li><li><a href=#nvvmreadptxsregclock64-nvvmclock64op><code>nvvm.read.ptx.sreg.clock64</code> (NVVM::Clock64Op)</a></li><li><a href=#nvvmreadptxsregclusterctaidx-nvvmblockinclusteridxop><code>nvvm.read.ptx.sreg.cluster.ctaid.x</code> (NVVM::BlockInClusterIdXOp)</a></li><li><a href=#nvvmreadptxsregclusterctaidy-nvvmblockinclusteridyop><code>nvvm.read.ptx.sreg.cluster.ctaid.y</code> (NVVM::BlockInClusterIdYOp)</a></li><li><a href=#nvvmreadptxsregclusterctaidz-nvvmblockinclusteridzop><code>nvvm.read.ptx.sreg.cluster.ctaid.z</code> (NVVM::BlockInClusterIdZOp)</a></li><li><a href=#nvvmreadptxsregclusterctarank-nvvmclusterid><code>nvvm.read.ptx.sreg.cluster.ctarank</code> (NVVM::ClusterId)</a></li><li><a href=#nvvmreadptxsregclusternctaidx-nvvmclusterdimblocksxop><code>nvvm.read.ptx.sreg.cluster.nctaid.x</code> (NVVM::ClusterDimBlocksXOp)</a></li><li><a href=#nvvmreadptxsregclusternctaidy-nvvmclusterdimblocksyop><code>nvvm.read.ptx.sreg.cluster.nctaid.y</code> (NVVM::ClusterDimBlocksYOp)</a></li><li><a href=#nvvmreadptxsregclusternctaidz-nvvmclusterdimblockszop><code>nvvm.read.ptx.sreg.cluster.nctaid.z</code> (NVVM::ClusterDimBlocksZOp)</a></li><li><a href=#nvvmreadptxsregclusternctarank-nvvmclusterdim><code>nvvm.read.ptx.sreg.cluster.nctarank</code> (NVVM::ClusterDim)</a></li><li><a href=#nvvmreadptxsregclusteridx-nvvmclusteridxop><code>nvvm.read.ptx.sreg.clusterid.x</code> (NVVM::ClusterIdXOp)</a></li><li><a href=#nvvmreadptxsregclusteridy-nvvmclusteridyop><code>nvvm.read.ptx.sreg.clusterid.y</code> (NVVM::ClusterIdYOp)</a></li><li><a href=#nvvmreadptxsregclusteridz-nvvmclusteridzop><code>nvvm.read.ptx.sreg.clusterid.z</code> (NVVM::ClusterIdZOp)</a></li><li><a href=#nvvmreadptxsregctaidx-nvvmblockidxop><code>nvvm.read.ptx.sreg.ctaid.x</code> (NVVM::BlockIdXOp)</a></li><li><a href=#nvvmreadptxsregctaidy-nvvmblockidyop><code>nvvm.read.ptx.sreg.ctaid.y</code> (NVVM::BlockIdYOp)</a></li><li><a href=#nvvmreadptxsregctaidz-nvvmblockidzop><code>nvvm.read.ptx.sreg.ctaid.z</code> (NVVM::BlockIdZOp)</a></li><li><a href=#nvvmreadptxsregenvreg0-nvvmenvreg0op><code>nvvm.read.ptx.sreg.envreg0</code> (NVVM::EnvReg0Op)</a></li><li><a href=#nvvmreadptxsregenvreg1-nvvmenvreg1op><code>nvvm.read.ptx.sreg.envreg1</code> (NVVM::EnvReg1Op)</a></li><li><a href=#nvvmreadptxsregenvreg10-nvvmenvreg10op><code>nvvm.read.ptx.sreg.envreg10</code> (NVVM::EnvReg10Op)</a></li><li><a href=#nvvmreadptxsregenvreg11-nvvmenvreg11op><code>nvvm.read.ptx.sreg.envreg11</code> (NVVM::EnvReg11Op)</a></li><li><a href=#nvvmreadptxsregenvreg12-nvvmenvreg12op><code>nvvm.read.ptx.sreg.envreg12</code> (NVVM::EnvReg12Op)</a></li><li><a href=#nvvmreadptxsregenvreg13-nvvmenvreg13op><code>nvvm.read.ptx.sreg.envreg13</code> (NVVM::EnvReg13Op)</a></li><li><a href=#nvvmreadptxsregenvreg14-nvvmenvreg14op><code>nvvm.read.ptx.sreg.envreg14</code> (NVVM::EnvReg14Op)</a></li><li><a href=#nvvmreadptxsregenvreg15-nvvmenvreg15op><code>nvvm.read.ptx.sreg.envreg15</code> (NVVM::EnvReg15Op)</a></li><li><a href=#nvvmreadptxsregenvreg16-nvvmenvreg16op><code>nvvm.read.ptx.sreg.envreg16</code> (NVVM::EnvReg16Op)</a></li><li><a href=#nvvmreadptxsregenvreg17-nvvmenvreg17op><code>nvvm.read.ptx.sreg.envreg17</code> (NVVM::EnvReg17Op)</a></li><li><a href=#nvvmreadptxsregenvreg18-nvvmenvreg18op><code>nvvm.read.ptx.sreg.envreg18</code> (NVVM::EnvReg18Op)</a></li><li><a href=#nvvmreadptxsregenvreg19-nvvmenvreg19op><code>nvvm.read.ptx.sreg.envreg19</code> (NVVM::EnvReg19Op)</a></li><li><a href=#nvvmreadptxsregenvreg2-nvvmenvreg2op><code>nvvm.read.ptx.sreg.envreg2</code> (NVVM::EnvReg2Op)</a></li><li><a href=#nvvmreadptxsregenvreg20-nvvmenvreg20op><code>nvvm.read.ptx.sreg.envreg20</code> (NVVM::EnvReg20Op)</a></li><li><a href=#nvvmreadptxsregenvreg21-nvvmenvreg21op><code>nvvm.read.ptx.sreg.envreg21</code> (NVVM::EnvReg21Op)</a></li><li><a href=#nvvmreadptxsregenvreg22-nvvmenvreg22op><code>nvvm.read.ptx.sreg.envreg22</code> (NVVM::EnvReg22Op)</a></li><li><a href=#nvvmreadptxsregenvreg23-nvvmenvreg23op><code>nvvm.read.ptx.sreg.envreg23</code> (NVVM::EnvReg23Op)</a></li><li><a href=#nvvmreadptxsregenvreg24-nvvmenvreg24op><code>nvvm.read.ptx.sreg.envreg24</code> (NVVM::EnvReg24Op)</a></li><li><a href=#nvvmreadptxsregenvreg25-nvvmenvreg25op><code>nvvm.read.ptx.sreg.envreg25</code> (NVVM::EnvReg25Op)</a></li><li><a href=#nvvmreadptxsregenvreg26-nvvmenvreg26op><code>nvvm.read.ptx.sreg.envreg26</code> (NVVM::EnvReg26Op)</a></li><li><a href=#nvvmreadptxsregenvreg27-nvvmenvreg27op><code>nvvm.read.ptx.sreg.envreg27</code> (NVVM::EnvReg27Op)</a></li><li><a href=#nvvmreadptxsregenvreg28-nvvmenvreg28op><code>nvvm.read.ptx.sreg.envreg28</code> (NVVM::EnvReg28Op)</a></li><li><a href=#nvvmreadptxsregenvreg29-nvvmenvreg29op><code>nvvm.read.ptx.sreg.envreg29</code> (NVVM::EnvReg29Op)</a></li><li><a href=#nvvmreadptxsregenvreg3-nvvmenvreg3op><code>nvvm.read.ptx.sreg.envreg3</code> (NVVM::EnvReg3Op)</a></li><li><a href=#nvvmreadptxsregenvreg30-nvvmenvreg30op><code>nvvm.read.ptx.sreg.envreg30</code> (NVVM::EnvReg30Op)</a></li><li><a href=#nvvmreadptxsregenvreg31-nvvmenvreg31op><code>nvvm.read.ptx.sreg.envreg31</code> (NVVM::EnvReg31Op)</a></li><li><a href=#nvvmreadptxsregenvreg4-nvvmenvreg4op><code>nvvm.read.ptx.sreg.envreg4</code> (NVVM::EnvReg4Op)</a></li><li><a href=#nvvmreadptxsregenvreg5-nvvmenvreg5op><code>nvvm.read.ptx.sreg.envreg5</code> (NVVM::EnvReg5Op)</a></li><li><a href=#nvvmreadptxsregenvreg6-nvvmenvreg6op><code>nvvm.read.ptx.sreg.envreg6</code> (NVVM::EnvReg6Op)</a></li><li><a href=#nvvmreadptxsregenvreg7-nvvmenvreg7op><code>nvvm.read.ptx.sreg.envreg7</code> (NVVM::EnvReg7Op)</a></li><li><a href=#nvvmreadptxsregenvreg8-nvvmenvreg8op><code>nvvm.read.ptx.sreg.envreg8</code> (NVVM::EnvReg8Op)</a></li><li><a href=#nvvmreadptxsregenvreg9-nvvmenvreg9op><code>nvvm.read.ptx.sreg.envreg9</code> (NVVM::EnvReg9Op)</a></li><li><a href=#nvvmreadptxsregglobaltimer-nvvmglobaltimerop><code>nvvm.read.ptx.sreg.globaltimer</code> (NVVM::GlobalTimerOp)</a></li><li><a href=#nvvmreadptxsreggridid-nvvmgrididop><code>nvvm.read.ptx.sreg.gridid</code> (NVVM::GridIdOp)</a></li><li><a href=#nvvmreadptxsreglaneid-nvvmlaneidop><code>nvvm.read.ptx.sreg.laneid</code> (NVVM::LaneIdOp)</a></li><li><a href=#nvvmreadptxsreglanemaskeq-nvvmlanemaskeqop><code>nvvm.read.ptx.sreg.lanemask.eq</code> (NVVM::LaneMaskEqOp)</a></li><li><a href=#nvvmreadptxsreglanemaskge-nvvmlanemaskgeop><code>nvvm.read.ptx.sreg.lanemask.ge</code> (NVVM::LaneMaskGeOp)</a></li><li><a href=#nvvmreadptxsreglanemaskgt-nvvmlanemaskgtop><code>nvvm.read.ptx.sreg.lanemask.gt</code> (NVVM::LaneMaskGtOp)</a></li><li><a href=#nvvmreadptxsreglanemaskle-nvvmlanemaskleop><code>nvvm.read.ptx.sreg.lanemask.le</code> (NVVM::LaneMaskLeOp)</a></li><li><a href=#nvvmreadptxsreglanemasklt-nvvmlanemaskltop><code>nvvm.read.ptx.sreg.lanemask.lt</code> (NVVM::LaneMaskLtOp)</a></li><li><a href=#nvvmreadptxsregnclusteridx-nvvmclusterdimxop><code>nvvm.read.ptx.sreg.nclusterid.x</code> (NVVM::ClusterDimXOp)</a></li><li><a href=#nvvmreadptxsregnclusteridy-nvvmclusterdimyop><code>nvvm.read.ptx.sreg.nclusterid.y</code> (NVVM::ClusterDimYOp)</a></li><li><a href=#nvvmreadptxsregnclusteridz-nvvmclusterdimzop><code>nvvm.read.ptx.sreg.nclusterid.z</code> (NVVM::ClusterDimZOp)</a></li><li><a href=#nvvmreadptxsregnctaidx-nvvmgriddimxop><code>nvvm.read.ptx.sreg.nctaid.x</code> (NVVM::GridDimXOp)</a></li><li><a href=#nvvmreadptxsregnctaidy-nvvmgriddimyop><code>nvvm.read.ptx.sreg.nctaid.y</code> (NVVM::GridDimYOp)</a></li><li><a href=#nvvmreadptxsregnctaidz-nvvmgriddimzop><code>nvvm.read.ptx.sreg.nctaid.z</code> (NVVM::GridDimZOp)</a></li><li><a href=#nvvmreadptxsregnsmid-nvvmsmdimop><code>nvvm.read.ptx.sreg.nsmid</code> (NVVM::SmDimOp)</a></li><li><a href=#nvvmreadptxsregntidx-nvvmblockdimxop><code>nvvm.read.ptx.sreg.ntid.x</code> (NVVM::BlockDimXOp)</a></li><li><a href=#nvvmreadptxsregntidy-nvvmblockdimyop><code>nvvm.read.ptx.sreg.ntid.y</code> (NVVM::BlockDimYOp)</a></li><li><a href=#nvvmreadptxsregntidz-nvvmblockdimzop><code>nvvm.read.ptx.sreg.ntid.z</code> (NVVM::BlockDimZOp)</a></li><li><a href=#nvvmreadptxsregnwarpid-nvvmwarpdimop><code>nvvm.read.ptx.sreg.nwarpid</code> (NVVM::WarpDimOp)</a></li><li><a href=#nvvmreadptxsregsmid-nvvmsmidop><code>nvvm.read.ptx.sreg.smid</code> (NVVM::SmIdOp)</a></li><li><a href=#nvvmreadptxsregtidx-nvvmthreadidxop><code>nvvm.read.ptx.sreg.tid.x</code> (NVVM::ThreadIdXOp)</a></li><li><a href=#nvvmreadptxsregtidy-nvvmthreadidyop><code>nvvm.read.ptx.sreg.tid.y</code> (NVVM::ThreadIdYOp)</a></li><li><a href=#nvvmreadptxsregtidz-nvvmthreadidzop><code>nvvm.read.ptx.sreg.tid.z</code> (NVVM::ThreadIdZOp)</a></li><li><a href=#nvvmreadptxsregwarpid-nvvmwarpidop><code>nvvm.read.ptx.sreg.warpid</code> (NVVM::WarpIdOp)</a></li><li><a href=#nvvmreadptxsregwarpsize-nvvmwarpsizeop><code>nvvm.read.ptx.sreg.warpsize</code> (NVVM::WarpSizeOp)</a></li><li><a href=#nvvmreduxsync-nvvmreduxop><code>nvvm.redux.sync</code> (NVVM::ReduxOp)</a></li><li><a href=#nvvmsetmaxregister-nvvmsetmaxregisterop><code>nvvm.setmaxregister</code> (NVVM::SetMaxRegisterOp)</a></li><li><a href=#nvvmshflsync-nvvmshflop><code>nvvm.shfl.sync</code> (NVVM::ShflOp)</a></li><li><a href=#nvvmstbulk-nvvmbulkstoreop><code>nvvm.st.bulk</code> (NVVM::BulkStoreOp)</a></li><li><a href=#nvvmstmatrix-nvvmstmatrixop><code>nvvm.stmatrix</code> (NVVM::StMatrixOp)</a></li><li><a href=#nvvmtcgen05alloc-nvvmtcgen05allocop><code>nvvm.tcgen05.alloc</code> (NVVM::Tcgen05AllocOp)</a></li><li><a href=#nvvmtcgen05commit-nvvmtcgen05commitop><code>nvvm.tcgen05.commit</code> (NVVM::Tcgen05CommitOp)</a></li><li><a href=#nvvmtcgen05cp-nvvmtcgen05cpop><code>nvvm.tcgen05.cp</code> (NVVM::Tcgen05CpOp)</a></li><li><a href=#nvvmtcgen05dealloc-nvvmtcgen05deallocop><code>nvvm.tcgen05.dealloc</code> (NVVM::Tcgen05DeallocOp)</a></li><li><a href=#nvvmtcgen05fence-nvvmtcgen05fenceop><code>nvvm.tcgen05.fence</code> (NVVM::Tcgen05FenceOp)</a></li><li><a href=#nvvmtcgen05ld-nvvmtcgen05ldop><code>nvvm.tcgen05.ld</code> (NVVM::Tcgen05LdOp)</a></li><li><a href=#nvvmtcgen05mma_smem_desc-nvvmtcgen05mmasmemdescop><code>nvvm.tcgen05.mma_smem_desc</code> (NVVM::Tcgen05MmaSmemDescOp)</a></li><li><a href=#nvvmtcgen05relinquish_alloc_permit-nvvmtcgen05relinquishallocpermitop><code>nvvm.tcgen05.relinquish_alloc_permit</code> (NVVM::Tcgen05RelinquishAllocPermitOp)</a></li><li><a href=#nvvmtcgen05shift-nvvmtcgen05shiftop><code>nvvm.tcgen05.shift</code> (NVVM::Tcgen05ShiftOp)</a></li><li><a href=#nvvmtcgen05st-nvvmtcgen05stop><code>nvvm.tcgen05.st</code> (NVVM::Tcgen05StOp)</a></li><li><a href=#nvvmtcgen05wait-nvvmtcgen05waitop><code>nvvm.tcgen05.wait</code> (NVVM::Tcgen05WaitOp)</a></li><li><a href=#nvvmvotesync-nvvmvotesyncop><code>nvvm.vote.sync</code> (NVVM::VoteSyncOp)</a></li><li><a href=#nvvmwgmmacommitgroupsyncaligned-nvvmwgmmagroupsyncalignedop><code>nvvm.wgmma.commit.group.sync.aligned</code> (NVVM::WgmmaGroupSyncAlignedOp)</a></li><li><a href=#nvvmwgmmafencealigned-nvvmwgmmafencealignedop><code>nvvm.wgmma.fence.aligned</code> (NVVM::WgmmaFenceAlignedOp)</a></li><li><a href=#nvvmwgmmamma_async-nvvmwgmmammaasyncop><code>nvvm.wgmma.mma_async</code> (NVVM::WgmmaMmaAsyncOp)</a></li><li><a href=#nvvmwgmmawaitgroupsyncaligned-nvvmwgmmawaitgroupsyncop><code>nvvm.wgmma.wait.group.sync.aligned</code> (NVVM::WgmmaWaitGroupSyncOp)</a></li><li><a href=#nvvmwmmaload-nvvmwmmaloadop><code>nvvm.wmma.load</code> (NVVM::WMMALoadOp)</a></li><li><a href=#nvvmwmmamma-nvvmwmmammaop><code>nvvm.wmma.mma</code> (NVVM::WMMAMmaOp)</a></li><li><a href=#nvvmwmmastore-nvvmwmmastoreop><code>nvvm.wmma.store</code> (NVVM::WMMAStoreOp)</a></li></ul></li><li><a href=#attributes-78>Attributes</a><ul><li><a href=#cacheevictionpriorityattr>CacheEvictionPriorityAttr</a></li><li><a href=#convertfp6typeattr>ConvertFP6TypeAttr</a></li><li><a href=#convertfp8typeattr>ConvertFP8TypeAttr</a></li><li><a href=#dotaccumulatetypeattr>DotAccumulateTypeAttr</a></li><li><a href=#fproundingmodeattr>FPRoundingModeAttr</a></li><li><a href=#ldstmatrixelttypeattr>LdStMatrixEltTypeAttr</a></li><li><a href=#ldstmatrixshapeattr>LdStMatrixShapeAttr</a></li><li><a href=#loadcachemodifierkindattr>LoadCacheModifierKindAttr</a></li><li><a href=#mmab1opattr>MMAB1OpAttr</a></li><li><a href=#mmafragattr>MMAFragAttr</a></li><li><a href=#mmaintoverflowattr>MMAIntOverflowAttr</a></li><li><a href=#mmalayoutattr>MMALayoutAttr</a></li><li><a href=#mmatypesattr>MMATypesAttr</a></li><li><a href=#matchsynckindattr>MatchSyncKindAttr</a></li><li><a href=#memscopekindattr>MemScopeKindAttr</a></li><li><a href=#mmashapeattr>MMAShapeAttr</a></li><li><a href=#nvvmtargetattr>NVVMTargetAttr</a></li><li><a href=#prefetchcachelevelattr>PrefetchCacheLevelAttr</a></li><li><a href=#proxykindattr>ProxyKindAttr</a></li><li><a href=#reduxkindattr>ReduxKindAttr</a></li><li><a href=#saturationmodeattr>SaturationModeAttr</a></li><li><a href=#setmaxregisteractionattr>SetMaxRegisterActionAttr</a></li><li><a href=#sharedspaceattr>SharedSpaceAttr</a></li><li><a href=#shflkindattr>ShflKindAttr</a></li><li><a href=#tmareduxkindattr>TMAReduxKindAttr</a></li><li><a href=#tmastoremodeattr>TMAStoreModeAttr</a></li><li><a href=#tcgen05cpmulticastattr>Tcgen05CpMulticastAttr</a></li><li><a href=#tcgen05cpshapeattr>Tcgen05CpShapeAttr</a></li><li><a href=#tcgen05cpsrcformatattr>Tcgen05CpSrcFormatAttr</a></li><li><a href=#tcgen05fencekindattr>Tcgen05FenceKindAttr</a></li><li><a href=#tcgen05groupkindattr>Tcgen05GroupKindAttr</a></li><li><a href=#tcgen05ldstshapeattr>Tcgen05LdStShapeAttr</a></li><li><a href=#tcgen05waitkindattr>Tcgen05WaitKindAttr</a></li><li><a href=#votesynckindattr>VoteSyncKindAttr</a></li><li><a href=#wgmmascaleinattr>WGMMAScaleInAttr</a></li><li><a href=#wgmmascaleoutattr>WGMMAScaleOutAttr</a></li><li><a href=#wgmmatypesattr>WGMMATypesAttr</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#cacheevictionpriority>CacheEvictionPriority</a></li><li><a href=#convertfp6type>ConvertFP6Type</a></li><li><a href=#convertfp8type>ConvertFP8Type</a></li><li><a href=#dotaccumulatetype>DotAccumulateType</a></li><li><a href=#fproundingmode>FPRoundingMode</a></li><li><a href=#ldstmatrixelttype>LdStMatrixEltType</a></li><li><a href=#loadcachemodifierkind>LoadCacheModifierKind</a></li><li><a href=#mmab1op>MMAB1Op</a></li><li><a href=#mmafrag>MMAFrag</a></li><li><a href=#mmaintoverflow>MMAIntOverflow</a></li><li><a href=#mmalayout>MMALayout</a></li><li><a href=#mmatypes>MMATypes</a></li><li><a href=#matchsynckind>MatchSyncKind</a></li><li><a href=#memscopekind>MemScopeKind</a></li><li><a href=#prefetchcachelevel>PrefetchCacheLevel</a></li><li><a href=#proxykind>ProxyKind</a></li><li><a href=#reduxkind>ReduxKind</a></li><li><a href=#saturationmode>SaturationMode</a></li><li><a href=#setmaxregisteraction>SetMaxRegisterAction</a></li><li><a href=#sharedspace>SharedSpace</a></li><li><a href=#shflkind>ShflKind</a></li><li><a href=#tmareduxkind>TMAReduxKind</a></li><li><a href=#tmastoremode>TMAStoreMode</a></li><li><a href=#tcgen05cpmulticast>Tcgen05CpMulticast</a></li><li><a href=#tcgen05cpshape>Tcgen05CpShape</a></li><li><a href=#tcgen05cpsrcformat>Tcgen05CpSrcFormat</a></li><li><a href=#tcgen05fencekind>Tcgen05FenceKind</a></li><li><a href=#tcgen05groupkind>Tcgen05GroupKind</a></li><li><a href=#tcgen05ldstshape>Tcgen05LdStShape</a></li><li><a href=#tcgen05waitkind>Tcgen05WaitKind</a></li><li><a href=#votesynckind>VoteSyncKind</a></li><li><a href=#wgmmascalein>WGMMAScaleIn</a></li><li><a href=#wgmmascaleout>WGMMAScaleOut</a></li><li><a href=#wgmmatypes>WGMMATypes</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/LLVMIR/NVVMOps.td>source</a></p><h3 id=nvvmbarwarpsync-nvvmsyncwarpop><code>nvvm.bar.warp.sync</code> (NVVM::SyncWarpOp)&nbsp;<a class=headline-hash href=#nvvmbarwarpsync-nvvmsyncwarpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.bar.warp.sync` $mask attr-dict `:` type($mask)
</code></pre><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmbarrier-nvvmbarrierop><code>nvvm.barrier</code> (NVVM::BarrierOp)&nbsp;<a class=headline-hash href=#nvvmbarrier-nvvmbarrierop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.barrier` (`id` `=` $barrierId^)? (`number_of_threads` `=` $numberOfThreads^)? attr-dict
</code></pre><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>barrierId</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>numberOfThreads</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmbarrierarrive-nvvmbarrierarriveop><code>nvvm.barrier.arrive</code> (NVVM::BarrierArriveOp)&nbsp;<a class=headline-hash href=#nvvmbarrierarrive-nvvmbarrierarriveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.barrier.arrive` (`id` `=` $barrierId^)? `number_of_threads` `=` $numberOfThreads attr-dict
</code></pre><p>Thread that executes this op announces their arrival at the barrier with
given id and continue their execution.</p><p>The default barrier id is 0 that is similar to <code>nvvm.barrier</code> Op. When
<code>barrierId</code> is not present, the default barrier id is used.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-bar>For more information, see PTX ISA</a></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>barrierId</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>numberOfThreads</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmbarrier0-nvvmbarrier0op><code>nvvm.barrier0</code> (NVVM::Barrier0Op)&nbsp;<a class=headline-hash href=#nvvmbarrier0-nvvmbarrier0op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.barrier0` attr-dict
</code></pre><h3 id=nvvmbreakpoint-nvvmbreakpoint><code>nvvm.breakpoint</code> (NVVM::Breakpoint)&nbsp;<a class=headline-hash href=#nvvmbreakpoint-nvvmbreakpoint>¶</a></h3><p><em>Breakpoint Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.breakpoint` attr-dict
</code></pre><p>Breakpoint suspends execution of the program for debugging.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#miscellaneous-instructions-brkpt>For more information, see PTX ISA</a></p><h3 id=nvvmclusterarrive-nvvmclusterarriveop><code>nvvm.cluster.arrive</code> (NVVM::ClusterArriveOp)&nbsp;<a class=headline-hash href=#nvvmclusterarrive-nvvmclusterarriveop>¶</a></h3><p><em>Cluster Barrier Arrive Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cluster.arrive` attr-dict
</code></pre><p>The <code>cluster.arrive</code> can be used by the threads within the cluster for synchronization and
communication. The <code>cluster.arrive</code> instruction marks the warps&rsquo; arrival at the barrier
without causing the executing thread to wait for other participating threads.</p><p>The <code>aligned</code> attribute, when provided, generates the .aligned version of the PTX instruction.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-barrier-cluster>For more information, see PTX ISA</a></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>aligned</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=nvvmclusterarriverelaxed-nvvmclusterarriverelaxedop><code>nvvm.cluster.arrive.relaxed</code> (NVVM::ClusterArriveRelaxedOp)&nbsp;<a class=headline-hash href=#nvvmclusterarriverelaxed-nvvmclusterarriverelaxedop>¶</a></h3><p><em>Cluster Barrier Relaxed Arrive Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cluster.arrive.relaxed` attr-dict
</code></pre><p>The <code>cluster.arrive</code> can be used by the threads within the cluster for synchronization and
communication. The <code>cluster.arrive</code> instruction marks the warps&rsquo; arrival at the barrier
without causing the executing thread to wait for other participating threads.</p><p>The <code>aligned</code> attribute, when provided, generates the .aligned version of the PTX instruction.
The .relaxed qualifier on <code>cluster.arrive</code> specifies that there are no memory
ordering and visibility guarantees provided for the memory accesses performed prior to
<code>cluster.arrive</code>.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-barrier-cluster>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSM&lt;90></code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>aligned</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=nvvmclusterwait-nvvmclusterwaitop><code>nvvm.cluster.wait</code> (NVVM::ClusterWaitOp)&nbsp;<a class=headline-hash href=#nvvmclusterwait-nvvmclusterwaitop>¶</a></h3><p><em>Cluster Barrier Wait Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cluster.wait` attr-dict
</code></pre><p>The <code>cluster.wait</code> causes the executing thread to wait for all non-exited threads
of the cluster to perform <code>cluster.arrive</code>. The <code>aligned</code> attribute, when provided,
generates the .aligned version of the PTX instruction.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-barrier-cluster>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSM&lt;90></code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>aligned</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=nvvmconvertbf16x2tof8x2-nvvmconvertbf16x2tof8x2op><code>nvvm.convert.bf16x2.to.f8x2</code> (NVVM::ConvertBF16x2ToF8x2Op)&nbsp;<a class=headline-hash href=#nvvmconvertbf16x2tof8x2-nvvmconvertbf16x2tof8x2op>¶</a></h3><p><em>Convert a pair of bf16 inputs to f8x2</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.convert.bf16x2.to.f8x2` $type $a attr-dict `:` type($a) `-&gt;` type($dst)
</code></pre><p>This Op converts the given bf16 inputs in a bf16x2 vector to the specified
f8 type.
The result <code>dst</code> is represented as an i16 type or as a vector
of two i8 types.
If <code>dst</code> is returned as an i16 type, the converted values from <code>a</code>
are packed such that the value converted from the first element of <code>a</code>
is stored in the upper 8 bits of <code>dst</code> and the value converted from the
second element of <code>a</code> is stored in the lower 8 bits of <code>dst</code>.
If <code>dst</code> is returned as a vector type, each converted value is stored as an
i8 element in the vector.
The <code>rnd</code> and <code>sat</code> attributes specify the rounding and saturation modes
respectively.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt>For more information, see PTX ISA</a></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::NVVM::ConvertFP8TypeAttr</td><td>NVVM ConvertFP8Type kind</td></tr><tr><td><code>rnd</code></td><td>::mlir::NVVM::FPRoundingModeAttr</td><td>NVVM FPRoundingMode kind</td></tr><tr><td><code>sat</code></td><td>::mlir::NVVM::SaturationModeAttr</td><td>NVVM SaturationMode kind</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>vector of bfloat16 type values of length 2</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>16-bit signless integer or vector of 8-bit signless integer values of length 2</td></tr></tbody></table><h3 id=nvvmconvertf16x2tof8x2-nvvmconvertf16x2tof8x2op><code>nvvm.convert.f16x2.to.f8x2</code> (NVVM::ConvertF16x2ToF8x2Op)&nbsp;<a class=headline-hash href=#nvvmconvertf16x2tof8x2-nvvmconvertf16x2tof8x2op>¶</a></h3><p><em>Convert an f16x2 input to f8x2</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.convert.f16x2.to.f8x2` $type $a attr-dict `:` type($a) `-&gt;` type($dst)
</code></pre><p>This Op converts the given f16 inputs in an f16x2 vector to the specified
f8 type.
The result <code>dst</code> is represented as an i16 type or as a vector
of two i8 types.
If <code>dst</code> is returned as an i16 type, the converted values from <code>a</code>
are packed such that the value converted from the first element of <code>a</code>
is stored in the upper 8 bits of <code>dst</code> and the value converted from the
second element of <code>a</code> is stored in the lower 8 bits of <code>dst</code>.
If <code>dst</code> is returned as a vector type, each converted value is stored as an
i8 element in the vector.
The <code>relu</code> attribute, when set, lowers to the &lsquo;.relu&rsquo; variant of
the cvt instruction.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt>For more information, see PTX ISA</a></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::NVVM::ConvertFP8TypeAttr</td><td>NVVM ConvertFP8Type kind</td></tr><tr><td><code>relu</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>vector of 16-bit float values of length 2</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>16-bit signless integer or vector of 8-bit signless integer values of length 2</td></tr></tbody></table><h3 id=nvvmconvertf32x2tof6x2-nvvmconvertf32x2tof6x2op><code>nvvm.convert.f32x2.to.f6x2</code> (NVVM::ConvertF32x2ToF6x2Op)&nbsp;<a class=headline-hash href=#nvvmconvertf32x2tof6x2-nvvmconvertf32x2tof6x2op>¶</a></h3><p><em>Convert a pair of float inputs to f6x2</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.convert.f32x2.to.f6x2` $type $a `,` $b attr-dict `:` type($dst)
</code></pre><p>This Op converts each of the given float inputs to the specified fp6 type.
The result <code>dst</code> is represented either as an i16 type or as a vector
of two i8 types.
If <code>dst</code> is returned as an i16 type, the converted values are packed such
that the value converted from <code>a</code> is stored in the upper 8 bits of <code>dst</code>
with 2 MSB bits padded with zeros and the value converted from <code>b</code> is
stored in the lower 8 bits of <code>dst</code> with 2 MSB bits padded with zeros.
If <code>dst</code> is returned as a vector type, each converted value is stored as an
i8 element in the vector.
The <code>relu</code> attribute, when set, lowers to the &lsquo;.relu&rsquo; variant of
the cvt instruction.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt>For more information, see PTX ISA</a></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::NVVM::ConvertFP6TypeAttr</td><td>NVVM ConvertFP6Type kind</td></tr><tr><td><code>relu</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>16-bit signless integer or vector of 8-bit signless integer values of length 2</td></tr></tbody></table><h3 id=nvvmconvertf32x2tof8x2-nvvmconvertf32x2tof8x2op><code>nvvm.convert.f32x2.to.f8x2</code> (NVVM::ConvertF32x2ToF8x2Op)&nbsp;<a class=headline-hash href=#nvvmconvertf32x2tof8x2-nvvmconvertf32x2tof8x2op>¶</a></h3><p><em>Convert a pair of float inputs to f8x2</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.convert.f32x2.to.f8x2` $type $a `,` $b attr-dict `:` type($dst)
</code></pre><p>This Op converts each of the given float inputs to the specified fp8 type.
The result <code>dst</code> is represented as an i16 type or as a vector
of two i8 types.
If <code>dst</code> is returned as an i16 type, the converted values are packed such
that the value converted from <code>a</code> is stored in the upper 8 bits of <code>dst</code>
and the value converted from <code>b</code> is stored in the lower 8 bits of <code>dst</code>.
If <code>dst</code> is returned as a vector type, each converted value is stored as an
i8 element in the vector.
The <code>rnd</code> and <code>sat</code> attributes specify the rounding and saturation modes respectively.
The <code>relu</code> attribute, when set, lowers to the &lsquo;.relu&rsquo; variant of
the cvt instruction.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt>For more information, see PTX ISA</a></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type</code></td><td>::mlir::NVVM::ConvertFP8TypeAttr</td><td>NVVM ConvertFP8Type kind</td></tr><tr><td><code>rnd</code></td><td>::mlir::NVVM::FPRoundingModeAttr</td><td>NVVM FPRoundingMode kind</td></tr><tr><td><code>sat</code></td><td>::mlir::NVVM::SaturationModeAttr</td><td>NVVM SaturationMode kind</td></tr><tr><td><code>relu</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>16-bit signless integer or vector of 8-bit signless integer values of length 2</td></tr></tbody></table><h3 id=nvvmconvertfloattotf32-nvvmconvertfloattotf32op><code>nvvm.convert.float.to.tf32</code> (NVVM::ConvertFloatToTF32Op)&nbsp;<a class=headline-hash href=#nvvmconvertfloattotf32-nvvmconvertfloattotf32op>¶</a></h3><p><em>Convert the given float input to TF32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.convert.float.to.tf32` $src attr-dict
</code></pre><p>This Op converts the given f32 input to tf32.
The result <code>res</code> is represented as an i32 type.
The <code>relu</code> attribute, when set, lowers to the &lsquo;.relu&rsquo; variant of
the cvt instruction. The <code>rnd</code> and <code>sat</code> attributes specify the
the rounding and saturation modes respectively.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cvt>For more information, see PTX ISA</a></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rnd</code></td><td>::mlir::NVVM::FPRoundingModeAttr</td><td>NVVM FPRoundingMode kind</td></tr><tr><td><code>sat</code></td><td>::mlir::NVVM::SaturationModeAttr</td><td>NVVM SaturationMode kind</td></tr><tr><td><code>relu</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulkcommitgroup-nvvmcpasyncbulkcommitgroupop><code>nvvm.cp.async.bulk.commit.group</code> (NVVM::CpAsyncBulkCommitGroupOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulkcommitgroup-nvvmcpasyncbulkcommitgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.commit.group` attr-dict
</code></pre><p>This Op commits all prior initiated but uncommitted cp.async.bulk
instructions into a cp.async.bulk-group.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-commit-group>For more information, see PTX ISA</a></p><h3 id=nvvmcpasyncbulkglobalsharedcta-nvvmcpasyncbulksharedctatoglobalop><code>nvvm.cp.async.bulk.global.shared.cta</code> (NVVM::CpAsyncBulkSharedCTAToGlobalOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulkglobalsharedcta-nvvmcpasyncbulksharedctatoglobalop>¶</a></h3><p><em>Async bulk copy from Shared CTA memory to Global memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.global.shared.cta` $dstMem `,` $srcMem `,` $size
              (`l2_cache_hint` `=` $l2CacheHint^ )?
              (`byte_mask` `=` $byteMask^ )?
              attr-dict `:` type($dstMem) `,` type($srcMem)
</code></pre><p>Initiates an asynchronous copy operation from Shared CTA memory to
global memory. The 32-bit operand <code>size</code> specifies the amount of
memory to be copied, in terms of number of bytes. <code>size</code> must be a
multiple of 16. The <code>l2CacheHint</code> operand is optional, and it is used
to specify cache eviction policy that may be used during the memory
access. The <code>byteMask</code> operand is optional. The i-th bit in the 16-bit
wide <code>byteMask</code> specifies whether the i-th byte of each 16-byte wide
chunk of source data is copied to the destination. If the bit is set,
the byte is copied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>global<span class=p>.</span>shared<span class=p>.</span>cta <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// with l2_cache_hint
</span></span></span><span class=line><span class=cl><span class=c></span>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>global<span class=p>.</span>shared<span class=p>.</span>cta <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span> <span class=nl>l2_cache_hint =</span> <span class=nv>%ch</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// with byte_mask
</span></span></span><span class=line><span class=cl><span class=c></span>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>global<span class=p>.</span>shared<span class=p>.</span>cta <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span> <span class=nl>byte_mask =</span> <span class=nv>%mask</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// with both l2_cache_hint and byte_mask
</span></span></span><span class=line><span class=cl><span class=c></span>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>global<span class=p>.</span>shared<span class=p>.</span>cta <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span> <span class=nl>l2_cache_hint =</span> <span class=nv>%ch</span> <span class=nl>byte_mask =</span> <span class=nv>%mask</span>
</span></span><span class=line><span class=cl>      <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>3</span><span class=p>&gt;</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk>For more information, see PTX ISA</a></p><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dstMem</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>byteMask</code></td><td>16-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulkprefetch-nvvmcpasyncbulkprefetchop><code>nvvm.cp.async.bulk.prefetch</code> (NVVM::CpAsyncBulkPrefetchOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulkprefetch-nvvmcpasyncbulkprefetchop>¶</a></h3><p><em>Async bulk prefetch from global memory to L2 cache</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.prefetch` $srcMem `,` $size (`l2_cache_hint` `=` $l2CacheHint^ )?
              attr-dict  `:` type($srcMem)
</code></pre><p>Initiates an asynchronous prefetch of data from the location
specified by <code>srcMem</code> to the L2 cache.</p><p>The <code>l2CacheHint</code> operand is optional, and it is used to specify cache
eviction policy that may be used during the memory access.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>prefetch <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// with l2_cache_hint
</span></span></span><span class=line><span class=cl><span class=c></span>  nvvm<span class=p>.</span>cp<span class=p>.</span>async<span class=p>.</span>bulk<span class=p>.</span>prefetch <span class=nv>%src</span><span class=p>,</span> <span class=nv>%size</span> <span class=nl>l2_cache_hint =</span> <span class=nv>%ch</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-prefetch>For more information, see PTX ISA</a></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulksharedclusterglobal-nvvmcpasyncbulkglobaltosharedclusterop><code>nvvm.cp.async.bulk.shared.cluster.global</code> (NVVM::CpAsyncBulkGlobalToSharedClusterOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulksharedclusterglobal-nvvmcpasyncbulkglobaltosharedclusterop>¶</a></h3><p><em>Async bulk copy from global memory to Shared cluster memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.shared.cluster.global` $dstMem `,` $srcMem `,` $mbar `,` $size
              (`multicast_mask` `=` $multicastMask^ )?
              (`l2_cache_hint` `=` $l2CacheHint^ )?
              attr-dict  `:` type($dstMem) `,` type($srcMem)
</code></pre><p>Initiates an asynchronous copy operation from global memory to cluster&rsquo;s
shared memory.</p><p>The <code>multicastMask</code> operand is optional. When it is present, the Op copies
data from global memory to shared memory of multiple CTAs in the cluster.
Operand <code>multicastMask</code> specifies the destination CTAs in the cluster such
that each bit position in the 16-bit <code>multicastMask</code> operand corresponds to
the <code>nvvm.read.ptx.sreg.ctaid</code> of the destination CTA.</p><p>The <code>l2CacheHint</code> operand is optional, and it is used to specify cache
eviction policy that may be used during the memory access.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk>For more information, see PTX ISA</a></p><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dstMem</code></td><td>LLVM pointer in address space 7</td></tr><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>mbar</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>multicastMask</code></td><td>16-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulksharedclustersharedcta-nvvmcpasyncbulksharedctatosharedclusterop><code>nvvm.cp.async.bulk.shared.cluster.shared.cta</code> (NVVM::CpAsyncBulkSharedCTAToSharedClusterOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulksharedclustersharedcta-nvvmcpasyncbulksharedctatosharedclusterop>¶</a></h3><p><em>Async bulk copy from Shared CTA memory to Shared cluster memory</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.shared.cluster.shared.cta` $dstMem `,` $srcMem `,` $mbar `,` $size
              attr-dict  `:` type($dstMem) `,` type($srcMem)
</code></pre><p>Initiates an asynchronous copy operation from Shared CTA memory to Shared
cluster memory.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk>For more information, see PTX ISA</a></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dstMem</code></td><td>LLVM pointer in address space 7</td></tr><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>mbar</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulktensorglobalsharedcta-nvvmcpasyncbulktensorsharedctatoglobalop><code>nvvm.cp.async.bulk.tensor.global.shared.cta</code> (NVVM::CpAsyncBulkTensorSharedCTAToGlobalOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulktensorglobalsharedcta-nvvmcpasyncbulktensorsharedctatoglobalop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.tensor.global.shared.cta` $tmaDescriptor `,`
              $srcMem `,`
              `box` `[`$coordinates `]`
              (`,` `predicate` `=` $predicate^)?
              attr-dict  `:` type(operands)
</code></pre><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmaDescriptor</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulktensorprefetch-nvvmcpasyncbulktensorprefetchop><code>nvvm.cp.async.bulk.tensor.prefetch</code> (NVVM::CpAsyncBulkTensorPrefetchOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulktensorprefetch-nvvmcpasyncbulktensorprefetchop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.tensor.prefetch` $tmaDescriptor `,`
              `box` `[`$coordinates `]`
              (`im2col` `[` $im2colOffsets^ `]` )?
              (`l2_cache_hint` `=` $l2CacheHint^ )?
              attr-dict  `:` type($tmaDescriptor)
</code></pre><p>Initiates an asynchronous prefetch operation on the tensor data from global
memory to L2 cache.</p><p>The Op has two modes:</p><ol><li><p>Tiled Mode: It&rsquo;s the default mode. The source multi-dimensional tensor
layout is preserved at the destination.</p></li><li><p>Im2col Mode: This mode is used when <code>im2colOffsets</code> operands are present.
the elements in the Bounding Box of the source tensor are rearranged into
columns at the destination. In this mode, the tensor has to be at least
3-dimensional.</p></li></ol><p>The <code>l2CacheHint</code> operand is optional, and it is used to specify cache
eviction policy that may be used during the memory access.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-prefetch-tensor>For more information, see PTX ISA</a></p><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmaDescriptor</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>im2colOffsets</code></td><td>variadic of 16-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulktensorreduce-nvvmcpasyncbulktensorreduceop><code>nvvm.cp.async.bulk.tensor.reduce</code> (NVVM::CpAsyncBulkTensorReduceOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulktensorreduce-nvvmcpasyncbulktensorreduceop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.tensor.reduce` $tmaDescriptor `,`
              $srcMem `,`
              `box` `[`$coordinates `]`
              (`l2_cache_hint` `=` $l2CacheHint^ )?
              attr-dict  `:` type($tmaDescriptor) `,` type($srcMem)
</code></pre><p>Initiates an asynchronous reduction operation of tensor data in
global memory with tensor data in shared memory.</p><p>The <code>mode</code> attribute indicates whether the copy mode is tile or im2col.
The <code>redOp</code> attribute specifies the reduction operations applied.
The supported reduction operations are:
{add, min, max, inc, dec, and, or, xor}</p><p>The <code>l2CacheHint</code> operand is optional, and it is used to specify cache
eviction policy that may be used during the memory access.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-reduce-async-bulk-tensor>For more information, see PTX ISA</a></p><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>redKind</code></td><td>::mlir::NVVM::TMAReduxKindAttr</td><td>NVVM TMA redux kind</td></tr><tr><td><code>mode</code></td><td>::mlir::NVVM::TMAStoreModeAttr</td><td>NVVM TMA Store Mode</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmaDescriptor</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>srcMem</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulktensorsharedclusterglobal-nvvmcpasyncbulktensorglobaltosharedclusterop><code>nvvm.cp.async.bulk.tensor.shared.cluster.global</code> (NVVM::CpAsyncBulkTensorGlobalToSharedClusterOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulktensorsharedclusterglobal-nvvmcpasyncbulktensorglobaltosharedclusterop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.tensor.shared.cluster.global` $dstMem `,`
              $tmaDescriptor `,`
              $mbar `,`
              `box` `[`$coordinates `]`
              (`im2col` `[` $im2colOffsets^ `]` )?
              (`multicast_mask` `=` $multicastMask^ )?
              (`l2_cache_hint` `=` $l2CacheHint^ )?
              (`predicate` `=` $predicate^)?
              attr-dict  `:` type($dstMem) `,` type($tmaDescriptor)
</code></pre><p>Initiates an asynchronous copy operation on the tensor data from global
memory to shared memory.</p><p>The Op operates has two load modes:</p><ol><li><p>Tiled Mode: It&rsquo;s the default mode. The source multi-dimensional tensor
layout is preserved at the destination.</p></li><li><p>Im2col Mode: This mode is used when <code>im2colOffsets</code> operands are present.
the elements in the Bounding Box of the source tensor are rearranged into
columns at the destination. In this mode, the tensor has to be at least
3-dimensional.</p></li></ol><p>The <code>multicastMask</code> operand is optional. When it is present, the Op copies
data from global memory to shared memory of multiple CTAs in the cluster.
Operand <code>multicastMask</code> specifies the destination CTAs in the cluster such
that each bit position in the 16-bit <code>multicastMask</code> operand corresponds to
the <code>nvvm.read.ptx.sreg.ctaid</code> of the destination CTA.</p><p>The <code>l2CacheHint</code> operand is optional, and it is used to specify cache
eviction policy that may be used during the memory access.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-tensor>For more information, see PTX ISA</a></p><p>Traits: <code>AttrSizedOperandSegments</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dstMem</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>tmaDescriptor</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>coordinates</code></td><td>variadic of 32-bit signless integer</td></tr><tr><td style=text-align:center><code>mbar</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>im2colOffsets</code></td><td>variadic of 16-bit signless integer</td></tr><tr><td style=text-align:center><code>multicastMask</code></td><td>16-bit signless integer</td></tr><tr><td style=text-align:center><code>l2CacheHint</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmcpasyncbulkwait_group-nvvmcpasyncbulkwaitgroupop><code>nvvm.cp.async.bulk.wait_group</code> (NVVM::CpAsyncBulkWaitGroupOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncbulkwait_group-nvvmcpasyncbulkwaitgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.bulk.wait_group` $group attr-dict
</code></pre><p>Op waits for completion of the most recent bulk async-groups.</p><p>The <code>$group</code> operand tells waiting has to be done until for $group or fewer
of the most recent bulk async-groups. If <code>$group</code> is 0, the op wait until
all the most recent bulk async-groups have completed.</p><p>The <code>$read</code> indicates that the waiting has to be done until all the bulk
async operations in the specified bulk async-group have completed reading
from their source locations.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#data-movement-and-conversion-instructions-cp-async-bulk-wait-group>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSM&lt;90></code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose minimum value is 0</td></tr><tr><td><code>read</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h3 id=nvvmcpasynccommitgroup-nvvmcpasynccommitgroupop><code>nvvm.cp.async.commit.group</code> (NVVM::CpAsyncCommitGroupOp)&nbsp;<a class=headline-hash href=#nvvmcpasynccommitgroup-nvvmcpasynccommitgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.commit.group` attr-dict
</code></pre><h3 id=nvvmcpasyncmbarrierarrive-nvvmcpasyncmbarrierarriveop><code>nvvm.cp.async.mbarrier.arrive</code> (NVVM::CpAsyncMBarrierArriveOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncmbarrierarrive-nvvmcpasyncmbarrierarriveop>¶</a></h3><p><em>NVVM Dialect Op for cp.async.mbarrier.arrive</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.mbarrier.arrive` $addr attr-dict `:` type(operands)
</code></pre><p>The <code>cp.async.mbarrier.arrive</code> Op makes the mbarrier object track
all prior cp.async operations initiated by the executing thread.
The <code>addr</code> operand specifies the address of the mbarrier object
in generic address space. The <code>noinc</code> attr impacts how the
mbarrier&rsquo;s state is updated.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-cp-async-mbarrier-arrive>For more information, see PTX ISA</a></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>noinc</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=nvvmcpasyncmbarrierarriveshared-nvvmcpasyncmbarrierarrivesharedop><code>nvvm.cp.async.mbarrier.arrive.shared</code> (NVVM::CpAsyncMBarrierArriveSharedOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncmbarrierarriveshared-nvvmcpasyncmbarrierarrivesharedop>¶</a></h3><p><em>NVVM Dialect Op for cp.async.mbarrier.arrive.shared</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.mbarrier.arrive.shared` $addr attr-dict `:` type(operands)
</code></pre><p>The <code>cp.async.mbarrier.arrive.shared</code> Op makes the mbarrier object
track all prior cp.async operations initiated by the executing thread.
The <code>addr</code> operand specifies the address of the mbarrier object in
shared memory. The <code>noinc</code> attr impacts how the mbarrier&rsquo;s state
is updated.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-cp-async-mbarrier-arrive>For more information, see PTX ISA</a></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>noinc</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=nvvmcpasyncsharedglobal-nvvmcpasyncop><code>nvvm.cp.async.shared.global</code> (NVVM::CpAsyncOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncsharedglobal-nvvmcpasyncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.shared.global` $dst `,` $src `,` $size `,` `cache` `=` $modifier (`,` $cpSize^)? attr-dict `:` type(operands)
</code></pre><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>modifier</code></td><td>::mlir::NVVM::LoadCacheModifierKindAttr</td><td><details><summary>NVVM load cache modifier kind</summary><pre><code>Enum attribute of the different kinds of cache operators for load instructions.
<p>
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#id62>For more information, see PTX ISA</a> <br>
</code></pre></p></details></td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>src</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>cpSize</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmcpasyncwaitgroup-nvvmcpasyncwaitgroupop><code>nvvm.cp.async.wait.group</code> (NVVM::CpAsyncWaitGroupOp)&nbsp;<a class=headline-hash href=#nvvmcpasyncwaitgroup-nvvmcpasyncwaitgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.cp.async.wait.group` $n attr-dict
</code></pre><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>n</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=nvvmdotaccumulate2way-nvvmdotaccumulate2wayop><code>nvvm.dot.accumulate.2way</code> (NVVM::DotAccumulate2WayOp)&nbsp;<a class=headline-hash href=#nvvmdotaccumulate2way-nvvmdotaccumulate2wayop>¶</a></h3><p><em>Two-way 16-bit to 8-bit dot product-accumulate instruction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.dot.accumulate.2way` $a $a_type `,` $b $b_type `,` $c attr-dict `:` type($a) `,` type($b)
</code></pre><p>Performs a two-way 16-bit to 8-bit dot-product which is accumulated in a
32-bit result.
Operand <code>a</code> is a vector of two 16-bit elements and operand <code>b</code> a vector
of four 8-bit elements between which the dot product is computed.</p><p>The <code>a_type</code> and <code>b_type</code> attributes specify the type of the elements in <code>a</code>
and <code>b</code> respectively.
If <code>a_type</code> or <code>b_type</code> is <code>s</code>, then the elements in the corresponding
vector are sign-extended to 32-bit before the dot product is computed.
If <code>a_type</code> or <code>b_type</code> is <code>u</code>, then the elements in the corresponding
vector are zero-extended to 32-bit instead.</p><p>The <code>b_hi</code> boolean attribute specifies which two bytes of <code>b</code> are used for
the dot product. If <code>b_hi</code> is true, then the dot product is computed
between <code>a</code> and elements at indices 2 and 3 of <code>b</code>. If <code>b_hi</code> is false,
then the dot product is computed between <code>a</code> and elements at indices 0 and
1 of <code>b</code>.</p><p>Operand <code>c</code> is a 32-bit integer to which the result is accumulated. It is
treated as holding a signed integer if any of <code>a_type</code> or <code>b_type</code> is
signed.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp2a>For more information, see PTX ISA</a></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>a_type</code></td><td>::mlir::NVVM::DotAccumulateTypeAttr</td><td>NVVM DotAccumulateType</td></tr><tr><td><code>b_type</code></td><td>::mlir::NVVM::DotAccumulateTypeAttr</td><td>NVVM DotAccumulateType</td></tr><tr><td><code>b_hi</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>b</code></td><td>vector of 8-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmdotaccumulate4way-nvvmdotaccumulate4wayop><code>nvvm.dot.accumulate.4way</code> (NVVM::DotAccumulate4WayOp)&nbsp;<a class=headline-hash href=#nvvmdotaccumulate4way-nvvmdotaccumulate4wayop>¶</a></h3><p><em>Four-way byte dot product-accumulate instruction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.dot.accumulate.4way` $a $a_type `,` $b $b_type `,` $c attr-dict `:` type($a) `,` type($b)
</code></pre><p>Performs a four-way byte dot-product which is accumulated in a 32-bit
result.
Operand <code>a</code> and <code>b</code> are vectors of 4 bytes between which the dot product is
computed.</p><p>The <code>a_type</code> and <code>b_type</code> attributes specify the type of the elements in <code>a</code>
and <code>b</code> respectively.
If <code>a_type</code> or <code>b_type</code> is <code>signed</code>, then the elements in the corresponding
vector are sign-extended to 32-bit before the dot product is computed.
If <code>a_type</code> or <code>b_type</code> is <code>unsigned</code>, then the elements in the
corresponding vector are zero-extended to 32-bit instead.</p><p>Operand <code>c</code> is a 32-bit integer to which the result is accumulated. It is
treated as holding a signed integer if any of <code>a_type</code> or <code>b_type</code> is <code>s8</code>.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#integer-arithmetic-instructions-dp4a>For more information, see PTX ISA</a></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>a_type</code></td><td>::mlir::NVVM::DotAccumulateTypeAttr</td><td>NVVM DotAccumulateType</td></tr><tr><td><code>b_type</code></td><td>::mlir::NVVM::DotAccumulateTypeAttr</td><td>NVVM DotAccumulateType</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>vector of 8-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>b</code></td><td>vector of 8-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmelectsync-nvvmelectsyncop><code>nvvm.elect.sync</code> (NVVM::ElectSyncOp)&nbsp;<a class=headline-hash href=#nvvmelectsync-nvvmelectsyncop>¶</a></h3><p><em>Elect one leader thread</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.elect.sync` ($membermask^)? attr-dict `-&gt;` type(results)
</code></pre><p>The <code>elect.sync</code> instruction elects one predicated active leader
thread from among a set of threads specified in the <code>membermask</code>.
When the <code>membermask</code> is not provided explicitly, a default value
of <code>0xFFFFFFFF</code> is used. The predicate result is set to <code>True</code> for
the leader thread, and <code>False</code> for all other threads.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-elect-sync>For more information, see PTX ISA</a></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>membermask</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pred</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmexit-nvvmexit><code>nvvm.exit</code> (NVVM::Exit)&nbsp;<a class=headline-hash href=#nvvmexit-nvvmexit>¶</a></h3><p><em>Exit Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.exit` attr-dict
</code></pre><p>Ends execution of a thread.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#control-flow-instructions-exit>For more information, see PTX ISA</a></p><h3 id=nvvmfencembarrierinit-nvvmfencembarrierinitop><code>nvvm.fence.mbarrier.init</code> (NVVM::FenceMbarrierInitOp)&nbsp;<a class=headline-hash href=#nvvmfencembarrierinit-nvvmfencembarrierinitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.fence.mbarrier.init` attr-dict
</code></pre><p>Fence operation that applies on the prior nvvm.mbarrier.init</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-membar>For more information, see PTX ISA</a></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h3 id=nvvmfenceproxy-nvvmfenceproxyop><code>nvvm.fence.proxy</code> (NVVM::FenceProxyOp)&nbsp;<a class=headline-hash href=#nvvmfenceproxy-nvvmfenceproxyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.fence.proxy` attr-dict
</code></pre><p>Fence operation with proxy to establish an ordering between memory accesses
that may happen through different proxies.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-membar>For more information, see PTX ISA</a></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::ProxyKindAttr</td><td>Proxy kind</td></tr><tr><td><code>space</code></td><td>::mlir::NVVM::SharedSpaceAttr</td><td>Shared memory space</td></tr></table><h3 id=nvvmfenceproxyacquire-nvvmfenceproxyacquireop><code>nvvm.fence.proxy.acquire</code> (NVVM::FenceProxyAcquireOp)&nbsp;<a class=headline-hash href=#nvvmfenceproxyacquire-nvvmfenceproxyacquireop>¶</a></h3><p><em>Uni-directional proxy fence operation with acquire semantics</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.fence.proxy.acquire` $scope $addr `,` $size (`from_proxy` `=` $fromProxy^)? (`to_proxy` `=` $toProxy^)? attr-dict
</code></pre><p><code>fence.proxy.acquire</code> is a uni-directional fence used to establish ordering
between a prior memory access performed via the generic proxy and a
subsequent memory access performed via the tensormap proxy</p><p>The address operand <code>addr</code> and the operand <code>size</code> together specify the
memory range <code>[addr, addr+size)</code> on which the ordering guarantees on the
memory accesses across the proxies is to be provided. The only supported
value for the <code>size</code> operand is 128 and must be an immediate. Generic Addressing
is used unconditionally, and the address specified by the operand <code>addr</code> must
fall within the <code>.global</code> state space. Otherwise, the behavior is undefined</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-membar>For more information, see PTX ISA</a></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::NVVM::MemScopeKindAttr</td><td>NVVM Memory Scope kind</td></tr><tr><td><code>fromProxy</code></td><td>::mlir::NVVM::ProxyKindAttr</td><td>Proxy kind</td></tr><tr><td><code>toProxy</code></td><td>::mlir::NVVM::ProxyKindAttr</td><td>Proxy kind</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 0</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmfenceproxyrelease-nvvmfenceproxyreleaseop><code>nvvm.fence.proxy.release</code> (NVVM::FenceProxyReleaseOp)&nbsp;<a class=headline-hash href=#nvvmfenceproxyrelease-nvvmfenceproxyreleaseop>¶</a></h3><p><em>Uni-directional proxy fence operation with release semantics</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.fence.proxy.release` $scope (`from_proxy` `=` $fromProxy^)? (`to_proxy` `=` $toProxy^)? attr-dict
</code></pre><p><code>fence.proxy.release</code> is a uni-directional fence used to establish ordering
between a prior memory access performed via the generic proxy and a
subsequent memory access performed via the tensormap proxy. <code>fence.proxy.release</code>
operation can form a release sequence that synchronizes with an acquire
sequence that contains the fence.proxy.acquire proxy fence operation</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#parallel-synchronization-and-communication-instructions-membar>For more information, see PTX ISA</a></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::NVVM::MemScopeKindAttr</td><td>NVVM Memory Scope kind</td></tr><tr><td><code>fromProxy</code></td><td>::mlir::NVVM::ProxyKindAttr</td><td>Proxy kind</td></tr><tr><td><code>toProxy</code></td><td>::mlir::NVVM::ProxyKindAttr</td><td>Proxy kind</td></tr></table><h3 id=nvvmfencesccluster-nvvmfencescclusterop><code>nvvm.fence.sc.cluster</code> (NVVM::FenceScClusterOp)&nbsp;<a class=headline-hash href=#nvvmfencesccluster-nvvmfencescclusterop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.fence.sc.cluster` attr-dict
</code></pre><h3 id=nvvmgriddepcontrollaunchdependents-nvvmgriddepcontrollaunchdependentsop><code>nvvm.griddepcontrol.launch.dependents</code> (NVVM::GriddepcontrolLaunchDependentsOp)&nbsp;<a class=headline-hash href=#nvvmgriddepcontrollaunchdependents-nvvmgriddepcontrollaunchdependentsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.griddepcontrol.launch.dependents` attr-dict
</code></pre><p>Signals that specific dependents the runtime system designated to react to
this instruction can be scheduled as soon as all other CTAs in the grid
issue the same instruction or have completed.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol>For more information, see PTX ISA</a></p><h3 id=nvvmgriddepcontrolwait-nvvmgriddepcontrolwaitop><code>nvvm.griddepcontrol.wait</code> (NVVM::GriddepcontrolWaitOp)&nbsp;<a class=headline-hash href=#nvvmgriddepcontrolwait-nvvmgriddepcontrolwaitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.griddepcontrol.wait` attr-dict
</code></pre><p>Causes the executing thread to wait until all prerequisite grids in flight
have completed and all the memory operations from the prerequisite grids
are performed and made visible to the current grid.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-griddepcontrol>For more information, see PTX ISA</a></p><h3 id=nvvminline_ptx-nvvminlineptxop><code>nvvm.inline_ptx</code> (NVVM::InlinePtxOp)&nbsp;<a class=headline-hash href=#nvvminline_ptx-nvvminlineptxop>¶</a></h3><p><em>Inline PTX Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.inline_ptx` $ptxCode `(` $readOnlyArgs `)`
              (`,` `predicate` `=` $predicate^)? attr-dict
              `:` type(operands)
              (`-&gt;` type($writeOnlyArgs)^)?
</code></pre><p>This op allows using PTX directly within the NVVM
dialect, while greatly simplifying llvm.inline_asm generation. It
automatically handles register size selection and sets the correct
read/write access for each operand. The operation leverages the
<code>BasicPtxBuilderInterface</code> to abstract away low-level details of
PTX assembly formatting.</p><pre><code>The `predicate` attribute is used to specify a predicate for the 
PTX instruction.

Example 1: Read-only Parameters
```mlir
nvvm.inline_ptx &quot;mbarrier.init.b64 [$0], $1;&quot; (%barrier_gen, %count) : !llvm.ptr, i32

// Lowers to:
llvm.inline_asm has_side_effects asm_dialect = att 
  &quot;mbarrier.init.b64 [$0], $1;&quot;, &quot;l,r&quot; %arg0, %arg2 : (!llvm.ptr, i32) -&gt; ()
```

Example 2: Read-only and Write-only Parameters
```mlir
%0 = nvvm.inline_ptx &quot;ex2.approx.ftz.f32 $0, $1;&quot; (%input) : f32 -&gt; f32

// Lowers to:
%0 = llvm.inline_asm has_side_effects asm_dialect = att 
  &quot;ex2.approx.ftz.f32 $0, $1;&quot;, &quot;=f,f&quot; %arg0 : (f32) -&gt; f32
```

Example 3: Predicate Usage
```mlir
nvvm.inline_ptx &quot;mbarrier.init.b64 [$0], $1;&quot; (%barrier_gen, %count), 
  predicate = %pred : !llvm.ptr, i32, i1

// Lowers to:
llvm.inline_asm has_side_effects asm_dialect = att 
  &quot;@$2 mbarrier.init.b64 [$0], $1;&quot;, &quot;l,r,b&quot; %arg0, %arg2, %arg3 
  : (!llvm.ptr, i32, i1) -&gt; ()
```
</code></pre><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ptxCode</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>readOnlyArgs</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>writeOnlyArgs</code></td><td>variadic of any type</td></tr></tbody></table><h3 id=nvvmldmatrix-nvvmldmatrixop><code>nvvm.ldmatrix</code> (NVVM::LdMatrixOp)&nbsp;<a class=headline-hash href=#nvvmldmatrix-nvvmldmatrixop>¶</a></h3><p><em>Cooperative matrix load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.ldmatrix` $ptr attr-dict `:` functional-type($ptr, $res)
</code></pre><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>num</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>layout</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>any type</td></tr></tbody></table><h3 id=nvvmmapa-nvvmmapaop><code>nvvm.mapa</code> (NVVM::MapaOp)&nbsp;<a class=headline-hash href=#nvvmmapa-nvvmmapaop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mapa` $a`,` $b attr-dict `:` type($a) `-&gt;` type($res)
</code></pre><p>Traits: <code>NVVMRequiresSM&lt;90></code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>LLVM pointer in address space 0 or LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>b</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer in address space 0 or LLVM pointer in address space 3</td></tr></tbody></table><h3 id=nvvmmatchsync-nvvmmatchsyncop><code>nvvm.match.sync</code> (NVVM::MatchSyncOp)&nbsp;<a class=headline-hash href=#nvvmmatchsync-nvvmmatchsyncop>¶</a></h3><p><em>Broadcast and compare a value across threads in warp</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.match.sync` $kind $thread_mask `,` $val attr-dict `:` type($val) `-&gt;` type($res)
</code></pre><p>The <code>match.sync</code> op performs broadcast and compare of operand <code>val</code> across
all non-exited threads in <code>thread_mask</code> and returns a mask depending on the
kind and an optional predicate.</p><p>The matching operation kinds are:</p><ul><li><code>any</code>: Returns a mask corresponding to the non-exited threads in the
<code>thread_mask</code> that have the same value of operand <code>val</code>.</li><li><code>all</code>: Returns a mask and a predicate. If all non-exited threads in the
<code>thread_mask</code> have the same value of operand <code>val</code>, the predicate is set to
true and the mask corresponds to the non-exited threads in the
<code>thread_mask</code>. Otherwise, the predicate is set to false and the mask is 0.</li></ul><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-match-sync>For more information, see PTX ISA</a></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::MatchSyncKindAttr</td><td>NVVM match sync kind</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>thread_mask</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or LLVM struct type</td></tr></tbody></table><h3 id=nvvmmbarrierarrive-nvvmmbarrierarriveop><code>nvvm.mbarrier.arrive</code> (NVVM::MBarrierArriveOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarrive-nvvmmbarrierarriveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive` $addr attr-dict `:` type($addr) `-&gt;` type($res)
</code></pre><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarrierarriveexpect_tx-nvvmmbarrierarriveexpecttxop><code>nvvm.mbarrier.arrive.expect_tx</code> (NVVM::MBarrierArriveExpectTxOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarriveexpect_tx-nvvmmbarrierarriveexpecttxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive.expect_tx` $addr `,` $txcount (`,` `predicate` `=` $predicate^)? attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>txcount</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmmbarrierarriveexpect_txshared-nvvmmbarrierarriveexpecttxsharedop><code>nvvm.mbarrier.arrive.expect_tx.shared</code> (NVVM::MBarrierArriveExpectTxSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarriveexpect_txshared-nvvmmbarrierarriveexpecttxsharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive.expect_tx.shared` $addr `,` $txcount (`,` `predicate` `=` $predicate^)? attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>txcount</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmmbarrierarrivenocomplete-nvvmmbarrierarrivenocompleteop><code>nvvm.mbarrier.arrive.nocomplete</code> (NVVM::MBarrierArriveNocompleteOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarrivenocomplete-nvvmmbarrierarrivenocompleteop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive.nocomplete` $addr `,` $count attr-dict `:` type(operands) `-&gt;` type($res)
</code></pre><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>count</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarrierarrivenocompleteshared-nvvmmbarrierarrivenocompletesharedop><code>nvvm.mbarrier.arrive.nocomplete.shared</code> (NVVM::MBarrierArriveNocompleteSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarrivenocompleteshared-nvvmmbarrierarrivenocompletesharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive.nocomplete.shared` $addr `,` $count attr-dict `:` type(operands) `-&gt;` type($res)
</code></pre><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>count</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarrierarriveshared-nvvmmbarrierarrivesharedop><code>nvvm.mbarrier.arrive.shared</code> (NVVM::MBarrierArriveSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierarriveshared-nvvmmbarrierarrivesharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.arrive.shared` $addr attr-dict `:` qualified(type($addr)) `-&gt;` type($res)
</code></pre><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarrierinit-nvvmmbarrierinitop><code>nvvm.mbarrier.init</code> (NVVM::MBarrierInitOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierinit-nvvmmbarrierinitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.init` $addr `,` $count (`,` `predicate` `=` $predicate^)? attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>count</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmmbarrierinitshared-nvvmmbarrierinitsharedop><code>nvvm.mbarrier.init.shared</code> (NVVM::MBarrierInitSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierinitshared-nvvmmbarrierinitsharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.init.shared` $addr `,` $count (`,` `predicate` `=` $predicate^)? attr-dict `:` type(operands)
</code></pre><p>Traits: <code>NVVMRequiresSM&lt;80></code></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>count</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmmbarrierinval-nvvmmbarrierinvalop><code>nvvm.mbarrier.inval</code> (NVVM::MBarrierInvalOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierinval-nvvmmbarrierinvalop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.inval` $addr attr-dict `:` type(operands)
</code></pre><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=nvvmmbarrierinvalshared-nvvmmbarrierinvalsharedop><code>nvvm.mbarrier.inval.shared</code> (NVVM::MBarrierInvalSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarrierinvalshared-nvvmmbarrierinvalsharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.inval.shared` $addr attr-dict `:` type(operands)
</code></pre><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=nvvmmbarriertestwait-nvvmmbarriertestwaitop><code>nvvm.mbarrier.test.wait</code> (NVVM::MBarrierTestWaitOp)&nbsp;<a class=headline-hash href=#nvvmmbarriertestwait-nvvmmbarriertestwaitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.test.wait` $addr `,` $state attr-dict `:` type(operands) `-&gt;` type($res)
</code></pre><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>state</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarriertestwaitshared-nvvmmbarriertestwaitsharedop><code>nvvm.mbarrier.test.wait.shared</code> (NVVM::MBarrierTestWaitSharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarriertestwaitshared-nvvmmbarriertestwaitsharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.test.wait.shared` $addr `,` $state attr-dict `:` type(operands) `-&gt;` type($res)
</code></pre><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>state</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmmbarriertry_waitparity-nvvmmbarriertrywaitparityop><code>nvvm.mbarrier.try_wait.parity</code> (NVVM::MBarrierTryWaitParityOp)&nbsp;<a class=headline-hash href=#nvvmmbarriertry_waitparity-nvvmmbarriertrywaitparityop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.try_wait.parity` $addr `,` $phase `,` $ticks attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>phase</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>ticks</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmmbarriertry_waitparityshared-nvvmmbarriertrywaitparitysharedop><code>nvvm.mbarrier.try_wait.parity.shared</code> (NVVM::MBarrierTryWaitParitySharedOp)&nbsp;<a class=headline-hash href=#nvvmmbarriertry_waitparityshared-nvvmmbarriertrywaitparitysharedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.mbarrier.try_wait.parity.shared` $addr `,` $phase `,` $ticks attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>phase</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>ticks</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmmmasync-nvvmmmaop><code>nvvm.mma.sync</code> (NVVM::MmaOp)&nbsp;<a class=headline-hash href=#nvvmmmasync-nvvmmmaop>¶</a></h3><p><em>Cooperative matrix-multiply and accumulate</em></p><p>The <code>nvvm.mma.sync</code> operation collectively performs the operation
<code>D = matmul(A, B) + C</code> using all threads in a warp.</p><p>All the threads in the warp must execute the same <code>mma.sync</code> operation.</p><p>For each possible multiplicand PTX data type, there are one or more possible
instruction shapes given as &ldquo;mMnNkK&rdquo;. The below table describes the posssibilities
as well as the types required for the operands. Note that the data type for
C (the accumulator) and D (the result) can vary independently when there are
multiple possibilities in the &ldquo;C/D Type&rdquo; column.</p><p>When an optional attribute cannot be immediately inferred from the types of
the operands and the result during parsing or validation, an error will be
raised.</p><p><code>b1Op</code> is only relevant when the binary (b1) type is given to
<code>multiplicandDataType</code>. It specifies how the multiply-and-acumulate is
performed and is either <code>xor_popc</code> or <code>and_poc</code>. The default is <code>xor_popc</code>.</p><p><code>intOverflowBehavior</code> is only relevant when the <code>multiplicandType</code> attribute
is one of <code>u8, s8, u4, s4</code>, this attribute describes how overflow is handled
in the accumulator. When the attribute is <code>satfinite</code>, the accumulator values
are clamped in the int32 range on overflow. This is the default behavior.
Alternatively, accumulator behavior <code>wrapped</code> can also be specified, in
which case overflow wraps from one end of the range to the other.</p><p><code>layoutA</code> and <code>layoutB</code> are required and should generally be set to
<code>#nvvm.mma_layout&lt;row></code> and <code>#nvvm.mma_layout&lt;col></code> respectively, but other
combinations are possible for certain layouts according to the table below.</p><pre tabindex=0><code>| A/B Type | Shape     | ALayout | BLayout | A Type   | B Type   | C/D Type          |
|----------|-----------|---------|---------|----------|----------|-------------------|
| f64      | .m8n8k4   | row     | col     | 1x f64   | 1x f64   | 2x f64            |
| f16      | .m8n8k4   | row/col | row/col | 2x f16x2 | 2x f16x2 | 4x f16x2 or 8xf32 |
|          | .m16n8k8  | row     | col     | 2x f16x2 | 1x f16x2 | 2x f16x2 or 4 f32 |
|          | .m16n8k16 | row     | col     | 4x f16x2 | 2x f16x2 | 2x f16x2 or 4 f32 |
| bf16     | .m16n8k8  | row     | col     | 2x i32   | 1x i32   | 4x f32            |
|          | .m16n8k16 | row     | col     | 4x i32   | 2x i32   | 4x f32            |
| tf32     | .m16n8k4  | row     | col     | 2x i32   | 1x i32   | 4x f32            |
|          | .m16n8k8  | row     | col     | 4x i32   | 2x i32   | 2x f16x2 or 4 f32 |
| u8/s8    | .m8n8k16  | row     | col     | 1x i32   | 1x i32   | 2x i32            |
|          | .m16n8k16 | row     | col     | 2x i32   | 1x i32   | 4x i32            |
|          | .m16n8k32 | row     | col     | 4x i32   | 2x i32   | 4x i32            |
| u4/s4    | .m8n8k32  | row     | col     | 1x i32   | 1x i32   | 2x i32            |
|          | m16n8k32  | row     | col     | 2x i32   | 1x i32   | 4x i32            |
|          | m16n8k64  | row     | col     | 4x i32   | 2x i32   | 4x i32            |
| b1       | m8n8k128  | row     | col     | 1x i32   | 1x i32   | 2x i32            |
|          | m16n8k128 | row     | col     | 2x i32   | 1x i32   | 4x i32            |
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%128</span> <span class=p>=</span> nvvm<span class=p>.</span>mma<span class=p>.</span>sync A<span class=p>[</span><span class=nv>%120</span><span class=p>,</span> <span class=nv>%121</span><span class=p>,</span> <span class=nv>%122</span><span class=p>,</span> <span class=nv>%123</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                     B<span class=p>[</span><span class=nv>%124</span><span class=p>,</span> <span class=nv>%125</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                     C<span class=p>[</span><span class=nv>%126</span><span class=p>,</span> <span class=nv>%127</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                     <span class=p>{</span><span class=nl>layoutA =</span> <span class=nv>#nvvm.mma_layout</span><span class=p>&lt;</span>row<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>                      <span class=nl>layoutB =</span> <span class=nv>#nvvm.mma_layout</span><span class=p>&lt;</span>col<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>                      <span class=nl>shape =</span> <span class=p>{</span><span class=nl>k =</span> <span class=m>16</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>m =</span> <span class=m>16</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>n =</span> <span class=m>8</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f16</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f16</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f16</span><span class=p>&gt;)</span>
</span></span><span class=line><span class=cl>       <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f16</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=k>f16</span><span class=p>&gt;)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::MMAShapeAttr</td><td>Attribute for MMA operation shape.</td></tr><tr><td><code>b1Op</code></td><td>::mlir::NVVM::MMAB1OpAttr</td><td>MMA binary operations</td></tr><tr><td><code>intOverflowBehavior</code></td><td>::mlir::NVVM::MMAIntOverflowAttr</td><td>MMA overflow options</td></tr><tr><td><code>layoutA</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>layoutB</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>multiplicandAPtxType</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr><tr><td><code>multiplicandBPtxType</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operandA</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>operandB</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>operandC</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM structure type</td></tr></tbody></table><h3 id=nvvmprefetch-nvvmprefetchop><code>nvvm.prefetch</code> (NVVM::PrefetchOp)&nbsp;<a class=headline-hash href=#nvvmprefetch-nvvmprefetchop>¶</a></h3><p><em>Brings the cache line containing an address into the specified cache level</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.prefetch` `level` `=` $cacheLevel (`uniform` $uniform^)? `,` $addr (`,` `evict_priority` `=` $evictPriority^)? attr-dict `:` type($addr)
</code></pre><p>Operand <code>addr</code> can be a global, local or generic address pointer. No
operation is performed if <code>addr</code> maps to a <code>shared</code> memory location.</p><p>The <code>cacheLevel</code> attribute specifies the cache level to which the cache line
containing the specified address is brought.</p><p><code>uniform</code> can be specified after the <code>cacheLevel</code> to indicate that the
prefetch is performed to the specified uniform cache level. If <code>uniform</code> is
specified, <code>addr</code> must be a generic address pointer and no operation is
performed if <code>addr</code> maps to a <code>const</code>, <code>local</code>, or <code>shared</code> memory location.</p><p>The <code>evictPriority</code> attribute is optional and specifies the cache eviction
priority when <code>cacheLevel</code> is L2.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-prefetch-prefetchu>For more information, see PTX ISA</a></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cacheLevel</code></td><td>::mlir::NVVM::PrefetchCacheLevelAttr</td><td><details><summary>NVVM Prefetch Cache Level</summary><p>Enum cases:</p><ul><li>L1 (<code>L1</code>)</li><li>L2 (<code>L2</code>)</li></ul></details></td></tr><tr><td><code>uniform</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>evictPriority</code></td><td>::mlir::NVVM::CacheEvictionPriorityAttr</td><td><details><summary>NVVM Cache Eviction Priority</summary><p>Enum cases:</p><ul><li>evict_normal (<code>EvictNormal</code>)</li><li>evict_first (<code>EvictFirst</code>)</li><li>evict_last (<code>EvictLast</code>)</li><li>evict_unchanged (<code>EvictUnchanged</code>)</li><li>no_allocate (<code>NoAllocate</code>)</li></ul></details></td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 1 or LLVM pointer in address space 5 or LLVM pointer in address space 0</td></tr></tbody></table><h3 id=nvvmprefetchtensormap-nvvmprefetchtensormapop><code>nvvm.prefetch.tensormap</code> (NVVM::PrefetchTensorMapOp)&nbsp;<a class=headline-hash href=#nvvmprefetchtensormap-nvvmprefetchtensormapop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.prefetch.tensormap` $tmaDescriptor (`,` `predicate` `=` $predicate^)? attr-dict `:` type(operands)
</code></pre><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmaDescriptor</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=nvvmrcpapproxftzf-nvvmrcpapproxftzf32op><code>nvvm.rcp.approx.ftz.f</code> (NVVM::RcpApproxFtzF32Op)&nbsp;<a class=headline-hash href=#nvvmrcpapproxftzf-nvvmrcpapproxftzf32op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.rcp.approx.ftz.f` $arg attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float</td></tr></tbody></table><h3 id=nvvmreadptxsregclock-nvvmclockop><code>nvvm.read.ptx.sreg.clock</code> (NVVM::ClockOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclock-nvvmclockop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.clock` attr-dict `:` type($res)
</code></pre><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclock64-nvvmclock64op><code>nvvm.read.ptx.sreg.clock64</code> (NVVM::Clock64Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclock64-nvvmclock64op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.clock64` attr-dict `:` type($res)
</code></pre><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusterctaidx-nvvmblockinclusteridxop><code>nvvm.read.ptx.sreg.cluster.ctaid.x</code> (NVVM::BlockInClusterIdXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusterctaidx-nvvmblockinclusteridxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.ctaid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusterctaidy-nvvmblockinclusteridyop><code>nvvm.read.ptx.sreg.cluster.ctaid.y</code> (NVVM::BlockInClusterIdYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusterctaidy-nvvmblockinclusteridyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.ctaid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusterctaidz-nvvmblockinclusteridzop><code>nvvm.read.ptx.sreg.cluster.ctaid.z</code> (NVVM::BlockInClusterIdZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusterctaidz-nvvmblockinclusteridzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.ctaid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusterctarank-nvvmclusterid><code>nvvm.read.ptx.sreg.cluster.ctarank</code> (NVVM::ClusterId)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusterctarank-nvvmclusterid>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.ctarank` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusternctaidx-nvvmclusterdimblocksxop><code>nvvm.read.ptx.sreg.cluster.nctaid.x</code> (NVVM::ClusterDimBlocksXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusternctaidx-nvvmclusterdimblocksxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.nctaid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusternctaidy-nvvmclusterdimblocksyop><code>nvvm.read.ptx.sreg.cluster.nctaid.y</code> (NVVM::ClusterDimBlocksYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusternctaidy-nvvmclusterdimblocksyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.nctaid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusternctaidz-nvvmclusterdimblockszop><code>nvvm.read.ptx.sreg.cluster.nctaid.z</code> (NVVM::ClusterDimBlocksZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusternctaidz-nvvmclusterdimblockszop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.nctaid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusternctarank-nvvmclusterdim><code>nvvm.read.ptx.sreg.cluster.nctarank</code> (NVVM::ClusterDim)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusternctarank-nvvmclusterdim>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.cluster.nctarank` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusteridx-nvvmclusteridxop><code>nvvm.read.ptx.sreg.clusterid.x</code> (NVVM::ClusterIdXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusteridx-nvvmclusteridxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.clusterid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>NVVMRequiresSM&lt;90></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusteridy-nvvmclusteridyop><code>nvvm.read.ptx.sreg.clusterid.y</code> (NVVM::ClusterIdYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusteridy-nvvmclusteridyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.clusterid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregclusteridz-nvvmclusteridzop><code>nvvm.read.ptx.sreg.clusterid.z</code> (NVVM::ClusterIdZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregclusteridz-nvvmclusteridzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.clusterid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregctaidx-nvvmblockidxop><code>nvvm.read.ptx.sreg.ctaid.x</code> (NVVM::BlockIdXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregctaidx-nvvmblockidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ctaid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregctaidy-nvvmblockidyop><code>nvvm.read.ptx.sreg.ctaid.y</code> (NVVM::BlockIdYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregctaidy-nvvmblockidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ctaid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregctaidz-nvvmblockidzop><code>nvvm.read.ptx.sreg.ctaid.z</code> (NVVM::BlockIdZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregctaidz-nvvmblockidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ctaid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg0-nvvmenvreg0op><code>nvvm.read.ptx.sreg.envreg0</code> (NVVM::EnvReg0Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg0-nvvmenvreg0op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg0` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg1-nvvmenvreg1op><code>nvvm.read.ptx.sreg.envreg1</code> (NVVM::EnvReg1Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg1-nvvmenvreg1op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg1` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg10-nvvmenvreg10op><code>nvvm.read.ptx.sreg.envreg10</code> (NVVM::EnvReg10Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg10-nvvmenvreg10op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg10` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg11-nvvmenvreg11op><code>nvvm.read.ptx.sreg.envreg11</code> (NVVM::EnvReg11Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg11-nvvmenvreg11op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg11` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg12-nvvmenvreg12op><code>nvvm.read.ptx.sreg.envreg12</code> (NVVM::EnvReg12Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg12-nvvmenvreg12op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg12` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg13-nvvmenvreg13op><code>nvvm.read.ptx.sreg.envreg13</code> (NVVM::EnvReg13Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg13-nvvmenvreg13op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg13` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg14-nvvmenvreg14op><code>nvvm.read.ptx.sreg.envreg14</code> (NVVM::EnvReg14Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg14-nvvmenvreg14op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg14` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg15-nvvmenvreg15op><code>nvvm.read.ptx.sreg.envreg15</code> (NVVM::EnvReg15Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg15-nvvmenvreg15op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg15` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg16-nvvmenvreg16op><code>nvvm.read.ptx.sreg.envreg16</code> (NVVM::EnvReg16Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg16-nvvmenvreg16op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg16` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg17-nvvmenvreg17op><code>nvvm.read.ptx.sreg.envreg17</code> (NVVM::EnvReg17Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg17-nvvmenvreg17op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg17` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg18-nvvmenvreg18op><code>nvvm.read.ptx.sreg.envreg18</code> (NVVM::EnvReg18Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg18-nvvmenvreg18op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg18` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg19-nvvmenvreg19op><code>nvvm.read.ptx.sreg.envreg19</code> (NVVM::EnvReg19Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg19-nvvmenvreg19op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg19` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg2-nvvmenvreg2op><code>nvvm.read.ptx.sreg.envreg2</code> (NVVM::EnvReg2Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg2-nvvmenvreg2op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg2` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg20-nvvmenvreg20op><code>nvvm.read.ptx.sreg.envreg20</code> (NVVM::EnvReg20Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg20-nvvmenvreg20op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg20` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg21-nvvmenvreg21op><code>nvvm.read.ptx.sreg.envreg21</code> (NVVM::EnvReg21Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg21-nvvmenvreg21op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg21` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg22-nvvmenvreg22op><code>nvvm.read.ptx.sreg.envreg22</code> (NVVM::EnvReg22Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg22-nvvmenvreg22op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg22` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg23-nvvmenvreg23op><code>nvvm.read.ptx.sreg.envreg23</code> (NVVM::EnvReg23Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg23-nvvmenvreg23op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg23` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg24-nvvmenvreg24op><code>nvvm.read.ptx.sreg.envreg24</code> (NVVM::EnvReg24Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg24-nvvmenvreg24op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg24` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg25-nvvmenvreg25op><code>nvvm.read.ptx.sreg.envreg25</code> (NVVM::EnvReg25Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg25-nvvmenvreg25op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg25` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg26-nvvmenvreg26op><code>nvvm.read.ptx.sreg.envreg26</code> (NVVM::EnvReg26Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg26-nvvmenvreg26op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg26` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg27-nvvmenvreg27op><code>nvvm.read.ptx.sreg.envreg27</code> (NVVM::EnvReg27Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg27-nvvmenvreg27op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg27` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg28-nvvmenvreg28op><code>nvvm.read.ptx.sreg.envreg28</code> (NVVM::EnvReg28Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg28-nvvmenvreg28op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg28` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg29-nvvmenvreg29op><code>nvvm.read.ptx.sreg.envreg29</code> (NVVM::EnvReg29Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg29-nvvmenvreg29op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg29` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg3-nvvmenvreg3op><code>nvvm.read.ptx.sreg.envreg3</code> (NVVM::EnvReg3Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg3-nvvmenvreg3op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg3` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg30-nvvmenvreg30op><code>nvvm.read.ptx.sreg.envreg30</code> (NVVM::EnvReg30Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg30-nvvmenvreg30op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg30` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg31-nvvmenvreg31op><code>nvvm.read.ptx.sreg.envreg31</code> (NVVM::EnvReg31Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg31-nvvmenvreg31op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg31` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg4-nvvmenvreg4op><code>nvvm.read.ptx.sreg.envreg4</code> (NVVM::EnvReg4Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg4-nvvmenvreg4op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg4` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg5-nvvmenvreg5op><code>nvvm.read.ptx.sreg.envreg5</code> (NVVM::EnvReg5Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg5-nvvmenvreg5op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg5` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg6-nvvmenvreg6op><code>nvvm.read.ptx.sreg.envreg6</code> (NVVM::EnvReg6Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg6-nvvmenvreg6op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg6` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg7-nvvmenvreg7op><code>nvvm.read.ptx.sreg.envreg7</code> (NVVM::EnvReg7Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg7-nvvmenvreg7op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg7` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg8-nvvmenvreg8op><code>nvvm.read.ptx.sreg.envreg8</code> (NVVM::EnvReg8Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg8-nvvmenvreg8op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg8` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregenvreg9-nvvmenvreg9op><code>nvvm.read.ptx.sreg.envreg9</code> (NVVM::EnvReg9Op)&nbsp;<a class=headline-hash href=#nvvmreadptxsregenvreg9-nvvmenvreg9op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.envreg9` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregglobaltimer-nvvmglobaltimerop><code>nvvm.read.ptx.sreg.globaltimer</code> (NVVM::GlobalTimerOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregglobaltimer-nvvmglobaltimerop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.globaltimer` attr-dict `:` type($res)
</code></pre><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreggridid-nvvmgrididop><code>nvvm.read.ptx.sreg.gridid</code> (NVVM::GridIdOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreggridid-nvvmgrididop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.gridid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglaneid-nvvmlaneidop><code>nvvm.read.ptx.sreg.laneid</code> (NVVM::LaneIdOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglaneid-nvvmlaneidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.laneid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglanemaskeq-nvvmlanemaskeqop><code>nvvm.read.ptx.sreg.lanemask.eq</code> (NVVM::LaneMaskEqOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglanemaskeq-nvvmlanemaskeqop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.lanemask.eq` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglanemaskge-nvvmlanemaskgeop><code>nvvm.read.ptx.sreg.lanemask.ge</code> (NVVM::LaneMaskGeOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglanemaskge-nvvmlanemaskgeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.lanemask.ge` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglanemaskgt-nvvmlanemaskgtop><code>nvvm.read.ptx.sreg.lanemask.gt</code> (NVVM::LaneMaskGtOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglanemaskgt-nvvmlanemaskgtop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.lanemask.gt` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglanemaskle-nvvmlanemaskleop><code>nvvm.read.ptx.sreg.lanemask.le</code> (NVVM::LaneMaskLeOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglanemaskle-nvvmlanemaskleop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.lanemask.le` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsreglanemasklt-nvvmlanemaskltop><code>nvvm.read.ptx.sreg.lanemask.lt</code> (NVVM::LaneMaskLtOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsreglanemasklt-nvvmlanemaskltop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.lanemask.lt` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnclusteridx-nvvmclusterdimxop><code>nvvm.read.ptx.sreg.nclusterid.x</code> (NVVM::ClusterDimXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnclusteridx-nvvmclusterdimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nclusterid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-40>Attributes:&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnclusteridy-nvvmclusterdimyop><code>nvvm.read.ptx.sreg.nclusterid.y</code> (NVVM::ClusterDimYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnclusteridy-nvvmclusterdimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nclusterid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-41>Attributes:&nbsp;<a class=headline-hash href=#attributes-41>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-77>Results:&nbsp;<a class=headline-hash href=#results-77>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnclusteridz-nvvmclusterdimzop><code>nvvm.read.ptx.sreg.nclusterid.z</code> (NVVM::ClusterDimZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnclusteridz-nvvmclusterdimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nclusterid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-42>Attributes:&nbsp;<a class=headline-hash href=#attributes-42>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-78>Results:&nbsp;<a class=headline-hash href=#results-78>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnctaidx-nvvmgriddimxop><code>nvvm.read.ptx.sreg.nctaid.x</code> (NVVM::GridDimXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnctaidx-nvvmgriddimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nctaid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-43>Attributes:&nbsp;<a class=headline-hash href=#attributes-43>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-79>Results:&nbsp;<a class=headline-hash href=#results-79>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnctaidy-nvvmgriddimyop><code>nvvm.read.ptx.sreg.nctaid.y</code> (NVVM::GridDimYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnctaidy-nvvmgriddimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nctaid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-44>Attributes:&nbsp;<a class=headline-hash href=#attributes-44>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-80>Results:&nbsp;<a class=headline-hash href=#results-80>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnctaidz-nvvmgriddimzop><code>nvvm.read.ptx.sreg.nctaid.z</code> (NVVM::GridDimZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnctaidz-nvvmgriddimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nctaid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-45>Attributes:&nbsp;<a class=headline-hash href=#attributes-45>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-81>Results:&nbsp;<a class=headline-hash href=#results-81>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnsmid-nvvmsmdimop><code>nvvm.read.ptx.sreg.nsmid</code> (NVVM::SmDimOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnsmid-nvvmsmdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nsmid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-46>Attributes:&nbsp;<a class=headline-hash href=#attributes-46>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-82>Results:&nbsp;<a class=headline-hash href=#results-82>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregntidx-nvvmblockdimxop><code>nvvm.read.ptx.sreg.ntid.x</code> (NVVM::BlockDimXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregntidx-nvvmblockdimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ntid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-47>Attributes:&nbsp;<a class=headline-hash href=#attributes-47>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-83>Results:&nbsp;<a class=headline-hash href=#results-83>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregntidy-nvvmblockdimyop><code>nvvm.read.ptx.sreg.ntid.y</code> (NVVM::BlockDimYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregntidy-nvvmblockdimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ntid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-48>Attributes:&nbsp;<a class=headline-hash href=#attributes-48>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-84>Results:&nbsp;<a class=headline-hash href=#results-84>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregntidz-nvvmblockdimzop><code>nvvm.read.ptx.sreg.ntid.z</code> (NVVM::BlockDimZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregntidz-nvvmblockdimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.ntid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-49>Attributes:&nbsp;<a class=headline-hash href=#attributes-49>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-85>Results:&nbsp;<a class=headline-hash href=#results-85>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregnwarpid-nvvmwarpdimop><code>nvvm.read.ptx.sreg.nwarpid</code> (NVVM::WarpDimOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregnwarpid-nvvmwarpdimop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.nwarpid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-50>Attributes:&nbsp;<a class=headline-hash href=#attributes-50>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-86>Results:&nbsp;<a class=headline-hash href=#results-86>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregsmid-nvvmsmidop><code>nvvm.read.ptx.sreg.smid</code> (NVVM::SmIdOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregsmid-nvvmsmidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.smid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-51>Attributes:&nbsp;<a class=headline-hash href=#attributes-51>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-87>Results:&nbsp;<a class=headline-hash href=#results-87>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregtidx-nvvmthreadidxop><code>nvvm.read.ptx.sreg.tid.x</code> (NVVM::ThreadIdXOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregtidx-nvvmthreadidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.tid.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-52>Attributes:&nbsp;<a class=headline-hash href=#attributes-52>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-88>Results:&nbsp;<a class=headline-hash href=#results-88>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregtidy-nvvmthreadidyop><code>nvvm.read.ptx.sreg.tid.y</code> (NVVM::ThreadIdYOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregtidy-nvvmthreadidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.tid.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-53>Attributes:&nbsp;<a class=headline-hash href=#attributes-53>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-89>Results:&nbsp;<a class=headline-hash href=#results-89>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregtidz-nvvmthreadidzop><code>nvvm.read.ptx.sreg.tid.z</code> (NVVM::ThreadIdZOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregtidz-nvvmthreadidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.tid.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-54>Attributes:&nbsp;<a class=headline-hash href=#attributes-54>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-90>Results:&nbsp;<a class=headline-hash href=#results-90>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregwarpid-nvvmwarpidop><code>nvvm.read.ptx.sreg.warpid</code> (NVVM::WarpIdOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregwarpid-nvvmwarpidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.warpid` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-55>Attributes:&nbsp;<a class=headline-hash href=#attributes-55>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-91>Results:&nbsp;<a class=headline-hash href=#results-91>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreadptxsregwarpsize-nvvmwarpsizeop><code>nvvm.read.ptx.sreg.warpsize</code> (NVVM::WarpSizeOp)&nbsp;<a class=headline-hash href=#nvvmreadptxsregwarpsize-nvvmwarpsizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.read.ptx.sreg.warpsize` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-56>Attributes:&nbsp;<a class=headline-hash href=#attributes-56>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-92>Results:&nbsp;<a class=headline-hash href=#results-92>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmreduxsync-nvvmreduxop><code>nvvm.redux.sync</code> (NVVM::ReduxOp)&nbsp;<a class=headline-hash href=#nvvmreduxsync-nvvmreduxop>¶</a></h3><p><em>Redux Sync Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.redux.sync` $kind $val `,` $mask_and_clamp  attr-dict `:` type($val) `-&gt;` type($res)
</code></pre><p><code>redux.sync</code> performs a reduction operation <code>kind</code> of the 32 bit source
register across all non-exited threads in the membermask.</p><p>The <code>abs</code> and <code>nan</code> attributes can be used in the case of f32 input type,
where the <code>abs</code> attribute causes the absolute value of the input to be used
in the reduction operation, and the <code>nan</code> attribute causes the reduction
operation to return NaN if any of the inputs to participating threads are
NaN.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-redux-sync>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSM&lt;80></code></p><h4 id=attributes-57>Attributes:&nbsp;<a class=headline-hash href=#attributes-57>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::ReduxKindAttr</td><td>NVVM redux kind</td></tr><tr><td><code>abs</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>nan</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>mask_and_clamp</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-93>Results:&nbsp;<a class=headline-hash href=#results-93>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmsetmaxregister-nvvmsetmaxregisterop><code>nvvm.setmaxregister</code> (NVVM::SetMaxRegisterOp)&nbsp;<a class=headline-hash href=#nvvmsetmaxregister-nvvmsetmaxregisterop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.setmaxregister` $action $regCount attr-dict
</code></pre><h4 id=attributes-58>Attributes:&nbsp;<a class=headline-hash href=#attributes-58>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>regCount</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>action</code></td><td>::mlir::NVVM::SetMaxRegisterActionAttr</td><td>NVVM set max register action</td></tr></table><h3 id=nvvmshflsync-nvvmshflop><code>nvvm.shfl.sync</code> (NVVM::ShflOp)&nbsp;<a class=headline-hash href=#nvvmshflsync-nvvmshflop>¶</a></h3><p><em>NVVM Dialect Op for shfl.sync</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.shfl.sync` $kind $thread_mask `,` $val `,` $offset `,` $mask_and_clamp  attr-dict
              `:` type($val) `-&gt;` type($res)
</code></pre><p>The <code>shfl.sync</code> Op implements data shuffle within threads of a warp.
The <code>thread_mask</code> denotes the threads participating in the Op where
the bit position corresponds to a particular thread’s laneid.
The <code>offset</code> specifies a source lane or source lane offset
(depending on <code>kind</code>). The <code>val</code> is the input value to be copied from
the source. The <code>mask_and_clamp</code> contains two packed values specifying
a mask for logically splitting warps into sub-segments and an upper bound
for clamping the source lane index.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-shfl-sync>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSM&lt;30></code></p><h4 id=attributes-59>Attributes:&nbsp;<a class=headline-hash href=#attributes-59>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::ShflKindAttr</td><td>NVVM shuffle kind</td></tr><tr><td><code>return_value_and_is_valid</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>thread_mask</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>mask_and_clamp</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-94>Results:&nbsp;<a class=headline-hash href=#results-94>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=nvvmstbulk-nvvmbulkstoreop><code>nvvm.st.bulk</code> (NVVM::BulkStoreOp)&nbsp;<a class=headline-hash href=#nvvmstbulk-nvvmbulkstoreop>¶</a></h3><p><em>Bulk Store Op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.st.bulk` $addr `,` `size` `=` $size (`,` `init` `=` $initVal^)? attr-dict `:` type($addr)
</code></pre><p>Initializes a region of shared memory at the address given by <code>addr</code>.
The <code>size</code> operand specifies the number of bytes to initialize and must be
a multiple of 8.
The <code>initVal</code> operand specifies the value to initialize the memory to. The
only supported value is 0.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#data-movement-and-conversion-instructions-st-bulk>For more information, see PTX ISA</a></p><h4 id=attributes-60>Attributes:&nbsp;<a class=headline-hash href=#attributes-60>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>initVal</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer in address space 0 or LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>size</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmstmatrix-nvvmstmatrixop><code>nvvm.stmatrix</code> (NVVM::StMatrixOp)&nbsp;<a class=headline-hash href=#nvvmstmatrix-nvvmstmatrixop>¶</a></h3><p><em>Cooperative matrix store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.stmatrix` $ptr `,` $sources attr-dict `:` type(operands)
</code></pre><p>Collectively store one or more matrices across all threads in a warp to the
location indicated by the address operand $ptr in shared memory.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-store-instruction-stmatrix>For more information, see PTX ISA</a></p><h4 id=attributes-61>Attributes:&nbsp;<a class=headline-hash href=#attributes-61>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::LdStMatrixShapeAttr</td><td>Matrix shape for ldmatrix and stmatrix</td></tr><tr><td><code>eltType</code></td><td>::mlir::NVVM::LdStMatrixEltTypeAttr</td><td>Element type for ldmatrix and stmatrix</td></tr></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>sources</code></td><td>variadic of 32-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05alloc-nvvmtcgen05allocop><code>nvvm.tcgen05.alloc</code> (NVVM::Tcgen05AllocOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05alloc-nvvmtcgen05allocop>¶</a></h3><p><em>Tcgen05 alloc operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.alloc` $addr `,` $nCols attr-dict `:` type(operands)
</code></pre><p>The <code>tcgen05.alloc</code> Op allocates tensor core memory for
the amount specified by <code>nCols</code> and writes the destination
address to the <code>addr</code> argument. The <code>nCols</code> operand specifies the
number of columns to be allocated and it must be a power-of-two.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-memory-alloc-manage-instructions>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-62>Attributes:&nbsp;<a class=headline-hash href=#attributes-62>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type or LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>nCols</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05commit-nvvmtcgen05commitop><code>nvvm.tcgen05.commit</code> (NVVM::Tcgen05CommitOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05commit-nvvmtcgen05commitop>¶</a></h3><p><em>Tcgen05 commit operations</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.commit` $addr (`,` `multicast_mask` `=` $multicastMask^)?
              attr-dict `:` type(operands)
</code></pre><p>The <code>tcgen05.commit</code> makes the mbarrier object, specified by
the operand <code>addr</code>, track the completion of all the prior
async-tcgen05 operations initiated by the executing thread.
The multicast variants allow signaling on the mbarrier objects
of multiple CTAs within the cluster. Operand <code>multicastMask</code>,
when present, specifies the destination CTAs in the cluster such
that each bit position in the 16-bit <code>multicastMask</code> operand
corresponds to the <code>nvvm.read.ptx.sreg.ctaid</code> of the destination CTA.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen-async-sync-operations-commit>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-63>Attributes:&nbsp;<a class=headline-hash href=#attributes-63>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type or LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>multicastMask</code></td><td>16-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05cp-nvvmtcgen05cpop><code>nvvm.tcgen05.cp</code> (NVVM::Tcgen05CpOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05cp-nvvmtcgen05cpop>¶</a></h3><p><em>Tcgen05 copy operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.cp` $taddr`,` $smem_desc attr-dict
</code></pre><p>Instruction tcgen05.cp initiates an asynchronous copy operation from
shared memory to the location specified by the address operand <code>taddr</code>
in the Tensor Memory. The 64-bit register operand <code>smem_desc</code> specifies
the matrix descriptor representing the source matrix in the shared memory
that needs to be copied.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  nvvm<span class=p>.</span>tcgen05<span class=p>.</span>cp <span class=nv>%taddr</span><span class=p>,</span> <span class=nv>%smem_desc</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nl>group =</span> <span class=nv>#nvvm.tcgen05_group</span><span class=p>&lt;</span>cta_2<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nl>shape =</span> <span class=nv>#nvvm.tcgen05_cp_shape</span><span class=p>&lt;</span>shape_64x128b<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nl>multicast =</span> <span class=nv>#nvvm.tcgen05_cp_multicast</span><span class=p>&lt;</span>warpx2_01_23<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>    <span class=nl>srcFormat =</span> <span class=nv>#nvvm.tcgen05_cp_src_fmt</span><span class=p>&lt;</span>b6x16_p32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tensorcore-5th-generation-instructions-tcgen05-cp>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-64>Attributes:&nbsp;<a class=headline-hash href=#attributes-64>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::Tcgen05CpShapeAttr</td><td>tcgen05 cp shapes</td></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr><tr><td><code>multicast</code></td><td>::mlir::NVVM::Tcgen05CpMulticastAttr</td><td>tcgen05 cp multicast</td></tr><tr><td><code>srcFormat</code></td><td>::mlir::NVVM::Tcgen05CpSrcFormatAttr</td><td>tcgen05 cp source format</td></tr></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>taddr</code></td><td>LLVM pointer in address space 6</td></tr><tr><td style=text-align:center><code>smem_desc</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05dealloc-nvvmtcgen05deallocop><code>nvvm.tcgen05.dealloc</code> (NVVM::Tcgen05DeallocOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05dealloc-nvvmtcgen05deallocop>¶</a></h3><p><em>Tcgen05 dealloc operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.dealloc` $taddr `,` $nCols attr-dict `:` type(operands)
</code></pre><p>The <code>tcgen05.dealloc</code> Op de-allocates the tensor core memory
specified by <code>tmemAddr</code>, which must be from a previous tensor
memory allocation. The <code>nCols</code> operand specifies the number
of columns to be de-allocated, and it must be a power-of-two.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-memory-alloc-manage-instructions>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-65>Attributes:&nbsp;<a class=headline-hash href=#attributes-65>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr></table><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>taddr</code></td><td>LLVM pointer in address space 6</td></tr><tr><td style=text-align:center><code>nCols</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05fence-nvvmtcgen05fenceop><code>nvvm.tcgen05.fence</code> (NVVM::Tcgen05FenceOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05fence-nvvmtcgen05fenceop>¶</a></h3><p><em>Tcgen05 fence operations</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.fence` $kind attr-dict
</code></pre><p>The <code>tcgen05.fence&lt;before></code> orders all prior async tcgen05 operations
with respect to the subsequent tcgen05 and execution ordering operations.
The <code>tcgen05.fence&lt;after></code> orders all subsequent async tcgen05 operations
with respect to the prior tcgen05 and execution ordering operations.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tensorcore-5th-generation-instructions-tcgen05-fence>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-66>Attributes:&nbsp;<a class=headline-hash href=#attributes-66>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::Tcgen05FenceKindAttr</td><td>NVVM Tcgen05 fence kind</td></tr></table><h3 id=nvvmtcgen05ld-nvvmtcgen05ldop><code>nvvm.tcgen05.ld</code> (NVVM::Tcgen05LdOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05ld-nvvmtcgen05ldop>¶</a></h3><p><em>Tensor memory load instructions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.ld` $tmemAddr (`,` $offset^)? (`pack` $pack^)? attr-dict `:` type($res)
</code></pre><p>Instruction <code>tcgen05.ld</code> asynchronously loads data from the Tensor Memory at
the location specified by the 32-bit address operand <code>tmemAddr</code> into the
destination register <code>res</code>, collectively across all threads of the warps.</p><p>The <code>shape</code> and the <code>num</code> attribute together determines the total
dimension of the data which is loaded from the Tensor Memory. The <code>shape</code>
attribute indicates the base dimension of data to be accessed as described
in the Data Movement Shape. The <code>num</code> attribute indicates the repeat
factor on the base dimension resulting in the total dimension of the data
that is accessed.</p><p>The shape <code>16x32bx2</code> performs two accesses into Tensor Memory of the shape
<code>16x32b</code>. The base address of the first access is specified by <code>tmemAddr</code>
and the base address of the second access is specified by
<code>tmemAddr + offset</code>, where <code>offset</code> is an immediate argument.</p><p>The unit attribute <code>pack</code> can be used to pack two 16-bit
elements from adjacent columns into a single 32-bit element during the load.</p><p>The following table describes the size of the vector for various combinations
of <code>num</code> and <code>shape</code> attributes:</p><pre tabindex=0><code>|=====================================================================|
| num/shape      |     16x32bx2/16x64b/32x32b |  16x128b   | 16x256b  |
|=====================================================================|
| x1             |          1                 |    2       |    4     |
| x2             |          2                 |    4       |    8     |
| x4             |          4                 |    8       |    16    |
| x8             |          8                 |    16      |    32    |
| x16            |          16                |    32      |    64    |
| x32            |          32                |    64      |    128   |
| x64            |          64                |    128     |    NA    |
| x128           |          128               |    NA      |    NA    |
|=====================================================================|
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  nvvm<span class=p>.</span>tcgen05<span class=p>.</span>ld <span class=nv>%tmemAddr</span><span class=p>,</span> <span class=nv>%offset</span> pack <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nl>shape =</span> <span class=nv>#nvvm.tcgen05_ldst_shape</span><span class=p>&lt;</span>shape_16x32bx2<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-st>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-67>Attributes:&nbsp;<a class=headline-hash href=#attributes-67>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pack</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::Tcgen05LdStShapeAttr</td><td>allowed 32-bit signless integer cases: 0, 1, 2, 3, 4</td></tr></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmemAddr</code></td><td>LLVM pointer in address space 6</td></tr><tr><td style=text-align:center><code>offset</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-95>Results:&nbsp;<a class=headline-hash href=#results-95>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or vector of 32-bit signless integer values of length 2/4/8/16/32/64/128</td></tr></tbody></table><h3 id=nvvmtcgen05mma_smem_desc-nvvmtcgen05mmasmemdescop><code>nvvm.tcgen05.mma_smem_desc</code> (NVVM::Tcgen05MmaSmemDescOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05mma_smem_desc-nvvmtcgen05mmasmemdescop>¶</a></h3><p><em>Constructs a Shared Memory descriptor for MMA Operands A or B</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.mma_smem_desc` `(` operands `)` attr-dict `:` `(` type(operands) `)` `-&gt;` type($res)
</code></pre><p>The <code>nvvm.tcgen05_mma_smem_desc</code> constructs a Shared Memory descriptor
for tcgen05.mma. This descriptor is a 64-bit value which describes the
properties of multiplicand matrix in shared memory including its location
in the shared memory of the current CTA.</p><pre tabindex=0><code>+-----------+------+------------------------------------------------------+
| Bit-field | Size | Description                                          |
+-----------+------+------------------------------------------------------+
| 0-13      | 14   | Matrix start address                                 |
| 14-15     | 2    | Reserved                                             |
| 16-29     | 14   | Leading dim relative-offset (or) absolute-address    |
| 30-31     | 2    | Reserved                                             |
| 32-45     | 14   | Stride dimension byte offset                         |
| 46-48     | 3    | Fixed constant value of 0b001                        |
| 49-51     | 3    | Matrix base offset                                   |
| 52        | 1    | Leading dimension stride mode:                       |
|           |      |   0: byte offset relative                            |
|           |      |   1: byte address absolute                           |
| 53-60     | 8    | Fixed constant value of 0xb00000000                  |
| 61-63     | 3    | Swizzling mode:                                      |
|           |      |   0: No swizzling                                    |
|           |      |   1: 128-Byte with 32B atomic swizzling              |
|           |      |   2: 128-Byte swizzling                              |
|           |      |   4: 64-Byte swizzling                               |
|           |      |   6: 32-Byte swizzling                               |
|           |      |   (Values 3, 5 and 7 are invalid)                    |
+-----------+------+------------------------------------------------------+    
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%desc</span> <span class=p>=</span> nvvm<span class=p>.</span>tcgen05<span class=p>.</span>mma_smem_desc <span class=p>(</span><span class=nv>%startAddr</span><span class=p>,</span> <span class=nv>%leadingDimOffset</span><span class=p>,</span> <span class=nv>%strideDimOffset</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=nv>%baseOffset</span><span class=p>,</span> <span class=nv>%leadingDimMode</span><span class=p>,</span> <span class=nv>%swizzleMode</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i8</span><span class=p>,</span> <span class=k>i1</span><span class=p>,</span> <span class=k>i8</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-shared-memory-descriptor>For more information, see PTX ISA</a></p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>startAddr</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>leadingDimOffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>strideDimOffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>baseOffset</code></td><td>8-bit signless integer</td></tr><tr><td style=text-align:center><code>leadingDimMode</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>swizzleMode</code></td><td>8-bit signless integer</td></tr></tbody></table><h4 id=results-96>Results:&nbsp;<a class=headline-hash href=#results-96>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05relinquish_alloc_permit-nvvmtcgen05relinquishallocpermitop><code>nvvm.tcgen05.relinquish_alloc_permit</code> (NVVM::Tcgen05RelinquishAllocPermitOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05relinquish_alloc_permit-nvvmtcgen05relinquishallocpermitop>¶</a></h3><p><em>Tcgen05 Op to relinquish the right to allocate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.relinquish_alloc_permit` attr-dict
</code></pre><p>The <code>tcgen05.relinquish_alloc_permit</code> Op specifies that the CTA
of the executing thread is relinquishing the right to allocate
Tensor Memory. So, it is illegal for a CTA to perform <code>tcgen05.alloc</code>
after any of its constituent threads execute <code>tcgen05.relinquish_alloc_permit</code>.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-memory-alloc-manage-instructions>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-68>Attributes:&nbsp;<a class=headline-hash href=#attributes-68>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr></table><h3 id=nvvmtcgen05shift-nvvmtcgen05shiftop><code>nvvm.tcgen05.shift</code> (NVVM::Tcgen05ShiftOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05shift-nvvmtcgen05shiftop>¶</a></h3><p><em>Tcgen05 shift operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.shift` $taddr attr-dict `:` type(operands)
</code></pre><p>The <code>tcgen05.shift</code> is an asynchronous instruction which initiates
the shifting of 32-byte elements downwards across all the rows,
except the last, by one row. The operand <code>taddr</code> specifies the base
address of the matrix in Tensor Memory whose rows must be down shifted.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-shift>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101,103></code></p><h4 id=attributes-69>Attributes:&nbsp;<a class=headline-hash href=#attributes-69>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::NVVM::Tcgen05GroupKindAttr</td><td>NVVM Tcgen05 group kind</td></tr></table><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>taddr</code></td><td>LLVM pointer in address space 6</td></tr></tbody></table><h3 id=nvvmtcgen05st-nvvmtcgen05stop><code>nvvm.tcgen05.st</code> (NVVM::Tcgen05StOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05st-nvvmtcgen05stop>¶</a></h3><p><em>Tensor memory store instructions</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.st` $tmemAddr `,` $val (`,` $offset^)? (`unpack` $unpack^)? attr-dict `:` type($val)
</code></pre><p>Instruction <code>tcgen05.st</code> asynchronously stores data from the source register <code>r</code>
into the Tensor Memory at the location specified by the 32-bit address operand
<code>tmemAddr</code>, collectively across all threads of the warps.</p><p>The <code>shape</code> and the <code>num</code> attribute together determines the total dimension of
the data which is stored to the Tensor Memory. The <code>shape</code> indicates the base
dimension of data to be accessed. The <code>num</code> attribute indicates the repeat
factor on the base dimension resulting in the total dimension of the data that
is accessed.</p><p>The shape <code>16x32bx2</code> performs two accesses into Tensor Memory of the shape
<code>16x32b</code>. The base address of the first access is specified by <code>tmemAddr</code>
and the base address of the second access is specified by
<code>tmemAddr + offset</code>, where <code>offset</code> is an immediate argument.</p><p>The unit attribute <code>unpack</code> can be used to unpack a 32-bit element
in the register into two 16-bit elements and store them in adjacent columns.</p><p>The following table describes the size of the vector for various combinations
of <code>num</code> and <code>shape</code> attributes:</p><pre tabindex=0><code>|=====================================================================|
| num/shape      |     16x32bx2/16x64b/32x32b |  16x128b   | 16x256b  |
|=====================================================================|
| x1             |          1                 |    2       |    4     |
| x2             |          2                 |    4       |    8     |
| x4             |          4                 |    8       |    16    |
| x8             |          8                 |    16      |    32    |
| x16            |          16                |    32      |    64    |
| x32            |          32                |    64      |    128   |
| x64            |          64                |    128     |    NA    |
| x128           |          128               |    NA      |    NA    |
|=====================================================================|
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  nvvm<span class=p>.</span>tcgen05<span class=p>.</span>st <span class=nv>%tmemAddr</span><span class=p>,</span> <span class=nv>%val</span><span class=p>,</span> <span class=nv>%offset</span> unpack <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nl>shape =</span> <span class=nv>#nvvm.tcgen05_ldst_shape</span><span class=p>&lt;</span>shape_16x32bx2<span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=p>:</span> <span class=p>&lt;</span><span class=m>2x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-st>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-70>Attributes:&nbsp;<a class=headline-hash href=#attributes-70>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>unpack</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::Tcgen05LdStShapeAttr</td><td>allowed 32-bit signless integer cases: 0, 1, 2, 3, 4</td></tr></table><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tmemAddr</code></td><td>LLVM pointer in address space 6</td></tr><tr><td style=text-align:center><code>val</code></td><td>32-bit signless integer or vector of 32-bit signless integer values of length 2/4/8/16/32/64/128</td></tr><tr><td style=text-align:center><code>offset</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=nvvmtcgen05wait-nvvmtcgen05waitop><code>nvvm.tcgen05.wait</code> (NVVM::Tcgen05WaitOp)&nbsp;<a class=headline-hash href=#nvvmtcgen05wait-nvvmtcgen05waitop>¶</a></h3><p><em>Tcgen05 wait operations</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.tcgen05.wait` $kind attr-dict
</code></pre><p>The <code>tcgen05.wait&lt;load></code> causes the executing thread to block until
all prior <code>tcgen05.ld</code> operations issued by the executing thread
have completed. Similarly, the <code>tcgen05.wait&lt;store></code> causes the executing
thread to block until all prior <code>tcgen05.st</code> operations issued by the
executing thread have completed.
<a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#tcgen05-instructions-tcgen05-wait>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;100,101></code></p><h4 id=attributes-71>Attributes:&nbsp;<a class=headline-hash href=#attributes-71>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::Tcgen05WaitKindAttr</td><td>NVVM Tcgen05 wait kind</td></tr></table><h3 id=nvvmvotesync-nvvmvotesyncop><code>nvvm.vote.sync</code> (NVVM::VoteSyncOp)&nbsp;<a class=headline-hash href=#nvvmvotesync-nvvmvotesyncop>¶</a></h3><p><em>Vote across thread group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.vote.sync` $kind $mask `,` $pred attr-dict `-&gt;` type($res)
</code></pre><p>The <code>vote.sync</code> op will cause executing thread to wait until all non-exited
threads corresponding to membermask have executed <code>vote.sync</code> with the same
qualifiers and same membermask value before resuming execution.</p><p>The vote operation kinds are:</p><ul><li><code>any</code>: True if source predicate is True for some thread in membermask.</li><li><code>all</code>: True if source predicate is True for all non-exited threads in
membermask.</li><li><code>uni</code>: True if source predicate has the same value in all non-exited
threads in membermask.</li><li><code>ballot</code>: In the ballot form, the destination result is a 32 bit integer.
In this form, the predicate from each thread in membermask are copied into
the corresponding bit position of the result, where the bit position
corresponds to the thread’s lane id.</li></ul><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#parallel-synchronization-and-communication-instructions-vote-sync>For more information, see PTX ISA</a></p><h4 id=attributes-72>Attributes:&nbsp;<a class=headline-hash href=#attributes-72>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::NVVM::VoteSyncKindAttr</td><td>NVVM vote sync kind</td></tr></table><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>pred</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-97>Results:&nbsp;<a class=headline-hash href=#results-97>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 1-bit signless integer</td></tr></tbody></table><h3 id=nvvmwgmmacommitgroupsyncaligned-nvvmwgmmagroupsyncalignedop><code>nvvm.wgmma.commit.group.sync.aligned</code> (NVVM::WgmmaGroupSyncAlignedOp)&nbsp;<a class=headline-hash href=#nvvmwgmmacommitgroupsyncaligned-nvvmwgmmagroupsyncalignedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wgmma.commit.group.sync.aligned` attr-dict
</code></pre><p>Commits all prior uncommitted warpgroup level matrix multiplication operations.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions-wgmma-commit-group>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;90></code></p><h3 id=nvvmwgmmafencealigned-nvvmwgmmafencealignedop><code>nvvm.wgmma.fence.aligned</code> (NVVM::WgmmaFenceAlignedOp)&nbsp;<a class=headline-hash href=#nvvmwgmmafencealigned-nvvmwgmmafencealignedop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wgmma.fence.aligned` attr-dict
</code></pre><p>Enforce an ordering of register accesses between warpgroup level matrix
multiplication and other operations.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions-wgmma-fence>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;90></code></p><h3 id=nvvmwgmmamma_async-nvvmwgmmammaasyncop><code>nvvm.wgmma.mma_async</code> (NVVM::WgmmaMmaAsyncOp)&nbsp;<a class=headline-hash href=#nvvmwgmmamma_async-nvvmwgmmammaasyncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wgmma.mma_async` $descriptorA `,` $descriptorB `,` $inouts `,` $shape `,`
              `D` `[` $typeD `,` $scaleD (`,` $satfinite^)? `]` `,`
              `A` `[` $typeA `,` $scaleA `,` $layoutA `]` `,`
              `B` `[` $typeB `,` $scaleB `,` $layoutB `]`
              attr-dict `:`
              type($inouts) `-&gt;` type($results)
</code></pre><p>The warpgroup (128 threads) level matrix multiply and accumulate operation
has either of the following forms, where matrix D is called accumulator:
D = A * B + D
D = A * B, where the input from accumulator D is disabled.</p><p>Supported shapes:</p><pre tabindex=0><code>|--------------|--------------|------------|--------------|---------------|
|              |              |            |              |f16+=e4m3*e4m3 |
|              |              |            |              |f16+=e5m2*e5m2 |
|f32+=tf32*tf32|f16+=f16 *f16 | s32+=s8*s8 |s32 += b1 * b1|f16+=e5m2*e4m3 |
|              |f32+=f16 *f16 | s32+=u8*u8 |              |f16+=e4m3*e5m2 |
|              |f32+=bf16*bf16| s32+=u8*u8 |              |f16+=e4m3*e5m2 |
|              |f32+=bf16*bf16| s32+=s8*u8 |              |f32+=e4m3*e4m3 |
|              |              | s32+=u8*s8 |              |f32+=e5m2*e5m2 |
|              |              |            |              |f32+=e4m3*e5m2 |
|              |              |            |              |f32+=e4m3*e5m2 |
|--------------|--------------|------------|--------------|---------------|
|   .m64n8k8   |  .m64n8k16   | .m64n8k32  | .m64n8k256   | .m64n8k32     |
|   .m64n16k8  |  .m64n16k16  | .m64n16k32 | .m64n16k256  | .m64n16k32    |
|   .m64n24k8  |  .m64n24k16  | .m64n24k32 | .m64n24k256  | .m64n24k32    |
|   .m64n32k8  |  .m64n32k16  | .m64n32k32 | .m64n32k256  | .m64n32k32    |
|   .m64n40k8  |  .m64n40k16  | .m64n48k32 | .m64n48k256  | .m64n40k32    |
|   .m64n48k8  |  .m64n48k16  | .m64n64k32 | .m64n64k256  | .m64n48k32    |
|   .m64n56k8  |  .m64n56k16  | .m64n80k32 | .m64n80k256  | .m64n56k32    |
|   .m64n64k8  |  .m64n64k16  | .m64n96k32 | .m64n96k256  | .m64n64k32    |
|   .m64n72k8  |  .m64n72k16  | .m64n112k32| .m64n112k256 | .m64n72k32    |
|   .m64n80k8  |  .m64n80k16  | .m64n128k32| .m64n128k256 | .m64n80k32    |
|   .m64n88k8  |  .m64n88k16  | .m64n144k32| .m64n144k256 | .m64n88k32    |
|   .m64n96k8  |  .m64n96k16  | .m64n160k32| .m64n160k256 | .m64n96k32    |
|   .m64n104k8 |  .m64n104k16 | .m64n176k32| .m64n176k256 | .m64n104k32   |
|   .m64n112k8 |  .m64n112k16 | .m64n192k32| .m64n192k256 | .m64n112k32   |
|   .m64n120k8 |  .m64n120k16 | .m64n208k32| .m64n208k256 | .m64n120k32   |
|   .m64n128k8 |  .m64n128k16 | .m64n224k32| .m64n224k256 | .m64n128k32   |
|   .m64n136k8 |  .m64n136k16 | .m64n240k32| .m64n240k256 | .m64n136k32   |
|   .m64n144k8 |  .m64n144k16 | .m64n256k32| .m64n256k256 | .m64n144k32   |
|   .m64n152k8 |  .m64n152k16 |            |              | .m64n152k32   |
|   .m64n160k8 |  .m64n160k16 |            |              | .m64n160k32   |
|   .m64n168k8 |  .m64n168k16 |            |              | .m64n168k32   |
|   .m64n176k8 |  .m64n176k16 |            |              | .m64n176k32   |
|   .m64n184k8 |  .m64n184k16 |            |              | .m64n184k32   |
|   .m64n192k8 |  .m64n192k16 |            |              | .m64n192k32   |
|   .m64n200k8 |  .m64n200k16 |            |              | .m64n200k32   |
|   .m64n208k8 |  .m64n208k16 |            |              | .m64n208k32   |
|   .m64n216k8 |  .m64n216k16 |            |              | .m64n216k32   |
|   .m64n224k8 |  .m64n224k16 |            |              | .m64n224k32   |
|   .m64n232k8 |  .m64n232k16 |            |              | .m64n232k32   |
|   .m64n240k8 |  .m64n240k16 |            |              | .m64n240k32   |
|   .m64n248k8 |  .m64n248k16 |            |              | .m64n248k32   |
|   .m64n256k8 |  .m64n256k16 |            |              | .m64n256k32   |
|--------------|--------------|------------|--------------|---------------|
</code></pre><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions>For more information, see PTX ISA</a></p><p>Interfaces: <code>BasicPtxBuilderInterface</code></p><h4 id=attributes-73>Attributes:&nbsp;<a class=headline-hash href=#attributes-73>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shape</code></td><td>::mlir::NVVM::MMAShapeAttr</td><td>Attribute for MMA operation shape.</td></tr><tr><td><code>typeA</code></td><td>::mlir::NVVM::WGMMATypesAttr</td><td>NVVM WGMMA types</td></tr><tr><td><code>typeB</code></td><td>::mlir::NVVM::WGMMATypesAttr</td><td>NVVM WGMMA types</td></tr><tr><td><code>typeD</code></td><td>::mlir::NVVM::WGMMATypesAttr</td><td>NVVM WGMMA types</td></tr><tr><td><code>scaleD</code></td><td>::mlir::NVVM::WGMMAScaleOutAttr</td><td>WGMMA input predicate</td></tr><tr><td><code>scaleA</code></td><td>::mlir::NVVM::WGMMAScaleInAttr</td><td>WGMMA overflow options</td></tr><tr><td><code>scaleB</code></td><td>::mlir::NVVM::WGMMAScaleInAttr</td><td>WGMMA overflow options</td></tr><tr><td><code>layoutA</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>layoutB</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>satfinite</code></td><td>::mlir::NVVM::MMAIntOverflowAttr</td><td>MMA overflow options</td></tr></table><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>inouts</code></td><td>LLVM structure type</td></tr><tr><td style=text-align:center><code>descriptorA</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>descriptorB</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-98>Results:&nbsp;<a class=headline-hash href=#results-98>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>LLVM structure type</td></tr></tbody></table><h3 id=nvvmwgmmawaitgroupsyncaligned-nvvmwgmmawaitgroupsyncop><code>nvvm.wgmma.wait.group.sync.aligned</code> (NVVM::WgmmaWaitGroupSyncOp)&nbsp;<a class=headline-hash href=#nvvmwgmmawaitgroupsyncaligned-nvvmwgmmawaitgroupsyncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wgmma.wait.group.sync.aligned` attr-dict $group
</code></pre><p>Signal the completion of a preceding warpgroup operation.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#asynchronous-warpgroup-level-matrix-instructions-wgmma-wait-group>For more information, see PTX ISA</a></p><p>Traits: <code>NVVMRequiresSMa&lt;90></code></p><h4 id=attributes-74>Attributes:&nbsp;<a class=headline-hash href=#attributes-74>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>group</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h3 id=nvvmwmmaload-nvvmwmmaloadop><code>nvvm.wmma.load</code> (NVVM::WMMALoadOp)&nbsp;<a class=headline-hash href=#nvvmwmmaload-nvvmwmmaloadop>¶</a></h3><p><em>Warp synchronous matrix load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wmma.load` $ptr `,` $stride attr-dict `:` functional-type($ptr, $res)
</code></pre><h4 id=attributes-75>Attributes:&nbsp;<a class=headline-hash href=#attributes-75>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>m</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>n</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>layout</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>eltype</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr><tr><td><code>frag</code></td><td>::mlir::NVVM::MMAFragAttr</td><td>NVVM MMA frag type</td></tr></table><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-99>Results:&nbsp;<a class=headline-hash href=#results-99>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM structure type</td></tr></tbody></table><h3 id=nvvmwmmamma-nvvmwmmammaop><code>nvvm.wmma.mma</code> (NVVM::WMMAMmaOp)&nbsp;<a class=headline-hash href=#nvvmwmmamma-nvvmwmmammaop>¶</a></h3><p><em>Warp synchronous matrix-multiply accumulate using tensor cores.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wmma.mma` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=attributes-76>Attributes:&nbsp;<a class=headline-hash href=#attributes-76>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>m</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>n</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>layoutA</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>layoutB</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>eltypeA</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr><tr><td><code>eltypeB</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr></table><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-100>Results:&nbsp;<a class=headline-hash href=#results-100>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM structure type</td></tr></tbody></table><h3 id=nvvmwmmastore-nvvmwmmastoreop><code>nvvm.wmma.store</code> (NVVM::WMMAStoreOp)&nbsp;<a class=headline-hash href=#nvvmwmmastore-nvvmwmmastoreop>¶</a></h3><p><em>Warp synchronous matrix store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `nvvm.wmma.store` $ptr `,` $stride `,` $args attr-dict `:` qualified(type($ptr)) `,`
              type($args)
</code></pre><h4 id=attributes-77>Attributes:&nbsp;<a class=headline-hash href=#attributes-77>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>m</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>n</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>k</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>layout</code></td><td>::mlir::NVVM::MMALayoutAttr</td><td>NVVM MMA layout</td></tr><tr><td><code>eltype</code></td><td>::mlir::NVVM::MMATypesAttr</td><td>NVVM MMA types</td></tr></table><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>32-bit signless integer</td></tr></tbody></table><h2 id=attributes-78>Attributes&nbsp;<a class=headline-hash href=#attributes-78>¶</a></h2><h3 id=cacheevictionpriorityattr>CacheEvictionPriorityAttr&nbsp;<a class=headline-hash href=#cacheevictionpriorityattr>¶</a></h3><p><em>NVVM Cache Eviction Priority</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.cache_eviction_priority&lt;
  ::mlir::NVVM::CacheEvictionPriority   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>evict_normal (<code>EvictNormal</code>)</li><li>evict_first (<code>EvictFirst</code>)</li><li>evict_last (<code>EvictLast</code>)</li><li>evict_unchanged (<code>EvictUnchanged</code>)</li><li>no_allocate (<code>NoAllocate</code>)</li></ul><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::CacheEvictionPriority</code></td><td>an enum of type CacheEvictionPriority</td></tr></tbody></table><h3 id=convertfp6typeattr>ConvertFP6TypeAttr&nbsp;<a class=headline-hash href=#convertfp6typeattr>¶</a></h3><p><em>NVVM ConvertFP6Type kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.convert_fp6_type&lt;
  ::mlir::NVVM::ConvertFP6Type   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::ConvertFP6Type</code></td><td>an enum of type ConvertFP6Type</td></tr></tbody></table><h3 id=convertfp8typeattr>ConvertFP8TypeAttr&nbsp;<a class=headline-hash href=#convertfp8typeattr>¶</a></h3><p><em>NVVM ConvertFP8Type kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.convert_fp8_type&lt;
  ::mlir::NVVM::ConvertFP8Type   # value
&gt;
</code></pre><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::ConvertFP8Type</code></td><td>an enum of type ConvertFP8Type</td></tr></tbody></table><h3 id=dotaccumulatetypeattr>DotAccumulateTypeAttr&nbsp;<a class=headline-hash href=#dotaccumulatetypeattr>¶</a></h3><p><em>NVVM DotAccumulateType</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.dot_accumulate_type&lt;
  ::mlir::NVVM::DotAccumulateType   # value
&gt;
</code></pre><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::DotAccumulateType</code></td><td>an enum of type DotAccumulateType</td></tr></tbody></table><h3 id=fproundingmodeattr>FPRoundingModeAttr&nbsp;<a class=headline-hash href=#fproundingmodeattr>¶</a></h3><p><em>NVVM FPRoundingMode kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.fp_rnd_mode&lt;
  ::mlir::NVVM::FPRoundingMode   # value
&gt;
</code></pre><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::FPRoundingMode</code></td><td>an enum of type FPRoundingMode</td></tr></tbody></table><h3 id=ldstmatrixelttypeattr>LdStMatrixEltTypeAttr&nbsp;<a class=headline-hash href=#ldstmatrixelttypeattr>¶</a></h3><p><em>Element type for ldmatrix and stmatrix</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.ld_st_matrix_elt_type&lt;
  ::mlir::NVVM::LdStMatrixEltType   # value
&gt;
</code></pre><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::LdStMatrixEltType</code></td><td>an enum of type LdStMatrixEltType</td></tr></tbody></table><h3 id=ldstmatrixshapeattr>LdStMatrixShapeAttr&nbsp;<a class=headline-hash href=#ldstmatrixshapeattr>¶</a></h3><p><em>Matrix shape for ldmatrix and stmatrix</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.ld_st_matrix_shape&lt;
  int,   # m
  int   # n
&gt;
</code></pre><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>m</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>n</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=loadcachemodifierkindattr>LoadCacheModifierKindAttr&nbsp;<a class=headline-hash href=#loadcachemodifierkindattr>¶</a></h3><p><em>NVVM load cache modifier kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.load_cache_modifier&lt;
  ::mlir::NVVM::LoadCacheModifierKind   # value
&gt;
</code></pre><p>Enum attribute of the different kinds of cache operators for load instructions.</p><p><a href=https://docs.nvidia.com/cuda/parallel-thread-execution/#id62>For more information, see PTX ISA</a></p><h4 id=parameters-7>Parameters:&nbsp;<a class=headline-hash href=#parameters-7>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::LoadCacheModifierKind</code></td><td>an enum of type LoadCacheModifierKind</td></tr></tbody></table><h3 id=mmab1opattr>MMAB1OpAttr&nbsp;<a class=headline-hash href=#mmab1opattr>¶</a></h3><p><em>MMA binary operations</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mma_b1op&lt;
  ::mlir::NVVM::MMAB1Op   # value
&gt;
</code></pre><h4 id=parameters-8>Parameters:&nbsp;<a class=headline-hash href=#parameters-8>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MMAB1Op</code></td><td>an enum of type MMAB1Op</td></tr></tbody></table><h3 id=mmafragattr>MMAFragAttr&nbsp;<a class=headline-hash href=#mmafragattr>¶</a></h3><p><em>NVVM MMA frag type</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mma_frag&lt;
  ::mlir::NVVM::MMAFrag   # value
&gt;
</code></pre><h4 id=parameters-9>Parameters:&nbsp;<a class=headline-hash href=#parameters-9>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MMAFrag</code></td><td>an enum of type MMAFrag</td></tr></tbody></table><h3 id=mmaintoverflowattr>MMAIntOverflowAttr&nbsp;<a class=headline-hash href=#mmaintoverflowattr>¶</a></h3><p><em>MMA overflow options</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mma_int_overflow&lt;
  ::mlir::NVVM::MMAIntOverflow   # value
&gt;
</code></pre><h4 id=parameters-10>Parameters:&nbsp;<a class=headline-hash href=#parameters-10>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MMAIntOverflow</code></td><td>an enum of type MMAIntOverflow</td></tr></tbody></table><h3 id=mmalayoutattr>MMALayoutAttr&nbsp;<a class=headline-hash href=#mmalayoutattr>¶</a></h3><p><em>NVVM MMA layout</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mma_layout&lt;
  ::mlir::NVVM::MMALayout   # value
&gt;
</code></pre><h4 id=parameters-11>Parameters:&nbsp;<a class=headline-hash href=#parameters-11>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MMALayout</code></td><td>an enum of type MMALayout</td></tr></tbody></table><h3 id=mmatypesattr>MMATypesAttr&nbsp;<a class=headline-hash href=#mmatypesattr>¶</a></h3><p><em>NVVM MMA types</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mma_type&lt;
  ::mlir::NVVM::MMATypes   # value
&gt;
</code></pre><h4 id=parameters-12>Parameters:&nbsp;<a class=headline-hash href=#parameters-12>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MMATypes</code></td><td>an enum of type MMATypes</td></tr></tbody></table><h3 id=matchsynckindattr>MatchSyncKindAttr&nbsp;<a class=headline-hash href=#matchsynckindattr>¶</a></h3><p><em>NVVM match sync kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.match_sync_kind&lt;
  ::mlir::NVVM::MatchSyncKind   # value
&gt;
</code></pre><h4 id=parameters-13>Parameters:&nbsp;<a class=headline-hash href=#parameters-13>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MatchSyncKind</code></td><td>an enum of type MatchSyncKind</td></tr></tbody></table><h3 id=memscopekindattr>MemScopeKindAttr&nbsp;<a class=headline-hash href=#memscopekindattr>¶</a></h3><p><em>NVVM Memory Scope kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.mem_scope&lt;
  ::mlir::NVVM::MemScopeKind   # value
&gt;
</code></pre><h4 id=parameters-14>Parameters:&nbsp;<a class=headline-hash href=#parameters-14>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::MemScopeKind</code></td><td>an enum of type MemScopeKind</td></tr></tbody></table><h3 id=mmashapeattr>MMAShapeAttr&nbsp;<a class=headline-hash href=#mmashapeattr>¶</a></h3><p><em>Attribute for MMA operation shape.</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.shape&lt;
  int,   # m
  int,   # n
  int   # k
&gt;
</code></pre><h4 id=parameters-15>Parameters:&nbsp;<a class=headline-hash href=#parameters-15>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>m</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>n</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>k</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=nvvmtargetattr>NVVMTargetAttr&nbsp;<a class=headline-hash href=#nvvmtargetattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#nvvm.target&lt;
  int,   # O
  ::llvm::StringRef,   # triple
  ::llvm::StringRef,   # chip
  ::llvm::StringRef,   # features
  DictionaryAttr,   # flags
  ArrayAttr,   # link
  bool   # verifyTarget
&gt;
</code></pre><p>GPU target attribute for controlling compilation of NVIDIA targets. All
parameters decay into default values if not present.</p><p>Examples:</p><ol><li>Target with default values.</li></ol><pre tabindex=0><code>  gpu.module @mymodule [#nvvm.target] attributes {...} {
    ...
  }
</code></pre><ol start=2><li>Target with <code>sm_90</code> chip and fast math.</li></ol><pre tabindex=0><code>  gpu.module @mymodule [#nvvm.target&lt;chip = &#34;sm_90&#34;, flags = {fast}&gt;] {
    ...
  }
</code></pre><h4 id=parameters-16>Parameters:&nbsp;<a class=headline-hash href=#parameters-16>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>O</td><td style=text-align:center><code>int</code></td><td>Optimization level to apply.</td></tr><tr><td style=text-align:center>triple</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target triple.</td></tr><tr><td style=text-align:center>chip</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target chip.</td></tr><tr><td style=text-align:center>features</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target chip features.</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center><code>DictionaryAttr</code></td><td>Target specific flags.</td></tr><tr><td style=text-align:center>link</td><td style=text-align:center><code>ArrayAttr</code></td><td>Files to link to the LLVM module.</td></tr><tr><td style=text-align:center>verifyTarget</td><td style=text-align:center><code>bool</code></td><td>Perform SM version check on Ops.</td></tr></tbody></table><h3 id=prefetchcachelevelattr>PrefetchCacheLevelAttr&nbsp;<a class=headline-hash href=#prefetchcachelevelattr>¶</a></h3><p><em>NVVM Prefetch Cache Level</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.prefetch_cache_level&lt;
  ::mlir::NVVM::PrefetchCacheLevel   # value
&gt;
</code></pre><p>Enum cases:</p><ul><li>L1 (<code>L1</code>)</li><li>L2 (<code>L2</code>)</li></ul><h4 id=parameters-17>Parameters:&nbsp;<a class=headline-hash href=#parameters-17>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::PrefetchCacheLevel</code></td><td>an enum of type PrefetchCacheLevel</td></tr></tbody></table><h3 id=proxykindattr>ProxyKindAttr&nbsp;<a class=headline-hash href=#proxykindattr>¶</a></h3><p><em>Proxy kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.proxy_kind&lt;
  ::mlir::NVVM::ProxyKind   # value
&gt;
</code></pre><h4 id=parameters-18>Parameters:&nbsp;<a class=headline-hash href=#parameters-18>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::ProxyKind</code></td><td>an enum of type ProxyKind</td></tr></tbody></table><h3 id=reduxkindattr>ReduxKindAttr&nbsp;<a class=headline-hash href=#reduxkindattr>¶</a></h3><p><em>NVVM redux kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.redux_kind&lt;
  ::mlir::NVVM::ReduxKind   # value
&gt;
</code></pre><h4 id=parameters-19>Parameters:&nbsp;<a class=headline-hash href=#parameters-19>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::ReduxKind</code></td><td>an enum of type ReduxKind</td></tr></tbody></table><h3 id=saturationmodeattr>SaturationModeAttr&nbsp;<a class=headline-hash href=#saturationmodeattr>¶</a></h3><p><em>NVVM SaturationMode kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.sat_mode&lt;
  ::mlir::NVVM::SaturationMode   # value
&gt;
</code></pre><h4 id=parameters-20>Parameters:&nbsp;<a class=headline-hash href=#parameters-20>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::SaturationMode</code></td><td>an enum of type SaturationMode</td></tr></tbody></table><h3 id=setmaxregisteractionattr>SetMaxRegisterActionAttr&nbsp;<a class=headline-hash href=#setmaxregisteractionattr>¶</a></h3><p><em>NVVM set max register action</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.action&lt;
  ::mlir::NVVM::SetMaxRegisterAction   # value
&gt;
</code></pre><h4 id=parameters-21>Parameters:&nbsp;<a class=headline-hash href=#parameters-21>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::SetMaxRegisterAction</code></td><td>an enum of type SetMaxRegisterAction</td></tr></tbody></table><h3 id=sharedspaceattr>SharedSpaceAttr&nbsp;<a class=headline-hash href=#sharedspaceattr>¶</a></h3><p><em>Shared memory space</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.shared_space&lt;
  ::mlir::NVVM::SharedSpace   # value
&gt;
</code></pre><h4 id=parameters-22>Parameters:&nbsp;<a class=headline-hash href=#parameters-22>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::SharedSpace</code></td><td>an enum of type SharedSpace</td></tr></tbody></table><h3 id=shflkindattr>ShflKindAttr&nbsp;<a class=headline-hash href=#shflkindattr>¶</a></h3><p><em>NVVM shuffle kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.shfl_kind&lt;
  ::mlir::NVVM::ShflKind   # value
&gt;
</code></pre><h4 id=parameters-23>Parameters:&nbsp;<a class=headline-hash href=#parameters-23>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::ShflKind</code></td><td>an enum of type ShflKind</td></tr></tbody></table><h3 id=tmareduxkindattr>TMAReduxKindAttr&nbsp;<a class=headline-hash href=#tmareduxkindattr>¶</a></h3><p><em>NVVM TMA redux kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tma_redux_kind&lt;
  ::mlir::NVVM::TMAReduxKind   # value
&gt;
</code></pre><h4 id=parameters-24>Parameters:&nbsp;<a class=headline-hash href=#parameters-24>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::TMAReduxKind</code></td><td>an enum of type TMAReduxKind</td></tr></tbody></table><h3 id=tmastoremodeattr>TMAStoreModeAttr&nbsp;<a class=headline-hash href=#tmastoremodeattr>¶</a></h3><p><em>NVVM TMA Store Mode</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tma_store_mode&lt;
  ::mlir::NVVM::TMAStoreMode   # value
&gt;
</code></pre><h4 id=parameters-25>Parameters:&nbsp;<a class=headline-hash href=#parameters-25>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::TMAStoreMode</code></td><td>an enum of type TMAStoreMode</td></tr></tbody></table><h3 id=tcgen05cpmulticastattr>Tcgen05CpMulticastAttr&nbsp;<a class=headline-hash href=#tcgen05cpmulticastattr>¶</a></h3><p><em>Tcgen05 cp multicast</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_cp_multicast&lt;
  ::mlir::NVVM::Tcgen05CpMulticast   # value
&gt;
</code></pre><h4 id=parameters-26>Parameters:&nbsp;<a class=headline-hash href=#parameters-26>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05CpMulticast</code></td><td>an enum of type Tcgen05CpMulticast</td></tr></tbody></table><h3 id=tcgen05cpshapeattr>Tcgen05CpShapeAttr&nbsp;<a class=headline-hash href=#tcgen05cpshapeattr>¶</a></h3><p><em>Tcgen05 cp shapes</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_cp_shape&lt;
  ::mlir::NVVM::Tcgen05CpShape   # value
&gt;
</code></pre><h4 id=parameters-27>Parameters:&nbsp;<a class=headline-hash href=#parameters-27>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05CpShape</code></td><td>an enum of type Tcgen05CpShape</td></tr></tbody></table><h3 id=tcgen05cpsrcformatattr>Tcgen05CpSrcFormatAttr&nbsp;<a class=headline-hash href=#tcgen05cpsrcformatattr>¶</a></h3><p><em>Tcgen05 cp source format</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_cp_src_fmt&lt;
  ::mlir::NVVM::Tcgen05CpSrcFormat   # value
&gt;
</code></pre><h4 id=parameters-28>Parameters:&nbsp;<a class=headline-hash href=#parameters-28>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05CpSrcFormat</code></td><td>an enum of type Tcgen05CpSrcFormat</td></tr></tbody></table><h3 id=tcgen05fencekindattr>Tcgen05FenceKindAttr&nbsp;<a class=headline-hash href=#tcgen05fencekindattr>¶</a></h3><p><em>NVVM Tcgen05 fence kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_fence&lt;
  ::mlir::NVVM::Tcgen05FenceKind   # value
&gt;
</code></pre><h4 id=parameters-29>Parameters:&nbsp;<a class=headline-hash href=#parameters-29>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05FenceKind</code></td><td>an enum of type Tcgen05FenceKind</td></tr></tbody></table><h3 id=tcgen05groupkindattr>Tcgen05GroupKindAttr&nbsp;<a class=headline-hash href=#tcgen05groupkindattr>¶</a></h3><p><em>NVVM Tcgen05 group kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_group&lt;
  ::mlir::NVVM::Tcgen05GroupKind   # value
&gt;
</code></pre><h4 id=parameters-30>Parameters:&nbsp;<a class=headline-hash href=#parameters-30>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05GroupKind</code></td><td>an enum of type Tcgen05GroupKind</td></tr></tbody></table><h3 id=tcgen05ldstshapeattr>Tcgen05LdStShapeAttr&nbsp;<a class=headline-hash href=#tcgen05ldstshapeattr>¶</a></h3><p><em>Allowed 32-bit signless integer cases: 0, 1, 2, 3, 4</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_ldst_shape&lt;
  ::mlir::NVVM::Tcgen05LdStShape   # value
&gt;
</code></pre><h4 id=parameters-31>Parameters:&nbsp;<a class=headline-hash href=#parameters-31>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05LdStShape</code></td><td>an enum of type Tcgen05LdStShape</td></tr></tbody></table><h3 id=tcgen05waitkindattr>Tcgen05WaitKindAttr&nbsp;<a class=headline-hash href=#tcgen05waitkindattr>¶</a></h3><p><em>NVVM Tcgen05 wait kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.tcgen05_wait&lt;
  ::mlir::NVVM::Tcgen05WaitKind   # value
&gt;
</code></pre><h4 id=parameters-32>Parameters:&nbsp;<a class=headline-hash href=#parameters-32>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::Tcgen05WaitKind</code></td><td>an enum of type Tcgen05WaitKind</td></tr></tbody></table><h3 id=votesynckindattr>VoteSyncKindAttr&nbsp;<a class=headline-hash href=#votesynckindattr>¶</a></h3><p><em>NVVM vote sync kind</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.vote_sync_kind&lt;
  ::mlir::NVVM::VoteSyncKind   # value
&gt;
</code></pre><h4 id=parameters-33>Parameters:&nbsp;<a class=headline-hash href=#parameters-33>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::VoteSyncKind</code></td><td>an enum of type VoteSyncKind</td></tr></tbody></table><h3 id=wgmmascaleinattr>WGMMAScaleInAttr&nbsp;<a class=headline-hash href=#wgmmascaleinattr>¶</a></h3><p><em>WGMMA overflow options</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.wgmma_scale_in&lt;
  ::mlir::NVVM::WGMMAScaleIn   # value
&gt;
</code></pre><h4 id=parameters-34>Parameters:&nbsp;<a class=headline-hash href=#parameters-34>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::WGMMAScaleIn</code></td><td>an enum of type WGMMAScaleIn</td></tr></tbody></table><h3 id=wgmmascaleoutattr>WGMMAScaleOutAttr&nbsp;<a class=headline-hash href=#wgmmascaleoutattr>¶</a></h3><p><em>WGMMA input predicate</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.wgmma_scale_out&lt;
  ::mlir::NVVM::WGMMAScaleOut   # value
&gt;
</code></pre><h4 id=parameters-35>Parameters:&nbsp;<a class=headline-hash href=#parameters-35>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::WGMMAScaleOut</code></td><td>an enum of type WGMMAScaleOut</td></tr></tbody></table><h3 id=wgmmatypesattr>WGMMATypesAttr&nbsp;<a class=headline-hash href=#wgmmatypesattr>¶</a></h3><p><em>NVVM WGMMA types</em></p><p>Syntax:</p><pre tabindex=0><code>#nvvm.wgmma_type&lt;
  ::mlir::NVVM::WGMMATypes   # value
&gt;
</code></pre><h4 id=parameters-36>Parameters:&nbsp;<a class=headline-hash href=#parameters-36>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::NVVM::WGMMATypes</code></td><td>an enum of type WGMMATypes</td></tr></tbody></table><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=cacheevictionpriority>CacheEvictionPriority&nbsp;<a class=headline-hash href=#cacheevictionpriority>¶</a></h3><p><em>NVVM Cache Eviction Priority</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>EvictNormal</td><td style=text-align:center><code>0</code></td><td>evict_normal</td></tr><tr><td style=text-align:center>EvictFirst</td><td style=text-align:center><code>1</code></td><td>evict_first</td></tr><tr><td style=text-align:center>EvictLast</td><td style=text-align:center><code>2</code></td><td>evict_last</td></tr><tr><td style=text-align:center>EvictUnchanged</td><td style=text-align:center><code>3</code></td><td>evict_unchanged</td></tr><tr><td style=text-align:center>NoAllocate</td><td style=text-align:center><code>4</code></td><td>no_allocate</td></tr></tbody></table><h3 id=convertfp6type>ConvertFP6Type&nbsp;<a class=headline-hash href=#convertfp6type>¶</a></h3><p><em>NVVM ConvertFP6Type kind</em></p><h4 id=cases-1>Cases:&nbsp;<a class=headline-hash href=#cases-1>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>E2M3</td><td style=text-align:center><code>0</code></td><td>e2m3</td></tr><tr><td style=text-align:center>E3M2</td><td style=text-align:center><code>1</code></td><td>e3m2</td></tr></tbody></table><h3 id=convertfp8type>ConvertFP8Type&nbsp;<a class=headline-hash href=#convertfp8type>¶</a></h3><p><em>NVVM ConvertFP8Type kind</em></p><h4 id=cases-2>Cases:&nbsp;<a class=headline-hash href=#cases-2>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>E4M3</td><td style=text-align:center><code>0</code></td><td>e4m3</td></tr><tr><td style=text-align:center>E5M2</td><td style=text-align:center><code>1</code></td><td>e5m2</td></tr><tr><td style=text-align:center>UE8M0</td><td style=text-align:center><code>2</code></td><td>ue8m0</td></tr></tbody></table><h3 id=dotaccumulatetype>DotAccumulateType&nbsp;<a class=headline-hash href=#dotaccumulatetype>¶</a></h3><p><em>NVVM DotAccumulateType</em></p><h4 id=cases-3>Cases:&nbsp;<a class=headline-hash href=#cases-3>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>SIGNED</td><td style=text-align:center><code>1</code></td><td>signed</td></tr><tr><td style=text-align:center>UNSIGNED</td><td style=text-align:center><code>0</code></td><td>unsigned</td></tr></tbody></table><h3 id=fproundingmode>FPRoundingMode&nbsp;<a class=headline-hash href=#fproundingmode>¶</a></h3><p><em>NVVM FPRoundingMode kind</em></p><h4 id=cases-4>Cases:&nbsp;<a class=headline-hash href=#cases-4>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>NONE</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>RN</td><td style=text-align:center><code>1</code></td><td>rn</td></tr><tr><td style=text-align:center>RM</td><td style=text-align:center><code>2</code></td><td>rm</td></tr><tr><td style=text-align:center>RP</td><td style=text-align:center><code>3</code></td><td>rp</td></tr><tr><td style=text-align:center>RZ</td><td style=text-align:center><code>4</code></td><td>rz</td></tr><tr><td style=text-align:center>RNA</td><td style=text-align:center><code>5</code></td><td>rna</td></tr></tbody></table><h3 id=ldstmatrixelttype>LdStMatrixEltType&nbsp;<a class=headline-hash href=#ldstmatrixelttype>¶</a></h3><p><em>Element type for ldmatrix and stmatrix</em></p><h4 id=cases-5>Cases:&nbsp;<a class=headline-hash href=#cases-5>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>B16</td><td style=text-align:center><code>0</code></td><td>b16</td></tr><tr><td style=text-align:center>B8</td><td style=text-align:center><code>1</code></td><td>b8</td></tr><tr><td style=text-align:center>B8X16_B6X16_P32</td><td style=text-align:center><code>2</code></td><td>b8x16.b6x16_p32</td></tr><tr><td style=text-align:center>B8X16_B4X16_P64</td><td style=text-align:center><code>3</code></td><td>b8x16.b4x16_p64</td></tr></tbody></table><h3 id=loadcachemodifierkind>LoadCacheModifierKind&nbsp;<a class=headline-hash href=#loadcachemodifierkind>¶</a></h3><p><em>NVVM load cache modifier kind</em></p><h4 id=cases-6>Cases:&nbsp;<a class=headline-hash href=#cases-6>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>CA</td><td style=text-align:center><code>0</code></td><td>ca</td></tr><tr><td style=text-align:center>CG</td><td style=text-align:center><code>1</code></td><td>cg</td></tr><tr><td style=text-align:center>CS</td><td style=text-align:center><code>2</code></td><td>cs</td></tr><tr><td style=text-align:center>LU</td><td style=text-align:center><code>3</code></td><td>lu</td></tr><tr><td style=text-align:center>CV</td><td style=text-align:center><code>4</code></td><td>cv</td></tr></tbody></table><h3 id=mmab1op>MMAB1Op&nbsp;<a class=headline-hash href=#mmab1op>¶</a></h3><p><em>MMA binary operations</em></p><h4 id=cases-7>Cases:&nbsp;<a class=headline-hash href=#cases-7>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>none</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>xor_popc</td><td style=text-align:center><code>1</code></td><td>xor_popc</td></tr><tr><td style=text-align:center>and_popc</td><td style=text-align:center><code>2</code></td><td>and_popc</td></tr></tbody></table><h3 id=mmafrag>MMAFrag&nbsp;<a class=headline-hash href=#mmafrag>¶</a></h3><p><em>NVVM MMA frag type</em></p><h4 id=cases-8>Cases:&nbsp;<a class=headline-hash href=#cases-8>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>a</td><td style=text-align:center><code>0</code></td><td>a</td></tr><tr><td style=text-align:center>b</td><td style=text-align:center><code>1</code></td><td>b</td></tr><tr><td style=text-align:center>c</td><td style=text-align:center><code>2</code></td><td>c</td></tr></tbody></table><h3 id=mmaintoverflow>MMAIntOverflow&nbsp;<a class=headline-hash href=#mmaintoverflow>¶</a></h3><p><em>MMA overflow options</em></p><h4 id=cases-9>Cases:&nbsp;<a class=headline-hash href=#cases-9>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>satfinite</td><td style=text-align:center><code>1</code></td><td>satfinite</td></tr><tr><td style=text-align:center>wrapped</td><td style=text-align:center><code>0</code></td><td>wrapped</td></tr></tbody></table><h3 id=mmalayout>MMALayout&nbsp;<a class=headline-hash href=#mmalayout>¶</a></h3><p><em>NVVM MMA layout</em></p><h4 id=cases-10>Cases:&nbsp;<a class=headline-hash href=#cases-10>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>row</td><td style=text-align:center><code>0</code></td><td>row</td></tr><tr><td style=text-align:center>col</td><td style=text-align:center><code>1</code></td><td>col</td></tr></tbody></table><h3 id=mmatypes>MMATypes&nbsp;<a class=headline-hash href=#mmatypes>¶</a></h3><p><em>NVVM MMA types</em></p><h4 id=cases-11>Cases:&nbsp;<a class=headline-hash href=#cases-11>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>f16</td><td style=text-align:center><code>0</code></td><td>f16</td></tr><tr><td style=text-align:center>f32</td><td style=text-align:center><code>1</code></td><td>f32</td></tr><tr><td style=text-align:center>tf32</td><td style=text-align:center><code>2</code></td><td>tf32</td></tr><tr><td style=text-align:center>bf16</td><td style=text-align:center><code>9</code></td><td>bf16</td></tr><tr><td style=text-align:center>s8</td><td style=text-align:center><code>4</code></td><td>s8</td></tr><tr><td style=text-align:center>u8</td><td style=text-align:center><code>3</code></td><td>u8</td></tr><tr><td style=text-align:center>s32</td><td style=text-align:center><code>5</code></td><td>s32</td></tr><tr><td style=text-align:center>s4</td><td style=text-align:center><code>8</code></td><td>s4</td></tr><tr><td style=text-align:center>u4</td><td style=text-align:center><code>7</code></td><td>u4</td></tr><tr><td style=text-align:center>b1</td><td style=text-align:center><code>6</code></td><td>b1</td></tr><tr><td style=text-align:center>f64</td><td style=text-align:center><code>10</code></td><td>f64</td></tr></tbody></table><h3 id=matchsynckind>MatchSyncKind&nbsp;<a class=headline-hash href=#matchsynckind>¶</a></h3><p><em>NVVM match sync kind</em></p><h4 id=cases-12>Cases:&nbsp;<a class=headline-hash href=#cases-12>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>any</td><td style=text-align:center><code>0</code></td><td>any</td></tr><tr><td style=text-align:center>all</td><td style=text-align:center><code>1</code></td><td>all</td></tr></tbody></table><h3 id=memscopekind>MemScopeKind&nbsp;<a class=headline-hash href=#memscopekind>¶</a></h3><p><em>NVVM Memory Scope kind</em></p><h4 id=cases-13>Cases:&nbsp;<a class=headline-hash href=#cases-13>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>CTA</td><td style=text-align:center><code>0</code></td><td>cta</td></tr><tr><td style=text-align:center>CLUSTER</td><td style=text-align:center><code>1</code></td><td>cluster</td></tr><tr><td style=text-align:center>GPU</td><td style=text-align:center><code>2</code></td><td>gpu</td></tr><tr><td style=text-align:center>SYS</td><td style=text-align:center><code>3</code></td><td>sys</td></tr></tbody></table><h3 id=prefetchcachelevel>PrefetchCacheLevel&nbsp;<a class=headline-hash href=#prefetchcachelevel>¶</a></h3><p><em>NVVM Prefetch Cache Level</em></p><h4 id=cases-14>Cases:&nbsp;<a class=headline-hash href=#cases-14>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>L1</td><td style=text-align:center><code>0</code></td><td>L1</td></tr><tr><td style=text-align:center>L2</td><td style=text-align:center><code>1</code></td><td>L2</td></tr></tbody></table><h3 id=proxykind>ProxyKind&nbsp;<a class=headline-hash href=#proxykind>¶</a></h3><p><em>Proxy kind</em></p><h4 id=cases-15>Cases:&nbsp;<a class=headline-hash href=#cases-15>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>alias</td><td style=text-align:center><code>0</code></td><td>alias</td></tr><tr><td style=text-align:center>async</td><td style=text-align:center><code>1</code></td><td>async</td></tr><tr><td style=text-align:center>async_global</td><td style=text-align:center><code>2</code></td><td>async.global</td></tr><tr><td style=text-align:center>async_shared</td><td style=text-align:center><code>3</code></td><td>async.shared</td></tr><tr><td style=text-align:center>TENSORMAP</td><td style=text-align:center><code>4</code></td><td>tensormap</td></tr><tr><td style=text-align:center>GENERIC</td><td style=text-align:center><code>5</code></td><td>generic</td></tr></tbody></table><h3 id=reduxkind>ReduxKind&nbsp;<a class=headline-hash href=#reduxkind>¶</a></h3><p><em>NVVM redux kind</em></p><h4 id=cases-16>Cases:&nbsp;<a class=headline-hash href=#cases-16>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>ADD</td><td style=text-align:center><code>1</code></td><td>add</td></tr><tr><td style=text-align:center>AND</td><td style=text-align:center><code>2</code></td><td>and</td></tr><tr><td style=text-align:center>MAX</td><td style=text-align:center><code>3</code></td><td>max</td></tr><tr><td style=text-align:center>MIN</td><td style=text-align:center><code>4</code></td><td>min</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>5</code></td><td>or</td></tr><tr><td style=text-align:center>UMAX</td><td style=text-align:center><code>6</code></td><td>umax</td></tr><tr><td style=text-align:center>UMIN</td><td style=text-align:center><code>7</code></td><td>umin</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>8</code></td><td>xor</td></tr><tr><td style=text-align:center>FMIN</td><td style=text-align:center><code>9</code></td><td>fmin</td></tr><tr><td style=text-align:center>FMAX</td><td style=text-align:center><code>10</code></td><td>fmax</td></tr></tbody></table><h3 id=saturationmode>SaturationMode&nbsp;<a class=headline-hash href=#saturationmode>¶</a></h3><p><em>NVVM SaturationMode kind</em></p><h4 id=cases-17>Cases:&nbsp;<a class=headline-hash href=#cases-17>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>NONE</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>SATFINITE</td><td style=text-align:center><code>1</code></td><td>satfinite</td></tr></tbody></table><h3 id=setmaxregisteraction>SetMaxRegisterAction&nbsp;<a class=headline-hash href=#setmaxregisteraction>¶</a></h3><p><em>NVVM set max register action</em></p><h4 id=cases-18>Cases:&nbsp;<a class=headline-hash href=#cases-18>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>decrease</td><td style=text-align:center><code>1</code></td><td>decrease</td></tr><tr><td style=text-align:center>increase</td><td style=text-align:center><code>0</code></td><td>increase</td></tr></tbody></table><h3 id=sharedspace>SharedSpace&nbsp;<a class=headline-hash href=#sharedspace>¶</a></h3><p><em>Shared memory space</em></p><h4 id=cases-19>Cases:&nbsp;<a class=headline-hash href=#cases-19>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>shared_cta</td><td style=text-align:center><code>0</code></td><td>cta</td></tr><tr><td style=text-align:center>shared_cluster</td><td style=text-align:center><code>1</code></td><td>cluster</td></tr></tbody></table><h3 id=shflkind>ShflKind&nbsp;<a class=headline-hash href=#shflkind>¶</a></h3><p><em>NVVM shuffle kind</em></p><h4 id=cases-20>Cases:&nbsp;<a class=headline-hash href=#cases-20>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>bfly</td><td style=text-align:center><code>0</code></td><td>bfly</td></tr><tr><td style=text-align:center>up</td><td style=text-align:center><code>1</code></td><td>up</td></tr><tr><td style=text-align:center>down</td><td style=text-align:center><code>2</code></td><td>down</td></tr><tr><td style=text-align:center>idx</td><td style=text-align:center><code>3</code></td><td>idx</td></tr></tbody></table><h3 id=tmareduxkind>TMAReduxKind&nbsp;<a class=headline-hash href=#tmareduxkind>¶</a></h3><p><em>NVVM TMA redux kind</em></p><h4 id=cases-21>Cases:&nbsp;<a class=headline-hash href=#cases-21>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>ADD</td><td style=text-align:center><code>0</code></td><td>add</td></tr><tr><td style=text-align:center>MAX</td><td style=text-align:center><code>2</code></td><td>max</td></tr><tr><td style=text-align:center>MIN</td><td style=text-align:center><code>1</code></td><td>min</td></tr><tr><td style=text-align:center>INC</td><td style=text-align:center><code>3</code></td><td>inc</td></tr><tr><td style=text-align:center>DEC</td><td style=text-align:center><code>4</code></td><td>dec</td></tr><tr><td style=text-align:center>AND</td><td style=text-align:center><code>5</code></td><td>and</td></tr><tr><td style=text-align:center>OR</td><td style=text-align:center><code>6</code></td><td>or</td></tr><tr><td style=text-align:center>XOR</td><td style=text-align:center><code>7</code></td><td>xor</td></tr></tbody></table><h3 id=tmastoremode>TMAStoreMode&nbsp;<a class=headline-hash href=#tmastoremode>¶</a></h3><p><em>NVVM TMA Store Mode</em></p><h4 id=cases-22>Cases:&nbsp;<a class=headline-hash href=#cases-22>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>TILE</td><td style=text-align:center><code>0</code></td><td>tile</td></tr><tr><td style=text-align:center>IM2COL</td><td style=text-align:center><code>1</code></td><td>im2col</td></tr></tbody></table><h3 id=tcgen05cpmulticast>Tcgen05CpMulticast&nbsp;<a class=headline-hash href=#tcgen05cpmulticast>¶</a></h3><p><em>Tcgen05 cp multicast</em></p><h4 id=cases-23>Cases:&nbsp;<a class=headline-hash href=#cases-23>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>NONE</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>WARPX2_02_13</td><td style=text-align:center><code>1</code></td><td>warpx2_02_13</td></tr><tr><td style=text-align:center>WARPX2_01_23</td><td style=text-align:center><code>2</code></td><td>warpx2_01_23</td></tr><tr><td style=text-align:center>WARPX4</td><td style=text-align:center><code>3</code></td><td>warpx4</td></tr></tbody></table><h3 id=tcgen05cpshape>Tcgen05CpShape&nbsp;<a class=headline-hash href=#tcgen05cpshape>¶</a></h3><p><em>Tcgen05 cp shapes</em></p><h4 id=cases-24>Cases:&nbsp;<a class=headline-hash href=#cases-24>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>SHAPE_128x256b</td><td style=text-align:center><code>0</code></td><td>shape_128x256b</td></tr><tr><td style=text-align:center>SHAPE_4x256b</td><td style=text-align:center><code>1</code></td><td>shape_4x256b</td></tr><tr><td style=text-align:center>SHAPE_128x128b</td><td style=text-align:center><code>2</code></td><td>shape_128x128b</td></tr><tr><td style=text-align:center>SHAPE_64x128b</td><td style=text-align:center><code>3</code></td><td>shape_64x128b</td></tr><tr><td style=text-align:center>SHAPE_32x128b</td><td style=text-align:center><code>4</code></td><td>shape_32x128b</td></tr></tbody></table><h3 id=tcgen05cpsrcformat>Tcgen05CpSrcFormat&nbsp;<a class=headline-hash href=#tcgen05cpsrcformat>¶</a></h3><p><em>Tcgen05 cp source format</em></p><h4 id=cases-25>Cases:&nbsp;<a class=headline-hash href=#cases-25>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>B6x16_P32</td><td style=text-align:center><code>0</code></td><td>b6x16_p32</td></tr><tr><td style=text-align:center>B4x16_P64</td><td style=text-align:center><code>1</code></td><td>b4x16_p64</td></tr></tbody></table><h3 id=tcgen05fencekind>Tcgen05FenceKind&nbsp;<a class=headline-hash href=#tcgen05fencekind>¶</a></h3><p><em>NVVM Tcgen05 fence kind</em></p><h4 id=cases-26>Cases:&nbsp;<a class=headline-hash href=#cases-26>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>BEFORE_THREAD_SYNC</td><td style=text-align:center><code>0</code></td><td>before</td></tr><tr><td style=text-align:center>AFTER_THREAD_SYNC</td><td style=text-align:center><code>1</code></td><td>after</td></tr></tbody></table><h3 id=tcgen05groupkind>Tcgen05GroupKind&nbsp;<a class=headline-hash href=#tcgen05groupkind>¶</a></h3><p><em>NVVM Tcgen05 group kind</em></p><h4 id=cases-27>Cases:&nbsp;<a class=headline-hash href=#cases-27>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>CTA_1</td><td style=text-align:center><code>0</code></td><td>cta_1</td></tr><tr><td style=text-align:center>CTA_2</td><td style=text-align:center><code>1</code></td><td>cta_2</td></tr></tbody></table><h3 id=tcgen05ldstshape>Tcgen05LdStShape&nbsp;<a class=headline-hash href=#tcgen05ldstshape>¶</a></h3><p><em>Allowed 32-bit signless integer cases: 0, 1, 2, 3, 4</em></p><h4 id=cases-28>Cases:&nbsp;<a class=headline-hash href=#cases-28>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>SHAPE_16X64B</td><td style=text-align:center><code>0</code></td><td>shape_16x64b</td></tr><tr><td style=text-align:center>SHAPE_16X128B</td><td style=text-align:center><code>1</code></td><td>shape_16x128b</td></tr><tr><td style=text-align:center>SHAPE_16X256B</td><td style=text-align:center><code>2</code></td><td>shape_16x256b</td></tr><tr><td style=text-align:center>SHAPE_32X32B</td><td style=text-align:center><code>3</code></td><td>shape_32x32b</td></tr><tr><td style=text-align:center>SHAPE_16X32BX2</td><td style=text-align:center><code>4</code></td><td>shape_16x32bx2</td></tr></tbody></table><h3 id=tcgen05waitkind>Tcgen05WaitKind&nbsp;<a class=headline-hash href=#tcgen05waitkind>¶</a></h3><p><em>NVVM Tcgen05 wait kind</em></p><h4 id=cases-29>Cases:&nbsp;<a class=headline-hash href=#cases-29>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>LOAD</td><td style=text-align:center><code>0</code></td><td>load</td></tr><tr><td style=text-align:center>STORE</td><td style=text-align:center><code>1</code></td><td>store</td></tr></tbody></table><h3 id=votesynckind>VoteSyncKind&nbsp;<a class=headline-hash href=#votesynckind>¶</a></h3><p><em>NVVM vote sync kind</em></p><h4 id=cases-30>Cases:&nbsp;<a class=headline-hash href=#cases-30>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>any</td><td style=text-align:center><code>0</code></td><td>any</td></tr><tr><td style=text-align:center>all</td><td style=text-align:center><code>1</code></td><td>all</td></tr><tr><td style=text-align:center>ballot</td><td style=text-align:center><code>2</code></td><td>ballot</td></tr><tr><td style=text-align:center>uni</td><td style=text-align:center><code>3</code></td><td>uni</td></tr></tbody></table><h3 id=wgmmascalein>WGMMAScaleIn&nbsp;<a class=headline-hash href=#wgmmascalein>¶</a></h3><p><em>WGMMA overflow options</em></p><h4 id=cases-31>Cases:&nbsp;<a class=headline-hash href=#cases-31>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>one</td><td style=text-align:center><code>1</code></td><td>one</td></tr><tr><td style=text-align:center>neg</td><td style=text-align:center><code>-1</code></td><td>neg</td></tr></tbody></table><h3 id=wgmmascaleout>WGMMAScaleOut&nbsp;<a class=headline-hash href=#wgmmascaleout>¶</a></h3><p><em>WGMMA input predicate</em></p><h4 id=cases-32>Cases:&nbsp;<a class=headline-hash href=#cases-32>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>zero</td><td style=text-align:center><code>0</code></td><td>zero</td></tr><tr><td style=text-align:center>one</td><td style=text-align:center><code>1</code></td><td>one</td></tr></tbody></table><h3 id=wgmmatypes>WGMMATypes&nbsp;<a class=headline-hash href=#wgmmatypes>¶</a></h3><p><em>NVVM WGMMA types</em></p><h4 id=cases-33>Cases:&nbsp;<a class=headline-hash href=#cases-33>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>f16</td><td style=text-align:center><code>0</code></td><td>f16</td></tr><tr><td style=text-align:center>tf32</td><td style=text-align:center><code>1</code></td><td>tf32</td></tr><tr><td style=text-align:center>u8</td><td style=text-align:center><code>2</code></td><td>u8</td></tr><tr><td style=text-align:center>s8</td><td style=text-align:center><code>3</code></td><td>s8</td></tr><tr><td style=text-align:center>b1</td><td style=text-align:center><code>4</code></td><td>b1</td></tr><tr><td style=text-align:center>bf16</td><td style=text-align:center><code>5</code></td><td>bf16</td></tr><tr><td style=text-align:center>e4m3</td><td style=text-align:center><code>6</code></td><td>e4m3</td></tr><tr><td style=text-align:center>e5m2</td><td style=text-align:center><code>7</code></td><td>e5m2</td></tr><tr><td style=text-align:center>f32</td><td style=text-align:center><code>8</code></td><td>f32</td></tr><tr><td style=text-align:center>s32</td><td style=text-align:center><code>9</code></td><td>s32</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/NVGPU/ title="'nvgpu' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'nvgpu' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ title="'omp' Dialect">Next - 'omp' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>