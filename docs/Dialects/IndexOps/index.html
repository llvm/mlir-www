<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'index' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/IndexOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'index' Dialect</h1><p><em>The Index dialect</em></p><p>The Index dialect contains operations for manipulating values of the builtin
<code>index</code> type. The index type models target-specific values of pointer width,
like <code>intptr_t</code>. Index values are typically used as loop bounds, array
subscripts, tensor dimensions, etc.</p><p>The operations in this dialect operate exclusively on scalar index types.
The dialect and its operations treat the index type as signless and contains
signed and unsigned versions of certain operations where the distinction is
meaningful. In particular, the operations and transformations are careful to
be aware of the target-independent-ness of the index type, such as when
folding.</p><p>The folding semantics of the Index dialect operations ensure that folding
produces the same results irrespective of the eventual target pointer width.
All index constants are stored in <code>APInt</code>s of maximum index bitwidth: 64.
Operations are folded using 64-bit integer arithmetic.</p><p>For operations where the values of the upper 32 bits don&rsquo;t impact the values
of the lower 32 bits, no additional handling is required because if the
target is 32-bit, the truncated folded result will be the same as if the
operation were computed with 32-bit arithmetic, and if the target is 64-bit,
the fold result is valid by default.</p><p>Consider addition: an overflow in 32-bit is the same as truncating the
result computed in 64-bit. For example, <code>add(0x800000008, 0x800000008)</code> is
<code>0x1000000010</code> in 64-bit, which truncates to <code>0x10</code>, the same result as
truncating the operands first: <code>add(0x08, 0x08)</code>. Specifically, an operation
<code>f</code> can always be folded if it satisfies the following for all 64-bit values
of <code>a</code> and <code>b</code>:</p><pre tabindex=0><code>trunc(f(a, b)) = f(trunc(a), trunc(b))
</code></pre><p>When materializing target-specific code, constants just need to be truncated
as appropriate.</p><p>Operations where the values of the upper 32 bits do impact the values of the
lower 32 bits are not folded if the results would be different in 32-bit.
These are operations that right shift &ndash; division, remainder, etc. These
operations are only folded for subsets of <code>a</code> and <code>b</code> for which the above
property is satisfied. This is checked per fold attempt.</p><p>Consider division: the 32-bit computation will differ from 64-bit if the
latter results in a high bit shifted into the lower 32 bits. For example,
<code>div(0x100000002, 2)</code> is <code>0x80000001</code> in 64-bit but <code>0x01</code> in 32-bit; it
cannot be folded. However, <code>div(0x200000002, 2)</code> can be folded. The 64-bit
result is <code>0x100000001</code>, which truncated to 32 bits is <code>0x01</code>. The 32-bit
result of the operation with truncated operands <code>div(0x02, 2)</code> which is
<code>0x01</code>, the same as truncating the 64-bit result.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#indexadd-indexaddop><code>index.add</code> (index::AddOp)</a></li><li><a href=#indexand-indexandop><code>index.and</code> (index::AndOp)</a></li><li><a href=#indexboolconstant-indexboolconstantop><code>index.bool.constant</code> (index::BoolConstantOp)</a></li><li><a href=#indexcasts-indexcastsop><code>index.casts</code> (index::CastSOp)</a></li><li><a href=#indexcastu-indexcastuop><code>index.castu</code> (index::CastUOp)</a></li><li><a href=#indexceildivs-indexceildivsop><code>index.ceildivs</code> (index::CeilDivSOp)</a></li><li><a href=#indexceildivu-indexceildivuop><code>index.ceildivu</code> (index::CeilDivUOp)</a></li><li><a href=#indexcmp-indexcmpop><code>index.cmp</code> (index::CmpOp)</a></li><li><a href=#indexconstant-indexconstantop><code>index.constant</code> (index::ConstantOp)</a></li><li><a href=#indexdivs-indexdivsop><code>index.divs</code> (index::DivSOp)</a></li><li><a href=#indexdivu-indexdivuop><code>index.divu</code> (index::DivUOp)</a></li><li><a href=#indexfloordivs-indexfloordivsop><code>index.floordivs</code> (index::FloorDivSOp)</a></li><li><a href=#indexmaxs-indexmaxsop><code>index.maxs</code> (index::MaxSOp)</a></li><li><a href=#indexmaxu-indexmaxuop><code>index.maxu</code> (index::MaxUOp)</a></li><li><a href=#indexmins-indexminsop><code>index.mins</code> (index::MinSOp)</a></li><li><a href=#indexminu-indexminuop><code>index.minu</code> (index::MinUOp)</a></li><li><a href=#indexmul-indexmulop><code>index.mul</code> (index::MulOp)</a></li><li><a href=#indexor-indexorop><code>index.or</code> (index::OrOp)</a></li><li><a href=#indexrems-indexremsop><code>index.rems</code> (index::RemSOp)</a></li><li><a href=#indexremu-indexremuop><code>index.remu</code> (index::RemUOp)</a></li><li><a href=#indexshl-indexshlop><code>index.shl</code> (index::ShlOp)</a></li><li><a href=#indexshrs-indexshrsop><code>index.shrs</code> (index::ShrSOp)</a></li><li><a href=#indexshru-indexshruop><code>index.shru</code> (index::ShrUOp)</a></li><li><a href=#indexsizeof-indexsizeofop><code>index.sizeof</code> (index::SizeOfOp)</a></li><li><a href=#indexsub-indexsubop><code>index.sub</code> (index::SubOp)</a></li><li><a href=#indexxor-indexxorop><code>index.xor</code> (index::XOrOp)</a></li></ul></li><li><a href=#attributes-3>Attributes</a><ul><li><a href=#indexcmppredicateattr>IndexCmpPredicateAttr</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#indexcmppredicate>IndexCmpPredicate</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Index/IR/IndexOps.td>source</a></p><h3 id=indexadd-indexaddop><code>index.add</code> (index::AddOp)&nbsp;<a class=headline-hash href=#indexadd-indexaddop>¶</a></h3><p><em>Index addition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.add` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.add</code> operation takes two index values and computes their sum.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a + b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>add <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexand-indexandop><code>index.and</code> (index::AndOp)&nbsp;<a class=headline-hash href=#indexand-indexandop>¶</a></h3><p><em>Index bitwise and</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.and` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.and</code> operation takes two index values and computes their bitwise
and.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a &amp; b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>and <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexboolconstant-indexboolconstantop><code>index.bool.constant</code> (index::BoolConstantOp)&nbsp;<a class=headline-hash href=#indexboolconstant-indexboolconstantop>¶</a></h3><p><em>Boolean constant</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.bool.constant` attr-dict $value
</code></pre><p>The <code>index.bool.constant</code> operation produces an bool-typed SSA value equal
to either <code>true</code> or <code>false</code>.</p><p>This operation is used to materialize bool constants that arise when folding
<code>index.cmp</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>bool<span class=p>.</span><span class=kt>constant</span> true
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=indexcasts-indexcastsop><code>index.casts</code> (index::CastSOp)&nbsp;<a class=headline-hash href=#indexcasts-indexcastsop>¶</a></h3><p><em>Index signed cast</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.casts` $input attr-dict `:` type($input) `to` type($output)
</code></pre><p>The <code>index.casts</code> operation enables conversions between values of index type
and concrete fixed-width integer types. If casting to a wider integer, the
value is sign-extended. If casting to a narrower integer, the value is
truncated.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Cast to i32
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>casts <span class=nv>%a</span> <span class=p>:</span> <span class=k>index</span> to <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Cast from i64
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>casts <span class=nv>%b</span> <span class=p>:</span> <span class=k>i64</span> to <span class=k>index</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>integer or index</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>integer or index</td></tr></tbody></table><h3 id=indexcastu-indexcastuop><code>index.castu</code> (index::CastUOp)&nbsp;<a class=headline-hash href=#indexcastu-indexcastuop>¶</a></h3><p><em>Index unsigned cast</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.castu` $input attr-dict `:` type($input) `to` type($output)
</code></pre><p>The <code>index.castu</code> operation enables conversions between values of index type
and concrete fixed-width integer types. If casting to a wider integer, the
value is zero-extended. If casting to a narrower integer, the value is
truncated.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Cast to i32
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>castu <span class=nv>%a</span> <span class=p>:</span> <span class=k>index</span> to <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Cast from i64
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>castu <span class=nv>%b</span> <span class=p>:</span> <span class=k>i64</span> to <span class=k>index</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>input</code></td><td>integer or index</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>integer or index</td></tr></tbody></table><h3 id=indexceildivs-indexceildivsop><code>index.ceildivs</code> (index::CeilDivSOp)&nbsp;<a class=headline-hash href=#indexceildivs-indexceildivsop>¶</a></h3><p><em>Index signed ceil division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.ceildivs` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.ceildivs</code> operation takes two index values and computes their
signed quotient. Treats the leading bit as the sign and rounds towards
positive infinity, i.e. <code>7 / -2 = -3</code>.</p><p>Note: division by zero and signed division overflow are undefined behaviour.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = ceil(a / b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>ceildivs <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexceildivu-indexceildivuop><code>index.ceildivu</code> (index::CeilDivUOp)&nbsp;<a class=headline-hash href=#indexceildivu-indexceildivuop>¶</a></h3><p><em>Index unsigned ceil division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.ceildivu` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.ceildivu</code> operation takes two index values and computes their
unsigned quotient. Treats the leading bit as the most significant and rounds
towards positive infinity, i.e. <code>6 / -2 = 1</code>.</p><p>Note: division by zero is undefined behaviour.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = ceil(a / b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>ceildivu <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexcmp-indexcmpop><code>index.cmp</code> (index::CmpOp)&nbsp;<a class=headline-hash href=#indexcmp-indexcmpop>¶</a></h3><p><em>Index compare</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.cmp` `` $pred `(` $lhs `,` $rhs `)` attr-dict
</code></pre><p>The <code>index.cmp</code> operation takes two index values and compares them according
to the comparison predicate and returns an <code>i1</code>. The following comparisons
are supported:</p><ul><li><code>eq</code>: equal</li><li><code>ne</code>: not equal</li><li><code>slt</code>: signed less than</li><li><code>sle</code>: signed less than or equal</li><li><code>sgt</code>: signed greater than</li><li><code>sge</code>: signed greater than or equal</li><li><code>ult</code>: unsigned less than</li><li><code>ule</code>: unsigned less than or equal</li><li><code>ugt</code>: unsigned greater than</li><li><code>uge</code>: unsigned greater than or equal</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Signed less than comparison.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>cmp slt<span class=p>(</span><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Unsigned greater than or equal comparison.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>cmp uge<span class=p>(</span><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Not equal comparison.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>cmp ne<span class=p>(</span><span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>)</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>::mlir::index::IndexCmpPredicateAttr</td><td>index comparison predicate kind</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=indexconstant-indexconstantop><code>index.constant</code> (index::ConstantOp)&nbsp;<a class=headline-hash href=#indexconstant-indexconstantop>¶</a></h3><p><em>Index constant</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.constant` attr-dict $value
</code></pre><p>The <code>index.constant</code> operation produces an index-typed SSA value equal to
some index-typed integer constant.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span><span class=kt>constant</span> <span class=m>42</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::IntegerAttr</td><td>index attribute</td></tr></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexdivs-indexdivsop><code>index.divs</code> (index::DivSOp)&nbsp;<a class=headline-hash href=#indexdivs-indexdivsop>¶</a></h3><p><em>Index signed division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.divs` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.divs</code> operation takes two index values and computes their signed
quotient. Treats the leading bit as the sign and rounds towards zero, i.e.
<code>6 / -2 = -3</code>.</p><p>Note: division by zero and signed division overflow are undefined behaviour.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a / b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>divs <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexdivu-indexdivuop><code>index.divu</code> (index::DivUOp)&nbsp;<a class=headline-hash href=#indexdivu-indexdivuop>¶</a></h3><p><em>Index unsigned division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.divu` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.divu</code> operation takes two index values and computes their
unsigned quotient. Treats the leading bit as the most significant and rounds
towards zero, i.e. <code>6 / -2 = 0</code>.</p><p>Note: division by zero is undefined behaviour.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a / b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>divu <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexfloordivs-indexfloordivsop><code>index.floordivs</code> (index::FloorDivSOp)&nbsp;<a class=headline-hash href=#indexfloordivs-indexfloordivsop>¶</a></h3><p><em>Index signed floor division</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.floordivs` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.floordivs</code> operation takes two index values and computes their
signed quotient. Treats the leading bit as the sign and rounds towards
negative infinity, i.e. <code>5 / -2 = -3</code>.</p><p>Note: division by zero and signed division overflow are undefined behaviour.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = floor(a / b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>floordivs <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexmaxs-indexmaxsop><code>index.maxs</code> (index::MaxSOp)&nbsp;<a class=headline-hash href=#indexmaxs-indexmaxsop>¶</a></h3><p><em>Index signed maximum</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.maxs` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.maxs</code> operation takes two index values and computes their signed
maximum value. Treats the leading bit as the sign, i.e. <code>max(-2, 6) = 6</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = max(a, b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>maxs <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexmaxu-indexmaxuop><code>index.maxu</code> (index::MaxUOp)&nbsp;<a class=headline-hash href=#indexmaxu-indexmaxuop>¶</a></h3><p><em>Index unsigned maximum</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.maxu` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.maxu</code> operation takes two index values and computes their
unsigned maximum value. Treats the leading bit as the most significant, i.e.
<code>max(15, 6) = 15</code> or <code>max(-2, 6) = -2</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = max(a, b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>maxu <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexmins-indexminsop><code>index.mins</code> (index::MinSOp)&nbsp;<a class=headline-hash href=#indexmins-indexminsop>¶</a></h3><p><em>Index signed minimum</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.mins` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.mins</code> operation takes two index values and computes their signed
minimum value. Treats the leading bit as the sign, i.e. <code>min(-2, 6) = -2</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = min(a, b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>mins <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexminu-indexminuop><code>index.minu</code> (index::MinUOp)&nbsp;<a class=headline-hash href=#indexminu-indexminuop>¶</a></h3><p><em>Index unsigned minimum</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.minu` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.minu</code> operation takes two index values and computes their
unsigned minimum value. Treats the leading bit as the most significant, i.e.
<code>min(15, 6) = 6</code> or <code>min(-2, 6) = 6</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = min(a, b)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>minu <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexmul-indexmulop><code>index.mul</code> (index::MulOp)&nbsp;<a class=headline-hash href=#indexmul-indexmulop>¶</a></h3><p><em>Index multiplication</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.mul` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.mul</code> operation takes two index values and computes their product.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a * b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>mul <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexor-indexorop><code>index.or</code> (index::OrOp)&nbsp;<a class=headline-hash href=#indexor-indexorop>¶</a></h3><p><em>Index bitwise or</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.or` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.or</code> operation takes two index values and computes their bitwise
or.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a | b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>or <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexrems-indexremsop><code>index.rems</code> (index::RemSOp)&nbsp;<a class=headline-hash href=#indexrems-indexremsop>¶</a></h3><p><em>Index signed remainder</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.rems` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.rems</code> operation takes two index values and computes their signed
remainder. Treats the leading bit as the sign, i.e. <code>6 % -2 = 0</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a % b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>rems <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexremu-indexremuop><code>index.remu</code> (index::RemUOp)&nbsp;<a class=headline-hash href=#indexremu-indexremuop>¶</a></h3><p><em>Index unsigned remainder</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.remu` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.remu</code> operation takes two index values and computes their
unsigned remainder. Treats the leading bit as the most significant, i.e.
<code>6 % -2 = 6</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a % b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>remu <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Interfaces: <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexshl-indexshlop><code>index.shl</code> (index::ShlOp)&nbsp;<a class=headline-hash href=#indexshl-indexshlop>¶</a></h3><p><em>Index shift left</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.shl` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.shl</code> operation shifts an index value to the left by a variable
amount. The low order bits are filled with zeroes. The RHS operand is always
treated as unsigned. If the RHS operand is equal to or greater than the
index bitwidth, the result is a poison value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a &lt;&lt; b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>shl <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexshrs-indexshrsop><code>index.shrs</code> (index::ShrSOp)&nbsp;<a class=headline-hash href=#indexshrs-indexshrsop>¶</a></h3><p><em>Signed index shift right</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.shrs` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.shrs</code> operation shifts an index value to the right by a variable
amount. The LHS operand is treated as signed. The high order bits are filled
with copies of the most significant bit. If the RHS operand is equal to or
greater than the index bitwidth, the result is a poison value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a &gt;&gt; b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>shrs <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexshru-indexshruop><code>index.shru</code> (index::ShrUOp)&nbsp;<a class=headline-hash href=#indexshru-indexshruop>¶</a></h3><p><em>Unsigned index shift right</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.shru` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.shru</code> operation shifts an index value to the right by a variable
amount. The LHS operand is treated as unsigned. The high order bits are
filled with zeroes. If the RHS operand is equal to or greater than the index
bitwidth, the result is a poison value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a &gt;&gt; b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>shru <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexsizeof-indexsizeofop><code>index.sizeof</code> (index::SizeOfOp)&nbsp;<a class=headline-hash href=#indexsizeof-indexsizeofop>¶</a></h3><p><em>Size in bits of the index type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.sizeof` attr-dict
</code></pre><p>The <code>index.sizeof</code> operation produces an index-typed SSA value equal to the
size in bits of the <code>index</code> type. For example, on 32-bit systems, the result
is <code>32 : index</code>, and on 64-bit systems, the result is <code>64 : index</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>sizeof
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexsub-indexsubop><code>index.sub</code> (index::SubOp)&nbsp;<a class=headline-hash href=#indexsub-indexsubop>¶</a></h3><p><em>Index subtraction</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.sub` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.sub</code> operation takes two index values and computes the difference
of the first from the second operand.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a - b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>sub <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h3 id=indexxor-indexxorop><code>index.xor</code> (index::XOrOp)&nbsp;<a class=headline-hash href=#indexxor-indexxorop>¶</a></h3><p><em>Index bitwise xor</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `index.xor` $lhs `,` $rhs attr-dict
</code></pre><p>The <code>index.xor</code> operation takes two index values and computes their bitwise
xor.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// c = a ^ b
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span> <span class=p>=</span> <span class=k>index</span><span class=p>.</span>xor <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>index</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>index</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>index</td></tr></tbody></table><h2 id=attributes-3>Attributes&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h2><h3 id=indexcmppredicateattr>IndexCmpPredicateAttr&nbsp;<a class=headline-hash href=#indexcmppredicateattr>¶</a></h3><p><em>Index comparison predicate kind</em></p><p>Syntax:</p><pre tabindex=0><code>#index.cmp_predicate&lt;
  ::mlir::index::IndexCmpPredicate   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::index::IndexCmpPredicate</code></td><td>an enum of type IndexCmpPredicate</td></tr></tbody></table><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=indexcmppredicate>IndexCmpPredicate&nbsp;<a class=headline-hash href=#indexcmppredicate>¶</a></h3><p><em>Index comparison predicate kind</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>EQ</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>NE</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>SLT</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>SLE</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>SGT</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>SGE</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ULT</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ULE</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>UGT</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>UGE</td><td style=text-align:center><code>9</code></td><td>uge</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/GPU/ title="'gpu' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'gpu' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/IRDL/ title="'irdl' Dialect">Next - 'irdl' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>