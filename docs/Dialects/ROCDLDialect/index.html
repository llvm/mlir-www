<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'rocdl' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'rocdl' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#rocdlballot-rocdlballotop><code>rocdl.ballot</code> (ROCDL::BallotOp)</a></li><li><a href=#rocdlbarrier-rocdlbarrierop><code>rocdl.barrier</code> (ROCDL::BarrierOp)</a></li><li><a href=#rocdlclusteridx-rocdlclusteridxop><code>rocdl.cluster.id.x</code> (ROCDL::ClusterIdXOp)</a></li><li><a href=#rocdlclusteridy-rocdlclusteridyop><code>rocdl.cluster.id.y</code> (ROCDL::ClusterIdYOp)</a></li><li><a href=#rocdlclusteridz-rocdlclusteridzop><code>rocdl.cluster.id.z</code> (ROCDL::ClusterIdZOp)</a></li><li><a href=#rocdlclusterloadasynctoldsb128-rocdlclusterloadasynctoldsb128op><code>rocdl.cluster.load.async.to.lds.b128</code> (ROCDL::ClusterLoadAsyncToLDSB128Op)</a></li><li><a href=#rocdlclusterloadasynctoldsb32-rocdlclusterloadasynctoldsb32op><code>rocdl.cluster.load.async.to.lds.b32</code> (ROCDL::ClusterLoadAsyncToLDSB32Op)</a></li><li><a href=#rocdlclusterloadasynctoldsb64-rocdlclusterloadasynctoldsb64op><code>rocdl.cluster.load.async.to.lds.b64</code> (ROCDL::ClusterLoadAsyncToLDSB64Op)</a></li><li><a href=#rocdlclusterloadasynctoldsb8-rocdlclusterloadasynctoldsb8op><code>rocdl.cluster.load.async.to.lds.b8</code> (ROCDL::ClusterLoadAsyncToLDSB8Op)</a></li><li><a href=#rocdlcos-rocdlrocdlcos><code>rocdl.cos</code> (ROCDL::ROCDLCos)</a></li><li><a href=#rocdlcvtf32bf8-rocdlcvtf32bf8op><code>rocdl.cvt.f32.bf8</code> (ROCDL::CvtF32Bf8Op)</a></li><li><a href=#rocdlcvtf32fp8-rocdlcvtf32fp8op><code>rocdl.cvt.f32.fp8</code> (ROCDL::CvtF32Fp8Op)</a></li><li><a href=#rocdlcvtpkbf8f32-rocdlcvtpkbf8f32op><code>rocdl.cvt.pk.bf8.f32</code> (ROCDL::CvtPkBf8F32Op)</a></li><li><a href=#rocdlcvtpkf32bf8-rocdlcvtpkf32bf8op><code>rocdl.cvt.pk.f32.bf8</code> (ROCDL::CvtPkF32Bf8Op)</a></li><li><a href=#rocdlcvtpkf32fp8-rocdlcvtpkf32fp8op><code>rocdl.cvt.pk.f32.fp8</code> (ROCDL::CvtPkF32Fp8Op)</a></li><li><a href=#rocdlcvtpkfp8f32-rocdlcvtpkfp8f32op><code>rocdl.cvt.pk.fp8.f32</code> (ROCDL::CvtPkFp8F32Op)</a></li><li><a href=#rocdlcvtpkrtz-rocdlcvtpkrtz><code>rocdl.cvt.pkrtz</code> (ROCDL::CvtPkRtz)</a></li><li><a href=#rocdlcvtscalepk16bf16bf6-rocdlcvtpkscalepk16bf16bf6op><code>rocdl.cvt.scale.pk16.bf16.bf6</code> (ROCDL::CvtPkScalePk16Bf16Bf6Op)</a></li><li><a href=#rocdlcvtscalepk16bf16fp6-rocdlcvtpkscalepk16bf16fp6op><code>rocdl.cvt.scale.pk16.bf16.fp6</code> (ROCDL::CvtPkScalePk16Bf16Fp6Op)</a></li><li><a href=#rocdlcvtscalepk16f16bf6-rocdlcvtpkscalepk16f16bf6op><code>rocdl.cvt.scale.pk16.f16.bf6</code> (ROCDL::CvtPkScalePk16F16Bf6Op)</a></li><li><a href=#rocdlcvtscalepk16f16fp6-rocdlcvtpkscalepk16f16fp6op><code>rocdl.cvt.scale.pk16.f16.fp6</code> (ROCDL::CvtPkScalePk16F16Fp6Op)</a></li><li><a href=#rocdlcvtscalepk16f32bf6-rocdlcvtpkscalepk16f32bf6op><code>rocdl.cvt.scale.pk16.f32.bf6</code> (ROCDL::CvtPkScalePk16F32Bf6Op)</a></li><li><a href=#rocdlcvtscalepk16f32fp6-rocdlcvtpkscalepk16f32fp6op><code>rocdl.cvt.scale.pk16.f32.fp6</code> (ROCDL::CvtPkScalePk16F32Fp6Op)</a></li><li><a href=#rocdlcvtscalepk8bf16bf8-rocdlcvtpkscalepk8bf16bf8op><code>rocdl.cvt.scale.pk8.bf16.bf8</code> (ROCDL::CvtPkScalePk8Bf16Bf8Op)</a></li><li><a href=#rocdlcvtscalepk8bf16fp4-rocdlcvtpkscalepk8bf16fp4op><code>rocdl.cvt.scale.pk8.bf16.fp4</code> (ROCDL::CvtPkScalePk8Bf16Fp4Op)</a></li><li><a href=#rocdlcvtscalepk8bf16fp8-rocdlcvtpkscalepk8bf16fp8op><code>rocdl.cvt.scale.pk8.bf16.fp8</code> (ROCDL::CvtPkScalePk8Bf16Fp8Op)</a></li><li><a href=#rocdlcvtscalepk8f16bf8-rocdlcvtpkscalepk8f16bf8op><code>rocdl.cvt.scale.pk8.f16.bf8</code> (ROCDL::CvtPkScalePk8F16Bf8Op)</a></li><li><a href=#rocdlcvtscalepk8f16fp4-rocdlcvtpkscalepk8f16fp4op><code>rocdl.cvt.scale.pk8.f16.fp4</code> (ROCDL::CvtPkScalePk8F16Fp4Op)</a></li><li><a href=#rocdlcvtscalepk8f16fp8-rocdlcvtpkscalepk8f16fp8op><code>rocdl.cvt.scale.pk8.f16.fp8</code> (ROCDL::CvtPkScalePk8F16Fp8Op)</a></li><li><a href=#rocdlcvtscalepk8f32bf8-rocdlcvtpkscalepk8f32bf8op><code>rocdl.cvt.scale.pk8.f32.bf8</code> (ROCDL::CvtPkScalePk8F32Bf8Op)</a></li><li><a href=#rocdlcvtscalepk8f32fp4-rocdlcvtpkscalepk8f32fp4op><code>rocdl.cvt.scale.pk8.f32.fp4</code> (ROCDL::CvtPkScalePk8F32Fp4Op)</a></li><li><a href=#rocdlcvtscalepk8f32fp8-rocdlcvtpkscalepk8f32fp8op><code>rocdl.cvt.scale.pk8.f32.fp8</code> (ROCDL::CvtPkScalePk8F32Fp8Op)</a></li><li><a href=#rocdlcvtscalef322xpk16bf6f32-rocdlcvtscalef322xpk16bf6f32op><code>rocdl.cvt.scalef32.2xpk16.bf6.f32</code> (ROCDL::CvtScaleF322xPk16Bf6F32Op)</a></li><li><a href=#rocdlcvtscalef322xpk16fp6f32-rocdlcvtscalef322xpk16fp6f32op><code>rocdl.cvt.scalef32.2xpk16.fp6.f32</code> (ROCDL::CvtScaleF322xPk16Fp6F32Op)</a></li><li><a href=#rocdlcvtscalef32f16bf8-rocdlcvtscalef32f16bf8op><code>rocdl.cvt.scalef32.f16.bf8</code> (ROCDL::CvtScaleF32F16Bf8Op)</a></li><li><a href=#rocdlcvtscalef32f16fp8-rocdlcvtscalef32f16fp8op><code>rocdl.cvt.scalef32.f16.fp8</code> (ROCDL::CvtScaleF32F16Fp8Op)</a></li><li><a href=#rocdlcvtscalef32f32bf8-rocdlcvtscalef32f32bf8op><code>rocdl.cvt.scalef32.f32.bf8</code> (ROCDL::CvtScaleF32F32Bf8Op)</a></li><li><a href=#rocdlcvtscalef32f32fp8-rocdlcvtscalef32f32fp8op><code>rocdl.cvt.scalef32.f32.fp8</code> (ROCDL::CvtScaleF32F32Fp8Op)</a></li><li><a href=#rocdlcvtscalef32pkbf16bf8-rocdlcvtscalef32pkbf16bf8op><code>rocdl.cvt.scalef32.pk.bf16.bf8</code> (ROCDL::CvtScaleF32PkBf16Bf8Op)</a></li><li><a href=#rocdlcvtscalef32pkbf16fp4-rocdlcvtscalef32pkbf16fp4op><code>rocdl.cvt.scalef32.pk.bf16.fp4</code> (ROCDL::CvtScaleF32PkBf16Fp4Op)</a></li><li><a href=#rocdlcvtscalef32pkbf16fp8-rocdlcvtscalef32pkbf16fp8op><code>rocdl.cvt.scalef32.pk.bf16.fp8</code> (ROCDL::CvtScaleF32PkBf16Fp8Op)</a></li><li><a href=#rocdlcvtscalef32pkbf8bf16-rocdlcvtscalef32pkbf8bf16op><code>rocdl.cvt.scalef32.pk.bf8.bf16</code> (ROCDL::CvtScaleF32PkBf8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pkbf8f16-rocdlcvtscalef32pkbf8f16op><code>rocdl.cvt.scalef32.pk.bf8.f16</code> (ROCDL::CvtScaleF32PkBf8F16Op)</a></li><li><a href=#rocdlcvtscalef32pkbf8f32-rocdlcvtscalef32pkbf8f32op><code>rocdl.cvt.scalef32.pk.bf8.f32</code> (ROCDL::CvtScaleF32PkBf8F32Op)</a></li><li><a href=#rocdlcvtscalef32pkf16bf8-rocdlcvtscalef32pkf16bf8op><code>rocdl.cvt.scalef32.pk.f16.bf8</code> (ROCDL::CvtScaleF32PkF16Bf8Op)</a></li><li><a href=#rocdlcvtscalef32pkf16fp4-rocdlcvtscalef32pkf16fp4op><code>rocdl.cvt.scalef32.pk.f16.fp4</code> (ROCDL::CvtScaleF32PkF16Fp4Op)</a></li><li><a href=#rocdlcvtscalef32pkf16fp8-rocdlcvtscalef32pkf16fp8op><code>rocdl.cvt.scalef32.pk.f16.fp8</code> (ROCDL::CvtScaleF32PkF16Fp8Op)</a></li><li><a href=#rocdlcvtscalef32pkf32bf8-rocdlcvtscalef32pkf32bf8op><code>rocdl.cvt.scalef32.pk.f32.bf8</code> (ROCDL::CvtScaleF32PkF32Bf8Op)</a></li><li><a href=#rocdlcvtscalef32pkf32fp4-rocdlcvtscalef32pkf32fp4op><code>rocdl.cvt.scalef32.pk.f32.fp4</code> (ROCDL::CvtScaleF32PkF32Fp4Op)</a></li><li><a href=#rocdlcvtscalef32pkf32fp8-rocdlcvtscalef32pkf32fp8op><code>rocdl.cvt.scalef32.pk.f32.fp8</code> (ROCDL::CvtScaleF32PkF32Fp8Op)</a></li><li><a href=#rocdlcvtscalef32pkfp4bf16-rocdlcvtscalef32pkfp4bf16op><code>rocdl.cvt.scalef32.pk.fp4.bf16</code> (ROCDL::CvtScaleF32PkFp4Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pkfp4f16-rocdlcvtscalef32pkfp4f16op><code>rocdl.cvt.scalef32.pk.fp4.f16</code> (ROCDL::CvtScaleF32PkFp4F16Op)</a></li><li><a href=#rocdlcvtscalef32pkfp4f32-rocdlcvtscalef32pkfp4f32op><code>rocdl.cvt.scalef32.pk.fp4.f32</code> (ROCDL::CvtScaleF32PkFp4F32Op)</a></li><li><a href=#rocdlcvtscalef32pkfp8bf16-rocdlcvtscalef32pkfp8bf16op><code>rocdl.cvt.scalef32.pk.fp8.bf16</code> (ROCDL::CvtScaleF32PkFp8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pkfp8f16-rocdlcvtscalef32pkfp8f16op><code>rocdl.cvt.scalef32.pk.fp8.f16</code> (ROCDL::CvtScaleF32PkFp8F16Op)</a></li><li><a href=#rocdlcvtscalef32pkfp8f32-rocdlcvtscalef32pkfp8f32op><code>rocdl.cvt.scalef32.pk.fp8.f32</code> (ROCDL::CvtScaleF32PkFp8F32Op)</a></li><li><a href=#rocdlcvtscalef32pk16bf6bf16-rocdlcvtscalef32pk16bf6bf16op><code>rocdl.cvt.scalef32.pk16.bf6.bf16</code> (ROCDL::CvtScaleF32Pk16Bf6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk16bf6f16-rocdlcvtscalef32pk16bf6f16op><code>rocdl.cvt.scalef32.pk16.bf6.f16</code> (ROCDL::CvtScaleF32Pk16Bf6F16Op)</a></li><li><a href=#rocdlcvtscalef32pk16bf6f32-rocdlcvtscalef32pk16bf6f32op><code>rocdl.cvt.scalef32.pk16.bf6.f32</code> (ROCDL::CvtScaleF32Pk16Bf6F32Op)</a></li><li><a href=#rocdlcvtscalef32pk16fp6bf16-rocdlcvtscalef32pk16fp6bf16op><code>rocdl.cvt.scalef32.pk16.fp6.bf16</code> (ROCDL::CvtScaleF32Pk16Fp6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk16fp6f16-rocdlcvtscalef32pk16fp6f16op><code>rocdl.cvt.scalef32.pk16.fp6.f16</code> (ROCDL::CvtScaleF32Pk16Fp6F16Op)</a></li><li><a href=#rocdlcvtscalef32pk16fp6f32-rocdlcvtscalef32pk16fp6f32op><code>rocdl.cvt.scalef32.pk16.fp6.f32</code> (ROCDL::CvtScaleF32Pk16Fp6F32Op)</a></li><li><a href=#rocdlcvtscalef32pk32bf16bf6-rocdlcvtscalef32pk32bf16bf6op><code>rocdl.cvt.scalef32.pk32.bf16.bf6</code> (ROCDL::CvtScaleF32Pk32Bf16Bf6Op)</a></li><li><a href=#rocdlcvtscalef32pk32bf16fp6-rocdlcvtscalef32pk32bf16fp6op><code>rocdl.cvt.scalef32.pk32.bf16.fp6</code> (ROCDL::CvtScaleF32Pk32Bf16Fp6Op)</a></li><li><a href=#rocdlcvtscalef32pk32bf6bf16-rocdlcvtscalef32pk32bf6bf16op><code>rocdl.cvt.scalef32.pk32.bf6.bf16</code> (ROCDL::CvtScaleF32Pk32Bf6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk32bf6f16-rocdlcvtscalef32pk32bf6f16op><code>rocdl.cvt.scalef32.pk32.bf6.f16</code> (ROCDL::CvtScaleF32Pk32Bf6F16Op)</a></li><li><a href=#rocdlcvtscalef32pk32f16bf6-rocdlcvtscalef32pk32f16bf6op><code>rocdl.cvt.scalef32.pk32.f16.bf6</code> (ROCDL::CvtScaleF32Pk32F16Bf6Op)</a></li><li><a href=#rocdlcvtscalef32pk32f16fp6-rocdlcvtscalef32pk32f16fp6op><code>rocdl.cvt.scalef32.pk32.f16.fp6</code> (ROCDL::CvtScaleF32Pk32F16Fp6Op)</a></li><li><a href=#rocdlcvtscalef32pk32f32bf6-rocdlcvtscalef32pk32f32bf6op><code>rocdl.cvt.scalef32.pk32.f32.bf6</code> (ROCDL::CvtScaleF32Pk32F32Bf6Op)</a></li><li><a href=#rocdlcvtscalef32pk32f32fp6-rocdlcvtscalef32pk32f32fp6op><code>rocdl.cvt.scalef32.pk32.f32.fp6</code> (ROCDL::CvtScaleF32Pk32F32Fp6Op)</a></li><li><a href=#rocdlcvtscalef32pk32fp6bf16-rocdlcvtscalef32pk32fp6bf16op><code>rocdl.cvt.scalef32.pk32.fp6.bf16</code> (ROCDL::CvtScaleF32Pk32Fp6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk32fp6f16-rocdlcvtscalef32pk32fp6f16op><code>rocdl.cvt.scalef32.pk32.fp6.f16</code> (ROCDL::CvtScaleF32Pk32Fp6F16Op)</a></li><li><a href=#rocdlcvtscalef32pk8bf8bf16-rocdlcvtscalef32pk8bf8bf16op><code>rocdl.cvt.scalef32.pk8.bf8.bf16</code> (ROCDL::CvtScaleF32Pk8Bf8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk8bf8f16-rocdlcvtscalef32pk8bf8f16op><code>rocdl.cvt.scalef32.pk8.bf8.f16</code> (ROCDL::CvtScaleF32Pk8Bf8F16Op)</a></li><li><a href=#rocdlcvtscalef32pk8bf8f32-rocdlcvtscalef32pk8bf8f32op><code>rocdl.cvt.scalef32.pk8.bf8.f32</code> (ROCDL::CvtScaleF32Pk8Bf8F32Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp4bf16-rocdlcvtscalef32pk8fp4bf16op><code>rocdl.cvt.scalef32.pk8.fp4.bf16</code> (ROCDL::CvtScaleF32Pk8Fp4Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp4f16-rocdlcvtscalef32pk8fp4f16op><code>rocdl.cvt.scalef32.pk8.fp4.f16</code> (ROCDL::CvtScaleF32Pk8Fp4F16Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp4f32-rocdlcvtscalef32pk8fp4f32op><code>rocdl.cvt.scalef32.pk8.fp4.f32</code> (ROCDL::CvtScaleF32Pk8Fp4F32Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp8bf16-rocdlcvtscalef32pk8fp8bf16op><code>rocdl.cvt.scalef32.pk8.fp8.bf16</code> (ROCDL::CvtScaleF32Pk8Fp8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp8f16-rocdlcvtscalef32pk8fp8f16op><code>rocdl.cvt.scalef32.pk8.fp8.f16</code> (ROCDL::CvtScaleF32Pk8Fp8F16Op)</a></li><li><a href=#rocdlcvtscalef32pk8fp8f32-rocdlcvtscalef32pk8fp8f32op><code>rocdl.cvt.scalef32.pk8.fp8.f32</code> (ROCDL::CvtScaleF32Pk8Fp8F32Op)</a></li><li><a href=#rocdlcvtscalef32srbf8bf16-rocdlcvtscalef32srbf8bf16op><code>rocdl.cvt.scalef32.sr.bf8.bf16</code> (ROCDL::CvtScaleF32SrBf8BF16Op)</a></li><li><a href=#rocdlcvtscalef32srbf8f16-rocdlcvtscalef32srbf8f16op><code>rocdl.cvt.scalef32.sr.bf8.f16</code> (ROCDL::CvtScaleF32SrBf8F16Op)</a></li><li><a href=#rocdlcvtscalef32srbf8f32-rocdlcvtscalef32srbf8f32op><code>rocdl.cvt.scalef32.sr.bf8.f32</code> (ROCDL::CvtScaleF32SrBf8F32Op)</a></li><li><a href=#rocdlcvtscalef32srfp8bf16-rocdlcvtscalef32srfp8bf16op><code>rocdl.cvt.scalef32.sr.fp8.bf16</code> (ROCDL::CvtScaleF32SrFp8BF16Op)</a></li><li><a href=#rocdlcvtscalef32srfp8f16-rocdlcvtscalef32srfp8f16op><code>rocdl.cvt.scalef32.sr.fp8.f16</code> (ROCDL::CvtScaleF32SrFp8F16Op)</a></li><li><a href=#rocdlcvtscalef32srfp8f32-rocdlcvtscalef32srfp8f32op><code>rocdl.cvt.scalef32.sr.fp8.f32</code> (ROCDL::CvtScaleF32SrFp8F32Op)</a></li><li><a href=#rocdlcvtscalef32srpkfp4bf16-rocdlcvtscalef32srpkfp4bf16op><code>rocdl.cvt.scalef32.sr.pk.fp4.bf16</code> (ROCDL::CvtScaleF32SrPkFp4Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpkfp4f16-rocdlcvtscalef32srpkfp4f16op><code>rocdl.cvt.scalef32.sr.pk.fp4.f16</code> (ROCDL::CvtScaleF32SrPkFp4F16Op)</a></li><li><a href=#rocdlcvtscalef32srpkfp4f32-rocdlcvtscalef32srpkfp4f32op><code>rocdl.cvt.scalef32.sr.pk.fp4.f32</code> (ROCDL::CvtScaleF32SrPkFp4F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk16bf6bf16-rocdlcvtscalef32srpk16bf6bf16op><code>rocdl.cvt.scalef32.sr.pk16.bf6.bf16</code> (ROCDL::CvtScaleF32SrPk16Bf6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk16bf6f16-rocdlcvtscalef32srpk16bf6f16op><code>rocdl.cvt.scalef32.sr.pk16.bf6.f16</code> (ROCDL::CvtScaleF32SrPk16Bf6F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk16bf6f32-rocdlcvtscalef32srpk16bf6f32op><code>rocdl.cvt.scalef32.sr.pk16.bf6.f32</code> (ROCDL::CvtScaleF32SrPk16Bf6F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk16fp6bf16-rocdlcvtscalef32srpk16fp6bf16op><code>rocdl.cvt.scalef32.sr.pk16.fp6.bf16</code> (ROCDL::CvtScaleF32SrPk16Fp6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk16fp6f16-rocdlcvtscalef32srpk16fp6f16op><code>rocdl.cvt.scalef32.sr.pk16.fp6.f16</code> (ROCDL::CvtScaleF32SrPk16Fp6F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk16fp6f32-rocdlcvtscalef32srpk16fp6f32op><code>rocdl.cvt.scalef32.sr.pk16.fp6.f32</code> (ROCDL::CvtScaleF32SrPk16Fp6F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk32bf6bf16-rocdlcvtscalef32srpk32bf6bf16op><code>rocdl.cvt.scalef32.sr.pk32.bf6.bf16</code> (ROCDL::CvtScaleF32SrPk32Bf6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk32bf6f16-rocdlcvtscalef32srpk32bf6f16op><code>rocdl.cvt.scalef32.sr.pk32.bf6.f16</code> (ROCDL::CvtScaleF32SrPk32Bf6F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk32bf6f32-rocdlcvtscalef32srpk32bf6f32op><code>rocdl.cvt.scalef32.sr.pk32.bf6.f32</code> (ROCDL::CvtScaleF32SrPk32Bf6F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk32fp6bf16-rocdlcvtscalef32srpk32fp6bf16op><code>rocdl.cvt.scalef32.sr.pk32.fp6.bf16</code> (ROCDL::CvtScaleF32SrPk32Fp6Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk32fp6f16-rocdlcvtscalef32srpk32fp6f16op><code>rocdl.cvt.scalef32.sr.pk32.fp6.f16</code> (ROCDL::CvtScaleF32SrPk32Fp6F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk32fp6f32-rocdlcvtscalef32srpk32fp6f32op><code>rocdl.cvt.scalef32.sr.pk32.fp6.f32</code> (ROCDL::CvtScaleF32SrPk32Fp6F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk8bf8bf16-rocdlcvtscalef32srpk8bf8bf16op><code>rocdl.cvt.scalef32.sr.pk8.bf8.bf16</code> (ROCDL::CvtScaleF32SrPk8Bf8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8bf8f16-rocdlcvtscalef32srpk8bf8f16op><code>rocdl.cvt.scalef32.sr.pk8.bf8.f16</code> (ROCDL::CvtScaleF32SrPk8Bf8F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8bf8f32-rocdlcvtscalef32srpk8bf8f32op><code>rocdl.cvt.scalef32.sr.pk8.bf8.f32</code> (ROCDL::CvtScaleF32SrPk8Bf8F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp4bf16-rocdlcvtscalef32srpk8fp4bf16op><code>rocdl.cvt.scalef32.sr.pk8.fp4.bf16</code> (ROCDL::CvtScaleF32SrPk8Fp4Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp4f16-rocdlcvtscalef32srpk8fp4f16op><code>rocdl.cvt.scalef32.sr.pk8.fp4.f16</code> (ROCDL::CvtScaleF32SrPk8Fp4F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp4f32-rocdlcvtscalef32srpk8fp4f32op><code>rocdl.cvt.scalef32.sr.pk8.fp4.f32</code> (ROCDL::CvtScaleF32SrPk8Fp4F32Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp8bf16-rocdlcvtscalef32srpk8fp8bf16op><code>rocdl.cvt.scalef32.sr.pk8.fp8.bf16</code> (ROCDL::CvtScaleF32SrPk8Fp8Bf16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp8f16-rocdlcvtscalef32srpk8fp8f16op><code>rocdl.cvt.scalef32.sr.pk8.fp8.f16</code> (ROCDL::CvtScaleF32SrPk8Fp8F16Op)</a></li><li><a href=#rocdlcvtscalef32srpk8fp8f32-rocdlcvtscalef32srpk8fp8f32op><code>rocdl.cvt.scalef32.sr.pk8.fp8.f32</code> (ROCDL::CvtScaleF32SrPk8Fp8F32Op)</a></li><li><a href=#rocdlcvtsrbf8f32-rocdlcvtsrbf8f32op><code>rocdl.cvt.sr.bf8.f32</code> (ROCDL::CvtSrBf8F32Op)</a></li><li><a href=#rocdlcvtsrfp8f32-rocdlcvtsrfp8f32op><code>rocdl.cvt.sr.fp8.f32</code> (ROCDL::CvtSrFp8F32Op)</a></li><li><a href=#rocdldsatomicasyncbarrierarriveb64-rocdldsatomicasyncbarrierarriveop><code>rocdl.ds.atomic.async.barrier.arrive.b64</code> (ROCDL::DsAtomicAsyncBarrierArriveOp)</a></li><li><a href=#rocdldsatomicbarrierarrivertnb64-rocdldsatomicbarrierarrivertnop><code>rocdl.ds.atomic.barrier.arrive.rtn.b64</code> (ROCDL::DsAtomicBarrierArriveRtnOp)</a></li><li><a href=#rocdldsloadtr16b128-rocdldsloadtr16_b128><code>rocdl.ds.load.tr16.b128</code> (ROCDL::DsLoadTr16_B128)</a></li><li><a href=#rocdldsloadtr4b64-rocdldsloadtr4_b64><code>rocdl.ds.load.tr4.b64</code> (ROCDL::DsLoadTr4_B64)</a></li><li><a href=#rocdldsloadtr6b96-rocdldsloadtr6_b96><code>rocdl.ds.load.tr6.b96</code> (ROCDL::DsLoadTr6_B96)</a></li><li><a href=#rocdldsloadtr8b64-rocdldsloadtr8_b64><code>rocdl.ds.load.tr8.b64</code> (ROCDL::DsLoadTr8_B64)</a></li><li><a href=#rocdldsreadtr16b64-rocdlds_read_tr16_b64><code>rocdl.ds.read.tr16.b64</code> (ROCDL::ds_read_tr16_b64)</a></li><li><a href=#rocdldsreadtr4b64-rocdlds_read_tr4_b64><code>rocdl.ds.read.tr4.b64</code> (ROCDL::ds_read_tr4_b64)</a></li><li><a href=#rocdldsreadtr6b96-rocdlds_read_tr6_b96><code>rocdl.ds.read.tr6.b96</code> (ROCDL::ds_read_tr6_b96)</a></li><li><a href=#rocdldsreadtr8b64-rocdlds_read_tr8_b64><code>rocdl.ds.read.tr8.b64</code> (ROCDL::ds_read_tr8_b64)</a></li><li><a href=#rocdlds_bpermute-rocdldsbpermuteop><code>rocdl.ds_bpermute</code> (ROCDL::DsBpermuteOp)</a></li><li><a href=#rocdlds_swizzle-rocdldsswizzleop><code>rocdl.ds_swizzle</code> (ROCDL::DsSwizzleOp)</a></li><li><a href=#rocdlexp-rocdlrocdlexp><code>rocdl.exp</code> (ROCDL::ROCDLExp)</a></li><li><a href=#rocdlexp2-rocdlrocdlexp2><code>rocdl.exp2</code> (ROCDL::ROCDLExp2)</a></li><li><a href=#rocdlflatprefetch-rocdlflatprefetchop><code>rocdl.flat.prefetch</code> (ROCDL::FlatPrefetchOp)</a></li><li><a href=#rocdlfmed3-rocdlfmed3op><code>rocdl.fmed3</code> (ROCDL::FMed3Op)</a></li><li><a href=#rocdlgloballoadasynctoldsb128-rocdlgloballoadasynctoldsb128op><code>rocdl.global.load.async.to.lds.b128</code> (ROCDL::GlobalLoadAsyncToLDSB128Op)</a></li><li><a href=#rocdlgloballoadasynctoldsb32-rocdlgloballoadasynctoldsb32op><code>rocdl.global.load.async.to.lds.b32</code> (ROCDL::GlobalLoadAsyncToLDSB32Op)</a></li><li><a href=#rocdlgloballoadasynctoldsb64-rocdlgloballoadasynctoldsb64op><code>rocdl.global.load.async.to.lds.b64</code> (ROCDL::GlobalLoadAsyncToLDSB64Op)</a></li><li><a href=#rocdlgloballoadasynctoldsb8-rocdlgloballoadasynctoldsb8op><code>rocdl.global.load.async.to.lds.b8</code> (ROCDL::GlobalLoadAsyncToLDSB8Op)</a></li><li><a href=#rocdlgloballoadlds-rocdlgloballoadldsop><code>rocdl.global.load.lds</code> (ROCDL::GlobalLoadLDSOp)</a></li><li><a href=#rocdlgloballoadtrb128-rocdlgloballoadtr8_b128><code>rocdl.global.load.tr.b128</code> (ROCDL::GlobalLoadTr8_B128)</a></li><li><a href=#rocdlgloballoadtrb64-rocdlgloballoadtr8_b64><code>rocdl.global.load.tr.b64</code> (ROCDL::GlobalLoadTr8_B64)</a></li><li><a href=#rocdlgloballoadtr4b64-rocdlgloballoadtr4_b64><code>rocdl.global.load.tr4.b64</code> (ROCDL::GlobalLoadTr4_B64)</a></li><li><a href=#rocdlgloballoadtr6b96-rocdlgloballoadtr6_b96><code>rocdl.global.load.tr6.b96</code> (ROCDL::GlobalLoadTr6_B96)</a></li><li><a href=#rocdlglobalprefetch-rocdlglobalprefetchop><code>rocdl.global.prefetch</code> (ROCDL::GlobalPrefetchOp)</a></li><li><a href=#rocdlgriddimx-rocdlgriddimxop><code>rocdl.grid.dim.x</code> (ROCDL::GridDimXOp)</a></li><li><a href=#rocdlgriddimy-rocdlgriddimyop><code>rocdl.grid.dim.y</code> (ROCDL::GridDimYOp)</a></li><li><a href=#rocdlgriddimz-rocdlgriddimzop><code>rocdl.grid.dim.z</code> (ROCDL::GridDimZOp)</a></li><li><a href=#rocdliglpopt-rocdliglpopt><code>rocdl.iglp.opt</code> (ROCDL::IglpOpt)</a></li><li><a href=#rocdlloadtolds-rocdlloadtoldsop><code>rocdl.load.to.lds</code> (ROCDL::LoadToLDSOp)</a></li><li><a href=#rocdllog-rocdlrocdllog><code>rocdl.log</code> (ROCDL::ROCDLLog)</a></li><li><a href=#rocdlmakebufferrsrc-rocdlmakebufferrsrcop><code>rocdl.make.buffer.rsrc</code> (ROCDL::MakeBufferRsrcOp)</a></li><li><a href=#rocdlmbcnthi-rocdlmbcnthiop><code>rocdl.mbcnt.hi</code> (ROCDL::MbcntHiOp)</a></li><li><a href=#rocdlmbcntlo-rocdlmbcntloop><code>rocdl.mbcnt.lo</code> (ROCDL::MbcntLoOp)</a></li><li><a href=#rocdlmfmaf3216x16x16bf161k-rocdlmfma_f32_16x16x16bf16_1k><code>rocdl.mfma.f32.16x16x16bf16.1k</code> (ROCDL::mfma_f32_16x16x16bf16_1k)</a></li><li><a href=#rocdlmfmaf3216x16x16f16-rocdlmfma_f32_16x16x16f16><code>rocdl.mfma.f32.16x16x16f16</code> (ROCDL::mfma_f32_16x16x16f16)</a></li><li><a href=#rocdlmfmaf3216x16x1f32-rocdlmfma_f32_16x16x1f32><code>rocdl.mfma.f32.16x16x1f32</code> (ROCDL::mfma_f32_16x16x1f32)</a></li><li><a href=#rocdlmfmaf3216x16x2bf16-rocdlmfma_f32_16x16x2bf16><code>rocdl.mfma.f32.16x16x2bf16</code> (ROCDL::mfma_f32_16x16x2bf16)</a></li><li><a href=#rocdlmfmaf3216x16x32bf16-rocdlmfma_f32_16x16x32_bf16><code>rocdl.mfma.f32.16x16x32.bf16</code> (ROCDL::mfma_f32_16x16x32_bf16)</a></li><li><a href=#rocdlmfmaf3216x16x32bf8bf8-rocdlmfma_f32_16x16x32_bf8_bf8><code>rocdl.mfma.f32.16x16x32.bf8.bf8</code> (ROCDL::mfma_f32_16x16x32_bf8_bf8)</a></li><li><a href=#rocdlmfmaf3216x16x32bf8fp8-rocdlmfma_f32_16x16x32_bf8_fp8><code>rocdl.mfma.f32.16x16x32.bf8.fp8</code> (ROCDL::mfma_f32_16x16x32_bf8_fp8)</a></li><li><a href=#rocdlmfmaf3216x16x32f16-rocdlmfma_f32_16x16x32_f16><code>rocdl.mfma.f32.16x16x32.f16</code> (ROCDL::mfma_f32_16x16x32_f16)</a></li><li><a href=#rocdlmfmaf3216x16x32fp8bf8-rocdlmfma_f32_16x16x32_fp8_bf8><code>rocdl.mfma.f32.16x16x32.fp8.bf8</code> (ROCDL::mfma_f32_16x16x32_fp8_bf8)</a></li><li><a href=#rocdlmfmaf3216x16x32fp8fp8-rocdlmfma_f32_16x16x32_fp8_fp8><code>rocdl.mfma.f32.16x16x32.fp8.fp8</code> (ROCDL::mfma_f32_16x16x32_fp8_fp8)</a></li><li><a href=#rocdlmfmaf3216x16x4bf161k-rocdlmfma_f32_16x16x4bf16_1k><code>rocdl.mfma.f32.16x16x4bf16.1k</code> (ROCDL::mfma_f32_16x16x4bf16_1k)</a></li><li><a href=#rocdlmfmaf3216x16x4f16-rocdlmfma_f32_16x16x4f16><code>rocdl.mfma.f32.16x16x4f16</code> (ROCDL::mfma_f32_16x16x4f16)</a></li><li><a href=#rocdlmfmaf3216x16x4f32-rocdlmfma_f32_16x16x4f32><code>rocdl.mfma.f32.16x16x4f32</code> (ROCDL::mfma_f32_16x16x4f32)</a></li><li><a href=#rocdlmfmaf3216x16x8xf32-rocdlmfma_f32_16x16x8_xf32><code>rocdl.mfma.f32.16x16x8.xf32</code> (ROCDL::mfma_f32_16x16x8_xf32)</a></li><li><a href=#rocdlmfmaf3216x16x8bf16-rocdlmfma_f32_16x16x8bf16><code>rocdl.mfma.f32.16x16x8bf16</code> (ROCDL::mfma_f32_16x16x8bf16)</a></li><li><a href=#rocdlmfmaf3232x32x16bf16-rocdlmfma_f32_32x32x16_bf16><code>rocdl.mfma.f32.32x32x16.bf16</code> (ROCDL::mfma_f32_32x32x16_bf16)</a></li><li><a href=#rocdlmfmaf3232x32x16bf8bf8-rocdlmfma_f32_32x32x16_bf8_bf8><code>rocdl.mfma.f32.32x32x16.bf8.bf8</code> (ROCDL::mfma_f32_32x32x16_bf8_bf8)</a></li><li><a href=#rocdlmfmaf3232x32x16bf8fp8-rocdlmfma_f32_32x32x16_bf8_fp8><code>rocdl.mfma.f32.32x32x16.bf8.fp8</code> (ROCDL::mfma_f32_32x32x16_bf8_fp8)</a></li><li><a href=#rocdlmfmaf3232x32x16f16-rocdlmfma_f32_32x32x16_f16><code>rocdl.mfma.f32.32x32x16.f16</code> (ROCDL::mfma_f32_32x32x16_f16)</a></li><li><a href=#rocdlmfmaf3232x32x16fp8bf8-rocdlmfma_f32_32x32x16_fp8_bf8><code>rocdl.mfma.f32.32x32x16.fp8.bf8</code> (ROCDL::mfma_f32_32x32x16_fp8_bf8)</a></li><li><a href=#rocdlmfmaf3232x32x16fp8fp8-rocdlmfma_f32_32x32x16_fp8_fp8><code>rocdl.mfma.f32.32x32x16.fp8.fp8</code> (ROCDL::mfma_f32_32x32x16_fp8_fp8)</a></li><li><a href=#rocdlmfmaf3232x32x1f32-rocdlmfma_f32_32x32x1f32><code>rocdl.mfma.f32.32x32x1f32</code> (ROCDL::mfma_f32_32x32x1f32)</a></li><li><a href=#rocdlmfmaf3232x32x2bf16-rocdlmfma_f32_32x32x2bf16><code>rocdl.mfma.f32.32x32x2bf16</code> (ROCDL::mfma_f32_32x32x2bf16)</a></li><li><a href=#rocdlmfmaf3232x32x2f32-rocdlmfma_f32_32x32x2f32><code>rocdl.mfma.f32.32x32x2f32</code> (ROCDL::mfma_f32_32x32x2f32)</a></li><li><a href=#rocdlmfmaf3232x32x4xf32-rocdlmfma_f32_32x32x4_xf32><code>rocdl.mfma.f32.32x32x4.xf32</code> (ROCDL::mfma_f32_32x32x4_xf32)</a></li><li><a href=#rocdlmfmaf3232x32x4bf16-rocdlmfma_f32_32x32x4bf16><code>rocdl.mfma.f32.32x32x4bf16</code> (ROCDL::mfma_f32_32x32x4bf16)</a></li><li><a href=#rocdlmfmaf3232x32x4bf161k-rocdlmfma_f32_32x32x4bf16_1k><code>rocdl.mfma.f32.32x32x4bf16.1k</code> (ROCDL::mfma_f32_32x32x4bf16_1k)</a></li><li><a href=#rocdlmfmaf3232x32x4f16-rocdlmfma_f32_32x32x4f16><code>rocdl.mfma.f32.32x32x4f16</code> (ROCDL::mfma_f32_32x32x4f16)</a></li><li><a href=#rocdlmfmaf3232x32x8bf161k-rocdlmfma_f32_32x32x8bf16_1k><code>rocdl.mfma.f32.32x32x8bf16.1k</code> (ROCDL::mfma_f32_32x32x8bf16_1k)</a></li><li><a href=#rocdlmfmaf3232x32x8f16-rocdlmfma_f32_32x32x8f16><code>rocdl.mfma.f32.32x32x8f16</code> (ROCDL::mfma_f32_32x32x8f16)</a></li><li><a href=#rocdlmfmaf324x4x1f32-rocdlmfma_f32_4x4x1f32><code>rocdl.mfma.f32.4x4x1f32</code> (ROCDL::mfma_f32_4x4x1f32)</a></li><li><a href=#rocdlmfmaf324x4x2bf16-rocdlmfma_f32_4x4x2bf16><code>rocdl.mfma.f32.4x4x2bf16</code> (ROCDL::mfma_f32_4x4x2bf16)</a></li><li><a href=#rocdlmfmaf324x4x4bf161k-rocdlmfma_f32_4x4x4bf16_1k><code>rocdl.mfma.f32.4x4x4bf16.1k</code> (ROCDL::mfma_f32_4x4x4bf16_1k)</a></li><li><a href=#rocdlmfmaf324x4x4f16-rocdlmfma_f32_4x4x4f16><code>rocdl.mfma.f32.4x4x4f16</code> (ROCDL::mfma_f32_4x4x4f16)</a></li><li><a href=#rocdlmfmaf6416x16x4f64-rocdlmfma_f64_16x16x4f64><code>rocdl.mfma.f64.16x16x4f64</code> (ROCDL::mfma_f64_16x16x4f64)</a></li><li><a href=#rocdlmfmaf644x4x4f64-rocdlmfma_f64_4x4x4f64><code>rocdl.mfma.f64.4x4x4f64</code> (ROCDL::mfma_f64_4x4x4f64)</a></li><li><a href=#rocdlmfmai3216x16x16i8-rocdlmfma_i32_16x16x16i8><code>rocdl.mfma.i32.16x16x16i8</code> (ROCDL::mfma_i32_16x16x16i8)</a></li><li><a href=#rocdlmfmai3216x16x32i8-rocdlmfma_i32_16x16x32_i8><code>rocdl.mfma.i32.16x16x32.i8</code> (ROCDL::mfma_i32_16x16x32_i8)</a></li><li><a href=#rocdlmfmai3216x16x4i8-rocdlmfma_i32_16x16x4i8><code>rocdl.mfma.i32.16x16x4i8</code> (ROCDL::mfma_i32_16x16x4i8)</a></li><li><a href=#rocdlmfmai3216x16x64i8-rocdlmfma_i32_16x16x64_i8><code>rocdl.mfma.i32.16x16x64.i8</code> (ROCDL::mfma_i32_16x16x64_i8)</a></li><li><a href=#rocdlmfmai3232x32x16i8-rocdlmfma_i32_32x32x16_i8><code>rocdl.mfma.i32.32x32x16.i8</code> (ROCDL::mfma_i32_32x32x16_i8)</a></li><li><a href=#rocdlmfmai3232x32x32i8-rocdlmfma_i32_32x32x32_i8><code>rocdl.mfma.i32.32x32x32.i8</code> (ROCDL::mfma_i32_32x32x32_i8)</a></li><li><a href=#rocdlmfmai3232x32x4i8-rocdlmfma_i32_32x32x4i8><code>rocdl.mfma.i32.32x32x4i8</code> (ROCDL::mfma_i32_32x32x4i8)</a></li><li><a href=#rocdlmfmai3232x32x8i8-rocdlmfma_i32_32x32x8i8><code>rocdl.mfma.i32.32x32x8i8</code> (ROCDL::mfma_i32_32x32x8i8)</a></li><li><a href=#rocdlmfmai324x4x4i8-rocdlmfma_i32_4x4x4i8><code>rocdl.mfma.i32.4x4x4i8</code> (ROCDL::mfma_i32_4x4x4i8)</a></li><li><a href=#rocdlmfmascalef3216x16x128f8f6f4-rocdlmfma_scale_f32_16x16x128_f8f6f4><code>rocdl.mfma.scale.f32.16x16x128.f8f6f4</code> (ROCDL::mfma_scale_f32_16x16x128_f8f6f4)</a></li><li><a href=#rocdlmfmascalef3232x32x64f8f6f4-rocdlmfma_scale_f32_32x32x64_f8f6f4><code>rocdl.mfma.scale.f32.32x32x64.f8f6f4</code> (ROCDL::mfma_scale_f32_32x32x64_f8f6f4)</a></li><li><a href=#rocdlpermlane16swap-rocdlpermlane16swapop><code>rocdl.permlane16.swap</code> (ROCDL::Permlane16SwapOp)</a></li><li><a href=#rocdlpermlane32swap-rocdlpermlane32swapop><code>rocdl.permlane32.swap</code> (ROCDL::Permlane32SwapOp)</a></li><li><a href=#rocdlpermlanex16-rocdlpermlanex16op><code>rocdl.permlanex16</code> (ROCDL::PermlaneX16Op)</a></li><li><a href=#rocdlrawbufferatomiccmpswap-rocdlrawbufferatomiccmpswap><code>rocdl.raw.buffer.atomic.cmpswap</code> (ROCDL::RawBufferAtomicCmpSwap)</a></li><li><a href=#rocdlrawbufferatomicfadd-rocdlrawbufferatomicfaddop><code>rocdl.raw.buffer.atomic.fadd</code> (ROCDL::RawBufferAtomicFAddOp)</a></li><li><a href=#rocdlrawbufferatomicfmax-rocdlrawbufferatomicfmaxop><code>rocdl.raw.buffer.atomic.fmax</code> (ROCDL::RawBufferAtomicFMaxOp)</a></li><li><a href=#rocdlrawbufferatomicsmax-rocdlrawbufferatomicsmaxop><code>rocdl.raw.buffer.atomic.smax</code> (ROCDL::RawBufferAtomicSMaxOp)</a></li><li><a href=#rocdlrawbufferatomicumin-rocdlrawbufferatomicuminop><code>rocdl.raw.buffer.atomic.umin</code> (ROCDL::RawBufferAtomicUMinOp)</a></li><li><a href=#rocdlrawbufferload-rocdlrawbufferloadop><code>rocdl.raw.buffer.load</code> (ROCDL::RawBufferLoadOp)</a></li><li><a href=#rocdlrawbufferstore-rocdlrawbufferstoreop><code>rocdl.raw.buffer.store</code> (ROCDL::RawBufferStoreOp)</a></li><li><a href=#rocdlrawptrbufferatomiccmpswap-rocdlrawptrbufferatomiccmpswap><code>rocdl.raw.ptr.buffer.atomic.cmpswap</code> (ROCDL::RawPtrBufferAtomicCmpSwap)</a></li><li><a href=#rocdlrawptrbufferatomicfadd-rocdlrawptrbufferatomicfaddop><code>rocdl.raw.ptr.buffer.atomic.fadd</code> (ROCDL::RawPtrBufferAtomicFaddOp)</a></li><li><a href=#rocdlrawptrbufferatomicfmax-rocdlrawptrbufferatomicfmaxop><code>rocdl.raw.ptr.buffer.atomic.fmax</code> (ROCDL::RawPtrBufferAtomicFmaxOp)</a></li><li><a href=#rocdlrawptrbufferatomicsmax-rocdlrawptrbufferatomicsmaxop><code>rocdl.raw.ptr.buffer.atomic.smax</code> (ROCDL::RawPtrBufferAtomicSmaxOp)</a></li><li><a href=#rocdlrawptrbufferatomicumin-rocdlrawptrbufferatomicuminop><code>rocdl.raw.ptr.buffer.atomic.umin</code> (ROCDL::RawPtrBufferAtomicUminOp)</a></li><li><a href=#rocdlrawptrbufferload-rocdlrawptrbufferloadop><code>rocdl.raw.ptr.buffer.load</code> (ROCDL::RawPtrBufferLoadOp)</a></li><li><a href=#rocdlrawptrbufferloadlds-rocdlrawptrbufferloadldsop><code>rocdl.raw.ptr.buffer.load.lds</code> (ROCDL::RawPtrBufferLoadLdsOp)</a></li><li><a href=#rocdlrawptrbufferstore-rocdlrawptrbufferstoreop><code>rocdl.raw.ptr.buffer.store</code> (ROCDL::RawPtrBufferStoreOp)</a></li><li><a href=#rocdlrcp-rocdlrocdlrcp><code>rocdl.rcp</code> (ROCDL::ROCDLRcp)</a></li><li><a href=#rocdlreadfirstlane-rocdlreadfirstlaneop><code>rocdl.readfirstlane</code> (ROCDL::ReadfirstlaneOp)</a></li><li><a href=#rocdlreadlane-rocdlreadlaneop><code>rocdl.readlane</code> (ROCDL::ReadlaneOp)</a></li><li><a href=#rocdlsbarrier-rocdlsbarrierop><code>rocdl.s.barrier</code> (ROCDL::SBarrierOp)</a></li><li><a href=#rocdlsbarrierinit-rocdlbarrierinitop><code>rocdl.s.barrier.init</code> (ROCDL::BarrierInitOp)</a></li><li><a href=#rocdlsbarrierjoin-rocdlbarrierjoinop><code>rocdl.s.barrier.join</code> (ROCDL::BarrierJoinOp)</a></li><li><a href=#rocdlsbarrierleave-rocdlbarrierleaveop><code>rocdl.s.barrier.leave</code> (ROCDL::BarrierLeaveOp)</a></li><li><a href=#rocdlsbarriersignal-rocdlbarriersignalop><code>rocdl.s.barrier.signal</code> (ROCDL::BarrierSignalOp)</a></li><li><a href=#rocdlsbarriersignalisfirst-rocdlbarriersignalisfirstop><code>rocdl.s.barrier.signal.isfirst</code> (ROCDL::BarrierSignalIsfirstOp)</a></li><li><a href=#rocdlsbarriersignalvar-rocdlbarriersignalvarop><code>rocdl.s.barrier.signal.var</code> (ROCDL::BarrierSignalVarOp)</a></li><li><a href=#rocdlsbarrierwait-rocdlbarrierwaitop><code>rocdl.s.barrier.wait</code> (ROCDL::BarrierWaitOp)</a></li><li><a href=#rocdlsgetbarrierstate-rocdlgetbarrierstateop><code>rocdl.s.get.barrier.state</code> (ROCDL::GetBarrierStateOp)</a></li><li><a href=#rocdlsgetnamedbarrierstate-rocdlgetnamedbarrierstateop><code>rocdl.s.get.named.barrier.state</code> (ROCDL::GetNamedBarrierStateOp)</a></li><li><a href=#rocdlssetprio-rocdlsetprioop><code>rocdl.s.setprio</code> (ROCDL::SetPrioOp)</a></li><li><a href=#rocdlssleep-rocdlssleepop><code>rocdl.s.sleep</code> (ROCDL::SSleepOp)</a></li><li><a href=#rocdlswaitasynccnt-rocdlwaitasynccntop><code>rocdl.s.wait.asynccnt</code> (ROCDL::WaitAsynccntOp)</a></li><li><a href=#rocdlswaitdscnt-rocdlwaitdscntop><code>rocdl.s.wait.dscnt</code> (ROCDL::WaitDscntOp)</a></li><li><a href=#rocdlswaitexpcnt-rocdlwaitexpcntop><code>rocdl.s.wait.expcnt</code> (ROCDL::WaitExpcntOp)</a></li><li><a href=#rocdlswaitloadcnt-rocdlwaitloadcntop><code>rocdl.s.wait.loadcnt</code> (ROCDL::WaitLoadcntOp)</a></li><li><a href=#rocdlswaitstorecnt-rocdlwaitstorecntop><code>rocdl.s.wait.storecnt</code> (ROCDL::WaitStorecntOp)</a></li><li><a href=#rocdlswaittensorcnt-rocdlwaittensorcntop><code>rocdl.s.wait.tensorcnt</code> (ROCDL::WaitTensorcntOp)</a></li><li><a href=#rocdlswaitcnt-rocdlswaitcntop><code>rocdl.s.waitcnt</code> (ROCDL::SWaitcntOp)</a></li><li><a href=#rocdlschedbarrier-rocdlschedbarrier><code>rocdl.sched.barrier</code> (ROCDL::SchedBarrier)</a></li><li><a href=#rocdlschedgroupbarrier-rocdlschedgroupbarrier><code>rocdl.sched.group.barrier</code> (ROCDL::SchedGroupBarrier)</a></li><li><a href=#rocdlsin-rocdlrocdlsin><code>rocdl.sin</code> (ROCDL::ROCDLSin)</a></li><li><a href=#rocdlsmfmacf3216x16x128bf8bf8-rocdlsmfmac_f32_16x16x128_bf8_bf8><code>rocdl.smfmac.f32.16x16x128.bf8.bf8</code> (ROCDL::smfmac_f32_16x16x128_bf8_bf8)</a></li><li><a href=#rocdlsmfmacf3216x16x128bf8fp8-rocdlsmfmac_f32_16x16x128_bf8_fp8><code>rocdl.smfmac.f32.16x16x128.bf8.fp8</code> (ROCDL::smfmac_f32_16x16x128_bf8_fp8)</a></li><li><a href=#rocdlsmfmacf3216x16x128fp8bf8-rocdlsmfmac_f32_16x16x128_fp8_bf8><code>rocdl.smfmac.f32.16x16x128.fp8.bf8</code> (ROCDL::smfmac_f32_16x16x128_fp8_bf8)</a></li><li><a href=#rocdlsmfmacf3216x16x128fp8fp8-rocdlsmfmac_f32_16x16x128_fp8_fp8><code>rocdl.smfmac.f32.16x16x128.fp8.fp8</code> (ROCDL::smfmac_f32_16x16x128_fp8_fp8)</a></li><li><a href=#rocdlsmfmacf3216x16x32bf16-rocdlsmfmac_f32_16x16x32_bf16><code>rocdl.smfmac.f32.16x16x32.bf16</code> (ROCDL::smfmac_f32_16x16x32_bf16)</a></li><li><a href=#rocdlsmfmacf3216x16x32f16-rocdlsmfmac_f32_16x16x32_f16><code>rocdl.smfmac.f32.16x16x32.f16</code> (ROCDL::smfmac_f32_16x16x32_f16)</a></li><li><a href=#rocdlsmfmacf3216x16x64bf16-rocdlsmfmac_f32_16x16x64_bf16><code>rocdl.smfmac.f32.16x16x64.bf16</code> (ROCDL::smfmac_f32_16x16x64_bf16)</a></li><li><a href=#rocdlsmfmacf3216x16x64bf8bf8-rocdlsmfmac_f32_16x16x64_bf8_bf8><code>rocdl.smfmac.f32.16x16x64.bf8.bf8</code> (ROCDL::smfmac_f32_16x16x64_bf8_bf8)</a></li><li><a href=#rocdlsmfmacf3216x16x64bf8fp8-rocdlsmfmac_f32_16x16x64_bf8_fp8><code>rocdl.smfmac.f32.16x16x64.bf8.fp8</code> (ROCDL::smfmac_f32_16x16x64_bf8_fp8)</a></li><li><a href=#rocdlsmfmacf3216x16x64f16-rocdlsmfmac_f32_16x16x64_f16><code>rocdl.smfmac.f32.16x16x64.f16</code> (ROCDL::smfmac_f32_16x16x64_f16)</a></li><li><a href=#rocdlsmfmacf3216x16x64fp8bf8-rocdlsmfmac_f32_16x16x64_fp8_bf8><code>rocdl.smfmac.f32.16x16x64.fp8.bf8</code> (ROCDL::smfmac_f32_16x16x64_fp8_bf8)</a></li><li><a href=#rocdlsmfmacf3216x16x64fp8fp8-rocdlsmfmac_f32_16x16x64_fp8_fp8><code>rocdl.smfmac.f32.16x16x64.fp8.fp8</code> (ROCDL::smfmac_f32_16x16x64_fp8_fp8)</a></li><li><a href=#rocdlsmfmacf3232x32x16bf16-rocdlsmfmac_f32_32x32x16_bf16><code>rocdl.smfmac.f32.32x32x16.bf16</code> (ROCDL::smfmac_f32_32x32x16_bf16)</a></li><li><a href=#rocdlsmfmacf3232x32x16f16-rocdlsmfmac_f32_32x32x16_f16><code>rocdl.smfmac.f32.32x32x16.f16</code> (ROCDL::smfmac_f32_32x32x16_f16)</a></li><li><a href=#rocdlsmfmacf3232x32x32bf16-rocdlsmfmac_f32_32x32x32_bf16><code>rocdl.smfmac.f32.32x32x32.bf16</code> (ROCDL::smfmac_f32_32x32x32_bf16)</a></li><li><a href=#rocdlsmfmacf3232x32x32bf8bf8-rocdlsmfmac_f32_32x32x32_bf8_bf8><code>rocdl.smfmac.f32.32x32x32.bf8.bf8</code> (ROCDL::smfmac_f32_32x32x32_bf8_bf8)</a></li><li><a href=#rocdlsmfmacf3232x32x32bf8fp8-rocdlsmfmac_f32_32x32x32_bf8_fp8><code>rocdl.smfmac.f32.32x32x32.bf8.fp8</code> (ROCDL::smfmac_f32_32x32x32_bf8_fp8)</a></li><li><a href=#rocdlsmfmacf3232x32x32f16-rocdlsmfmac_f32_32x32x32_f16><code>rocdl.smfmac.f32.32x32x32.f16</code> (ROCDL::smfmac_f32_32x32x32_f16)</a></li><li><a href=#rocdlsmfmacf3232x32x32fp8bf8-rocdlsmfmac_f32_32x32x32_fp8_bf8><code>rocdl.smfmac.f32.32x32x32.fp8.bf8</code> (ROCDL::smfmac_f32_32x32x32_fp8_bf8)</a></li><li><a href=#rocdlsmfmacf3232x32x32fp8fp8-rocdlsmfmac_f32_32x32x32_fp8_fp8><code>rocdl.smfmac.f32.32x32x32.fp8.fp8</code> (ROCDL::smfmac_f32_32x32x32_fp8_fp8)</a></li><li><a href=#rocdlsmfmacf3232x32x64bf8bf8-rocdlsmfmac_f32_32x32x64_bf8_bf8><code>rocdl.smfmac.f32.32x32x64.bf8.bf8</code> (ROCDL::smfmac_f32_32x32x64_bf8_bf8)</a></li><li><a href=#rocdlsmfmacf3232x32x64bf8fp8-rocdlsmfmac_f32_32x32x64_bf8_fp8><code>rocdl.smfmac.f32.32x32x64.bf8.fp8</code> (ROCDL::smfmac_f32_32x32x64_bf8_fp8)</a></li><li><a href=#rocdlsmfmacf3232x32x64fp8bf8-rocdlsmfmac_f32_32x32x64_fp8_bf8><code>rocdl.smfmac.f32.32x32x64.fp8.bf8</code> (ROCDL::smfmac_f32_32x32x64_fp8_bf8)</a></li><li><a href=#rocdlsmfmacf3232x32x64fp8fp8-rocdlsmfmac_f32_32x32x64_fp8_fp8><code>rocdl.smfmac.f32.32x32x64.fp8.fp8</code> (ROCDL::smfmac_f32_32x32x64_fp8_fp8)</a></li><li><a href=#rocdlsmfmaci3216x16x128i8-rocdlsmfmac_i32_16x16x128_i8><code>rocdl.smfmac.i32.16x16x128.i8</code> (ROCDL::smfmac_i32_16x16x128_i8)</a></li><li><a href=#rocdlsmfmaci3216x16x64i8-rocdlsmfmac_i32_16x16x64_i8><code>rocdl.smfmac.i32.16x16x64.i8</code> (ROCDL::smfmac_i32_16x16x64_i8)</a></li><li><a href=#rocdlsmfmaci3232x32x32i8-rocdlsmfmac_i32_32x32x32_i8><code>rocdl.smfmac.i32.32x32x32.i8</code> (ROCDL::smfmac_i32_32x32x32_i8)</a></li><li><a href=#rocdlsmfmaci3232x32x64i8-rocdlsmfmac_i32_32x32x64_i8><code>rocdl.smfmac.i32.32x32x64.i8</code> (ROCDL::smfmac_i32_32x32x64_i8)</a></li><li><a href=#rocdlsqrt-rocdlrocdlsqrt><code>rocdl.sqrt</code> (ROCDL::ROCDLSqrt)</a></li><li><a href=#rocdltanh-rocdlrocdltanh><code>rocdl.tanh</code> (ROCDL::ROCDLTanh)</a></li><li><a href=#rocdltensorloadtolds-rocdltensorloadtoldsop><code>rocdl.tensor.load.to.lds</code> (ROCDL::TensorLoadToLDSOp)</a></li><li><a href=#rocdltensorloadtoldsd2-rocdltensorloadtoldsd2op><code>rocdl.tensor.load.to.lds.d2</code> (ROCDL::TensorLoadToLDSD2Op)</a></li><li><a href=#rocdltensorstorefromlds-rocdltensorstorefromldsop><code>rocdl.tensor.store.from.lds</code> (ROCDL::TensorStoreFromLDSOp)</a></li><li><a href=#rocdltensorstorefromldsd2-rocdltensorstorefromldsd2op><code>rocdl.tensor.store.from.lds.d2</code> (ROCDL::TensorStoreFromLDSD2Op)</a></li><li><a href=#rocdlupdatedpp-rocdldppupdateop><code>rocdl.update.dpp</code> (ROCDL::DPPUpdateOp)</a></li><li><a href=#rocdlwavefrontsize-rocdlwavefrontsizeop><code>rocdl.wavefrontsize</code> (ROCDL::WavefrontSizeOp)</a></li><li><a href=#rocdlwmmabf1616x16x16bf16-rocdlwmma_bf16_16x16x16_bf16><code>rocdl.wmma.bf16.16x16x16.bf16</code> (ROCDL::wmma_bf16_16x16x16_bf16)</a></li><li><a href=#rocdlwmmabf1616x16x32bf16-rocdlwmma_bf16_16x16x32_bf16><code>rocdl.wmma.bf16.16x16x32.bf16</code> (ROCDL::wmma_bf16_16x16x32_bf16)</a></li><li><a href=#rocdlwmmabf16f3216x16x32bf16-rocdlwmma_bf16f32_16x16x32_bf16><code>rocdl.wmma.bf16f32.16x16x32.bf16</code> (ROCDL::wmma_bf16f32_16x16x32_bf16)</a></li><li><a href=#rocdlwmmaf1616x16x128bf8_bf8-rocdlwmma_f16_16x16x128_bf8_bf8><code>rocdl.wmma.f16.16x16x128.bf8_bf8</code> (ROCDL::wmma_f16_16x16x128_bf8_bf8)</a></li><li><a href=#rocdlwmmaf1616x16x128bf8_fp8-rocdlwmma_f16_16x16x128_bf8_fp8><code>rocdl.wmma.f16.16x16x128.bf8_fp8</code> (ROCDL::wmma_f16_16x16x128_bf8_fp8)</a></li><li><a href=#rocdlwmmaf1616x16x128fp8_bf8-rocdlwmma_f16_16x16x128_fp8_bf8><code>rocdl.wmma.f16.16x16x128.fp8_bf8</code> (ROCDL::wmma_f16_16x16x128_fp8_bf8)</a></li><li><a href=#rocdlwmmaf1616x16x128fp8_fp8-rocdlwmma_f16_16x16x128_fp8_fp8><code>rocdl.wmma.f16.16x16x128.fp8_fp8</code> (ROCDL::wmma_f16_16x16x128_fp8_fp8)</a></li><li><a href=#rocdlwmmaf1616x16x16f16-rocdlwmma_f16_16x16x16_f16><code>rocdl.wmma.f16.16x16x16.f16</code> (ROCDL::wmma_f16_16x16x16_f16)</a></li><li><a href=#rocdlwmmaf1616x16x32f16-rocdlwmma_f16_16x16x32_f16><code>rocdl.wmma.f16.16x16x32.f16</code> (ROCDL::wmma_f16_16x16x32_f16)</a></li><li><a href=#rocdlwmmaf1616x16x64bf8_bf8-rocdlwmma_f16_16x16x64_bf8_bf8><code>rocdl.wmma.f16.16x16x64.bf8_bf8</code> (ROCDL::wmma_f16_16x16x64_bf8_bf8)</a></li><li><a href=#rocdlwmmaf1616x16x64bf8_fp8-rocdlwmma_f16_16x16x64_bf8_fp8><code>rocdl.wmma.f16.16x16x64.bf8_fp8</code> (ROCDL::wmma_f16_16x16x64_bf8_fp8)</a></li><li><a href=#rocdlwmmaf1616x16x64fp8_bf8-rocdlwmma_f16_16x16x64_fp8_bf8><code>rocdl.wmma.f16.16x16x64.fp8_bf8</code> (ROCDL::wmma_f16_16x16x64_fp8_bf8)</a></li><li><a href=#rocdlwmmaf1616x16x64fp8_fp8-rocdlwmma_f16_16x16x64_fp8_fp8><code>rocdl.wmma.f16.16x16x64.fp8_fp8</code> (ROCDL::wmma_f16_16x16x64_fp8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x128bf8_bf8-rocdlwmma_f32_16x16x128_bf8_bf8><code>rocdl.wmma.f32.16x16x128.bf8_bf8</code> (ROCDL::wmma_f32_16x16x128_bf8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x128bf8_fp8-rocdlwmma_f32_16x16x128_bf8_fp8><code>rocdl.wmma.f32.16x16x128.bf8_fp8</code> (ROCDL::wmma_f32_16x16x128_bf8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x128fp8_bf8-rocdlwmma_f32_16x16x128_fp8_bf8><code>rocdl.wmma.f32.16x16x128.fp8_bf8</code> (ROCDL::wmma_f32_16x16x128_fp8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x128fp8_fp8-rocdlwmma_f32_16x16x128_fp8_fp8><code>rocdl.wmma.f32.16x16x128.fp8_fp8</code> (ROCDL::wmma_f32_16x16x128_fp8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x16bf16-rocdlwmma_f32_16x16x16_bf16><code>rocdl.wmma.f32.16x16x16.bf16</code> (ROCDL::wmma_f32_16x16x16_bf16)</a></li><li><a href=#rocdlwmmaf3216x16x16bf8_bf8-rocdlwmma_f32_16x16x16_bf8_bf8><code>rocdl.wmma.f32.16x16x16.bf8_bf8</code> (ROCDL::wmma_f32_16x16x16_bf8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x16bf8_fp8-rocdlwmma_f32_16x16x16_bf8_fp8><code>rocdl.wmma.f32.16x16x16.bf8_fp8</code> (ROCDL::wmma_f32_16x16x16_bf8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x16f16-rocdlwmma_f32_16x16x16_f16><code>rocdl.wmma.f32.16x16x16.f16</code> (ROCDL::wmma_f32_16x16x16_f16)</a></li><li><a href=#rocdlwmmaf3216x16x16fp8_bf8-rocdlwmma_f32_16x16x16_fp8_bf8><code>rocdl.wmma.f32.16x16x16.fp8_bf8</code> (ROCDL::wmma_f32_16x16x16_fp8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x16fp8_fp8-rocdlwmma_f32_16x16x16_fp8_fp8><code>rocdl.wmma.f32.16x16x16.fp8_fp8</code> (ROCDL::wmma_f32_16x16x16_fp8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x32bf16-rocdlwmma_f32_16x16x32_bf16><code>rocdl.wmma.f32.16x16x32.bf16</code> (ROCDL::wmma_f32_16x16x32_bf16)</a></li><li><a href=#rocdlwmmaf3216x16x32f16-rocdlwmma_f32_16x16x32_f16><code>rocdl.wmma.f32.16x16x32.f16</code> (ROCDL::wmma_f32_16x16x32_f16)</a></li><li><a href=#rocdlwmmaf3216x16x4f32-rocdlwmma_f32_16x16x4_f32><code>rocdl.wmma.f32.16x16x4.f32</code> (ROCDL::wmma_f32_16x16x4_f32)</a></li><li><a href=#rocdlwmmaf3216x16x64bf8_bf8-rocdlwmma_f32_16x16x64_bf8_bf8><code>rocdl.wmma.f32.16x16x64.bf8_bf8</code> (ROCDL::wmma_f32_16x16x64_bf8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x64bf8_fp8-rocdlwmma_f32_16x16x64_bf8_fp8><code>rocdl.wmma.f32.16x16x64.bf8_fp8</code> (ROCDL::wmma_f32_16x16x64_bf8_fp8)</a></li><li><a href=#rocdlwmmaf3216x16x64fp8_bf8-rocdlwmma_f32_16x16x64_fp8_bf8><code>rocdl.wmma.f32.16x16x64.fp8_bf8</code> (ROCDL::wmma_f32_16x16x64_fp8_bf8)</a></li><li><a href=#rocdlwmmaf3216x16x64fp8_fp8-rocdlwmma_f32_16x16x64_fp8_fp8><code>rocdl.wmma.f32.16x16x64.fp8_fp8</code> (ROCDL::wmma_f32_16x16x64_fp8_fp8)</a></li><li><a href=#rocdlwmmai3216x16x16iu4-rocdlwmma_i32_16x16x16_iu4><code>rocdl.wmma.i32.16x16x16.iu4</code> (ROCDL::wmma_i32_16x16x16_iu4)</a></li><li><a href=#rocdlwmmai3216x16x16iu8-rocdlwmma_i32_16x16x16_iu8><code>rocdl.wmma.i32.16x16x16.iu8</code> (ROCDL::wmma_i32_16x16x16_iu8)</a></li><li><a href=#rocdlwmmai3216x16x32iu4-rocdlwmma_i32_16x16x32_iu4><code>rocdl.wmma.i32.16x16x32.iu4</code> (ROCDL::wmma_i32_16x16x32_iu4)</a></li><li><a href=#rocdlwmmai3216x16x64iu8-rocdlwmma_i32_16x16x64_iu8><code>rocdl.wmma.i32.16x16x64.iu8</code> (ROCDL::wmma_i32_16x16x64_iu8)</a></li><li><a href=#rocdlwmmascalef3216x16x128f8f6f4-rocdlwmma_scale_f32_16x16x128_f8f6f4><code>rocdl.wmma.scale.f32.16x16x128.f8f6f4</code> (ROCDL::wmma_scale_f32_16x16x128_f8f6f4)</a></li><li><a href=#rocdlwmmascalef3232x16x128f4-rocdlwmma_scale_f32_32x16x128_f4><code>rocdl.wmma.scale.f32.32x16x128.f4</code> (ROCDL::wmma_scale_f32_32x16x128_f4)</a></li><li><a href=#rocdlwmmascale16f3216x16x128f8f6f4-rocdlwmma_scale16_f32_16x16x128_f8f6f4><code>rocdl.wmma.scale16.f32.16x16x128.f8f6f4</code> (ROCDL::wmma_scale16_f32_16x16x128_f8f6f4)</a></li><li><a href=#rocdlwmmascale16f3232x16x128f4-rocdlwmma_scale16_f32_32x16x128_f4><code>rocdl.wmma.scale16.f32.32x16x128.f4</code> (ROCDL::wmma_scale16_f32_32x16x128_f4)</a></li><li><a href=#rocdlworkgroupdimx-rocdlblockdimxop><code>rocdl.workgroup.dim.x</code> (ROCDL::BlockDimXOp)</a></li><li><a href=#rocdlworkgroupdimy-rocdlblockdimyop><code>rocdl.workgroup.dim.y</code> (ROCDL::BlockDimYOp)</a></li><li><a href=#rocdlworkgroupdimz-rocdlblockdimzop><code>rocdl.workgroup.dim.z</code> (ROCDL::BlockDimZOp)</a></li><li><a href=#rocdlworkgroupidx-rocdlblockidxop><code>rocdl.workgroup.id.x</code> (ROCDL::BlockIdXOp)</a></li><li><a href=#rocdlworkgroupidy-rocdlblockidyop><code>rocdl.workgroup.id.y</code> (ROCDL::BlockIdYOp)</a></li><li><a href=#rocdlworkgroupidz-rocdlblockidzop><code>rocdl.workgroup.id.z</code> (ROCDL::BlockIdZOp)</a></li><li><a href=#rocdlworkitemidx-rocdlthreadidxop><code>rocdl.workitem.id.x</code> (ROCDL::ThreadIdXOp)</a></li><li><a href=#rocdlworkitemidy-rocdlthreadidyop><code>rocdl.workitem.id.y</code> (ROCDL::ThreadIdYOp)</a></li><li><a href=#rocdlworkitemidz-rocdlthreadidzop><code>rocdl.workitem.id.z</code> (ROCDL::ThreadIdZOp)</a></li></ul></li><li><a href=#attributes-165>Attributes</a><ul><li><a href=#rocdltargetattr>ROCDLTargetAttr</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/LLVMIR/ROCDLOps.td>source</a></p><h3 id=rocdlballot-rocdlballotop><code>rocdl.ballot</code> (ROCDL::BallotOp)&nbsp;<a class=headline-hash href=#rocdlballot-rocdlballotop>¶</a></h3><p><em>Vote across thread group</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ballot` $pred attr-dict `:` type($res)
</code></pre><p>Ballot provides a bit mask containing the 1-bit predicate value from each lane.
The nth bit of the result contains the 1 bit contributed by the nth warp lane.</p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>pred</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlbarrier-rocdlbarrierop><code>rocdl.barrier</code> (ROCDL::BarrierOp)&nbsp;<a class=headline-hash href=#rocdlbarrier-rocdlbarrierop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.barrier` attr-dict
</code></pre><h3 id=rocdlclusteridx-rocdlclusteridxop><code>rocdl.cluster.id.x</code> (ROCDL::ClusterIdXOp)&nbsp;<a class=headline-hash href=#rocdlclusteridx-rocdlclusteridxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.id.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlclusteridy-rocdlclusteridyop><code>rocdl.cluster.id.y</code> (ROCDL::ClusterIdYOp)&nbsp;<a class=headline-hash href=#rocdlclusteridy-rocdlclusteridyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.id.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlclusteridz-rocdlclusteridzop><code>rocdl.cluster.id.z</code> (ROCDL::ClusterIdZOp)&nbsp;<a class=headline-hash href=#rocdlclusteridz-rocdlclusteridzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.id.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlclusterloadasynctoldsb128-rocdlclusterloadasynctoldsb128op><code>rocdl.cluster.load.async.to.lds.b128</code> (ROCDL::ClusterLoadAsyncToLDSB128Op)&nbsp;<a class=headline-hash href=#rocdlclusterloadasynctoldsb128-rocdlclusterloadasynctoldsb128op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.load.async.to.lds.b128` $globalPtr `,`  $ldsPtr `,` $offset `,` $cpol `,` $mask
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Broadcasts memory load of 128 bits of data for a cluster of workgroups.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cpol</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlclusterloadasynctoldsb32-rocdlclusterloadasynctoldsb32op><code>rocdl.cluster.load.async.to.lds.b32</code> (ROCDL::ClusterLoadAsyncToLDSB32Op)&nbsp;<a class=headline-hash href=#rocdlclusterloadasynctoldsb32-rocdlclusterloadasynctoldsb32op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.load.async.to.lds.b32` $globalPtr `,`  $ldsPtr `,` $offset `,` $cpol `,` $mask
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Broadcasts memory load of 32 bits of data for a cluster of workgroups.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cpol</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlclusterloadasynctoldsb64-rocdlclusterloadasynctoldsb64op><code>rocdl.cluster.load.async.to.lds.b64</code> (ROCDL::ClusterLoadAsyncToLDSB64Op)&nbsp;<a class=headline-hash href=#rocdlclusterloadasynctoldsb64-rocdlclusterloadasynctoldsb64op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.load.async.to.lds.b64` $globalPtr `,`  $ldsPtr `,` $offset `,` $cpol `,` $mask
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Broadcasts memory load of 64 bits of data for a cluster of workgroups.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cpol</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlclusterloadasynctoldsb8-rocdlclusterloadasynctoldsb8op><code>rocdl.cluster.load.async.to.lds.b8</code> (ROCDL::ClusterLoadAsyncToLDSB8Op)&nbsp;<a class=headline-hash href=#rocdlclusterloadasynctoldsb8-rocdlclusterloadasynctoldsb8op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cluster.load.async.to.lds.b8` $globalPtr `,`  $ldsPtr `,` $offset `,` $cpol `,` $mask
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Broadcasts memory load of 8 bits of data for a cluster of workgroups.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cpol</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlcos-rocdlrocdlcos><code>rocdl.cos</code> (ROCDL::ROCDLCos)&nbsp;<a class=headline-hash href=#rocdlcos-rocdlrocdlcos>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cos` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlcvtf32bf8-rocdlcvtf32bf8op><code>rocdl.cvt.f32.bf8</code> (ROCDL::CvtF32Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtf32bf8-rocdlcvtf32bf8op>¶</a></h3><p><em>Convert bf8 to f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.f32.bf8` attr-dict $srcA `[` $byteSel `]` `:` type($res)
</code></pre><p>Convert 8-bit bf8 value from the <code>byteSel</code>th bit of <code>srcA</code> to fp32.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>byteSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtf32fp8-rocdlcvtf32fp8op><code>rocdl.cvt.f32.fp8</code> (ROCDL::CvtF32Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtf32fp8-rocdlcvtf32fp8op>¶</a></h3><p><em>Convert fp8 to f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.f32.fp8` attr-dict $srcA `[` $byteSel `]` `:` type($res)
</code></pre><p>Convert 8-bit fp8 value from the <code>byteSel</code>th bit of <code>srcA</code> to fp32.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>byteSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtpkbf8f32-rocdlcvtpkbf8f32op><code>rocdl.cvt.pk.bf8.f32</code> (ROCDL::CvtPkBf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtpkbf8f32-rocdlcvtpkbf8f32op>¶</a></h3><p><em>Convert two f32&rsquo;s to bf8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.pk.bf8.f32` attr-dict $srcA `,` $srcB `-&gt;` $old `[` $wordSel `]` `:` type($res)
</code></pre><p>Convert <code>srcA</code> and <code>srcB</code> to bf8 and store into the low/high word of
<code>old</code>, preserving the other word.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>wordSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>srcB</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtpkf32bf8-rocdlcvtpkf32bf8op><code>rocdl.cvt.pk.f32.bf8</code> (ROCDL::CvtPkF32Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtpkf32bf8-rocdlcvtpkf32bf8op>¶</a></h3><p><em>Convert packed bf8 to packed f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.pk.f32.bf8` attr-dict $src `[` $wordSel `]` `:` type($res)
</code></pre><p>Convert <code>src</code> based on $wordSel to packed fp32,</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>wordSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtpkf32fp8-rocdlcvtpkf32fp8op><code>rocdl.cvt.pk.f32.fp8</code> (ROCDL::CvtPkF32Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtpkf32fp8-rocdlcvtpkf32fp8op>¶</a></h3><p><em>Convert packed fp8 to packed f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.pk.f32.fp8` attr-dict $src `[` $wordSel `]` `:` type($res)
</code></pre><p>Convert <code>src</code> based on $wordSel to packed fp32.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>wordSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtpkfp8f32-rocdlcvtpkfp8f32op><code>rocdl.cvt.pk.fp8.f32</code> (ROCDL::CvtPkFp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtpkfp8f32-rocdlcvtpkfp8f32op>¶</a></h3><p><em>Convert two f32&rsquo;s to fp8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.pk.fp8.f32` attr-dict $srcA `,` $srcB `-&gt;` $old `[` $wordSel `]` `:` type($res)
</code></pre><p>Convert <code>srcA</code> and <code>srcB</code> to fp8 and store into the low/high word of
<code>old</code>, preserving the other word.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>wordSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>srcB</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtpkrtz-rocdlcvtpkrtz><code>rocdl.cvt.pkrtz</code> (ROCDL::CvtPkRtz)&nbsp;<a class=headline-hash href=#rocdlcvtpkrtz-rocdlcvtpkrtz>¶</a></h3><p><em>Convert two f32 input into a vector&lt;2xf16></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.pkrtz` attr-dict $srcA `,` $srcB `:` type($res)
</code></pre><p>Convert two f32 values into a packed vector&lt;2xf16>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>srcB</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtscalepk16bf16bf6-rocdlcvtpkscalepk16bf16bf6op><code>rocdl.cvt.scale.pk16.bf16.bf6</code> (ROCDL::CvtPkScalePk16Bf16Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16bf16bf6-rocdlcvtpkscalepk16bf16bf6op>¶</a></h3><p><em>Scales 16 bf6 and converts them to 16 bf16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.bf16.bf6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk16bf16fp6-rocdlcvtpkscalepk16bf16fp6op><code>rocdl.cvt.scale.pk16.bf16.fp6</code> (ROCDL::CvtPkScalePk16Bf16Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16bf16fp6-rocdlcvtpkscalepk16bf16fp6op>¶</a></h3><p><em>Scales 16 fp6 and converts them to 16 bf16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.bf16.fp6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk16f16bf6-rocdlcvtpkscalepk16f16bf6op><code>rocdl.cvt.scale.pk16.f16.bf6</code> (ROCDL::CvtPkScalePk16F16Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16f16bf6-rocdlcvtpkscalepk16f16bf6op>¶</a></h3><p><em>Scales 16 bf6 and converts them to 16 f16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.f16.bf6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk16f16fp6-rocdlcvtpkscalepk16f16fp6op><code>rocdl.cvt.scale.pk16.f16.fp6</code> (ROCDL::CvtPkScalePk16F16Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16f16fp6-rocdlcvtpkscalepk16f16fp6op>¶</a></h3><p><em>Scales 16 fp6 and converts them to 16 f16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.f16.fp6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk16f32bf6-rocdlcvtpkscalepk16f32bf6op><code>rocdl.cvt.scale.pk16.f32.bf6</code> (ROCDL::CvtPkScalePk16F32Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16f32bf6-rocdlcvtpkscalepk16f32bf6op>¶</a></h3><p><em>Scales 16 bf6 and converts them to 16 f32.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.f32.bf6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk16f32fp6-rocdlcvtpkscalepk16f32fp6op><code>rocdl.cvt.scale.pk16.f32.fp6</code> (ROCDL::CvtPkScalePk16F32Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk16f32fp6-rocdlcvtpkscalepk16f32fp6op>¶</a></h3><p><em>Scales 16 fp6 and converts them to 16 f32.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk16.f32.fp6` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr></tbody></table><h3 id=rocdlcvtscalepk8bf16bf8-rocdlcvtpkscalepk8bf16bf8op><code>rocdl.cvt.scale.pk8.bf16.bf8</code> (ROCDL::CvtPkScalePk8Bf16Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8bf16bf8-rocdlcvtpkscalepk8bf16bf8op>¶</a></h3><p><em>Scales 8 bf8 and converts them to 8 bf16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.bf16.bf8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8bf16fp4-rocdlcvtpkscalepk8bf16fp4op><code>rocdl.cvt.scale.pk8.bf16.fp4</code> (ROCDL::CvtPkScalePk8Bf16Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8bf16fp4-rocdlcvtpkscalepk8bf16fp4op>¶</a></h3><p><em>Scales 8 fp4 and converts them to 8 bf16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.bf16.fp4` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8bf16fp8-rocdlcvtpkscalepk8bf16fp8op><code>rocdl.cvt.scale.pk8.bf16.fp8</code> (ROCDL::CvtPkScalePk8Bf16Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8bf16fp8-rocdlcvtpkscalepk8bf16fp8op>¶</a></h3><p><em>Scales 8 fp8 and converts them to 8 bf16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.bf16.fp8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f16bf8-rocdlcvtpkscalepk8f16bf8op><code>rocdl.cvt.scale.pk8.f16.bf8</code> (ROCDL::CvtPkScalePk8F16Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f16bf8-rocdlcvtpkscalepk8f16bf8op>¶</a></h3><p><em>Scales 8 bf8 and converts them to 8 f16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f16.bf8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f16fp4-rocdlcvtpkscalepk8f16fp4op><code>rocdl.cvt.scale.pk8.f16.fp4</code> (ROCDL::CvtPkScalePk8F16Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f16fp4-rocdlcvtpkscalepk8f16fp4op>¶</a></h3><p><em>Scales 8 fp4 and converts them to 8 f16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f16.fp4` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f16fp8-rocdlcvtpkscalepk8f16fp8op><code>rocdl.cvt.scale.pk8.f16.fp8</code> (ROCDL::CvtPkScalePk8F16Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f16fp8-rocdlcvtpkscalepk8f16fp8op>¶</a></h3><p><em>Scales 8 fp8 and converts them to 8 f16.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f16.fp8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f32bf8-rocdlcvtpkscalepk8f32bf8op><code>rocdl.cvt.scale.pk8.f32.bf8</code> (ROCDL::CvtPkScalePk8F32Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f32bf8-rocdlcvtpkscalepk8f32bf8op>¶</a></h3><p><em>Scales 8 bf8 and converts them to 8 f32.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f32.bf8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f32fp4-rocdlcvtpkscalepk8f32fp4op><code>rocdl.cvt.scale.pk8.f32.fp4</code> (ROCDL::CvtPkScalePk8F32Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f32fp4-rocdlcvtpkscalepk8f32fp4op>¶</a></h3><p><em>Scales 8 fp4 and converts them to 8 f32.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f32.fp4` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalepk8f32fp8-rocdlcvtpkscalepk8f32fp8op><code>rocdl.cvt.scale.pk8.f32.fp8</code> (ROCDL::CvtPkScalePk8F32Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalepk8f32fp8-rocdlcvtpkscalepk8f32fp8op>¶</a></h3><p><em>Scales 8 fp8 and converts them to 8 f32.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scale.pk8.f32.fp8` attr-dict $src `,` $scale `[` $scaleSel `]` `:` type($res)
</code></pre><p>Available on gfx1250+.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scaleSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr></tbody></table><h3 id=rocdlcvtscalef322xpk16bf6f32-rocdlcvtscalef322xpk16bf6f32op><code>rocdl.cvt.scalef32.2xpk16.bf6.f32</code> (ROCDL::CvtScaleF322xPk16Bf6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef322xpk16bf6f32-rocdlcvtscalef322xpk16bf6f32op>¶</a></h3><p><em>Scale and convert two vector&lt;16xf32> to 32 packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.2xpk16.bf6.f32` attr-dict $src0 `,` $src1 `,` $scale `:` type($res)
</code></pre><p>Convert 32 single-precision float values, packed into two length-16
vectors that will be logically concanenated, to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>src1</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef322xpk16fp6f32-rocdlcvtscalef322xpk16fp6f32op><code>rocdl.cvt.scalef32.2xpk16.fp6.f32</code> (ROCDL::CvtScaleF322xPk16Fp6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef322xpk16fp6f32-rocdlcvtscalef322xpk16fp6f32op>¶</a></h3><p><em>Scale and convert two vector&lt;16xf32> to 32 packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.2xpk16.fp6.f32` attr-dict $src0 `,` $src1 `,` $scale `:` type($res)
</code></pre><p>Convert 32 single-precision float values, packed into two length-16
vectors that will be logically concanenated, to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>src1</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32f16bf8-rocdlcvtscalef32f16bf8op><code>rocdl.cvt.scalef32.f16.bf8</code> (ROCDL::CvtScaleF32F16Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32f16bf8-rocdlcvtscalef32f16bf8op>¶</a></h3><p><em>Scaled convert bf8 from packed vector to f16, updating tied result</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.f16.bf8` attr-dict $src `[` $srcSelIndex `]` `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert a bf8 byte from <code>src</code>, selected by
<code>srcSelIndex</code>, to f16 while multiplying it by the expontent of <code>scale</code>,
and place it into the <code>dstLoHiSel</code>th bit
of <code>oldVdst</code> preserving the other element of that vector in
the return value.</p><p>The bytes are stored as an <code>i32</code> and not a <code>&lt;4 x i8></code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32f16fp8-rocdlcvtscalef32f16fp8op><code>rocdl.cvt.scalef32.f16.fp8</code> (ROCDL::CvtScaleF32F16Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32f16fp8-rocdlcvtscalef32f16fp8op>¶</a></h3><p><em>Scaled convert fp8 from packed vector to f16, updating tied result</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.f16.fp8` attr-dict $src `[` $srcSelIndex `]` `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert a fp8 byte from <code>src</code>, selected by
<code>srcSelIndex</code>, to f16 while multiplying it by the expontent of <code>scale</code>,
and place it into the <code>dstLoHiSel</code>th bit
of <code>oldVdst</code> preserving the other element of that vector in
the return value.</p><p>The bytes are stored as an <code>i32</code> and not a <code>&lt;4 x i8></code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32f32bf8-rocdlcvtscalef32f32bf8op><code>rocdl.cvt.scalef32.f32.bf8</code> (ROCDL::CvtScaleF32F32Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32f32bf8-rocdlcvtscalef32f32bf8op>¶</a></h3><p><em>Scaled convert bf8 from packed vector to f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.f32.bf8` attr-dict $src `[` $srcSelIndex `]` `,` $scale `:` type($res)
</code></pre><p>Convert a bf8 byte from <code>src</code>, selected by
<code>srcSelIndex</code>, to f32, multiplying it by the exponent of <code>scale</code>.</p><p>The bytes are stored in an <code>i32</code>, not a <code>&lt;4 x i8></code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float</td></tr></tbody></table><h3 id=rocdlcvtscalef32f32fp8-rocdlcvtscalef32f32fp8op><code>rocdl.cvt.scalef32.f32.fp8</code> (ROCDL::CvtScaleF32F32Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32f32fp8-rocdlcvtscalef32f32fp8op>¶</a></h3><p><em>Scaled convert fp8 from packed vector to f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.f32.fp8` attr-dict $src `[` $srcSelIndex `]` `,` $scale `:` type($res)
</code></pre><p>Convert a fp8 byte from <code>src</code>, selected by
<code>srcSelIndex</code>, to f32, multiplying it by the exponent of <code>scale</code>.</p><p>The bytes are stored in an <code>i32</code>, not a <code>&lt;4 x i8></code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf16bf8-rocdlcvtscalef32pkbf16bf8op><code>rocdl.cvt.scalef32.pk.bf16.bf8</code> (ROCDL::CvtScaleF32PkBf16Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf16bf8-rocdlcvtscalef32pkbf16bf8op>¶</a></h3><p><em>Scaled convert two bf8to two bf16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf16.bf8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed bf8 values in <code>src0</code> to two bf16 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf16fp4-rocdlcvtscalef32pkbf16fp4op><code>rocdl.cvt.scalef32.pk.bf16.fp4</code> (ROCDL::CvtScaleF32PkBf16Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf16fp4-rocdlcvtscalef32pkbf16fp4op>¶</a></h3><p><em>Scale and convert two packed fp4 to packed bf16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf16.fp4` attr-dict $src `[` $srcSelIndex `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp4 (f4E2M1) values stored as one byte of a 32-bit integer
to packed bf16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>The byte to convert is chosen by <code>srcSelIndex</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf16fp8-rocdlcvtscalef32pkbf16fp8op><code>rocdl.cvt.scalef32.pk.bf16.fp8</code> (ROCDL::CvtScaleF32PkBf16Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf16fp8-rocdlcvtscalef32pkbf16fp8op>¶</a></h3><p><em>Scaled convert two fp8to two bf16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf16.fp8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp8 values in <code>src0</code> to two bf16 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf8bf16-rocdlcvtscalef32pkbf8bf16op><code>rocdl.cvt.scalef32.pk.bf8.bf16</code> (ROCDL::CvtScaleF32PkBf8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf8bf16-rocdlcvtscalef32pkbf8bf16op>¶</a></h3><p><em>Scaled convert two bf16to two bf8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf8.bf16` attr-dict $src0 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two bf16 values in <code>src0</code> to two bf8 bytes, dividing by the exponent in <code>scale</code>. The bytes are
packed into a 16-bit value which is inserted into <code>oldVdst</code> at the
<code>dstLoHiSel</code> position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf8f16-rocdlcvtscalef32pkbf8f16op><code>rocdl.cvt.scalef32.pk.bf8.f16</code> (ROCDL::CvtScaleF32PkBf8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf8f16-rocdlcvtscalef32pkbf8f16op>¶</a></h3><p><em>Scaled convert two f16to two bf8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf8.f16` attr-dict $src0 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two f16 values in <code>src0</code> to two bf8 bytes, dividing by the exponent in <code>scale</code>. The bytes are
packed into a 16-bit value which is inserted into <code>oldVdst</code> at the
<code>dstLoHiSel</code> position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkbf8f32-rocdlcvtscalef32pkbf8f32op><code>rocdl.cvt.scalef32.pk.bf8.f32</code> (ROCDL::CvtScaleF32PkBf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkbf8f32-rocdlcvtscalef32pkbf8f32op>¶</a></h3><p><em>Scaled convert two f32 to two bf8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.bf8.f32` attr-dict  $src0 `,` $src1 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two f32 values in <code>src0</code> and <code>src1</code> to two bf8 bytes,
dividing by the exponent in <code>scale</code>. The bytes are packed into
a 16-bit value which is inserted into <code>oldVdst</code> at the <code>dstLoHiSel</code>
position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>src1</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf16bf8-rocdlcvtscalef32pkf16bf8op><code>rocdl.cvt.scalef32.pk.f16.bf8</code> (ROCDL::CvtScaleF32PkF16Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf16bf8-rocdlcvtscalef32pkf16bf8op>¶</a></h3><p><em>Scaled convert two bf8to two f16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f16.bf8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed bf8 values in <code>src0</code> to two f16 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf16fp4-rocdlcvtscalef32pkf16fp4op><code>rocdl.cvt.scalef32.pk.f16.fp4</code> (ROCDL::CvtScaleF32PkF16Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf16fp4-rocdlcvtscalef32pkf16fp4op>¶</a></h3><p><em>Scale and convert two packed fp4 to packed f16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f16.fp4` attr-dict $src `[` $srcSelIndex `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp4 (f4E2M1) values stored as one byte of a 32-bit integer
to packed f16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>The byte to convert is chosen by <code>srcSelIndex</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf16fp8-rocdlcvtscalef32pkf16fp8op><code>rocdl.cvt.scalef32.pk.f16.fp8</code> (ROCDL::CvtScaleF32PkF16Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf16fp8-rocdlcvtscalef32pkf16fp8op>¶</a></h3><p><em>Scaled convert two fp8to two f16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f16.fp8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp8 values in <code>src0</code> to two f16 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-40>Attributes:&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf32bf8-rocdlcvtscalef32pkf32bf8op><code>rocdl.cvt.scalef32.pk.f32.bf8</code> (ROCDL::CvtScaleF32PkF32Bf8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf32bf8-rocdlcvtscalef32pkf32bf8op>¶</a></h3><p><em>Scaled convert two bf8to two f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f32.bf8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed bf8 values in <code>src0</code> to two f32 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-41>Attributes:&nbsp;<a class=headline-hash href=#attributes-41>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf32fp4-rocdlcvtscalef32pkf32fp4op><code>rocdl.cvt.scalef32.pk.f32.fp4</code> (ROCDL::CvtScaleF32PkF32Fp4Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf32fp4-rocdlcvtscalef32pkf32fp4op>¶</a></h3><p><em>Scale and convert two packed fp4 to packed f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f32.fp4` attr-dict $src `[` $srcSelIndex `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp4 (f4E2M1) values stored as one byte of a 32-bit integer
to packed f32, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>The byte to convert is chosen by <code>srcSelIndex</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-42>Attributes:&nbsp;<a class=headline-hash href=#attributes-42>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkf32fp8-rocdlcvtscalef32pkf32fp8op><code>rocdl.cvt.scalef32.pk.f32.fp8</code> (ROCDL::CvtScaleF32PkF32Fp8Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkf32fp8-rocdlcvtscalef32pkf32fp8op>¶</a></h3><p><em>Scaled convert two fp8to two f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.f32.fp8` attr-dict $src `[` $srcLoHiSel `]` `,` $scale `:` type($res)
</code></pre><p>Convert two packed fp8 values in <code>src0</code> to two f32 values, multiplying by the exponent in <code>scale</code>.
The two values to be converted are selected from the low or high half
of <code>src</code> (a packed vector represented as an <code>i32</code>)
on the basis of <code>srcLoHiSel</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-43>Attributes:&nbsp;<a class=headline-hash href=#attributes-43>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>srcLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp4bf16-rocdlcvtscalef32pkfp4bf16op><code>rocdl.cvt.scalef32.pk.fp4.bf16</code> (ROCDL::CvtScaleF32PkFp4Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp4bf16-rocdlcvtscalef32pkfp4bf16op>¶</a></h3><p><em>Scale and convert two bf16 to packed fp4, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp4.bf16` attr-dict $src `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two packed bf16 values to packed
fp4, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>The two scaled values are packed into a byte.
That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-44>Attributes:&nbsp;<a class=headline-hash href=#attributes-44>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp4f16-rocdlcvtscalef32pkfp4f16op><code>rocdl.cvt.scalef32.pk.fp4.f16</code> (ROCDL::CvtScaleF32PkFp4F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp4f16-rocdlcvtscalef32pkfp4f16op>¶</a></h3><p><em>Scale and convert two f16 to packed fp4, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp4.f16` attr-dict $src `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two packed f16 values to packed
fp4, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>The two scaled values are packed into a byte.
That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-45>Attributes:&nbsp;<a class=headline-hash href=#attributes-45>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp4f32-rocdlcvtscalef32pkfp4f32op><code>rocdl.cvt.scalef32.pk.fp4.f32</code> (ROCDL::CvtScaleF32PkFp4F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp4f32-rocdlcvtscalef32pkfp4f32op>¶</a></h3><p><em>Scale and convert two f32 values to two packed fp4, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp4.f32` attr-dict $src0 `,` $src1 `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two single-precision float values, passed in <code>src0</code> and <code>src1</code>
into two fp4 values, dividing them by the expontent part of <code>scale</code>
before doing so.</p><p>The two scaled values are packed into a byte.
That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-46>Attributes:&nbsp;<a class=headline-hash href=#attributes-46>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>src1</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp8bf16-rocdlcvtscalef32pkfp8bf16op><code>rocdl.cvt.scalef32.pk.fp8.bf16</code> (ROCDL::CvtScaleF32PkFp8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp8bf16-rocdlcvtscalef32pkfp8bf16op>¶</a></h3><p><em>Scaled convert two bf16to two fp8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp8.bf16` attr-dict $src0 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two bf16 values in <code>src0</code> to two fp8 bytes, dividing by the exponent in <code>scale</code>. The bytes are
packed into a 16-bit value which is inserted into <code>oldVdst</code> at the
<code>dstLoHiSel</code> position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-47>Attributes:&nbsp;<a class=headline-hash href=#attributes-47>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp8f16-rocdlcvtscalef32pkfp8f16op><code>rocdl.cvt.scalef32.pk.fp8.f16</code> (ROCDL::CvtScaleF32PkFp8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp8f16-rocdlcvtscalef32pkfp8f16op>¶</a></h3><p><em>Scaled convert two f16to two fp8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp8.f16` attr-dict $src0 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two f16 values in <code>src0</code> to two fp8 bytes, dividing by the exponent in <code>scale</code>. The bytes are
packed into a 16-bit value which is inserted into <code>oldVdst</code> at the
<code>dstLoHiSel</code> position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-48>Attributes:&nbsp;<a class=headline-hash href=#attributes-48>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pkfp8f32-rocdlcvtscalef32pkfp8f32op><code>rocdl.cvt.scalef32.pk.fp8.f32</code> (ROCDL::CvtScaleF32PkFp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pkfp8f32-rocdlcvtscalef32pkfp8f32op>¶</a></h3><p><em>Scaled convert two f32 to two fp8, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk.fp8.f32` attr-dict  $src0 `,` $src1 `,` $scale `-&gt;` $oldVdst `[` $dstLoHiSel `]` `:` type($res)
</code></pre><p>Convert two f32 values in <code>src0</code> and <code>src1</code> to two fp8 bytes,
dividing by the exponent in <code>scale</code>. The bytes are packed into
a 16-bit value which is inserted into <code>oldVdst</code> at the <code>dstLoHiSel</code>
position, with the entire updated vector being returned.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-49>Attributes:&nbsp;<a class=headline-hash href=#attributes-49>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstLoHiSel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr><tr><td style=text-align:center><code>src0</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>src1</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16bf6bf16-rocdlcvtscalef32pk16bf6bf16op><code>rocdl.cvt.scalef32.pk16.bf6.bf16</code> (ROCDL::CvtScaleF32Pk16Bf6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16bf6bf16-rocdlcvtscalef32pk16bf6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.bf6.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16bf6f16-rocdlcvtscalef32pk16bf6f16op><code>rocdl.cvt.scalef32.pk16.bf6.f16</code> (ROCDL::CvtScaleF32Pk16Bf6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16bf6f16-rocdlcvtscalef32pk16bf6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.bf6.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16bf6f32-rocdlcvtscalef32pk16bf6f32op><code>rocdl.cvt.scalef32.pk16.bf6.f32</code> (ROCDL::CvtScaleF32Pk16Bf6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16bf6f32-rocdlcvtscalef32pk16bf6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.bf6.f32` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16fp6bf16-rocdlcvtscalef32pk16fp6bf16op><code>rocdl.cvt.scalef32.pk16.fp6.bf16</code> (ROCDL::CvtScaleF32Pk16Fp6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16fp6bf16-rocdlcvtscalef32pk16fp6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.fp6.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16fp6f16-rocdlcvtscalef32pk16fp6f16op><code>rocdl.cvt.scalef32.pk16.fp6.f16</code> (ROCDL::CvtScaleF32Pk16Fp6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16fp6f16-rocdlcvtscalef32pk16fp6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.fp6.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk16fp6f32-rocdlcvtscalef32pk16fp6f32op><code>rocdl.cvt.scalef32.pk16.fp6.f32</code> (ROCDL::CvtScaleF32Pk16Fp6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk16fp6f32-rocdlcvtscalef32pk16fp6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk16.fp6.f32` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32bf16bf6-rocdlcvtscalef32pk32bf16bf6op><code>rocdl.cvt.scalef32.pk32.bf16.bf6</code> (ROCDL::CvtScaleF32Pk32Bf16Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32bf16bf6-rocdlcvtscalef32pk32bf16bf6op>¶</a></h3><p><em>Scale and convert packed bf6 to packed bf16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.bf16.bf6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf6 values to packed bf16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32bf16fp6-rocdlcvtscalef32pk32bf16fp6op><code>rocdl.cvt.scalef32.pk32.bf16.fp6</code> (ROCDL::CvtScaleF32Pk32Bf16Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32bf16fp6-rocdlcvtscalef32pk32bf16fp6op>¶</a></h3><p><em>Scale and convert packed fp6 to packed bf16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.bf16.fp6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed fp6 values to packed bf16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32bf6bf16-rocdlcvtscalef32pk32bf6bf16op><code>rocdl.cvt.scalef32.pk32.bf6.bf16</code> (ROCDL::CvtScaleF32Pk32Bf6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32bf6bf16-rocdlcvtscalef32pk32bf6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.bf6.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32bf6f16-rocdlcvtscalef32pk32bf6f16op><code>rocdl.cvt.scalef32.pk32.bf6.f16</code> (ROCDL::CvtScaleF32Pk32Bf6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32bf6f16-rocdlcvtscalef32pk32bf6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.bf6.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f16 values to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32f16bf6-rocdlcvtscalef32pk32f16bf6op><code>rocdl.cvt.scalef32.pk32.f16.bf6</code> (ROCDL::CvtScaleF32Pk32F16Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32f16bf6-rocdlcvtscalef32pk32f16bf6op>¶</a></h3><p><em>Scale and convert packed bf6 to packed f16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.f16.bf6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf6 values to packed f16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32f16fp6-rocdlcvtscalef32pk32f16fp6op><code>rocdl.cvt.scalef32.pk32.f16.fp6</code> (ROCDL::CvtScaleF32Pk32F16Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32f16fp6-rocdlcvtscalef32pk32f16fp6op>¶</a></h3><p><em>Scale and convert packed fp6 to packed f16</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.f16.fp6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed fp6 values to packed f16, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32f32bf6-rocdlcvtscalef32pk32f32bf6op><code>rocdl.cvt.scalef32.pk32.f32.bf6</code> (ROCDL::CvtScaleF32Pk32F32Bf6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32f32bf6-rocdlcvtscalef32pk32f32bf6op>¶</a></h3><p><em>Scale and convert packed bf6 to packed f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.f32.bf6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf6 values to packed f32, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32f32fp6-rocdlcvtscalef32pk32f32fp6op><code>rocdl.cvt.scalef32.pk32.f32.fp6</code> (ROCDL::CvtScaleF32Pk32F32Fp6Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32f32fp6-rocdlcvtscalef32pk32f32fp6op>¶</a></h3><p><em>Scale and convert packed fp6 to packed f32</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.f32.fp6` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed fp6 values to packed f32, multiplying by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit float values of length 32</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32fp6bf16-rocdlcvtscalef32pk32fp6bf16op><code>rocdl.cvt.scalef32.pk32.fp6.bf16</code> (ROCDL::CvtScaleF32Pk32Fp6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32fp6bf16-rocdlcvtscalef32pk32fp6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.fp6.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk32fp6f16-rocdlcvtscalef32pk32fp6f16op><code>rocdl.cvt.scalef32.pk32.fp6.f16</code> (ROCDL::CvtScaleF32Pk32Fp6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk32fp6f16-rocdlcvtscalef32pk32fp6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp6</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk32.fp6.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f16 values to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8bf8bf16-rocdlcvtscalef32pk8bf8bf16op><code>rocdl.cvt.scalef32.pk8.bf8.bf16</code> (ROCDL::CvtScaleF32Pk8Bf8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8bf8bf16-rocdlcvtscalef32pk8bf8bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.bf8.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8bf8f16-rocdlcvtscalef32pk8bf8f16op><code>rocdl.cvt.scalef32.pk8.bf8.f16</code> (ROCDL::CvtScaleF32Pk8Bf8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8bf8f16-rocdlcvtscalef32pk8bf8f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.bf8.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-69>Operands:&nbsp;<a class=headline-hash href=#operands-69>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8bf8f32-rocdlcvtscalef32pk8bf8f32op><code>rocdl.cvt.scalef32.pk8.bf8.f32</code> (ROCDL::CvtScaleF32Pk8Bf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8bf8f32-rocdlcvtscalef32pk8bf8f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed bf8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.bf8.f32` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-70>Operands:&nbsp;<a class=headline-hash href=#operands-70>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp4bf16-rocdlcvtscalef32pk8fp4bf16op><code>rocdl.cvt.scalef32.pk8.fp4.bf16</code> (ROCDL::CvtScaleF32Pk8Fp4Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp4bf16-rocdlcvtscalef32pk8fp4bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp4</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp4.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-71>Operands:&nbsp;<a class=headline-hash href=#operands-71>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp4f16-rocdlcvtscalef32pk8fp4f16op><code>rocdl.cvt.scalef32.pk8.fp4.f16</code> (ROCDL::CvtScaleF32Pk8Fp4F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp4f16-rocdlcvtscalef32pk8fp4f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp4</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp4.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-72>Operands:&nbsp;<a class=headline-hash href=#operands-72>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp4f32-rocdlcvtscalef32pk8fp4f32op><code>rocdl.cvt.scalef32.pk8.fp4.f32</code> (ROCDL::CvtScaleF32Pk8Fp4F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp4f32-rocdlcvtscalef32pk8fp4f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp4</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp4.f32` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-73>Operands:&nbsp;<a class=headline-hash href=#operands-73>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp8bf16-rocdlcvtscalef32pk8fp8bf16op><code>rocdl.cvt.scalef32.pk8.fp8.bf16</code> (ROCDL::CvtScaleF32Pk8Fp8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp8bf16-rocdlcvtscalef32pk8fp8bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp8.bf16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-74>Operands:&nbsp;<a class=headline-hash href=#operands-74>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp8f16-rocdlcvtscalef32pk8fp8f16op><code>rocdl.cvt.scalef32.pk8.fp8.f16</code> (ROCDL::CvtScaleF32Pk8Fp8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp8f16-rocdlcvtscalef32pk8fp8f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp8.f16` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-75>Operands:&nbsp;<a class=headline-hash href=#operands-75>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32pk8fp8f32-rocdlcvtscalef32pk8fp8f32op><code>rocdl.cvt.scalef32.pk8.fp8.f32</code> (ROCDL::CvtScaleF32Pk8Fp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32pk8fp8f32-rocdlcvtscalef32pk8fp8f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp8</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.pk8.fp8.f32` attr-dict $src `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-76>Operands:&nbsp;<a class=headline-hash href=#operands-76>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srbf8bf16-rocdlcvtscalef32srbf8bf16op><code>rocdl.cvt.scalef32.sr.bf8.bf16</code> (ROCDL::CvtScaleF32SrBf8BF16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srbf8bf16-rocdlcvtscalef32srbf8bf16op>¶</a></h3><p><em>Scaled convert bf16to bf8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.bf8.bf16` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a bf16 value in <code>src0</code> to a bf8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-50>Attributes:&nbsp;<a class=headline-hash href=#attributes-50>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-77>Operands:&nbsp;<a class=headline-hash href=#operands-77>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>bfloat16 type</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srbf8f16-rocdlcvtscalef32srbf8f16op><code>rocdl.cvt.scalef32.sr.bf8.f16</code> (ROCDL::CvtScaleF32SrBf8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srbf8f16-rocdlcvtscalef32srbf8f16op>¶</a></h3><p><em>Scaled convert f16to bf8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.bf8.f16` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a f16 value in <code>src0</code> to a bf8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-51>Attributes:&nbsp;<a class=headline-hash href=#attributes-51>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-78>Operands:&nbsp;<a class=headline-hash href=#operands-78>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>16-bit float</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-77>Results:&nbsp;<a class=headline-hash href=#results-77>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srbf8f32-rocdlcvtscalef32srbf8f32op><code>rocdl.cvt.scalef32.sr.bf8.f32</code> (ROCDL::CvtScaleF32SrBf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srbf8f32-rocdlcvtscalef32srbf8f32op>¶</a></h3><p><em>Scaled convert f32to bf8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.bf8.f32` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a f32 value in <code>src0</code> to a bf8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-52>Attributes:&nbsp;<a class=headline-hash href=#attributes-52>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-79>Operands:&nbsp;<a class=headline-hash href=#operands-79>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-78>Results:&nbsp;<a class=headline-hash href=#results-78>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srfp8bf16-rocdlcvtscalef32srfp8bf16op><code>rocdl.cvt.scalef32.sr.fp8.bf16</code> (ROCDL::CvtScaleF32SrFp8BF16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srfp8bf16-rocdlcvtscalef32srfp8bf16op>¶</a></h3><p><em>Scaled convert bf16to fp8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.fp8.bf16` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a bf16 value in <code>src0</code> to a fp8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-53>Attributes:&nbsp;<a class=headline-hash href=#attributes-53>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-80>Operands:&nbsp;<a class=headline-hash href=#operands-80>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>bfloat16 type</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-79>Results:&nbsp;<a class=headline-hash href=#results-79>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srfp8f16-rocdlcvtscalef32srfp8f16op><code>rocdl.cvt.scalef32.sr.fp8.f16</code> (ROCDL::CvtScaleF32SrFp8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srfp8f16-rocdlcvtscalef32srfp8f16op>¶</a></h3><p><em>Scaled convert f16to fp8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.fp8.f16` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a f16 value in <code>src0</code> to a fp8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-54>Attributes:&nbsp;<a class=headline-hash href=#attributes-54>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-81>Operands:&nbsp;<a class=headline-hash href=#operands-81>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>16-bit float</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-80>Results:&nbsp;<a class=headline-hash href=#results-80>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srfp8f32-rocdlcvtscalef32srfp8f32op><code>rocdl.cvt.scalef32.sr.fp8.f32</code> (ROCDL::CvtScaleF32SrFp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srfp8f32-rocdlcvtscalef32srfp8f32op>¶</a></h3><p><em>Scaled convert f32to fp8 with stochiastic rounding, updating packed vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.fp8.f32` attr-dict $src0 `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert a f32 value in <code>src0</code> to a fp8 bytes, dividing by the exponent in <code>scale</code> and using <code>seed</code>
for stochiastic rounding. Place the resulting byte in the
<code>dstSelIndex</code>th bit of <code>oldVdst</code> and return the entire packed vector,
which is stored as an <code>i32</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-55>Attributes:&nbsp;<a class=headline-hash href=#attributes-55>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-82>Operands:&nbsp;<a class=headline-hash href=#operands-82>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src0</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-81>Results:&nbsp;<a class=headline-hash href=#results-81>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpkfp4bf16-rocdlcvtscalef32srpkfp4bf16op><code>rocdl.cvt.scalef32.sr.pk.fp4.bf16</code> (ROCDL::CvtScaleF32SrPkFp4Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpkfp4bf16-rocdlcvtscalef32srpkfp4bf16op>¶</a></h3><p><em>Scale and convert two bf16 to packed fp4 with stochiastic rounding, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk.fp4.bf16` attr-dict $src `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two packed bf16 values to packed
fp4, dividing by the exponent part of <code>scale</code>
before doing so and using <code>seed</code> as the random seed for
stochiastic rounding.</p><p>The two scaled values are packed (little-endian)
into a byte. That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-56>Attributes:&nbsp;<a class=headline-hash href=#attributes-56>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-83>Operands:&nbsp;<a class=headline-hash href=#operands-83>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 2</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-82>Results:&nbsp;<a class=headline-hash href=#results-82>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpkfp4f16-rocdlcvtscalef32srpkfp4f16op><code>rocdl.cvt.scalef32.sr.pk.fp4.f16</code> (ROCDL::CvtScaleF32SrPkFp4F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpkfp4f16-rocdlcvtscalef32srpkfp4f16op>¶</a></h3><p><em>Scale and convert two f16 to packed fp4 with stochiastic rounding, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk.fp4.f16` attr-dict $src `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two packed f16 values to packed
fp4, dividing by the exponent part of <code>scale</code>
before doing so and using <code>seed</code> as the random seed for
stochiastic rounding.</p><p>The two scaled values are packed (little-endian)
into a byte. That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-57>Attributes:&nbsp;<a class=headline-hash href=#attributes-57>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-84>Operands:&nbsp;<a class=headline-hash href=#operands-84>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 2</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-83>Results:&nbsp;<a class=headline-hash href=#results-83>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpkfp4f32-rocdlcvtscalef32srpkfp4f32op><code>rocdl.cvt.scalef32.sr.pk.fp4.f32</code> (ROCDL::CvtScaleF32SrPkFp4F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpkfp4f32-rocdlcvtscalef32srpkfp4f32op>¶</a></h3><p><em>Scale and convert two f32 to packed fp4 with stochiastic rounding, updating tied vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk.fp4.f32` attr-dict $src `,` $seed `,` $scale `-&gt;` $oldVdst `[` $dstSelIndex `]` `:` type($res)
</code></pre><p>Convert two packed f32 values to packed
fp4, dividing by the exponent part of <code>scale</code>
before doing so and using <code>seed</code> as the random seed for
stochiastic rounding.</p><p>The two scaled values are packed (little-endian)
into a byte. That byte is used to update the <code>dstSelIndex</code>th
byte of <code>oldVdst</code>, which is returned in its entirity.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-58>Attributes:&nbsp;<a class=headline-hash href=#attributes-58>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dstSelIndex</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-85>Operands:&nbsp;<a class=headline-hash href=#operands-85>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>oldVdst</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 2</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-84>Results:&nbsp;<a class=headline-hash href=#results-84>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16bf6bf16-rocdlcvtscalef32srpk16bf6bf16op><code>rocdl.cvt.scalef32.sr.pk16.bf6.bf16</code> (ROCDL::CvtScaleF32SrPk16Bf6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16bf6bf16-rocdlcvtscalef32srpk16bf6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.bf6.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-86>Operands:&nbsp;<a class=headline-hash href=#operands-86>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-85>Results:&nbsp;<a class=headline-hash href=#results-85>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16bf6f16-rocdlcvtscalef32srpk16bf6f16op><code>rocdl.cvt.scalef32.sr.pk16.bf6.f16</code> (ROCDL::CvtScaleF32SrPk16Bf6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16bf6f16-rocdlcvtscalef32srpk16bf6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.bf6.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-87>Operands:&nbsp;<a class=headline-hash href=#operands-87>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-86>Results:&nbsp;<a class=headline-hash href=#results-86>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16bf6f32-rocdlcvtscalef32srpk16bf6f32op><code>rocdl.cvt.scalef32.sr.pk16.bf6.f32</code> (ROCDL::CvtScaleF32SrPk16Bf6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16bf6f32-rocdlcvtscalef32srpk16bf6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed bf6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.bf6.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed bf6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-88>Operands:&nbsp;<a class=headline-hash href=#operands-88>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-87>Results:&nbsp;<a class=headline-hash href=#results-87>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16fp6bf16-rocdlcvtscalef32srpk16fp6bf16op><code>rocdl.cvt.scalef32.sr.pk16.fp6.bf16</code> (ROCDL::CvtScaleF32SrPk16Fp6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16fp6bf16-rocdlcvtscalef32srpk16fp6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.fp6.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-89>Operands:&nbsp;<a class=headline-hash href=#operands-89>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-88>Results:&nbsp;<a class=headline-hash href=#results-88>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16fp6f16-rocdlcvtscalef32srpk16fp6f16op><code>rocdl.cvt.scalef32.sr.pk16.fp6.f16</code> (ROCDL::CvtScaleF32SrPk16Fp6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16fp6f16-rocdlcvtscalef32srpk16fp6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.fp6.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-90>Operands:&nbsp;<a class=headline-hash href=#operands-90>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-89>Results:&nbsp;<a class=headline-hash href=#results-89>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk16fp6f32-rocdlcvtscalef32srpk16fp6f32op><code>rocdl.cvt.scalef32.sr.pk16.fp6.f32</code> (ROCDL::CvtScaleF32SrPk16Fp6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk16fp6f32-rocdlcvtscalef32srpk16fp6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp6 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk16.fp6.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp6, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-91>Operands:&nbsp;<a class=headline-hash href=#operands-91>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 16</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-90>Results:&nbsp;<a class=headline-hash href=#results-90>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 3</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32bf6bf16-rocdlcvtscalef32srpk32bf6bf16op><code>rocdl.cvt.scalef32.sr.pk32.bf6.bf16</code> (ROCDL::CvtScaleF32SrPk32Bf6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32bf6bf16-rocdlcvtscalef32srpk32bf6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.bf6.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf16 values to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-92>Operands:&nbsp;<a class=headline-hash href=#operands-92>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-91>Results:&nbsp;<a class=headline-hash href=#results-91>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32bf6f16-rocdlcvtscalef32srpk32bf6f16op><code>rocdl.cvt.scalef32.sr.pk32.bf6.f16</code> (ROCDL::CvtScaleF32SrPk32Bf6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32bf6f16-rocdlcvtscalef32srpk32bf6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.bf6.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f16 values to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-93>Operands:&nbsp;<a class=headline-hash href=#operands-93>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-92>Results:&nbsp;<a class=headline-hash href=#results-92>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32bf6f32-rocdlcvtscalef32srpk32bf6f32op><code>rocdl.cvt.scalef32.sr.pk32.bf6.f32</code> (ROCDL::CvtScaleF32SrPk32Bf6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32bf6f32-rocdlcvtscalef32srpk32bf6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed bf6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.bf6.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f32 values to packed bf6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-94>Operands:&nbsp;<a class=headline-hash href=#operands-94>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-93>Results:&nbsp;<a class=headline-hash href=#results-93>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32fp6bf16-rocdlcvtscalef32srpk32fp6bf16op><code>rocdl.cvt.scalef32.sr.pk32.fp6.bf16</code> (ROCDL::CvtScaleF32SrPk32Fp6Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32fp6bf16-rocdlcvtscalef32srpk32fp6bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.fp6.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed bf16 values to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-95>Operands:&nbsp;<a class=headline-hash href=#operands-95>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-94>Results:&nbsp;<a class=headline-hash href=#results-94>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32fp6f16-rocdlcvtscalef32srpk32fp6f16op><code>rocdl.cvt.scalef32.sr.pk32.fp6.f16</code> (ROCDL::CvtScaleF32SrPk32Fp6F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32fp6f16-rocdlcvtscalef32srpk32fp6f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.fp6.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f16 values to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-96>Operands:&nbsp;<a class=headline-hash href=#operands-96>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-95>Results:&nbsp;<a class=headline-hash href=#results-95>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk32fp6f32-rocdlcvtscalef32srpk32fp6f32op><code>rocdl.cvt.scalef32.sr.pk32.fp6.f32</code> (ROCDL::CvtScaleF32SrPk32Fp6F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk32fp6f32-rocdlcvtscalef32srpk32fp6f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp6 with stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk32.fp6.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 32 packed f32 values to packed fp6, dividing by the exponent part of <code>scale</code>
before doing so and applying random rounding derived from
<code>seed</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-97>Operands:&nbsp;<a class=headline-hash href=#operands-97>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 32</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-96>Results:&nbsp;<a class=headline-hash href=#results-96>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 6</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8bf8bf16-rocdlcvtscalef32srpk8bf8bf16op><code>rocdl.cvt.scalef32.sr.pk8.bf8.bf16</code> (ROCDL::CvtScaleF32SrPk8Bf8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8bf8bf16-rocdlcvtscalef32srpk8bf8bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed bf8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.bf8.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-98>Operands:&nbsp;<a class=headline-hash href=#operands-98>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-97>Results:&nbsp;<a class=headline-hash href=#results-97>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8bf8f16-rocdlcvtscalef32srpk8bf8f16op><code>rocdl.cvt.scalef32.sr.pk8.bf8.f16</code> (ROCDL::CvtScaleF32SrPk8Bf8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8bf8f16-rocdlcvtscalef32srpk8bf8f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed bf8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.bf8.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-99>Operands:&nbsp;<a class=headline-hash href=#operands-99>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-98>Results:&nbsp;<a class=headline-hash href=#results-98>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8bf8f32-rocdlcvtscalef32srpk8bf8f32op><code>rocdl.cvt.scalef32.sr.pk8.bf8.f32</code> (ROCDL::CvtScaleF32SrPk8Bf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8bf8f32-rocdlcvtscalef32srpk8bf8f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed bf8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.bf8.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed bf8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-100>Operands:&nbsp;<a class=headline-hash href=#operands-100>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-99>Results:&nbsp;<a class=headline-hash href=#results-99>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp4bf16-rocdlcvtscalef32srpk8fp4bf16op><code>rocdl.cvt.scalef32.sr.pk8.fp4.bf16</code> (ROCDL::CvtScaleF32SrPk8Fp4Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp4bf16-rocdlcvtscalef32srpk8fp4bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp4 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp4.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-101>Operands:&nbsp;<a class=headline-hash href=#operands-101>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-100>Results:&nbsp;<a class=headline-hash href=#results-100>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp4f16-rocdlcvtscalef32srpk8fp4f16op><code>rocdl.cvt.scalef32.sr.pk8.fp4.f16</code> (ROCDL::CvtScaleF32SrPk8Fp4F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp4f16-rocdlcvtscalef32srpk8fp4f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp4 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp4.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-102>Operands:&nbsp;<a class=headline-hash href=#operands-102>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-101>Results:&nbsp;<a class=headline-hash href=#results-101>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp4f32-rocdlcvtscalef32srpk8fp4f32op><code>rocdl.cvt.scalef32.sr.pk8.fp4.f32</code> (ROCDL::CvtScaleF32SrPk8Fp4F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp4f32-rocdlcvtscalef32srpk8fp4f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp4 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp4.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp4, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-103>Operands:&nbsp;<a class=headline-hash href=#operands-103>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-102>Results:&nbsp;<a class=headline-hash href=#results-102>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp8bf16-rocdlcvtscalef32srpk8fp8bf16op><code>rocdl.cvt.scalef32.sr.pk8.fp8.bf16</code> (ROCDL::CvtScaleF32SrPk8Fp8Bf16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp8bf16-rocdlcvtscalef32srpk8fp8bf16op>¶</a></h3><p><em>Scale and convert packed bf16 to packed fp8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp8.bf16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed bf16 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-104>Operands:&nbsp;<a class=headline-hash href=#operands-104>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-103>Results:&nbsp;<a class=headline-hash href=#results-103>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp8f16-rocdlcvtscalef32srpk8fp8f16op><code>rocdl.cvt.scalef32.sr.pk8.fp8.f16</code> (ROCDL::CvtScaleF32SrPk8Fp8F16Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp8f16-rocdlcvtscalef32srpk8fp8f16op>¶</a></h3><p><em>Scale and convert packed f16 to packed fp8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp8.f16` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f16 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-105>Operands:&nbsp;<a class=headline-hash href=#operands-105>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 16-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-104>Results:&nbsp;<a class=headline-hash href=#results-104>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtscalef32srpk8fp8f32-rocdlcvtscalef32srpk8fp8f32op><code>rocdl.cvt.scalef32.sr.pk8.fp8.f32</code> (ROCDL::CvtScaleF32SrPk8Fp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtscalef32srpk8fp8f32-rocdlcvtscalef32srpk8fp8f32op>¶</a></h3><p><em>Scale and convert packed f32 to packed fp8 with stochastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.scalef32.sr.pk8.fp8.f32` attr-dict $src `,` $seed `,` $scale `:` type($res)
</code></pre><p>Convert 8 packed f32 values to packed fp8, multiplying by the exponent part of <code>scale</code>
before doing so and apply stochastic rounding. This op is for gfx1250+ arch.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-106>Operands:&nbsp;<a class=headline-hash href=#operands-106>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>fixed-length vector of 32-bit float values of length 8</td></tr><tr><td style=text-align:center><code>seed</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scale</code></td><td>32-bit float</td></tr></tbody></table><h4 id=results-105>Results:&nbsp;<a class=headline-hash href=#results-105>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 32-bit signless integer values of length 2</td></tr></tbody></table><h3 id=rocdlcvtsrbf8f32-rocdlcvtsrbf8f32op><code>rocdl.cvt.sr.bf8.f32</code> (ROCDL::CvtSrBf8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtsrbf8f32-rocdlcvtsrbf8f32op>¶</a></h3><p><em>Convert f32 to bf8, stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.sr.bf8.f32` attr-dict $srcA `,` $srcB `-&gt;` $old `[` $byteSel `]` `:` type($res)
</code></pre><p>Convert <code>srcA</code> to bf8, adding the rounding factor from <code>srcB</code>,
and store into the <code>byteSel</code>th byte of <code>old</code>, preserving the others.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-59>Attributes:&nbsp;<a class=headline-hash href=#attributes-59>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>byteSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-107>Operands:&nbsp;<a class=headline-hash href=#operands-107>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>srcB</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-106>Results:&nbsp;<a class=headline-hash href=#results-106>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlcvtsrfp8f32-rocdlcvtsrfp8f32op><code>rocdl.cvt.sr.fp8.f32</code> (ROCDL::CvtSrFp8F32Op)&nbsp;<a class=headline-hash href=#rocdlcvtsrfp8f32-rocdlcvtsrfp8f32op>¶</a></h3><p><em>Convert f32 to fp8, stochiastic rounding</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.cvt.sr.fp8.f32` attr-dict $srcA `,` $srcB `-&gt;` $old `[` $byteSel `]` `:` type($res)
</code></pre><p>Convert <code>srcA</code> to fp8, adding the rounding factor from <code>srcB</code>,
and store into the <code>byteSel</code>th byte of <code>old</code>, preserving the others.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-60>Attributes:&nbsp;<a class=headline-hash href=#attributes-60>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>byteSel</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-108>Operands:&nbsp;<a class=headline-hash href=#operands-108>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcA</code></td><td>32-bit float</td></tr><tr><td style=text-align:center><code>srcB</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-107>Results:&nbsp;<a class=headline-hash href=#results-107>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsatomicasyncbarrierarriveb64-rocdldsatomicasyncbarrierarriveop><code>rocdl.ds.atomic.async.barrier.arrive.b64</code> (ROCDL::DsAtomicAsyncBarrierArriveOp)&nbsp;<a class=headline-hash href=#rocdldsatomicasyncbarrierarriveb64-rocdldsatomicasyncbarrierarriveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.atomic.async.barrier.arrive.b64` $barrierPtr attr-dict `:` qualified(type($barrierPtr))
</code></pre><p>Waits on a given DS barrier and decrements pending count by -1.
Stays in order with ASYNC loads to LDS, and uses ASYNCcnt to track its completion.
Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-61>Attributes:&nbsp;<a class=headline-hash href=#attributes-61>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-109>Operands:&nbsp;<a class=headline-hash href=#operands-109>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>barrierPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdldsatomicbarrierarrivertnb64-rocdldsatomicbarrierarrivertnop><code>rocdl.ds.atomic.barrier.arrive.rtn.b64</code> (ROCDL::DsAtomicBarrierArriveRtnOp)&nbsp;<a class=headline-hash href=#rocdldsatomicbarrierarrivertnb64-rocdldsatomicbarrierarrivertnop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.atomic.barrier.arrive.rtn.b64` $barrierPtr `,` $val attr-dict `:` qualified(type($barrierPtr)) `,` type($val) `-&gt;` type($res)
</code></pre><p>Waits on a given DS barrier and decrements its pending count by a given value. Note, the barrier state
is given as a 64-bit structure containing pending count, phase and init count. The op returns the old
barrier state. The op is executed as an ordinary LDS operations and it is ordered with other LDS operations.
Thus, check DSCNT to determine when this instruction has executed.
Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-62>Attributes:&nbsp;<a class=headline-hash href=#attributes-62>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-110>Operands:&nbsp;<a class=headline-hash href=#operands-110>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>barrierPtr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>val</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-108>Results:&nbsp;<a class=headline-hash href=#results-108>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>64-bit signless integer</td></tr></tbody></table><h3 id=rocdldsloadtr16b128-rocdldsloadtr16_b128><code>rocdl.ds.load.tr16.b128</code> (ROCDL::DsLoadTr16_B128)&nbsp;<a class=headline-hash href=#rocdldsloadtr16b128-rocdldsloadtr16_b128>¶</a></h3><p><em>Loads and transposes a matrix from ds memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.load.tr16.b128` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 16-bit data from the ds memory,
transpose data between row-major and column-major order,
and store the result into a 128-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-63>Attributes:&nbsp;<a class=headline-hash href=#attributes-63>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-111>Operands:&nbsp;<a class=headline-hash href=#operands-111>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-109>Results:&nbsp;<a class=headline-hash href=#results-109>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsloadtr4b64-rocdldsloadtr4_b64><code>rocdl.ds.load.tr4.b64</code> (ROCDL::DsLoadTr4_B64)&nbsp;<a class=headline-hash href=#rocdldsloadtr4b64-rocdldsloadtr4_b64>¶</a></h3><p><em>Loads and transposes a matrix from ds memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.load.tr4.b64` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 4-bit data from the ds memory,
transpose data between row-major and column-major order,
and store the result into a 64-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-64>Attributes:&nbsp;<a class=headline-hash href=#attributes-64>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-112>Operands:&nbsp;<a class=headline-hash href=#operands-112>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-110>Results:&nbsp;<a class=headline-hash href=#results-110>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsloadtr6b96-rocdldsloadtr6_b96><code>rocdl.ds.load.tr6.b96</code> (ROCDL::DsLoadTr6_B96)&nbsp;<a class=headline-hash href=#rocdldsloadtr6b96-rocdldsloadtr6_b96>¶</a></h3><p><em>Loads and transposes a matrix from ds memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.load.tr6.b96` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 6-bit data from the ds memory,
transpose data between row-major and column-major order,
and store the result into a 96-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-65>Attributes:&nbsp;<a class=headline-hash href=#attributes-65>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-113>Operands:&nbsp;<a class=headline-hash href=#operands-113>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-111>Results:&nbsp;<a class=headline-hash href=#results-111>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsloadtr8b64-rocdldsloadtr8_b64><code>rocdl.ds.load.tr8.b64</code> (ROCDL::DsLoadTr8_B64)&nbsp;<a class=headline-hash href=#rocdldsloadtr8b64-rocdldsloadtr8_b64>¶</a></h3><p><em>Loads and transposes a matrix from ds memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.load.tr8.b64` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 8-bit data from the ds memory,
transpose data between row-major and column-major order,
and store the result into a 64-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-66>Attributes:&nbsp;<a class=headline-hash href=#attributes-66>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-114>Operands:&nbsp;<a class=headline-hash href=#operands-114>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-112>Results:&nbsp;<a class=headline-hash href=#results-112>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsreadtr16b64-rocdlds_read_tr16_b64><code>rocdl.ds.read.tr16.b64</code> (ROCDL::ds_read_tr16_b64)&nbsp;<a class=headline-hash href=#rocdldsreadtr16b64-rocdlds_read_tr16_b64>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.read.tr16.b64` $ptr attr-dict `:` type($ptr) `-&gt;` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-67>Attributes:&nbsp;<a class=headline-hash href=#attributes-67>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-115>Operands:&nbsp;<a class=headline-hash href=#operands-115>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-113>Results:&nbsp;<a class=headline-hash href=#results-113>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsreadtr4b64-rocdlds_read_tr4_b64><code>rocdl.ds.read.tr4.b64</code> (ROCDL::ds_read_tr4_b64)&nbsp;<a class=headline-hash href=#rocdldsreadtr4b64-rocdlds_read_tr4_b64>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.read.tr4.b64` $ptr attr-dict `:` type($ptr) `-&gt;` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-68>Attributes:&nbsp;<a class=headline-hash href=#attributes-68>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-116>Operands:&nbsp;<a class=headline-hash href=#operands-116>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-114>Results:&nbsp;<a class=headline-hash href=#results-114>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsreadtr6b96-rocdlds_read_tr6_b96><code>rocdl.ds.read.tr6.b96</code> (ROCDL::ds_read_tr6_b96)&nbsp;<a class=headline-hash href=#rocdldsreadtr6b96-rocdlds_read_tr6_b96>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.read.tr6.b96` $ptr attr-dict `:` type($ptr) `-&gt;` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-69>Attributes:&nbsp;<a class=headline-hash href=#attributes-69>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-117>Operands:&nbsp;<a class=headline-hash href=#operands-117>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-115>Results:&nbsp;<a class=headline-hash href=#results-115>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdldsreadtr8b64-rocdlds_read_tr8_b64><code>rocdl.ds.read.tr8.b64</code> (ROCDL::ds_read_tr8_b64)&nbsp;<a class=headline-hash href=#rocdldsreadtr8b64-rocdlds_read_tr8_b64>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds.read.tr8.b64` $ptr attr-dict `:` type($ptr) `-&gt;` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-70>Attributes:&nbsp;<a class=headline-hash href=#attributes-70>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-118>Operands:&nbsp;<a class=headline-hash href=#operands-118>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-116>Results:&nbsp;<a class=headline-hash href=#results-116>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlds_bpermute-rocdldsbpermuteop><code>rocdl.ds_bpermute</code> (ROCDL::DsBpermuteOp)&nbsp;<a class=headline-hash href=#rocdlds_bpermute-rocdldsbpermuteop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds_bpermute` $index `,` $src  attr-dict `:` `(` type($index) `,` type($src) `)` `-&gt;` type($res)
</code></pre><h4 id=operands-119>Operands:&nbsp;<a class=headline-hash href=#operands-119>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-117>Results:&nbsp;<a class=headline-hash href=#results-117>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlds_swizzle-rocdldsswizzleop><code>rocdl.ds_swizzle</code> (ROCDL::DsSwizzleOp)&nbsp;<a class=headline-hash href=#rocdlds_swizzle-rocdldsswizzleop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.ds_swizzle` $src `,` $offset  attr-dict `:` `(` type($src) `,` type($offset) `)` `-&gt;` type($res)
</code></pre><h4 id=operands-120>Operands:&nbsp;<a class=headline-hash href=#operands-120>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-118>Results:&nbsp;<a class=headline-hash href=#results-118>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlexp-rocdlrocdlexp><code>rocdl.exp</code> (ROCDL::ROCDLExp)&nbsp;<a class=headline-hash href=#rocdlexp-rocdlrocdlexp>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.exp` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-121>Operands:&nbsp;<a class=headline-hash href=#operands-121>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-119>Results:&nbsp;<a class=headline-hash href=#results-119>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlexp2-rocdlrocdlexp2><code>rocdl.exp2</code> (ROCDL::ROCDLExp2)&nbsp;<a class=headline-hash href=#rocdlexp2-rocdlrocdlexp2>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.exp2` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-122>Operands:&nbsp;<a class=headline-hash href=#operands-122>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-120>Results:&nbsp;<a class=headline-hash href=#results-120>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlflatprefetch-rocdlflatprefetchop><code>rocdl.flat.prefetch</code> (ROCDL::FlatPrefetchOp)&nbsp;<a class=headline-hash href=#rocdlflatprefetch-rocdlflatprefetchop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.flat.prefetch` $ptr `,` `scope` $scope attr-dict `:` qualified(type($ptr))
</code></pre><p>Prefetches 1 byte of data per lane using flat-memory addresses into the WGP-cache or L2-cache.
Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-71>Attributes:&nbsp;<a class=headline-hash href=#attributes-71>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-123>Operands:&nbsp;<a class=headline-hash href=#operands-123>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 0</td></tr></tbody></table><h3 id=rocdlfmed3-rocdlfmed3op><code>rocdl.fmed3</code> (ROCDL::FMed3Op)&nbsp;<a class=headline-hash href=#rocdlfmed3-rocdlfmed3op>¶</a></h3><p><em>Median of three float/half values</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.fmed3` $src0 `,` $src1 `,` $src2 attr-dict `:` type($res)
</code></pre><p>Computes the median of three floating-point values using the AMDGPU fmed3 intrinsic.
This operation is equivalent to <code>max(min(a, b), min(max(a, b), c))</code> but uses the
hardware-accelerated V_MED3_F16/V_MED3_F32 instruction for better performance.</p><p>The operation supports both scalar and vector floating-point types (f16, f32).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar f32 median
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%result</span> <span class=p>=</span> rocdl<span class=p>.</span>fmed3 <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Vector f16 median
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%result</span> <span class=p>=</span> rocdl<span class=p>.</span>fmed3 <span class=nv>%va</span><span class=p>,</span> <span class=nv>%vb</span><span class=p>,</span> <span class=nv>%vc</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-124>Operands:&nbsp;<a class=headline-hash href=#operands-124>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src0</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>src1</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>src2</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-121>Results:&nbsp;<a class=headline-hash href=#results-121>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=rocdlgloballoadasynctoldsb128-rocdlgloballoadasynctoldsb128op><code>rocdl.global.load.async.to.lds.b128</code> (ROCDL::GlobalLoadAsyncToLDSB128Op)&nbsp;<a class=headline-hash href=#rocdlgloballoadasynctoldsb128-rocdlgloballoadasynctoldsb128op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.async.to.lds.b128` $globalPtr `,`  $ldsPtr `,` $offset `,` $aux
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Asynchronously loads 128 bits of data from a global memory pointer
to a Local Data Share (LDS) pointer.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-72>Attributes:&nbsp;<a class=headline-hash href=#attributes-72>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-125>Operands:&nbsp;<a class=headline-hash href=#operands-125>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlgloballoadasynctoldsb32-rocdlgloballoadasynctoldsb32op><code>rocdl.global.load.async.to.lds.b32</code> (ROCDL::GlobalLoadAsyncToLDSB32Op)&nbsp;<a class=headline-hash href=#rocdlgloballoadasynctoldsb32-rocdlgloballoadasynctoldsb32op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.async.to.lds.b32` $globalPtr `,`  $ldsPtr `,` $offset `,` $aux
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Asynchronously loads 32 bits of data from a global memory pointer
to a Local Data Share (LDS) pointer.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-73>Attributes:&nbsp;<a class=headline-hash href=#attributes-73>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-126>Operands:&nbsp;<a class=headline-hash href=#operands-126>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlgloballoadasynctoldsb64-rocdlgloballoadasynctoldsb64op><code>rocdl.global.load.async.to.lds.b64</code> (ROCDL::GlobalLoadAsyncToLDSB64Op)&nbsp;<a class=headline-hash href=#rocdlgloballoadasynctoldsb64-rocdlgloballoadasynctoldsb64op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.async.to.lds.b64` $globalPtr `,`  $ldsPtr `,` $offset `,` $aux
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Asynchronously loads 64 bits of data from a global memory pointer
to a Local Data Share (LDS) pointer.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-74>Attributes:&nbsp;<a class=headline-hash href=#attributes-74>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-127>Operands:&nbsp;<a class=headline-hash href=#operands-127>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlgloballoadasynctoldsb8-rocdlgloballoadasynctoldsb8op><code>rocdl.global.load.async.to.lds.b8</code> (ROCDL::GlobalLoadAsyncToLDSB8Op)&nbsp;<a class=headline-hash href=#rocdlgloballoadasynctoldsb8-rocdlgloballoadasynctoldsb8op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.async.to.lds.b8` $globalPtr `,`  $ldsPtr `,` $offset `,` $aux
              attr-dict `:` qualified(type($globalPtr)) `,` qualified(type($ldsPtr))
</code></pre><p>Asynchronously loads 8 bits of data from a global memory pointer
to a Local Data Share (LDS) pointer.</p><p>Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-75>Attributes:&nbsp;<a class=headline-hash href=#attributes-75>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-128>Operands:&nbsp;<a class=headline-hash href=#operands-128>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlgloballoadlds-rocdlgloballoadldsop><code>rocdl.global.load.lds</code> (ROCDL::GlobalLoadLDSOp)&nbsp;<a class=headline-hash href=#rocdlgloballoadlds-rocdlgloballoadldsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.lds` $globalPtr `,`  $ldsPtr `,` $size `,` $offset `,` $aux
              attr-dict
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-76>Attributes:&nbsp;<a class=headline-hash href=#attributes-76>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-129>Operands:&nbsp;<a class=headline-hash href=#operands-129>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer in address space 1</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlgloballoadtrb128-rocdlgloballoadtr8_b128><code>rocdl.global.load.tr.b128</code> (ROCDL::GlobalLoadTr8_B128)&nbsp;<a class=headline-hash href=#rocdlgloballoadtrb128-rocdlgloballoadtr8_b128>¶</a></h3><p><em>Loads and transposes a matrix from global memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.tr.b128` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 16-bit data from the global memory,
transpose data between row-major and column-major order,
and store the result into a 128-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-77>Attributes:&nbsp;<a class=headline-hash href=#attributes-77>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-130>Operands:&nbsp;<a class=headline-hash href=#operands-130>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1</td></tr></tbody></table><h4 id=results-122>Results:&nbsp;<a class=headline-hash href=#results-122>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlgloballoadtrb64-rocdlgloballoadtr8_b64><code>rocdl.global.load.tr.b64</code> (ROCDL::GlobalLoadTr8_B64)&nbsp;<a class=headline-hash href=#rocdlgloballoadtrb64-rocdlgloballoadtr8_b64>¶</a></h3><p><em>Loads and transposes a matrix from global memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.tr.b64` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 8-bit data from the global memory,
transpose data between row-major and column-major order,
and store the result into a 64-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-78>Attributes:&nbsp;<a class=headline-hash href=#attributes-78>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-131>Operands:&nbsp;<a class=headline-hash href=#operands-131>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1</td></tr></tbody></table><h4 id=results-123>Results:&nbsp;<a class=headline-hash href=#results-123>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlgloballoadtr4b64-rocdlgloballoadtr4_b64><code>rocdl.global.load.tr4.b64</code> (ROCDL::GlobalLoadTr4_B64)&nbsp;<a class=headline-hash href=#rocdlgloballoadtr4b64-rocdlgloballoadtr4_b64>¶</a></h3><p><em>Loads and transposes a matrix from global memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.tr4.b64` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 4-bit data from the global memory,
transpose data between row-major and column-major order,
and store the result into a 64-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-79>Attributes:&nbsp;<a class=headline-hash href=#attributes-79>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-132>Operands:&nbsp;<a class=headline-hash href=#operands-132>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1</td></tr></tbody></table><h4 id=results-124>Results:&nbsp;<a class=headline-hash href=#results-124>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlgloballoadtr6b96-rocdlgloballoadtr6_b96><code>rocdl.global.load.tr6.b96</code> (ROCDL::GlobalLoadTr6_B96)&nbsp;<a class=headline-hash href=#rocdlgloballoadtr6b96-rocdlgloballoadtr6_b96>¶</a></h3><p><em>Loads and transposes a matrix from global memory to registers (available in gfx1250+).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.load.tr6.b96` $ptr attr-dict `:` qualified(type($ptr)) `-&gt;` type($res)
</code></pre><p>Load a matrix of 6-bit data from the global memory,
transpose data between row-major and column-major order,
and store the result into a 96-bit vector register.</p><p>Available in gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-80>Attributes:&nbsp;<a class=headline-hash href=#attributes-80>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-133>Operands:&nbsp;<a class=headline-hash href=#operands-133>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1</td></tr></tbody></table><h4 id=results-125>Results:&nbsp;<a class=headline-hash href=#results-125>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlglobalprefetch-rocdlglobalprefetchop><code>rocdl.global.prefetch</code> (ROCDL::GlobalPrefetchOp)&nbsp;<a class=headline-hash href=#rocdlglobalprefetch-rocdlglobalprefetchop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.global.prefetch` $ptr `,` `scope` $scope attr-dict `:` qualified(type($ptr))
</code></pre><p>Prefetches 1 byte of data per lane from global memory into the WGP-cache or L2-cache.
Available on gfx1250+.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-81>Attributes:&nbsp;<a class=headline-hash href=#attributes-81>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-134>Operands:&nbsp;<a class=headline-hash href=#operands-134>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1</td></tr></tbody></table><h3 id=rocdlgriddimx-rocdlgriddimxop><code>rocdl.grid.dim.x</code> (ROCDL::GridDimXOp)&nbsp;<a class=headline-hash href=#rocdlgriddimx-rocdlgriddimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.grid.dim.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-82>Attributes:&nbsp;<a class=headline-hash href=#attributes-82>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-126>Results:&nbsp;<a class=headline-hash href=#results-126>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlgriddimy-rocdlgriddimyop><code>rocdl.grid.dim.y</code> (ROCDL::GridDimYOp)&nbsp;<a class=headline-hash href=#rocdlgriddimy-rocdlgriddimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.grid.dim.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-83>Attributes:&nbsp;<a class=headline-hash href=#attributes-83>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-127>Results:&nbsp;<a class=headline-hash href=#results-127>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlgriddimz-rocdlgriddimzop><code>rocdl.grid.dim.z</code> (ROCDL::GridDimZOp)&nbsp;<a class=headline-hash href=#rocdlgriddimz-rocdlgriddimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.grid.dim.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-84>Attributes:&nbsp;<a class=headline-hash href=#attributes-84>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-128>Results:&nbsp;<a class=headline-hash href=#results-128>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdliglpopt-rocdliglpopt><code>rocdl.iglp.opt</code> (ROCDL::IglpOpt)&nbsp;<a class=headline-hash href=#rocdliglpopt-rocdliglpopt>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.iglp.opt` $variant attr-dict
</code></pre><h4 id=attributes-85>Attributes:&nbsp;<a class=headline-hash href=#attributes-85>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>variant</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlloadtolds-rocdlloadtoldsop><code>rocdl.load.to.lds</code> (ROCDL::LoadToLDSOp)&nbsp;<a class=headline-hash href=#rocdlloadtolds-rocdlloadtoldsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.load.to.lds` $globalPtr `,`  $ldsPtr `,` $size `,` $offset `,` $aux
              attr-dict `:` type($globalPtr)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-86>Attributes:&nbsp;<a class=headline-hash href=#attributes-86>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>offset</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>aux</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-135>Operands:&nbsp;<a class=headline-hash href=#operands-135>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>globalPtr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdllog-rocdlrocdllog><code>rocdl.log</code> (ROCDL::ROCDLLog)&nbsp;<a class=headline-hash href=#rocdllog-rocdlrocdllog>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.log` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-136>Operands:&nbsp;<a class=headline-hash href=#operands-136>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-129>Results:&nbsp;<a class=headline-hash href=#results-129>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlmakebufferrsrc-rocdlmakebufferrsrcop><code>rocdl.make.buffer.rsrc</code> (ROCDL::MakeBufferRsrcOp)&nbsp;<a class=headline-hash href=#rocdlmakebufferrsrc-rocdlmakebufferrsrcop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.make.buffer.rsrc` operands attr-dict `:` type($base) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-137>Operands:&nbsp;<a class=headline-hash href=#operands-137>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>16-bit signless integer</td></tr><tr><td style=text-align:center><code>numRecords</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>flags</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-130>Results:&nbsp;<a class=headline-hash href=#results-130>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=rocdlmbcnthi-rocdlmbcnthiop><code>rocdl.mbcnt.hi</code> (ROCDL::MbcntHiOp)&nbsp;<a class=headline-hash href=#rocdlmbcnthi-rocdlmbcnthiop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mbcnt.hi` $in0 `,` $in1  attr-dict `:` `(` type($in0) `,` type($in1) `)` `-&gt;` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-87>Attributes:&nbsp;<a class=headline-hash href=#attributes-87>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-138>Operands:&nbsp;<a class=headline-hash href=#operands-138>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in0</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>in1</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-131>Results:&nbsp;<a class=headline-hash href=#results-131>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlmbcntlo-rocdlmbcntloop><code>rocdl.mbcnt.lo</code> (ROCDL::MbcntLoOp)&nbsp;<a class=headline-hash href=#rocdlmbcntlo-rocdlmbcntloop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mbcnt.lo` $in0 `,` $in1  attr-dict `:` `(` type($in0) `,` type($in1) `)` `-&gt;` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-88>Attributes:&nbsp;<a class=headline-hash href=#attributes-88>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-139>Operands:&nbsp;<a class=headline-hash href=#operands-139>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in0</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>in1</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-132>Results:&nbsp;<a class=headline-hash href=#results-132>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x16bf161k-rocdlmfma_f32_16x16x16bf16_1k><code>rocdl.mfma.f32.16x16x16bf16.1k</code> (ROCDL::mfma_f32_16x16x16bf16_1k)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x16bf161k-rocdlmfma_f32_16x16x16bf16_1k>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x16bf16.1k` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-140>Operands:&nbsp;<a class=headline-hash href=#operands-140>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-133>Results:&nbsp;<a class=headline-hash href=#results-133>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x16f16-rocdlmfma_f32_16x16x16f16><code>rocdl.mfma.f32.16x16x16f16</code> (ROCDL::mfma_f32_16x16x16f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x16f16-rocdlmfma_f32_16x16x16f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x16f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-141>Operands:&nbsp;<a class=headline-hash href=#operands-141>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-134>Results:&nbsp;<a class=headline-hash href=#results-134>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x1f32-rocdlmfma_f32_16x16x1f32><code>rocdl.mfma.f32.16x16x1f32</code> (ROCDL::mfma_f32_16x16x1f32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x1f32-rocdlmfma_f32_16x16x1f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x1f32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-142>Operands:&nbsp;<a class=headline-hash href=#operands-142>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-135>Results:&nbsp;<a class=headline-hash href=#results-135>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x2bf16-rocdlmfma_f32_16x16x2bf16><code>rocdl.mfma.f32.16x16x2bf16</code> (ROCDL::mfma_f32_16x16x2bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x2bf16-rocdlmfma_f32_16x16x2bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x2bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-143>Operands:&nbsp;<a class=headline-hash href=#operands-143>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-136>Results:&nbsp;<a class=headline-hash href=#results-136>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32bf16-rocdlmfma_f32_16x16x32_bf16><code>rocdl.mfma.f32.16x16x32.bf16</code> (ROCDL::mfma_f32_16x16x32_bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32bf16-rocdlmfma_f32_16x16x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-144>Operands:&nbsp;<a class=headline-hash href=#operands-144>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-137>Results:&nbsp;<a class=headline-hash href=#results-137>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32bf8bf8-rocdlmfma_f32_16x16x32_bf8_bf8><code>rocdl.mfma.f32.16x16x32.bf8.bf8</code> (ROCDL::mfma_f32_16x16x32_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32bf8bf8-rocdlmfma_f32_16x16x32_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-145>Operands:&nbsp;<a class=headline-hash href=#operands-145>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-138>Results:&nbsp;<a class=headline-hash href=#results-138>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32bf8fp8-rocdlmfma_f32_16x16x32_bf8_fp8><code>rocdl.mfma.f32.16x16x32.bf8.fp8</code> (ROCDL::mfma_f32_16x16x32_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32bf8fp8-rocdlmfma_f32_16x16x32_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-146>Operands:&nbsp;<a class=headline-hash href=#operands-146>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-139>Results:&nbsp;<a class=headline-hash href=#results-139>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32f16-rocdlmfma_f32_16x16x32_f16><code>rocdl.mfma.f32.16x16x32.f16</code> (ROCDL::mfma_f32_16x16x32_f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32f16-rocdlmfma_f32_16x16x32_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-147>Operands:&nbsp;<a class=headline-hash href=#operands-147>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-140>Results:&nbsp;<a class=headline-hash href=#results-140>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32fp8bf8-rocdlmfma_f32_16x16x32_fp8_bf8><code>rocdl.mfma.f32.16x16x32.fp8.bf8</code> (ROCDL::mfma_f32_16x16x32_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32fp8bf8-rocdlmfma_f32_16x16x32_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-148>Operands:&nbsp;<a class=headline-hash href=#operands-148>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-141>Results:&nbsp;<a class=headline-hash href=#results-141>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x32fp8fp8-rocdlmfma_f32_16x16x32_fp8_fp8><code>rocdl.mfma.f32.16x16x32.fp8.fp8</code> (ROCDL::mfma_f32_16x16x32_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x32fp8fp8-rocdlmfma_f32_16x16x32_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x32.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-149>Operands:&nbsp;<a class=headline-hash href=#operands-149>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-142>Results:&nbsp;<a class=headline-hash href=#results-142>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x4bf161k-rocdlmfma_f32_16x16x4bf16_1k><code>rocdl.mfma.f32.16x16x4bf16.1k</code> (ROCDL::mfma_f32_16x16x4bf16_1k)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x4bf161k-rocdlmfma_f32_16x16x4bf16_1k>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x4bf16.1k` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-150>Operands:&nbsp;<a class=headline-hash href=#operands-150>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-143>Results:&nbsp;<a class=headline-hash href=#results-143>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x4f16-rocdlmfma_f32_16x16x4f16><code>rocdl.mfma.f32.16x16x4f16</code> (ROCDL::mfma_f32_16x16x4f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x4f16-rocdlmfma_f32_16x16x4f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x4f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-151>Operands:&nbsp;<a class=headline-hash href=#operands-151>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-144>Results:&nbsp;<a class=headline-hash href=#results-144>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x4f32-rocdlmfma_f32_16x16x4f32><code>rocdl.mfma.f32.16x16x4f32</code> (ROCDL::mfma_f32_16x16x4f32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x4f32-rocdlmfma_f32_16x16x4f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x4f32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-152>Operands:&nbsp;<a class=headline-hash href=#operands-152>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-145>Results:&nbsp;<a class=headline-hash href=#results-145>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x8xf32-rocdlmfma_f32_16x16x8_xf32><code>rocdl.mfma.f32.16x16x8.xf32</code> (ROCDL::mfma_f32_16x16x8_xf32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x8xf32-rocdlmfma_f32_16x16x8_xf32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x8.xf32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-153>Operands:&nbsp;<a class=headline-hash href=#operands-153>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-146>Results:&nbsp;<a class=headline-hash href=#results-146>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3216x16x8bf16-rocdlmfma_f32_16x16x8bf16><code>rocdl.mfma.f32.16x16x8bf16</code> (ROCDL::mfma_f32_16x16x8bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3216x16x8bf16-rocdlmfma_f32_16x16x8bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.16x16x8bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-154>Operands:&nbsp;<a class=headline-hash href=#operands-154>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-147>Results:&nbsp;<a class=headline-hash href=#results-147>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16bf16-rocdlmfma_f32_32x32x16_bf16><code>rocdl.mfma.f32.32x32x16.bf16</code> (ROCDL::mfma_f32_32x32x16_bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16bf16-rocdlmfma_f32_32x32x16_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-155>Operands:&nbsp;<a class=headline-hash href=#operands-155>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-148>Results:&nbsp;<a class=headline-hash href=#results-148>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16bf8bf8-rocdlmfma_f32_32x32x16_bf8_bf8><code>rocdl.mfma.f32.32x32x16.bf8.bf8</code> (ROCDL::mfma_f32_32x32x16_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16bf8bf8-rocdlmfma_f32_32x32x16_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-156>Operands:&nbsp;<a class=headline-hash href=#operands-156>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-149>Results:&nbsp;<a class=headline-hash href=#results-149>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16bf8fp8-rocdlmfma_f32_32x32x16_bf8_fp8><code>rocdl.mfma.f32.32x32x16.bf8.fp8</code> (ROCDL::mfma_f32_32x32x16_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16bf8fp8-rocdlmfma_f32_32x32x16_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-157>Operands:&nbsp;<a class=headline-hash href=#operands-157>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-150>Results:&nbsp;<a class=headline-hash href=#results-150>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16f16-rocdlmfma_f32_32x32x16_f16><code>rocdl.mfma.f32.32x32x16.f16</code> (ROCDL::mfma_f32_32x32x16_f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16f16-rocdlmfma_f32_32x32x16_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-158>Operands:&nbsp;<a class=headline-hash href=#operands-158>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-151>Results:&nbsp;<a class=headline-hash href=#results-151>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16fp8bf8-rocdlmfma_f32_32x32x16_fp8_bf8><code>rocdl.mfma.f32.32x32x16.fp8.bf8</code> (ROCDL::mfma_f32_32x32x16_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16fp8bf8-rocdlmfma_f32_32x32x16_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-159>Operands:&nbsp;<a class=headline-hash href=#operands-159>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-152>Results:&nbsp;<a class=headline-hash href=#results-152>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x16fp8fp8-rocdlmfma_f32_32x32x16_fp8_fp8><code>rocdl.mfma.f32.32x32x16.fp8.fp8</code> (ROCDL::mfma_f32_32x32x16_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x16fp8fp8-rocdlmfma_f32_32x32x16_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x16.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-160>Operands:&nbsp;<a class=headline-hash href=#operands-160>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-153>Results:&nbsp;<a class=headline-hash href=#results-153>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x1f32-rocdlmfma_f32_32x32x1f32><code>rocdl.mfma.f32.32x32x1f32</code> (ROCDL::mfma_f32_32x32x1f32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x1f32-rocdlmfma_f32_32x32x1f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x1f32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-161>Operands:&nbsp;<a class=headline-hash href=#operands-161>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-154>Results:&nbsp;<a class=headline-hash href=#results-154>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x2bf16-rocdlmfma_f32_32x32x2bf16><code>rocdl.mfma.f32.32x32x2bf16</code> (ROCDL::mfma_f32_32x32x2bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x2bf16-rocdlmfma_f32_32x32x2bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x2bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-162>Operands:&nbsp;<a class=headline-hash href=#operands-162>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-155>Results:&nbsp;<a class=headline-hash href=#results-155>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x2f32-rocdlmfma_f32_32x32x2f32><code>rocdl.mfma.f32.32x32x2f32</code> (ROCDL::mfma_f32_32x32x2f32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x2f32-rocdlmfma_f32_32x32x2f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x2f32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-163>Operands:&nbsp;<a class=headline-hash href=#operands-163>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-156>Results:&nbsp;<a class=headline-hash href=#results-156>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x4xf32-rocdlmfma_f32_32x32x4_xf32><code>rocdl.mfma.f32.32x32x4.xf32</code> (ROCDL::mfma_f32_32x32x4_xf32)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x4xf32-rocdlmfma_f32_32x32x4_xf32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x4.xf32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-164>Operands:&nbsp;<a class=headline-hash href=#operands-164>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-157>Results:&nbsp;<a class=headline-hash href=#results-157>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x4bf16-rocdlmfma_f32_32x32x4bf16><code>rocdl.mfma.f32.32x32x4bf16</code> (ROCDL::mfma_f32_32x32x4bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x4bf16-rocdlmfma_f32_32x32x4bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x4bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-165>Operands:&nbsp;<a class=headline-hash href=#operands-165>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-158>Results:&nbsp;<a class=headline-hash href=#results-158>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x4bf161k-rocdlmfma_f32_32x32x4bf16_1k><code>rocdl.mfma.f32.32x32x4bf16.1k</code> (ROCDL::mfma_f32_32x32x4bf16_1k)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x4bf161k-rocdlmfma_f32_32x32x4bf16_1k>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x4bf16.1k` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-166>Operands:&nbsp;<a class=headline-hash href=#operands-166>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-159>Results:&nbsp;<a class=headline-hash href=#results-159>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x4f16-rocdlmfma_f32_32x32x4f16><code>rocdl.mfma.f32.32x32x4f16</code> (ROCDL::mfma_f32_32x32x4f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x4f16-rocdlmfma_f32_32x32x4f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x4f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-167>Operands:&nbsp;<a class=headline-hash href=#operands-167>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-160>Results:&nbsp;<a class=headline-hash href=#results-160>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x8bf161k-rocdlmfma_f32_32x32x8bf16_1k><code>rocdl.mfma.f32.32x32x8bf16.1k</code> (ROCDL::mfma_f32_32x32x8bf16_1k)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x8bf161k-rocdlmfma_f32_32x32x8bf16_1k>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x8bf16.1k` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-168>Operands:&nbsp;<a class=headline-hash href=#operands-168>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-161>Results:&nbsp;<a class=headline-hash href=#results-161>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf3232x32x8f16-rocdlmfma_f32_32x32x8f16><code>rocdl.mfma.f32.32x32x8f16</code> (ROCDL::mfma_f32_32x32x8f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf3232x32x8f16-rocdlmfma_f32_32x32x8f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.32x32x8f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-169>Operands:&nbsp;<a class=headline-hash href=#operands-169>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-162>Results:&nbsp;<a class=headline-hash href=#results-162>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf324x4x1f32-rocdlmfma_f32_4x4x1f32><code>rocdl.mfma.f32.4x4x1f32</code> (ROCDL::mfma_f32_4x4x1f32)&nbsp;<a class=headline-hash href=#rocdlmfmaf324x4x1f32-rocdlmfma_f32_4x4x1f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.4x4x1f32` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-170>Operands:&nbsp;<a class=headline-hash href=#operands-170>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-163>Results:&nbsp;<a class=headline-hash href=#results-163>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf324x4x2bf16-rocdlmfma_f32_4x4x2bf16><code>rocdl.mfma.f32.4x4x2bf16</code> (ROCDL::mfma_f32_4x4x2bf16)&nbsp;<a class=headline-hash href=#rocdlmfmaf324x4x2bf16-rocdlmfma_f32_4x4x2bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.4x4x2bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-171>Operands:&nbsp;<a class=headline-hash href=#operands-171>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-164>Results:&nbsp;<a class=headline-hash href=#results-164>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf324x4x4bf161k-rocdlmfma_f32_4x4x4bf16_1k><code>rocdl.mfma.f32.4x4x4bf16.1k</code> (ROCDL::mfma_f32_4x4x4bf16_1k)&nbsp;<a class=headline-hash href=#rocdlmfmaf324x4x4bf161k-rocdlmfma_f32_4x4x4bf16_1k>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.4x4x4bf16.1k` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-172>Operands:&nbsp;<a class=headline-hash href=#operands-172>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-165>Results:&nbsp;<a class=headline-hash href=#results-165>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf324x4x4f16-rocdlmfma_f32_4x4x4f16><code>rocdl.mfma.f32.4x4x4f16</code> (ROCDL::mfma_f32_4x4x4f16)&nbsp;<a class=headline-hash href=#rocdlmfmaf324x4x4f16-rocdlmfma_f32_4x4x4f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f32.4x4x4f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-173>Operands:&nbsp;<a class=headline-hash href=#operands-173>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-166>Results:&nbsp;<a class=headline-hash href=#results-166>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf6416x16x4f64-rocdlmfma_f64_16x16x4f64><code>rocdl.mfma.f64.16x16x4f64</code> (ROCDL::mfma_f64_16x16x4f64)&nbsp;<a class=headline-hash href=#rocdlmfmaf6416x16x4f64-rocdlmfma_f64_16x16x4f64>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f64.16x16x4f64` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-174>Operands:&nbsp;<a class=headline-hash href=#operands-174>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-167>Results:&nbsp;<a class=headline-hash href=#results-167>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmaf644x4x4f64-rocdlmfma_f64_4x4x4f64><code>rocdl.mfma.f64.4x4x4f64</code> (ROCDL::mfma_f64_4x4x4f64)&nbsp;<a class=headline-hash href=#rocdlmfmaf644x4x4f64-rocdlmfma_f64_4x4x4f64>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.f64.4x4x4f64` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-175>Operands:&nbsp;<a class=headline-hash href=#operands-175>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-168>Results:&nbsp;<a class=headline-hash href=#results-168>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3216x16x16i8-rocdlmfma_i32_16x16x16i8><code>rocdl.mfma.i32.16x16x16i8</code> (ROCDL::mfma_i32_16x16x16i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3216x16x16i8-rocdlmfma_i32_16x16x16i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.16x16x16i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-176>Operands:&nbsp;<a class=headline-hash href=#operands-176>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-169>Results:&nbsp;<a class=headline-hash href=#results-169>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3216x16x32i8-rocdlmfma_i32_16x16x32_i8><code>rocdl.mfma.i32.16x16x32.i8</code> (ROCDL::mfma_i32_16x16x32_i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3216x16x32i8-rocdlmfma_i32_16x16x32_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.16x16x32.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-177>Operands:&nbsp;<a class=headline-hash href=#operands-177>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-170>Results:&nbsp;<a class=headline-hash href=#results-170>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3216x16x4i8-rocdlmfma_i32_16x16x4i8><code>rocdl.mfma.i32.16x16x4i8</code> (ROCDL::mfma_i32_16x16x4i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3216x16x4i8-rocdlmfma_i32_16x16x4i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.16x16x4i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-178>Operands:&nbsp;<a class=headline-hash href=#operands-178>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-171>Results:&nbsp;<a class=headline-hash href=#results-171>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3216x16x64i8-rocdlmfma_i32_16x16x64_i8><code>rocdl.mfma.i32.16x16x64.i8</code> (ROCDL::mfma_i32_16x16x64_i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3216x16x64i8-rocdlmfma_i32_16x16x64_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.16x16x64.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-179>Operands:&nbsp;<a class=headline-hash href=#operands-179>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-172>Results:&nbsp;<a class=headline-hash href=#results-172>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3232x32x16i8-rocdlmfma_i32_32x32x16_i8><code>rocdl.mfma.i32.32x32x16.i8</code> (ROCDL::mfma_i32_32x32x16_i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3232x32x16i8-rocdlmfma_i32_32x32x16_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.32x32x16.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-180>Operands:&nbsp;<a class=headline-hash href=#operands-180>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-173>Results:&nbsp;<a class=headline-hash href=#results-173>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3232x32x32i8-rocdlmfma_i32_32x32x32_i8><code>rocdl.mfma.i32.32x32x32.i8</code> (ROCDL::mfma_i32_32x32x32_i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3232x32x32i8-rocdlmfma_i32_32x32x32_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.32x32x32.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-181>Operands:&nbsp;<a class=headline-hash href=#operands-181>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-174>Results:&nbsp;<a class=headline-hash href=#results-174>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3232x32x4i8-rocdlmfma_i32_32x32x4i8><code>rocdl.mfma.i32.32x32x4i8</code> (ROCDL::mfma_i32_32x32x4i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3232x32x4i8-rocdlmfma_i32_32x32x4i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.32x32x4i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-182>Operands:&nbsp;<a class=headline-hash href=#operands-182>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-175>Results:&nbsp;<a class=headline-hash href=#results-175>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai3232x32x8i8-rocdlmfma_i32_32x32x8i8><code>rocdl.mfma.i32.32x32x8i8</code> (ROCDL::mfma_i32_32x32x8i8)&nbsp;<a class=headline-hash href=#rocdlmfmai3232x32x8i8-rocdlmfma_i32_32x32x8i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.32x32x8i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-183>Operands:&nbsp;<a class=headline-hash href=#operands-183>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-176>Results:&nbsp;<a class=headline-hash href=#results-176>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmai324x4x4i8-rocdlmfma_i32_4x4x4i8><code>rocdl.mfma.i32.4x4x4i8</code> (ROCDL::mfma_i32_4x4x4i8)&nbsp;<a class=headline-hash href=#rocdlmfmai324x4x4i8-rocdlmfma_i32_4x4x4i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.i32.4x4x4i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-184>Operands:&nbsp;<a class=headline-hash href=#operands-184>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-177>Results:&nbsp;<a class=headline-hash href=#results-177>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmascalef3216x16x128f8f6f4-rocdlmfma_scale_f32_16x16x128_f8f6f4><code>rocdl.mfma.scale.f32.16x16x128.f8f6f4</code> (ROCDL::mfma_scale_f32_16x16x128_f8f6f4)&nbsp;<a class=headline-hash href=#rocdlmfmascalef3216x16x128f8f6f4-rocdlmfma_scale_f32_16x16x128_f8f6f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.scale.f32.16x16x128.f8f6f4` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-185>Operands:&nbsp;<a class=headline-hash href=#operands-185>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-178>Results:&nbsp;<a class=headline-hash href=#results-178>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlmfmascalef3232x32x64f8f6f4-rocdlmfma_scale_f32_32x32x64_f8f6f4><code>rocdl.mfma.scale.f32.32x32x64.f8f6f4</code> (ROCDL::mfma_scale_f32_32x32x64_f8f6f4)&nbsp;<a class=headline-hash href=#rocdlmfmascalef3232x32x64f8f6f4-rocdlmfma_scale_f32_32x32x64_f8f6f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.mfma.scale.f32.32x32x64.f8f6f4` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-186>Operands:&nbsp;<a class=headline-hash href=#operands-186>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-179>Results:&nbsp;<a class=headline-hash href=#results-179>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlpermlane16swap-rocdlpermlane16swapop><code>rocdl.permlane16.swap</code> (ROCDL::Permlane16SwapOp)&nbsp;<a class=headline-hash href=#rocdlpermlane16swap-rocdlpermlane16swapop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.permlane16.swap` attr-dict $old `,` $src `,` $fi `,` $boundControl `:` `(` type($old) `,` type($src) `)` `-&gt;` type($res)
</code></pre><p>Performs a <code>permlane16.swap</code> operation with the given operands, applying the
permutation specified by $fi to the provided inputs.</p><h4 id=attributes-89>Attributes:&nbsp;<a class=headline-hash href=#attributes-89>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fi</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>boundControl</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-187>Operands:&nbsp;<a class=headline-hash href=#operands-187>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-180>Results:&nbsp;<a class=headline-hash href=#results-180>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible struct of 32-bit signless integerand32-bit signless integer</td></tr></tbody></table><h3 id=rocdlpermlane32swap-rocdlpermlane32swapop><code>rocdl.permlane32.swap</code> (ROCDL::Permlane32SwapOp)&nbsp;<a class=headline-hash href=#rocdlpermlane32swap-rocdlpermlane32swapop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.permlane32.swap` attr-dict $old `,` $src `,` $fi `,` $boundControl `:` `(` type($old) `,` type($src) `)` `-&gt;` type($res)
</code></pre><p>Performs a <code>permlane32.swap</code> operation with the given operands, applying the
permutation specified by $fi to the provided inputs.</p><h4 id=attributes-90>Attributes:&nbsp;<a class=headline-hash href=#attributes-90>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fi</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>boundControl</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-188>Operands:&nbsp;<a class=headline-hash href=#operands-188>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>old</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>src</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-181>Results:&nbsp;<a class=headline-hash href=#results-181>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible struct of 32-bit signless integerand32-bit signless integer</td></tr></tbody></table><h3 id=rocdlpermlanex16-rocdlpermlanex16op><code>rocdl.permlanex16</code> (ROCDL::PermlaneX16Op)&nbsp;<a class=headline-hash href=#rocdlpermlanex16-rocdlpermlanex16op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.permlanex16` attr-dict $old `,` $src0 `,` $src1 `,` $src2 `,` $fi `,` $boundControl `:` type($src0) `,` type($src1)
</code></pre><p>Performs a <code>permlanex16</code> operation with the given operands, applying the
permutation specified by $fi to the provided inputs.</p><h4 id=attributes-91>Attributes:&nbsp;<a class=headline-hash href=#attributes-91>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fi</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>boundControl</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-189>Operands:&nbsp;<a class=headline-hash href=#operands-189>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>old</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>src0</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>src1</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>src2</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-182>Results:&nbsp;<a class=headline-hash href=#results-182>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferatomiccmpswap-rocdlrawbufferatomiccmpswap><code>rocdl.raw.buffer.atomic.cmpswap</code> (ROCDL::RawBufferAtomicCmpSwap)&nbsp;<a class=headline-hash href=#rocdlrawbufferatomiccmpswap-rocdlrawbufferatomiccmpswap>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.buffer.atomic.cmpswap` attr-dict `(` operands `)` `:` type($res) `,` type($rsrc)
</code></pre><h4 id=operands-190>Operands:&nbsp;<a class=headline-hash href=#operands-190>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>cmp</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-183>Results:&nbsp;<a class=headline-hash href=#results-183>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferatomicfadd-rocdlrawbufferatomicfaddop><code>rocdl.raw.buffer.atomic.fadd</code> (ROCDL::RawBufferAtomicFAddOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferatomicfadd-rocdlrawbufferatomicfaddop>¶</a></h3><h4 id=operands-191>Operands:&nbsp;<a class=headline-hash href=#operands-191>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferatomicfmax-rocdlrawbufferatomicfmaxop><code>rocdl.raw.buffer.atomic.fmax</code> (ROCDL::RawBufferAtomicFMaxOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferatomicfmax-rocdlrawbufferatomicfmaxop>¶</a></h3><h4 id=operands-192>Operands:&nbsp;<a class=headline-hash href=#operands-192>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferatomicsmax-rocdlrawbufferatomicsmaxop><code>rocdl.raw.buffer.atomic.smax</code> (ROCDL::RawBufferAtomicSMaxOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferatomicsmax-rocdlrawbufferatomicsmaxop>¶</a></h3><h4 id=operands-193>Operands:&nbsp;<a class=headline-hash href=#operands-193>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferatomicumin-rocdlrawbufferatomicuminop><code>rocdl.raw.buffer.atomic.umin</code> (ROCDL::RawBufferAtomicUMinOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferatomicumin-rocdlrawbufferatomicuminop>¶</a></h3><h4 id=operands-194>Operands:&nbsp;<a class=headline-hash href=#operands-194>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferload-rocdlrawbufferloadop><code>rocdl.raw.buffer.load</code> (ROCDL::RawBufferLoadOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferload-rocdlrawbufferloadop>¶</a></h3><h4 id=operands-195>Operands:&nbsp;<a class=headline-hash href=#operands-195>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-184>Results:&nbsp;<a class=headline-hash href=#results-184>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawbufferstore-rocdlrawbufferstoreop><code>rocdl.raw.buffer.store</code> (ROCDL::RawBufferStoreOp)&nbsp;<a class=headline-hash href=#rocdlrawbufferstore-rocdlrawbufferstoreop>¶</a></h3><h4 id=operands-196>Operands:&nbsp;<a class=headline-hash href=#operands-196>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>aux</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawptrbufferatomiccmpswap-rocdlrawptrbufferatomiccmpswap><code>rocdl.raw.ptr.buffer.atomic.cmpswap</code> (ROCDL::RawPtrBufferAtomicCmpSwap)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferatomiccmpswap-rocdlrawptrbufferatomiccmpswap>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.atomic.cmpswap` operands attr-dict `:` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-92>Attributes:&nbsp;<a class=headline-hash href=#attributes-92>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-197>Operands:&nbsp;<a class=headline-hash href=#operands-197>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>cmp</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-185>Results:&nbsp;<a class=headline-hash href=#results-185>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawptrbufferatomicfadd-rocdlrawptrbufferatomicfaddop><code>rocdl.raw.ptr.buffer.atomic.fadd</code> (ROCDL::RawPtrBufferAtomicFaddOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferatomicfadd-rocdlrawptrbufferatomicfaddop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.atomic.fadd` operands attr-dict `:` type($vdata)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-93>Attributes:&nbsp;<a class=headline-hash href=#attributes-93>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-198>Operands:&nbsp;<a class=headline-hash href=#operands-198>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrawptrbufferatomicfmax-rocdlrawptrbufferatomicfmaxop><code>rocdl.raw.ptr.buffer.atomic.fmax</code> (ROCDL::RawPtrBufferAtomicFmaxOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferatomicfmax-rocdlrawptrbufferatomicfmaxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.atomic.fmax` operands attr-dict `:` type($vdata)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-94>Attributes:&nbsp;<a class=headline-hash href=#attributes-94>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-199>Operands:&nbsp;<a class=headline-hash href=#operands-199>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrawptrbufferatomicsmax-rocdlrawptrbufferatomicsmaxop><code>rocdl.raw.ptr.buffer.atomic.smax</code> (ROCDL::RawPtrBufferAtomicSmaxOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferatomicsmax-rocdlrawptrbufferatomicsmaxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.atomic.smax` operands attr-dict `:` type($vdata)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-95>Attributes:&nbsp;<a class=headline-hash href=#attributes-95>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-200>Operands:&nbsp;<a class=headline-hash href=#operands-200>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrawptrbufferatomicumin-rocdlrawptrbufferatomicuminop><code>rocdl.raw.ptr.buffer.atomic.umin</code> (ROCDL::RawPtrBufferAtomicUminOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferatomicumin-rocdlrawptrbufferatomicuminop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.atomic.umin` operands attr-dict `:` type($vdata)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-96>Attributes:&nbsp;<a class=headline-hash href=#attributes-96>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-201>Operands:&nbsp;<a class=headline-hash href=#operands-201>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrawptrbufferload-rocdlrawptrbufferloadop><code>rocdl.raw.ptr.buffer.load</code> (ROCDL::RawPtrBufferLoadOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferload-rocdlrawptrbufferloadop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.load` operands attr-dict `:` type($res)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-97>Attributes:&nbsp;<a class=headline-hash href=#attributes-97>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-202>Operands:&nbsp;<a class=headline-hash href=#operands-202>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-186>Results:&nbsp;<a class=headline-hash href=#results-186>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlrawptrbufferloadlds-rocdlrawptrbufferloadldsop><code>rocdl.raw.ptr.buffer.load.lds</code> (ROCDL::RawPtrBufferLoadLdsOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferloadlds-rocdlrawptrbufferloadldsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.load.lds` operands attr-dict
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-98>Attributes:&nbsp;<a class=headline-hash href=#attributes-98>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-203>Operands:&nbsp;<a class=headline-hash href=#operands-203>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>ldsPtr</code></td><td>LLVM pointer in address space 3</td></tr><tr><td style=text-align:center><code>size</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>voffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrawptrbufferstore-rocdlrawptrbufferstoreop><code>rocdl.raw.ptr.buffer.store</code> (ROCDL::RawPtrBufferStoreOp)&nbsp;<a class=headline-hash href=#rocdlrawptrbufferstore-rocdlrawptrbufferstoreop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.raw.ptr.buffer.store` operands attr-dict `:` type($vdata)
</code></pre><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-99>Attributes:&nbsp;<a class=headline-hash href=#attributes-99>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-204>Operands:&nbsp;<a class=headline-hash href=#operands-204>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vdata</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>rsrc</code></td><td>LLVM pointer in address space 8</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>soffset</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>aux</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlrcp-rocdlrocdlrcp><code>rocdl.rcp</code> (ROCDL::ROCDLRcp)&nbsp;<a class=headline-hash href=#rocdlrcp-rocdlrocdlrcp>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.rcp` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-205>Operands:&nbsp;<a class=headline-hash href=#operands-205>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-187>Results:&nbsp;<a class=headline-hash href=#results-187>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlreadfirstlane-rocdlreadfirstlaneop><code>rocdl.readfirstlane</code> (ROCDL::ReadfirstlaneOp)&nbsp;<a class=headline-hash href=#rocdlreadfirstlane-rocdlreadfirstlaneop>¶</a></h3><p><em>Get the value in first active lane.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.readfirstlane` $src attr-dict `:` type($res)
</code></pre><p>Returns the value in the lowest active lane of the input operand.</p><h4 id=operands-206>Operands:&nbsp;<a class=headline-hash href=#operands-206>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-188>Results:&nbsp;<a class=headline-hash href=#results-188>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlreadlane-rocdlreadlaneop><code>rocdl.readlane</code> (ROCDL::ReadlaneOp)&nbsp;<a class=headline-hash href=#rocdlreadlane-rocdlreadlaneop>¶</a></h3><p><em>Get the value in the specific lane.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.readlane` $src0 `,` $src1  attr-dict `:` `(` type($src0) `,` type($src1) `)` `-&gt;` type($res)
</code></pre><p>Get the value in lane <code>src1</code> from input <code>src0</code>.</p><h4 id=operands-207>Operands:&nbsp;<a class=headline-hash href=#operands-207>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src0</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>src1</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-189>Results:&nbsp;<a class=headline-hash href=#results-189>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsbarrier-rocdlsbarrierop><code>rocdl.s.barrier</code> (ROCDL::SBarrierOp)&nbsp;<a class=headline-hash href=#rocdlsbarrier-rocdlsbarrierop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier` attr-dict
</code></pre><h3 id=rocdlsbarrierinit-rocdlbarrierinitop><code>rocdl.s.barrier.init</code> (ROCDL::BarrierInitOp)&nbsp;<a class=headline-hash href=#rocdlsbarrierinit-rocdlbarrierinitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.init` $ptr `,` $id attr-dict
</code></pre><p>Available on gfx1250+.</p><h4 id=attributes-100>Attributes:&nbsp;<a class=headline-hash href=#attributes-100>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-208>Operands:&nbsp;<a class=headline-hash href=#operands-208>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlsbarrierjoin-rocdlbarrierjoinop><code>rocdl.s.barrier.join</code> (ROCDL::BarrierJoinOp)&nbsp;<a class=headline-hash href=#rocdlsbarrierjoin-rocdlbarrierjoinop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.join` $ptr attr-dict
</code></pre><p>Available on gfx1250+.</p><h4 id=operands-209>Operands:&nbsp;<a class=headline-hash href=#operands-209>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlsbarrierleave-rocdlbarrierleaveop><code>rocdl.s.barrier.leave</code> (ROCDL::BarrierLeaveOp)&nbsp;<a class=headline-hash href=#rocdlsbarrierleave-rocdlbarrierleaveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.leave` $id attr-dict
</code></pre><p>Available on gfx1250+.</p><h4 id=attributes-101>Attributes:&nbsp;<a class=headline-hash href=#attributes-101>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlsbarriersignal-rocdlbarriersignalop><code>rocdl.s.barrier.signal</code> (ROCDL::BarrierSignalOp)&nbsp;<a class=headline-hash href=#rocdlsbarriersignal-rocdlbarriersignalop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.signal` $id attr-dict
</code></pre><h4 id=attributes-102>Attributes:&nbsp;<a class=headline-hash href=#attributes-102>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlsbarriersignalisfirst-rocdlbarriersignalisfirstop><code>rocdl.s.barrier.signal.isfirst</code> (ROCDL::BarrierSignalIsfirstOp)&nbsp;<a class=headline-hash href=#rocdlsbarriersignalisfirst-rocdlbarriersignalisfirstop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.signal.isfirst` $id attr-dict `:` type($res)
</code></pre><p>Available on gfx1250+.</p><h4 id=attributes-103>Attributes:&nbsp;<a class=headline-hash href=#attributes-103>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=results-190>Results:&nbsp;<a class=headline-hash href=#results-190>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=rocdlsbarriersignalvar-rocdlbarriersignalvarop><code>rocdl.s.barrier.signal.var</code> (ROCDL::BarrierSignalVarOp)&nbsp;<a class=headline-hash href=#rocdlsbarriersignalvar-rocdlbarriersignalvarop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.signal.var` $ptr `,` $id attr-dict
</code></pre><p>Available on gfx1250+.</p><h4 id=attributes-104>Attributes:&nbsp;<a class=headline-hash href=#attributes-104>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-210>Operands:&nbsp;<a class=headline-hash href=#operands-210>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h3 id=rocdlsbarrierwait-rocdlbarrierwaitop><code>rocdl.s.barrier.wait</code> (ROCDL::BarrierWaitOp)&nbsp;<a class=headline-hash href=#rocdlsbarrierwait-rocdlbarrierwaitop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.barrier.wait` $id attr-dict
</code></pre><h4 id=attributes-105>Attributes:&nbsp;<a class=headline-hash href=#attributes-105>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlsgetbarrierstate-rocdlgetbarrierstateop><code>rocdl.s.get.barrier.state</code> (ROCDL::GetBarrierStateOp)&nbsp;<a class=headline-hash href=#rocdlsgetbarrierstate-rocdlgetbarrierstateop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.get.barrier.state` $id attr-dict `:` type($res)
</code></pre><p>Available on gfx1250+.</p><h4 id=attributes-106>Attributes:&nbsp;<a class=headline-hash href=#attributes-106>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=results-191>Results:&nbsp;<a class=headline-hash href=#results-191>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlsgetnamedbarrierstate-rocdlgetnamedbarrierstateop><code>rocdl.s.get.named.barrier.state</code> (ROCDL::GetNamedBarrierStateOp)&nbsp;<a class=headline-hash href=#rocdlsgetnamedbarrierstate-rocdlgetnamedbarrierstateop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.get.named.barrier.state` $ptr attr-dict `:` type($res)
</code></pre><p>Available on gfx1250+.</p><h4 id=operands-211>Operands:&nbsp;<a class=headline-hash href=#operands-211>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 3</td></tr></tbody></table><h4 id=results-192>Results:&nbsp;<a class=headline-hash href=#results-192>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=rocdlssetprio-rocdlsetprioop><code>rocdl.s.setprio</code> (ROCDL::SetPrioOp)&nbsp;<a class=headline-hash href=#rocdlssetprio-rocdlsetprioop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.setprio` $priority attr-dict
</code></pre><h4 id=attributes-107>Attributes:&nbsp;<a class=headline-hash href=#attributes-107>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>priority</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlssleep-rocdlssleepop><code>rocdl.s.sleep</code> (ROCDL::SSleepOp)&nbsp;<a class=headline-hash href=#rocdlssleep-rocdlssleepop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.sleep` attr-dict $count
</code></pre><h4 id=attributes-108>Attributes:&nbsp;<a class=headline-hash href=#attributes-108>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitasynccnt-rocdlwaitasynccntop><code>rocdl.s.wait.asynccnt</code> (ROCDL::WaitAsynccntOp)&nbsp;<a class=headline-hash href=#rocdlswaitasynccnt-rocdlwaitasynccntop>¶</a></h3><p><em>Wait until ASYNCCNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.asynccnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx1250+.</p><h4 id=attributes-109>Attributes:&nbsp;<a class=headline-hash href=#attributes-109>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitdscnt-rocdlwaitdscntop><code>rocdl.s.wait.dscnt</code> (ROCDL::WaitDscntOp)&nbsp;<a class=headline-hash href=#rocdlswaitdscnt-rocdlwaitdscntop>¶</a></h3><p><em>Wait until DSCNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.dscnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx12+.</p><h4 id=attributes-110>Attributes:&nbsp;<a class=headline-hash href=#attributes-110>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitexpcnt-rocdlwaitexpcntop><code>rocdl.s.wait.expcnt</code> (ROCDL::WaitExpcntOp)&nbsp;<a class=headline-hash href=#rocdlswaitexpcnt-rocdlwaitexpcntop>¶</a></h3><p><em>Wait until EXPCNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.expcnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx12+.</p><h4 id=attributes-111>Attributes:&nbsp;<a class=headline-hash href=#attributes-111>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitloadcnt-rocdlwaitloadcntop><code>rocdl.s.wait.loadcnt</code> (ROCDL::WaitLoadcntOp)&nbsp;<a class=headline-hash href=#rocdlswaitloadcnt-rocdlwaitloadcntop>¶</a></h3><p><em>Wait until LOADCNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.loadcnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx12+.</p><h4 id=attributes-112>Attributes:&nbsp;<a class=headline-hash href=#attributes-112>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitstorecnt-rocdlwaitstorecntop><code>rocdl.s.wait.storecnt</code> (ROCDL::WaitStorecntOp)&nbsp;<a class=headline-hash href=#rocdlswaitstorecnt-rocdlwaitstorecntop>¶</a></h3><p><em>Wait until STORECNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.storecnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx12+.</p><h4 id=attributes-113>Attributes:&nbsp;<a class=headline-hash href=#attributes-113>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaittensorcnt-rocdlwaittensorcntop><code>rocdl.s.wait.tensorcnt</code> (ROCDL::WaitTensorcntOp)&nbsp;<a class=headline-hash href=#rocdlswaittensorcnt-rocdlwaittensorcntop>¶</a></h3><p><em>Wait until TENSORCNT is less than or equal to <code>count</code></em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.wait.tensorcnt` $count attr-dict
</code></pre><p>Wait for the counter specified to be less-than or equal-to the <code>count</code>
before continuing.</p><p>Available on gfx1250+.</p><h4 id=attributes-114>Attributes:&nbsp;<a class=headline-hash href=#attributes-114>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>count</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr></table><h3 id=rocdlswaitcnt-rocdlswaitcntop><code>rocdl.s.waitcnt</code> (ROCDL::SWaitcntOp)&nbsp;<a class=headline-hash href=#rocdlswaitcnt-rocdlswaitcntop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.s.waitcnt` attr-dict $bitfield
</code></pre><h4 id=attributes-115>Attributes:&nbsp;<a class=headline-hash href=#attributes-115>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>bitfield</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlschedbarrier-rocdlschedbarrier><code>rocdl.sched.barrier</code> (ROCDL::SchedBarrier)&nbsp;<a class=headline-hash href=#rocdlschedbarrier-rocdlschedbarrier>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.sched.barrier` $mask attr-dict
</code></pre><h4 id=attributes-116>Attributes:&nbsp;<a class=headline-hash href=#attributes-116>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlschedgroupbarrier-rocdlschedgroupbarrier><code>rocdl.sched.group.barrier</code> (ROCDL::SchedGroupBarrier)&nbsp;<a class=headline-hash href=#rocdlschedgroupbarrier-rocdlschedgroupbarrier>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.sched.group.barrier` $mask `,` $size `,` $groupId attr-dict
</code></pre><h4 id=attributes-117>Attributes:&nbsp;<a class=headline-hash href=#attributes-117>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>groupId</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h3 id=rocdlsin-rocdlrocdlsin><code>rocdl.sin</code> (ROCDL::ROCDLSin)&nbsp;<a class=headline-hash href=#rocdlsin-rocdlrocdlsin>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.sin` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-212>Operands:&nbsp;<a class=headline-hash href=#operands-212>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-193>Results:&nbsp;<a class=headline-hash href=#results-193>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x128bf8bf8-rocdlsmfmac_f32_16x16x128_bf8_bf8><code>rocdl.smfmac.f32.16x16x128.bf8.bf8</code> (ROCDL::smfmac_f32_16x16x128_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x128bf8bf8-rocdlsmfmac_f32_16x16x128_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x128.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-213>Operands:&nbsp;<a class=headline-hash href=#operands-213>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-194>Results:&nbsp;<a class=headline-hash href=#results-194>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x128bf8fp8-rocdlsmfmac_f32_16x16x128_bf8_fp8><code>rocdl.smfmac.f32.16x16x128.bf8.fp8</code> (ROCDL::smfmac_f32_16x16x128_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x128bf8fp8-rocdlsmfmac_f32_16x16x128_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x128.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-214>Operands:&nbsp;<a class=headline-hash href=#operands-214>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-195>Results:&nbsp;<a class=headline-hash href=#results-195>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x128fp8bf8-rocdlsmfmac_f32_16x16x128_fp8_bf8><code>rocdl.smfmac.f32.16x16x128.fp8.bf8</code> (ROCDL::smfmac_f32_16x16x128_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x128fp8bf8-rocdlsmfmac_f32_16x16x128_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x128.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-215>Operands:&nbsp;<a class=headline-hash href=#operands-215>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-196>Results:&nbsp;<a class=headline-hash href=#results-196>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x128fp8fp8-rocdlsmfmac_f32_16x16x128_fp8_fp8><code>rocdl.smfmac.f32.16x16x128.fp8.fp8</code> (ROCDL::smfmac_f32_16x16x128_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x128fp8fp8-rocdlsmfmac_f32_16x16x128_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x128.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-216>Operands:&nbsp;<a class=headline-hash href=#operands-216>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-197>Results:&nbsp;<a class=headline-hash href=#results-197>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x32bf16-rocdlsmfmac_f32_16x16x32_bf16><code>rocdl.smfmac.f32.16x16x32.bf16</code> (ROCDL::smfmac_f32_16x16x32_bf16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x32bf16-rocdlsmfmac_f32_16x16x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x32.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-217>Operands:&nbsp;<a class=headline-hash href=#operands-217>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-198>Results:&nbsp;<a class=headline-hash href=#results-198>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x32f16-rocdlsmfmac_f32_16x16x32_f16><code>rocdl.smfmac.f32.16x16x32.f16</code> (ROCDL::smfmac_f32_16x16x32_f16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x32f16-rocdlsmfmac_f32_16x16x32_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x32.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-218>Operands:&nbsp;<a class=headline-hash href=#operands-218>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-199>Results:&nbsp;<a class=headline-hash href=#results-199>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64bf16-rocdlsmfmac_f32_16x16x64_bf16><code>rocdl.smfmac.f32.16x16x64.bf16</code> (ROCDL::smfmac_f32_16x16x64_bf16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64bf16-rocdlsmfmac_f32_16x16x64_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-219>Operands:&nbsp;<a class=headline-hash href=#operands-219>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-200>Results:&nbsp;<a class=headline-hash href=#results-200>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64bf8bf8-rocdlsmfmac_f32_16x16x64_bf8_bf8><code>rocdl.smfmac.f32.16x16x64.bf8.bf8</code> (ROCDL::smfmac_f32_16x16x64_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64bf8bf8-rocdlsmfmac_f32_16x16x64_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-220>Operands:&nbsp;<a class=headline-hash href=#operands-220>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-201>Results:&nbsp;<a class=headline-hash href=#results-201>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64bf8fp8-rocdlsmfmac_f32_16x16x64_bf8_fp8><code>rocdl.smfmac.f32.16x16x64.bf8.fp8</code> (ROCDL::smfmac_f32_16x16x64_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64bf8fp8-rocdlsmfmac_f32_16x16x64_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-221>Operands:&nbsp;<a class=headline-hash href=#operands-221>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-202>Results:&nbsp;<a class=headline-hash href=#results-202>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64f16-rocdlsmfmac_f32_16x16x64_f16><code>rocdl.smfmac.f32.16x16x64.f16</code> (ROCDL::smfmac_f32_16x16x64_f16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64f16-rocdlsmfmac_f32_16x16x64_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-222>Operands:&nbsp;<a class=headline-hash href=#operands-222>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-203>Results:&nbsp;<a class=headline-hash href=#results-203>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64fp8bf8-rocdlsmfmac_f32_16x16x64_fp8_bf8><code>rocdl.smfmac.f32.16x16x64.fp8.bf8</code> (ROCDL::smfmac_f32_16x16x64_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64fp8bf8-rocdlsmfmac_f32_16x16x64_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-223>Operands:&nbsp;<a class=headline-hash href=#operands-223>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-204>Results:&nbsp;<a class=headline-hash href=#results-204>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3216x16x64fp8fp8-rocdlsmfmac_f32_16x16x64_fp8_fp8><code>rocdl.smfmac.f32.16x16x64.fp8.fp8</code> (ROCDL::smfmac_f32_16x16x64_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3216x16x64fp8fp8-rocdlsmfmac_f32_16x16x64_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.16x16x64.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-224>Operands:&nbsp;<a class=headline-hash href=#operands-224>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-205>Results:&nbsp;<a class=headline-hash href=#results-205>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x16bf16-rocdlsmfmac_f32_32x32x16_bf16><code>rocdl.smfmac.f32.32x32x16.bf16</code> (ROCDL::smfmac_f32_32x32x16_bf16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x16bf16-rocdlsmfmac_f32_32x32x16_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x16.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-225>Operands:&nbsp;<a class=headline-hash href=#operands-225>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-206>Results:&nbsp;<a class=headline-hash href=#results-206>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x16f16-rocdlsmfmac_f32_32x32x16_f16><code>rocdl.smfmac.f32.32x32x16.f16</code> (ROCDL::smfmac_f32_32x32x16_f16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x16f16-rocdlsmfmac_f32_32x32x16_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x16.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-226>Operands:&nbsp;<a class=headline-hash href=#operands-226>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-207>Results:&nbsp;<a class=headline-hash href=#results-207>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32bf16-rocdlsmfmac_f32_32x32x32_bf16><code>rocdl.smfmac.f32.32x32x32.bf16</code> (ROCDL::smfmac_f32_32x32x32_bf16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32bf16-rocdlsmfmac_f32_32x32x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.bf16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-227>Operands:&nbsp;<a class=headline-hash href=#operands-227>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-208>Results:&nbsp;<a class=headline-hash href=#results-208>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32bf8bf8-rocdlsmfmac_f32_32x32x32_bf8_bf8><code>rocdl.smfmac.f32.32x32x32.bf8.bf8</code> (ROCDL::smfmac_f32_32x32x32_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32bf8bf8-rocdlsmfmac_f32_32x32x32_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-228>Operands:&nbsp;<a class=headline-hash href=#operands-228>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-209>Results:&nbsp;<a class=headline-hash href=#results-209>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32bf8fp8-rocdlsmfmac_f32_32x32x32_bf8_fp8><code>rocdl.smfmac.f32.32x32x32.bf8.fp8</code> (ROCDL::smfmac_f32_32x32x32_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32bf8fp8-rocdlsmfmac_f32_32x32x32_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-229>Operands:&nbsp;<a class=headline-hash href=#operands-229>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-210>Results:&nbsp;<a class=headline-hash href=#results-210>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32f16-rocdlsmfmac_f32_32x32x32_f16><code>rocdl.smfmac.f32.32x32x32.f16</code> (ROCDL::smfmac_f32_32x32x32_f16)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32f16-rocdlsmfmac_f32_32x32x32_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.f16` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-230>Operands:&nbsp;<a class=headline-hash href=#operands-230>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-211>Results:&nbsp;<a class=headline-hash href=#results-211>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32fp8bf8-rocdlsmfmac_f32_32x32x32_fp8_bf8><code>rocdl.smfmac.f32.32x32x32.fp8.bf8</code> (ROCDL::smfmac_f32_32x32x32_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32fp8bf8-rocdlsmfmac_f32_32x32x32_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-231>Operands:&nbsp;<a class=headline-hash href=#operands-231>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-212>Results:&nbsp;<a class=headline-hash href=#results-212>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x32fp8fp8-rocdlsmfmac_f32_32x32x32_fp8_fp8><code>rocdl.smfmac.f32.32x32x32.fp8.fp8</code> (ROCDL::smfmac_f32_32x32x32_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x32fp8fp8-rocdlsmfmac_f32_32x32x32_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x32.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-232>Operands:&nbsp;<a class=headline-hash href=#operands-232>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-213>Results:&nbsp;<a class=headline-hash href=#results-213>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x64bf8bf8-rocdlsmfmac_f32_32x32x64_bf8_bf8><code>rocdl.smfmac.f32.32x32x64.bf8.bf8</code> (ROCDL::smfmac_f32_32x32x64_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x64bf8bf8-rocdlsmfmac_f32_32x32x64_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x64.bf8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-233>Operands:&nbsp;<a class=headline-hash href=#operands-233>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-214>Results:&nbsp;<a class=headline-hash href=#results-214>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x64bf8fp8-rocdlsmfmac_f32_32x32x64_bf8_fp8><code>rocdl.smfmac.f32.32x32x64.bf8.fp8</code> (ROCDL::smfmac_f32_32x32x64_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x64bf8fp8-rocdlsmfmac_f32_32x32x64_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x64.bf8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-234>Operands:&nbsp;<a class=headline-hash href=#operands-234>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-215>Results:&nbsp;<a class=headline-hash href=#results-215>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x64fp8bf8-rocdlsmfmac_f32_32x32x64_fp8_bf8><code>rocdl.smfmac.f32.32x32x64.fp8.bf8</code> (ROCDL::smfmac_f32_32x32x64_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x64fp8bf8-rocdlsmfmac_f32_32x32x64_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x64.fp8.bf8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-235>Operands:&nbsp;<a class=headline-hash href=#operands-235>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-216>Results:&nbsp;<a class=headline-hash href=#results-216>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmacf3232x32x64fp8fp8-rocdlsmfmac_f32_32x32x64_fp8_fp8><code>rocdl.smfmac.f32.32x32x64.fp8.fp8</code> (ROCDL::smfmac_f32_32x32x64_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlsmfmacf3232x32x64fp8fp8-rocdlsmfmac_f32_32x32x64_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.f32.32x32x64.fp8.fp8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-236>Operands:&nbsp;<a class=headline-hash href=#operands-236>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-217>Results:&nbsp;<a class=headline-hash href=#results-217>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmaci3216x16x128i8-rocdlsmfmac_i32_16x16x128_i8><code>rocdl.smfmac.i32.16x16x128.i8</code> (ROCDL::smfmac_i32_16x16x128_i8)&nbsp;<a class=headline-hash href=#rocdlsmfmaci3216x16x128i8-rocdlsmfmac_i32_16x16x128_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.i32.16x16x128.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-237>Operands:&nbsp;<a class=headline-hash href=#operands-237>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-218>Results:&nbsp;<a class=headline-hash href=#results-218>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmaci3216x16x64i8-rocdlsmfmac_i32_16x16x64_i8><code>rocdl.smfmac.i32.16x16x64.i8</code> (ROCDL::smfmac_i32_16x16x64_i8)&nbsp;<a class=headline-hash href=#rocdlsmfmaci3216x16x64i8-rocdlsmfmac_i32_16x16x64_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.i32.16x16x64.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-238>Operands:&nbsp;<a class=headline-hash href=#operands-238>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-219>Results:&nbsp;<a class=headline-hash href=#results-219>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmaci3232x32x32i8-rocdlsmfmac_i32_32x32x32_i8><code>rocdl.smfmac.i32.32x32x32.i8</code> (ROCDL::smfmac_i32_32x32x32_i8)&nbsp;<a class=headline-hash href=#rocdlsmfmaci3232x32x32i8-rocdlsmfmac_i32_32x32x32_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.i32.32x32x32.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-239>Operands:&nbsp;<a class=headline-hash href=#operands-239>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-220>Results:&nbsp;<a class=headline-hash href=#results-220>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsmfmaci3232x32x64i8-rocdlsmfmac_i32_32x32x64_i8><code>rocdl.smfmac.i32.32x32x64.i8</code> (ROCDL::smfmac_i32_32x32x64_i8)&nbsp;<a class=headline-hash href=#rocdlsmfmaci3232x32x64i8-rocdlsmfmac_i32_32x32x64_i8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.smfmac.i32.32x32x64.i8` $args attr-dict `:` functional-type($args, $res)
</code></pre><h4 id=operands-240>Operands:&nbsp;<a class=headline-hash href=#operands-240>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-221>Results:&nbsp;<a class=headline-hash href=#results-221>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlsqrt-rocdlrocdlsqrt><code>rocdl.sqrt</code> (ROCDL::ROCDLSqrt)&nbsp;<a class=headline-hash href=#rocdlsqrt-rocdlrocdlsqrt>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.sqrt` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-241>Operands:&nbsp;<a class=headline-hash href=#operands-241>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-222>Results:&nbsp;<a class=headline-hash href=#results-222>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdltanh-rocdlrocdltanh><code>rocdl.tanh</code> (ROCDL::ROCDLTanh)&nbsp;<a class=headline-hash href=#rocdltanh-rocdlrocdltanh>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.tanh` $arg qualified(type($arg)) attr-dict `-&gt;` qualified(type($res))
</code></pre><p>Note: In the general case, prefer the conventional <code>arith</code>, <code>math</code>, or <code>llvm</code> ops over this.
Use this ROCDL-specific operation only when you fully understand its implication and
when it is strictly necessary. This op is usually chosen when a small loss in precision is
acceptable in exchange for higher execution speed.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-242>Operands:&nbsp;<a class=headline-hash href=#operands-242>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-223>Results:&nbsp;<a class=headline-hash href=#results-223>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type</td></tr></tbody></table><h3 id=rocdltensorloadtolds-rocdltensorloadtoldsop><code>rocdl.tensor.load.to.lds</code> (ROCDL::TensorLoadToLDSOp)&nbsp;<a class=headline-hash href=#rocdltensorloadtolds-rocdltensorloadtoldsop>¶</a></h3><p><em>Base class for ROCDL tensor load/store to/from LDS.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.tensor.load.to.lds` attr-dict operands `cachepolicy` $cachePolicy `:` type($dgroup0) `,` type($dgroup1)
</code></pre><p>Moves tiles of tensor data between global memory and LDS. The tile is
described by the $dgroup descriptors. 4 $dgroup descriptors allows for
movement of up to 5D tensors. $cachePolicy describes the memory scope and an
indicator of expected data re-use.</p><p>This op is for gfx1250+ architectures.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-118>Attributes:&nbsp;<a class=headline-hash href=#attributes-118>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cachePolicy</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-243>Operands:&nbsp;<a class=headline-hash href=#operands-243>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dgroup0</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup1</code></td><td>fixed-length vector of 32-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>dgroup2</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup3</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=rocdltensorloadtoldsd2-rocdltensorloadtoldsd2op><code>rocdl.tensor.load.to.lds.d2</code> (ROCDL::TensorLoadToLDSD2Op)&nbsp;<a class=headline-hash href=#rocdltensorloadtoldsd2-rocdltensorloadtoldsd2op>¶</a></h3><p><em>Base class for ROCDL tensor load/store to/from LDS (D2 variant).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.tensor.load.to.lds.d2` attr-dict operands `cachepolicy` $cachePolicy `:` type($dgroup0) `,` type($dgroup1)
</code></pre><p>Moves tiles of tensor data between global memory and LDS. The tile is
described by the $dgroup descriptors. 2 $dgroup descriptors allows for
movement of up to 2D tensors. $cachePolicy describes the memory scope and an
indicator of expected data re-use.</p><p>This op is for gfx1250+ architectures.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-119>Attributes:&nbsp;<a class=headline-hash href=#attributes-119>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cachePolicy</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-244>Operands:&nbsp;<a class=headline-hash href=#operands-244>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dgroup0</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup1</code></td><td>fixed-length vector of 32-bit signless integer values of length 8</td></tr></tbody></table><h3 id=rocdltensorstorefromlds-rocdltensorstorefromldsop><code>rocdl.tensor.store.from.lds</code> (ROCDL::TensorStoreFromLDSOp)&nbsp;<a class=headline-hash href=#rocdltensorstorefromlds-rocdltensorstorefromldsop>¶</a></h3><p><em>Base class for ROCDL tensor load/store to/from LDS.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.tensor.store.from.lds` attr-dict operands `cachepolicy` $cachePolicy `:` type($dgroup0) `,` type($dgroup1)
</code></pre><p>Moves tiles of tensor data between global memory and LDS. The tile is
described by the $dgroup descriptors. 4 $dgroup descriptors allows for
movement of up to 5D tensors. $cachePolicy describes the memory scope and an
indicator of expected data re-use.</p><p>This op is for gfx1250+ architectures.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-120>Attributes:&nbsp;<a class=headline-hash href=#attributes-120>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cachePolicy</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-245>Operands:&nbsp;<a class=headline-hash href=#operands-245>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dgroup0</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup1</code></td><td>fixed-length vector of 32-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>dgroup2</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup3</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=rocdltensorstorefromldsd2-rocdltensorstorefromldsd2op><code>rocdl.tensor.store.from.lds.d2</code> (ROCDL::TensorStoreFromLDSD2Op)&nbsp;<a class=headline-hash href=#rocdltensorstorefromldsd2-rocdltensorstorefromldsd2op>¶</a></h3><p><em>Base class for ROCDL tensor load/store to/from LDS (D2 variant).</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.tensor.store.from.lds.d2` attr-dict operands `cachepolicy` $cachePolicy `:` type($dgroup0) `,` type($dgroup1)
</code></pre><p>Moves tiles of tensor data between global memory and LDS. The tile is
described by the $dgroup descriptors. 2 $dgroup descriptors allows for
movement of up to 2D tensors. $cachePolicy describes the memory scope and an
indicator of expected data re-use.</p><p>This op is for gfx1250+ architectures.</p><p>Interfaces: <code>AliasAnalysisOpInterface</code></p><h4 id=attributes-121>Attributes:&nbsp;<a class=headline-hash href=#attributes-121>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cachePolicy</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-246>Operands:&nbsp;<a class=headline-hash href=#operands-246>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dgroup0</code></td><td>fixed-length vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>dgroup1</code></td><td>fixed-length vector of 32-bit signless integer values of length 8</td></tr></tbody></table><h3 id=rocdlupdatedpp-rocdldppupdateop><code>rocdl.update.dpp</code> (ROCDL::DPPUpdateOp)&nbsp;<a class=headline-hash href=#rocdlupdatedpp-rocdldppupdateop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.update.dpp` attr-dict $old `,` $src `with` $dppCtrl `,` $rowMask `,` $bankMask `,` $boundCtrl `:` type($src)
</code></pre><h4 id=attributes-122>Attributes:&nbsp;<a class=headline-hash href=#attributes-122>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dppCtrl</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>rowMask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>bankMask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>boundCtrl</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-247>Operands:&nbsp;<a class=headline-hash href=#operands-247>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>old</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-224>Results:&nbsp;<a class=headline-hash href=#results-224>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlwavefrontsize-rocdlwavefrontsizeop><code>rocdl.wavefrontsize</code> (ROCDL::WavefrontSizeOp)&nbsp;<a class=headline-hash href=#rocdlwavefrontsize-rocdlwavefrontsizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wavefrontsize` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-123>Attributes:&nbsp;<a class=headline-hash href=#attributes-123>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-225>Results:&nbsp;<a class=headline-hash href=#results-225>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlwmmabf1616x16x16bf16-rocdlwmma_bf16_16x16x16_bf16><code>rocdl.wmma.bf16.16x16x16.bf16</code> (ROCDL::wmma_bf16_16x16x16_bf16)&nbsp;<a class=headline-hash href=#rocdlwmmabf1616x16x16bf16-rocdlwmma_bf16_16x16x16_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.bf16.16x16x16.bf16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-124>Attributes:&nbsp;<a class=headline-hash href=#attributes-124>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>opsel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-248>Operands:&nbsp;<a class=headline-hash href=#operands-248>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-226>Results:&nbsp;<a class=headline-hash href=#results-226>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h3 id=rocdlwmmabf1616x16x32bf16-rocdlwmma_bf16_16x16x32_bf16><code>rocdl.wmma.bf16.16x16x32.bf16</code> (ROCDL::wmma_bf16_16x16x32_bf16)&nbsp;<a class=headline-hash href=#rocdlwmmabf1616x16x32bf16-rocdlwmma_bf16_16x16x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.bf16.16x16x32.bf16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-125>Attributes:&nbsp;<a class=headline-hash href=#attributes-125>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-249>Operands:&nbsp;<a class=headline-hash href=#operands-249>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>b</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>c</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr></tbody></table><h4 id=results-227>Results:&nbsp;<a class=headline-hash href=#results-227>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr></tbody></table><h3 id=rocdlwmmabf16f3216x16x32bf16-rocdlwmma_bf16f32_16x16x32_bf16><code>rocdl.wmma.bf16f32.16x16x32.bf16</code> (ROCDL::wmma_bf16f32_16x16x32_bf16)&nbsp;<a class=headline-hash href=#rocdlwmmabf16f3216x16x32bf16-rocdlwmma_bf16f32_16x16x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.bf16f32.16x16x32.bf16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-126>Attributes:&nbsp;<a class=headline-hash href=#attributes-126>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-250>Operands:&nbsp;<a class=headline-hash href=#operands-250>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>b</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-228>Results:&nbsp;<a class=headline-hash href=#results-228>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x128bf8_bf8-rocdlwmma_f16_16x16x128_bf8_bf8><code>rocdl.wmma.f16.16x16x128.bf8_bf8</code> (ROCDL::wmma_f16_16x16x128_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x128bf8_bf8-rocdlwmma_f16_16x16x128_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x128.bf8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-127>Attributes:&nbsp;<a class=headline-hash href=#attributes-127>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-251>Operands:&nbsp;<a class=headline-hash href=#operands-251>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-229>Results:&nbsp;<a class=headline-hash href=#results-229>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x128bf8_fp8-rocdlwmma_f16_16x16x128_bf8_fp8><code>rocdl.wmma.f16.16x16x128.bf8_fp8</code> (ROCDL::wmma_f16_16x16x128_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x128bf8_fp8-rocdlwmma_f16_16x16x128_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x128.bf8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-128>Attributes:&nbsp;<a class=headline-hash href=#attributes-128>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-252>Operands:&nbsp;<a class=headline-hash href=#operands-252>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-230>Results:&nbsp;<a class=headline-hash href=#results-230>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x128fp8_bf8-rocdlwmma_f16_16x16x128_fp8_bf8><code>rocdl.wmma.f16.16x16x128.fp8_bf8</code> (ROCDL::wmma_f16_16x16x128_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x128fp8_bf8-rocdlwmma_f16_16x16x128_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x128.fp8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-129>Attributes:&nbsp;<a class=headline-hash href=#attributes-129>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-253>Operands:&nbsp;<a class=headline-hash href=#operands-253>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-231>Results:&nbsp;<a class=headline-hash href=#results-231>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x128fp8_fp8-rocdlwmma_f16_16x16x128_fp8_fp8><code>rocdl.wmma.f16.16x16x128.fp8_fp8</code> (ROCDL::wmma_f16_16x16x128_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x128fp8_fp8-rocdlwmma_f16_16x16x128_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x128.fp8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-130>Attributes:&nbsp;<a class=headline-hash href=#attributes-130>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-254>Operands:&nbsp;<a class=headline-hash href=#operands-254>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-232>Results:&nbsp;<a class=headline-hash href=#results-232>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x16f16-rocdlwmma_f16_16x16x16_f16><code>rocdl.wmma.f16.16x16x16.f16</code> (ROCDL::wmma_f16_16x16x16_f16)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x16f16-rocdlwmma_f16_16x16x16_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x16.f16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-131>Attributes:&nbsp;<a class=headline-hash href=#attributes-131>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>opsel</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-255>Operands:&nbsp;<a class=headline-hash href=#operands-255>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-233>Results:&nbsp;<a class=headline-hash href=#results-233>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x32f16-rocdlwmma_f16_16x16x32_f16><code>rocdl.wmma.f16.16x16x32.f16</code> (ROCDL::wmma_f16_16x16x32_f16)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x32f16-rocdlwmma_f16_16x16x32_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x32.f16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-132>Attributes:&nbsp;<a class=headline-hash href=#attributes-132>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-256>Operands:&nbsp;<a class=headline-hash href=#operands-256>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-234>Results:&nbsp;<a class=headline-hash href=#results-234>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x64bf8_bf8-rocdlwmma_f16_16x16x64_bf8_bf8><code>rocdl.wmma.f16.16x16x64.bf8_bf8</code> (ROCDL::wmma_f16_16x16x64_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x64bf8_bf8-rocdlwmma_f16_16x16x64_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x64.bf8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-133>Attributes:&nbsp;<a class=headline-hash href=#attributes-133>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-257>Operands:&nbsp;<a class=headline-hash href=#operands-257>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-235>Results:&nbsp;<a class=headline-hash href=#results-235>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x64bf8_fp8-rocdlwmma_f16_16x16x64_bf8_fp8><code>rocdl.wmma.f16.16x16x64.bf8_fp8</code> (ROCDL::wmma_f16_16x16x64_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x64bf8_fp8-rocdlwmma_f16_16x16x64_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x64.bf8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-134>Attributes:&nbsp;<a class=headline-hash href=#attributes-134>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-258>Operands:&nbsp;<a class=headline-hash href=#operands-258>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-236>Results:&nbsp;<a class=headline-hash href=#results-236>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x64fp8_bf8-rocdlwmma_f16_16x16x64_fp8_bf8><code>rocdl.wmma.f16.16x16x64.fp8_bf8</code> (ROCDL::wmma_f16_16x16x64_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x64fp8_bf8-rocdlwmma_f16_16x16x64_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x64.fp8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-135>Attributes:&nbsp;<a class=headline-hash href=#attributes-135>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-259>Operands:&nbsp;<a class=headline-hash href=#operands-259>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-237>Results:&nbsp;<a class=headline-hash href=#results-237>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf1616x16x64fp8_fp8-rocdlwmma_f16_16x16x64_fp8_fp8><code>rocdl.wmma.f16.16x16x64.fp8_fp8</code> (ROCDL::wmma_f16_16x16x64_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf1616x16x64fp8_fp8-rocdlwmma_f16_16x16x64_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f16.16x16x64.fp8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-136>Attributes:&nbsp;<a class=headline-hash href=#attributes-136>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-260>Operands:&nbsp;<a class=headline-hash href=#operands-260>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h4 id=results-238>Results:&nbsp;<a class=headline-hash href=#results-238>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x128bf8_bf8-rocdlwmma_f32_16x16x128_bf8_bf8><code>rocdl.wmma.f32.16x16x128.bf8_bf8</code> (ROCDL::wmma_f32_16x16x128_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x128bf8_bf8-rocdlwmma_f32_16x16x128_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x128.bf8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-137>Attributes:&nbsp;<a class=headline-hash href=#attributes-137>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-261>Operands:&nbsp;<a class=headline-hash href=#operands-261>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-239>Results:&nbsp;<a class=headline-hash href=#results-239>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x128bf8_fp8-rocdlwmma_f32_16x16x128_bf8_fp8><code>rocdl.wmma.f32.16x16x128.bf8_fp8</code> (ROCDL::wmma_f32_16x16x128_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x128bf8_fp8-rocdlwmma_f32_16x16x128_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x128.bf8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-138>Attributes:&nbsp;<a class=headline-hash href=#attributes-138>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-262>Operands:&nbsp;<a class=headline-hash href=#operands-262>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-240>Results:&nbsp;<a class=headline-hash href=#results-240>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x128fp8_bf8-rocdlwmma_f32_16x16x128_fp8_bf8><code>rocdl.wmma.f32.16x16x128.fp8_bf8</code> (ROCDL::wmma_f32_16x16x128_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x128fp8_bf8-rocdlwmma_f32_16x16x128_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x128.fp8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-139>Attributes:&nbsp;<a class=headline-hash href=#attributes-139>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-263>Operands:&nbsp;<a class=headline-hash href=#operands-263>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-241>Results:&nbsp;<a class=headline-hash href=#results-241>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x128fp8_fp8-rocdlwmma_f32_16x16x128_fp8_fp8><code>rocdl.wmma.f32.16x16x128.fp8_fp8</code> (ROCDL::wmma_f32_16x16x128_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x128fp8_fp8-rocdlwmma_f32_16x16x128_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x128.fp8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-140>Attributes:&nbsp;<a class=headline-hash href=#attributes-140>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-264>Operands:&nbsp;<a class=headline-hash href=#operands-264>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-242>Results:&nbsp;<a class=headline-hash href=#results-242>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16bf16-rocdlwmma_f32_16x16x16_bf16><code>rocdl.wmma.f32.16x16x16.bf16</code> (ROCDL::wmma_f32_16x16x16_bf16)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16bf16-rocdlwmma_f32_16x16x16_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.bf16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-265>Operands:&nbsp;<a class=headline-hash href=#operands-265>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-243>Results:&nbsp;<a class=headline-hash href=#results-243>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16bf8_bf8-rocdlwmma_f32_16x16x16_bf8_bf8><code>rocdl.wmma.f32.16x16x16.bf8_bf8</code> (ROCDL::wmma_f32_16x16x16_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16bf8_bf8-rocdlwmma_f32_16x16x16_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.bf8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-266>Operands:&nbsp;<a class=headline-hash href=#operands-266>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-244>Results:&nbsp;<a class=headline-hash href=#results-244>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16bf8_fp8-rocdlwmma_f32_16x16x16_bf8_fp8><code>rocdl.wmma.f32.16x16x16.bf8_fp8</code> (ROCDL::wmma_f32_16x16x16_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16bf8_fp8-rocdlwmma_f32_16x16x16_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.bf8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-267>Operands:&nbsp;<a class=headline-hash href=#operands-267>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-245>Results:&nbsp;<a class=headline-hash href=#results-245>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16f16-rocdlwmma_f32_16x16x16_f16><code>rocdl.wmma.f32.16x16x16.f16</code> (ROCDL::wmma_f32_16x16x16_f16)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16f16-rocdlwmma_f32_16x16x16_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.f16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-268>Operands:&nbsp;<a class=headline-hash href=#operands-268>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-246>Results:&nbsp;<a class=headline-hash href=#results-246>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16fp8_bf8-rocdlwmma_f32_16x16x16_fp8_bf8><code>rocdl.wmma.f32.16x16x16.fp8_bf8</code> (ROCDL::wmma_f32_16x16x16_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16fp8_bf8-rocdlwmma_f32_16x16x16_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.fp8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-269>Operands:&nbsp;<a class=headline-hash href=#operands-269>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-247>Results:&nbsp;<a class=headline-hash href=#results-247>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x16fp8_fp8-rocdlwmma_f32_16x16x16_fp8_fp8><code>rocdl.wmma.f32.16x16x16.fp8_fp8</code> (ROCDL::wmma_f32_16x16x16_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x16fp8_fp8-rocdlwmma_f32_16x16x16_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x16.fp8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=operands-270>Operands:&nbsp;<a class=headline-hash href=#operands-270>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-248>Results:&nbsp;<a class=headline-hash href=#results-248>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x32bf16-rocdlwmma_f32_16x16x32_bf16><code>rocdl.wmma.f32.16x16x32.bf16</code> (ROCDL::wmma_f32_16x16x32_bf16)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x32bf16-rocdlwmma_f32_16x16x32_bf16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x32.bf16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-141>Attributes:&nbsp;<a class=headline-hash href=#attributes-141>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-271>Operands:&nbsp;<a class=headline-hash href=#operands-271>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>b</code></td><td>bfloat16 type or LLVM dialect-compatible vector of bfloat16 type</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-249>Results:&nbsp;<a class=headline-hash href=#results-249>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x32f16-rocdlwmma_f32_16x16x32_f16><code>rocdl.wmma.f32.16x16x32.f16</code> (ROCDL::wmma_f32_16x16x32_f16)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x32f16-rocdlwmma_f32_16x16x32_f16>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x32.f16` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-142>Attributes:&nbsp;<a class=headline-hash href=#attributes-142>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-272>Operands:&nbsp;<a class=headline-hash href=#operands-272>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>16-bit float or LLVM dialect-compatible vector of 16-bit float</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-250>Results:&nbsp;<a class=headline-hash href=#results-250>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x4f32-rocdlwmma_f32_16x16x4_f32><code>rocdl.wmma.f32.16x16x4.f32</code> (ROCDL::wmma_f32_16x16x4_f32)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x4f32-rocdlwmma_f32_16x16x4_f32>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x4.f32` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-143>Attributes:&nbsp;<a class=headline-hash href=#attributes-143>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-273>Operands:&nbsp;<a class=headline-hash href=#operands-273>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>b</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-251>Results:&nbsp;<a class=headline-hash href=#results-251>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x64bf8_bf8-rocdlwmma_f32_16x16x64_bf8_bf8><code>rocdl.wmma.f32.16x16x64.bf8_bf8</code> (ROCDL::wmma_f32_16x16x64_bf8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x64bf8_bf8-rocdlwmma_f32_16x16x64_bf8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x64.bf8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-144>Attributes:&nbsp;<a class=headline-hash href=#attributes-144>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-274>Operands:&nbsp;<a class=headline-hash href=#operands-274>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-252>Results:&nbsp;<a class=headline-hash href=#results-252>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x64bf8_fp8-rocdlwmma_f32_16x16x64_bf8_fp8><code>rocdl.wmma.f32.16x16x64.bf8_fp8</code> (ROCDL::wmma_f32_16x16x64_bf8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x64bf8_fp8-rocdlwmma_f32_16x16x64_bf8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x64.bf8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-145>Attributes:&nbsp;<a class=headline-hash href=#attributes-145>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-275>Operands:&nbsp;<a class=headline-hash href=#operands-275>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-253>Results:&nbsp;<a class=headline-hash href=#results-253>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x64fp8_bf8-rocdlwmma_f32_16x16x64_fp8_bf8><code>rocdl.wmma.f32.16x16x64.fp8_bf8</code> (ROCDL::wmma_f32_16x16x64_fp8_bf8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x64fp8_bf8-rocdlwmma_f32_16x16x64_fp8_bf8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x64.fp8_bf8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-146>Attributes:&nbsp;<a class=headline-hash href=#attributes-146>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-276>Operands:&nbsp;<a class=headline-hash href=#operands-276>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-254>Results:&nbsp;<a class=headline-hash href=#results-254>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmaf3216x16x64fp8_fp8-rocdlwmma_f32_16x16x64_fp8_fp8><code>rocdl.wmma.f32.16x16x64.fp8_fp8</code> (ROCDL::wmma_f32_16x16x64_fp8_fp8)&nbsp;<a class=headline-hash href=#rocdlwmmaf3216x16x64fp8_fp8-rocdlwmma_f32_16x16x64_fp8_fp8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.f32.16x16x64.fp8_fp8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-147>Attributes:&nbsp;<a class=headline-hash href=#attributes-147>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-277>Operands:&nbsp;<a class=headline-hash href=#operands-277>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h4 id=results-255>Results:&nbsp;<a class=headline-hash href=#results-255>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmai3216x16x16iu4-rocdlwmma_i32_16x16x16_iu4><code>rocdl.wmma.i32.16x16x16.iu4</code> (ROCDL::wmma_i32_16x16x16_iu4)&nbsp;<a class=headline-hash href=#rocdlwmmai3216x16x16iu4-rocdlwmma_i32_16x16x16_iu4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.i32.16x16x16.iu4` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-148>Attributes:&nbsp;<a class=headline-hash href=#attributes-148>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>clamp</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-278>Operands:&nbsp;<a class=headline-hash href=#operands-278>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-256>Results:&nbsp;<a class=headline-hash href=#results-256>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h3 id=rocdlwmmai3216x16x16iu8-rocdlwmma_i32_16x16x16_iu8><code>rocdl.wmma.i32.16x16x16.iu8</code> (ROCDL::wmma_i32_16x16x16_iu8)&nbsp;<a class=headline-hash href=#rocdlwmmai3216x16x16iu8-rocdlwmma_i32_16x16x16_iu8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.i32.16x16x16.iu8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-149>Attributes:&nbsp;<a class=headline-hash href=#attributes-149>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>clamp</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-279>Operands:&nbsp;<a class=headline-hash href=#operands-279>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-257>Results:&nbsp;<a class=headline-hash href=#results-257>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h3 id=rocdlwmmai3216x16x32iu4-rocdlwmma_i32_16x16x32_iu4><code>rocdl.wmma.i32.16x16x32.iu4</code> (ROCDL::wmma_i32_16x16x32_iu4)&nbsp;<a class=headline-hash href=#rocdlwmmai3216x16x32iu4-rocdlwmma_i32_16x16x32_iu4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.i32.16x16x32.iu4` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-150>Attributes:&nbsp;<a class=headline-hash href=#attributes-150>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>clamp</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-280>Operands:&nbsp;<a class=headline-hash href=#operands-280>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-258>Results:&nbsp;<a class=headline-hash href=#results-258>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h3 id=rocdlwmmai3216x16x64iu8-rocdlwmma_i32_16x16x64_iu8><code>rocdl.wmma.i32.16x16x64.iu8</code> (ROCDL::wmma_i32_16x16x64_iu8)&nbsp;<a class=headline-hash href=#rocdlwmmai3216x16x64iu8-rocdlwmma_i32_16x16x64_iu8>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.i32.16x16x64.iu8` $a `,` $b `,` $c attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-151>Attributes:&nbsp;<a class=headline-hash href=#attributes-151>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>signA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>signB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-281>Operands:&nbsp;<a class=headline-hash href=#operands-281>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-259>Results:&nbsp;<a class=headline-hash href=#results-259>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h3 id=rocdlwmmascalef3216x16x128f8f6f4-rocdlwmma_scale_f32_16x16x128_f8f6f4><code>rocdl.wmma.scale.f32.16x16x128.f8f6f4</code> (ROCDL::wmma_scale_f32_16x16x128_f8f6f4)&nbsp;<a class=headline-hash href=#rocdlwmmascalef3216x16x128f8f6f4-rocdlwmma_scale_f32_16x16x128_f8f6f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.scale.f32.16x16x128.f8f6f4` $a `,` $b `,` $c `,` $scaleA `,` $scaleB attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-152>Attributes:&nbsp;<a class=headline-hash href=#attributes-152>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fmtA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>scaleAType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>scaleBType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-282>Operands:&nbsp;<a class=headline-hash href=#operands-282>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>scaleA</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scaleB</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-260>Results:&nbsp;<a class=headline-hash href=#results-260>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmascalef3232x16x128f4-rocdlwmma_scale_f32_32x16x128_f4><code>rocdl.wmma.scale.f32.32x16x128.f4</code> (ROCDL::wmma_scale_f32_32x16x128_f4)&nbsp;<a class=headline-hash href=#rocdlwmmascalef3232x16x128f4-rocdlwmma_scale_f32_32x16x128_f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.scale.f32.32x16x128.f4` $a `,` $b `,` $c `,` $scaleA `,` $scaleB attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-153>Attributes:&nbsp;<a class=headline-hash href=#attributes-153>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>scaleAType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>scaleBType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-283>Operands:&nbsp;<a class=headline-hash href=#operands-283>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>scaleA</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>scaleB</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-261>Results:&nbsp;<a class=headline-hash href=#results-261>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmascale16f3216x16x128f8f6f4-rocdlwmma_scale16_f32_16x16x128_f8f6f4><code>rocdl.wmma.scale16.f32.16x16x128.f8f6f4</code> (ROCDL::wmma_scale16_f32_16x16x128_f8f6f4)&nbsp;<a class=headline-hash href=#rocdlwmmascale16f3216x16x128f8f6f4-rocdlwmma_scale16_f32_16x16x128_f8f6f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.scale16.f32.16x16x128.f8f6f4` $a `,` $b `,` $c `,` $scaleA `,` $scaleB attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-154>Attributes:&nbsp;<a class=headline-hash href=#attributes-154>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fmtA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>scaleAType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>scaleBType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-284>Operands:&nbsp;<a class=headline-hash href=#operands-284>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>scaleA</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>scaleB</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-262>Results:&nbsp;<a class=headline-hash href=#results-262>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlwmmascale16f3232x16x128f4-rocdlwmma_scale16_f32_32x16x128_f4><code>rocdl.wmma.scale16.f32.32x16x128.f4</code> (ROCDL::wmma_scale16_f32_32x16x128_f4)&nbsp;<a class=headline-hash href=#rocdlwmmascale16f3232x16x128f4-rocdlwmma_scale16_f32_32x16x128_f4>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.wmma.scale16.f32.32x16x128.f4` $a `,` $b `,` $c `,` $scaleA `,` $scaleB attr-dict `:` functional-type(operands, $res)
</code></pre><h4 id=attributes-155>Attributes:&nbsp;<a class=headline-hash href=#attributes-155>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>modC</code></td><td>::mlir::IntegerAttr</td><td>16-bit signless integer attribute</td></tr><tr><td><code>scaleAType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleA</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>scaleBType</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>fmtScaleB</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>reuseA</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>reuseB</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-285>Operands:&nbsp;<a class=headline-hash href=#operands-285>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr><tr><td style=text-align:center><code>scaleA</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>scaleB</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-263>Results:&nbsp;<a class=headline-hash href=#results-263>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit float or LLVM dialect-compatible vector of 32-bit float</td></tr></tbody></table><h3 id=rocdlworkgroupdimx-rocdlblockdimxop><code>rocdl.workgroup.dim.x</code> (ROCDL::BlockDimXOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupdimx-rocdlblockdimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.dim.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-156>Attributes:&nbsp;<a class=headline-hash href=#attributes-156>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-264>Results:&nbsp;<a class=headline-hash href=#results-264>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkgroupdimy-rocdlblockdimyop><code>rocdl.workgroup.dim.y</code> (ROCDL::BlockDimYOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupdimy-rocdlblockdimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.dim.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-157>Attributes:&nbsp;<a class=headline-hash href=#attributes-157>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-265>Results:&nbsp;<a class=headline-hash href=#results-265>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkgroupdimz-rocdlblockdimzop><code>rocdl.workgroup.dim.z</code> (ROCDL::BlockDimZOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupdimz-rocdlblockdimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.dim.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-158>Attributes:&nbsp;<a class=headline-hash href=#attributes-158>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-266>Results:&nbsp;<a class=headline-hash href=#results-266>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkgroupidx-rocdlblockidxop><code>rocdl.workgroup.id.x</code> (ROCDL::BlockIdXOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupidx-rocdlblockidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.id.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-159>Attributes:&nbsp;<a class=headline-hash href=#attributes-159>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-267>Results:&nbsp;<a class=headline-hash href=#results-267>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkgroupidy-rocdlblockidyop><code>rocdl.workgroup.id.y</code> (ROCDL::BlockIdYOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupidy-rocdlblockidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.id.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-160>Attributes:&nbsp;<a class=headline-hash href=#attributes-160>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-268>Results:&nbsp;<a class=headline-hash href=#results-268>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkgroupidz-rocdlblockidzop><code>rocdl.workgroup.id.z</code> (ROCDL::BlockIdZOp)&nbsp;<a class=headline-hash href=#rocdlworkgroupidz-rocdlblockidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workgroup.id.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-161>Attributes:&nbsp;<a class=headline-hash href=#attributes-161>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-269>Results:&nbsp;<a class=headline-hash href=#results-269>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkitemidx-rocdlthreadidxop><code>rocdl.workitem.id.x</code> (ROCDL::ThreadIdXOp)&nbsp;<a class=headline-hash href=#rocdlworkitemidx-rocdlthreadidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workitem.id.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-162>Attributes:&nbsp;<a class=headline-hash href=#attributes-162>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-270>Results:&nbsp;<a class=headline-hash href=#results-270>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkitemidy-rocdlthreadidyop><code>rocdl.workitem.id.y</code> (ROCDL::ThreadIdYOp)&nbsp;<a class=headline-hash href=#rocdlworkitemidy-rocdlthreadidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workitem.id.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-163>Attributes:&nbsp;<a class=headline-hash href=#attributes-163>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-271>Results:&nbsp;<a class=headline-hash href=#results-271>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=rocdlworkitemidz-rocdlthreadidzop><code>rocdl.workitem.id.z</code> (ROCDL::ThreadIdZOp)&nbsp;<a class=headline-hash href=#rocdlworkitemidz-rocdlthreadidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `rocdl.workitem.id.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-164>Attributes:&nbsp;<a class=headline-hash href=#attributes-164>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-272>Results:&nbsp;<a class=headline-hash href=#results-272>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h2 id=attributes-165>Attributes&nbsp;<a class=headline-hash href=#attributes-165>¶</a></h2><h3 id=rocdltargetattr>ROCDLTargetAttr&nbsp;<a class=headline-hash href=#rocdltargetattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#rocdl.target&lt;
  int,   # O
  ::llvm::StringRef,   # triple
  ::llvm::StringRef,   # chip
  ::llvm::StringRef,   # features
  ::llvm::StringRef,   # abi
  DictionaryAttr,   # flags
  ArrayAttr   # link
&gt;
</code></pre><p>ROCDL target attribute for controlling compilation of AMDGPU targets. All
parameters decay into default values if not present.</p><p>Examples:</p><ol><li>Target with default values.</li></ol><pre tabindex=0><code>  gpu.module @mymodule [#rocdl.target] attributes {...} {
    ...
  }
</code></pre><ol start=2><li>Target with <code>gfx90a</code> chip and fast math.</li></ol><pre tabindex=0><code>  gpu.module @mymodule [#rocdl.target&lt;chip = &#34;gfx90a&#34;, flags = {fast, no_wave64}&gt;] {
    ...
  }
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>O</td><td style=text-align:center><code>int</code></td><td>Optimization level to apply.</td></tr><tr><td style=text-align:center>triple</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target triple.</td></tr><tr><td style=text-align:center>chip</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target chip.</td></tr><tr><td style=text-align:center>features</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target chip features.</td></tr><tr><td style=text-align:center>abi</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>ABI version.</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center><code>DictionaryAttr</code></td><td>Target specific flags.</td></tr><tr><td style=text-align:center>link</td><td style=text-align:center><code>ArrayAttr</code></td><td>Files to link to the LLVM module.</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/QuantDialect/ title="'quant' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'quant' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/SCFDialect/ title="'scf' Dialect">Next - 'scf' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>