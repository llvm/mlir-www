<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'xevm' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'xevm' Dialect</h1><p><em>The XeVM dialect that extends LLVM dialect and models Intel GPU&rsquo;s hardware features.</em></p><p>The XeVM dialect is extension to the LLVM dialect that models hardware
features of Intel GPUs. The dialect is designed to work with the Xe
architecture for Intel GPUs, supporting advanced operations like 2D block
loads, stores, prefetch and matrix multiply-add (MMA) operations.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#xevmblockload-xevmblockloadop><code>xevm.blockload</code> (xevm::BlockLoadOp)</a></li><li><a href=#xevmblockload2d-xevmblockload2dop><code>xevm.blockload2d</code> (xevm::BlockLoad2dOp)</a></li><li><a href=#xevmblockprefetch2d-xevmblockprefetch2dop><code>xevm.blockprefetch2d</code> (xevm::BlockPrefetch2dOp)</a></li><li><a href=#xevmblockstore-xevmblockstoreop><code>xevm.blockstore</code> (xevm::BlockStoreOp)</a></li><li><a href=#xevmblockstore2d-xevmblockstore2dop><code>xevm.blockstore2d</code> (xevm::BlockStore2dOp)</a></li><li><a href=#xevmgroup_countx-xevmgriddimxop><code>xevm.group_count.x</code> (xevm::GridDimXOp)</a></li><li><a href=#xevmgroup_county-xevmgriddimyop><code>xevm.group_count.y</code> (xevm::GridDimYOp)</a></li><li><a href=#xevmgroup_countz-xevmgriddimzop><code>xevm.group_count.z</code> (xevm::GridDimZOp)</a></li><li><a href=#xevmgroup_idx-xevmworkgroupidxop><code>xevm.group_id.x</code> (xevm::WorkgroupIdXOp)</a></li><li><a href=#xevmgroup_idy-xevmworkgroupidyop><code>xevm.group_id.y</code> (xevm::WorkgroupIdYOp)</a></li><li><a href=#xevmgroup_idz-xevmworkgroupidzop><code>xevm.group_id.z</code> (xevm::WorkgroupIdZOp)</a></li><li><a href=#xevmlane_id-xevmlaneidop><code>xevm.lane_id</code> (xevm::LaneIdOp)</a></li><li><a href=#xevmlocal_idx-xevmworkitemidxop><code>xevm.local_id.x</code> (xevm::WorkitemIdXOp)</a></li><li><a href=#xevmlocal_idy-xevmworkitemidyop><code>xevm.local_id.y</code> (xevm::WorkitemIdYOp)</a></li><li><a href=#xevmlocal_idz-xevmworkitemidzop><code>xevm.local_id.z</code> (xevm::WorkitemIdZOp)</a></li><li><a href=#xevmlocal_sizex-xevmworkgroupdimxop><code>xevm.local_size.x</code> (xevm::WorkgroupDimXOp)</a></li><li><a href=#xevmlocal_sizey-xevmworkgroupdimyop><code>xevm.local_size.y</code> (xevm::WorkgroupDimYOp)</a></li><li><a href=#xevmlocal_sizez-xevmworkgroupdimzop><code>xevm.local_size.z</code> (xevm::WorkgroupDimZOp)</a></li><li><a href=#xevmmemfence-xevmmemfenceop><code>xevm.memfence</code> (xevm::MemfenceOp)</a></li><li><a href=#xevmmma-xevmmmaop><code>xevm.mma</code> (xevm::MMAOp)</a></li><li><a href=#xevmprefetch-xevmprefetchop><code>xevm.prefetch</code> (xevm::PrefetchOp)</a></li><li><a href=#xevmsubgroup_id-xevmsubgroupidop><code>xevm.subgroup_id</code> (xevm::SubgroupIdOp)</a></li><li><a href=#xevmsubgroup_size-xevmsubgroupsizeop><code>xevm.subgroup_size</code> (xevm::SubgroupSizeOp)</a></li></ul></li><li><a href=#attributes-23>Attributes</a><ul><li><a href=#addrspaceattr>AddrSpaceAttr</a></li><li><a href=#loadcachecontrolattr>LoadCacheControlAttr</a></li><li><a href=#mmashapeattr>MMAShapeAttr</a></li><li><a href=#mmatypesattr>MMATypesAttr</a></li><li><a href=#memscopeattr>MemScopeAttr</a></li><li><a href=#storecachecontrolattr>StoreCacheControlAttr</a></li><li><a href=#xevmtargetattr>XeVMTargetAttr</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#addrspace>AddrSpace</a></li><li><a href=#elemtype>ElemType</a></li><li><a href=#loadcachecontrol>LoadCacheControl</a></li><li><a href=#memscope>MemScope</a></li><li><a href=#storecachecontrol>StoreCacheControl</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/LLVMIR/XeVMOps.td>source</a></p><h3 id=xevmblockload-xevmblockloadop><code>xevm.blockload</code> (xevm::BlockLoadOp)&nbsp;<a class=headline-hash href=#xevmblockload-xevmblockloadop>¶</a></h3><p><em>Subgroup block load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.blockload` operands prop-dict attr-dict `:` functional-type(operands, results)
</code></pre><p>Reads one or more components of Result data for each invocation
in the subgroup from the specified <code>ptr</code> as a block operation.
The data is read strided, so the first value read is:</p><pre tabindex=0><code>  ptr[ SubgroupLocalInvocationId ]
</code></pre><p>and the second value read is:</p><pre tabindex=0><code>  ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
</code></pre><p>Result type may be a scalar or vector type of scalar element type.</p><p>The parameters are:</p><ul><li><code>ptr</code> - the base address to load from. Must be uniform across subgroup.</li><li><code>cache_control</code> - an enumerator that sets the cache behaviour</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%loaded_a</span> <span class=p>=</span> xevm<span class=p>.</span>blockload <span class=nv>%src</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=p>&lt;{</span><span class=nl>cache_control=</span><span class=nv>#xevm.load_cache_control</span><span class=p>&lt;</span>L1uc_L2uc_L3uc<span class=p>&gt;}&gt;</span>
</span></span><span class=line><span class=cl>                <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::LoadCacheControlAttr</td><td>Describe the cache settings for load operators</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or fixed-length vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values of ranks 1</td></tr></tbody></table><h3 id=xevmblockload2d-xevmblockload2dop><code>xevm.blockload2d</code> (xevm::BlockLoad2dOp)&nbsp;<a class=headline-hash href=#xevmblockload2d-xevmblockload2dop>¶</a></h3><p><em>2D block load</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.blockload2d` operands prop-dict attr-dict `:` functional-type(operands, results)
</code></pre><p>The <code>xevm.blockload2d</code> operation loads a two dimensional matrix tile
from a base matrix residing in global memory. The parameters are:</p><ul><li><code>ptr</code> - the base address of the base matrix containing the tile to load</li><li><code>base_width</code> - the width of the base matrix in number of bytes.</li><li><code>base_height</code> - the number of rows in the base matrix</li><li><code>base_pitch</code> - the physical stride between the first columns of the current
row and the subsequent row in number of bytes.</li><li><code>x</code>, <code>y</code>, <code>tile_width</code>, <code>tile_height</code> - the starting offsets and shape of
the tile to load in number of elements.</li><li><code>elem_size_in_bits</code> - the size in bits of the matrix element type<ul><li>32 for f32, tf32</li><li>16 for f16, int16, bf16</li><li>8 for int8</li></ul></li><li><code>v_blocks</code> - number of consecutive tiles in innermost dimension direction to load</li><li><code>transpose</code> - transpose the tile in registers (useful for 32 bit element type)</li><li><code>pack_register</code> - pack element types narrower than register bit width.
[M, N] => [M/factor, N, factor] where factor is register_size_in_bits / elem_size_in_bits</li><li><code>cache_control</code> - an enumerator that sets the cache behaviour</li></ul><p>Notes:</p><ul><li>the <code>transpose</code> and <code>pack_register</code> parameters are mutual exclusive</li><li>transposing the tile loaded is used for A matrix in backward path or used for the B matrix operand
(D = C + A * B), where A has row-major layout and B should have column-major layout in memory.</li><li>if the tile loaded contains out of bound elements of the matrix, they are filled with 0.</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%base_width_a</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%base_height_a</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>8</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%base_pitch_a</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%y</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%loaded_a</span> <span class=p>=</span> xevm<span class=p>.</span>blockload2d <span class=nv>%src</span><span class=p>,</span> <span class=nv>%base_width_a</span><span class=p>,</span> <span class=nv>%base_height_a</span><span class=p>,</span> <span class=nv>%base_pitch_a</span><span class=p>,</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span>
</span></span><span class=line><span class=cl>                <span class=p>&lt;{</span><span class=nl>elem_size_in_bits=</span><span class=m>16</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_width=</span><span class=m>16</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_height=</span><span class=m>8</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=nl>v_blocks=</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>transpose=</span>false <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>pack_register=</span>false<span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=nl>cache_control=</span><span class=nv>#xevm.load_cache_control</span><span class=p>&lt;</span>Default<span class=p>&gt;}&gt;</span>
</span></span><span class=line><span class=cl>                <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i16</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>elem_size_in_bits</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_height</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>v_blocks</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>transpose</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>pack_register</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::LoadCacheControlAttr</td><td>Describe the cache settings for load operators</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>base_width</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_height</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_pitch</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>x</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>y</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr></tbody></table><h3 id=xevmblockprefetch2d-xevmblockprefetch2dop><code>xevm.blockprefetch2d</code> (xevm::BlockPrefetch2dOp)&nbsp;<a class=headline-hash href=#xevmblockprefetch2d-xevmblockprefetch2dop>¶</a></h3><p><em>2D block prefetch</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.blockprefetch2d` operands prop-dict attr-dict `:` `(` type(operands) `)`
</code></pre><p>The <code>xevm.blockprefetch2d</code> operation prefetches a two dimensional tile
from a larger base matrix residing in global memory. The parameters are:</p><ul><li><code>ptr</code> - the base address of the base matrix containing the tile to prefetch</li><li><code>base_width</code> - the width of the base matrix in number of bytes.</li><li><code>base_height</code> - the number of rows in the base matrix</li><li><code>base_pitch</code> - the physical stride between the first columns of the current
row and the subsequent row in number of bytes.</li><li><code>x</code>, <code>y</code>, <code>tile_width</code>, <code>tile_height</code> - the starting offsets and shape of tile
to prefetch in number of elements.</li><li><code>elem_size_in_bits</code> - the size in bits of the matrix element<ul><li>32 for f32, bf32</li><li>16 for f16, int16, bf16</li><li>8 for int8, int4, int2</li></ul></li><li><code>v_blocks</code> - number of tiles in innermost dimension direction to prefetch</li><li><code>cache_control</code> - an enumerator that sets the cache behaviour</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  xevm<span class=p>.</span>blockprefetch2d <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%base_width</span><span class=p>,</span> <span class=nv>%base_height</span><span class=p>,</span> <span class=nv>%base_pitch</span><span class=p>,</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;{</span><span class=nl>elem_size_in_bits=</span><span class=m>8</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_width=</span><span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_height=</span><span class=m>8</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>v_blocks=</span><span class=m>1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>cache_control=</span><span class=nv>#xevm.load_cache_control</span><span class=p>&lt;</span>L1uc_L2uc_L3uc<span class=p>&gt;}&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span></code></pre></div><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>elem_size_in_bits</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_height</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>v_blocks</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::LoadCacheControlAttr</td><td>Describe the cache settings for load operators</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>base_width</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_height</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_pitch</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>x</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>y</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=xevmblockstore-xevmblockstoreop><code>xevm.blockstore</code> (xevm::BlockStoreOp)&nbsp;<a class=headline-hash href=#xevmblockstore-xevmblockstoreop>¶</a></h3><p><em>Subgroup block store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.blockstore` operands prop-dict attr-dict `:` `(` type(operands) `)`
</code></pre><p>Writes one or more components of <code>val</code> for each invocation
in the subgroup to the specified <code>ptr</code> as a block operation.
The data is written strided, so the first value is written to:</p><pre tabindex=0><code>  ptr[ SubgroupLocalInvocationId ]
</code></pre><p>and the second value is written to:</p><pre tabindex=0><code>  ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
</code></pre><p><code>val</code> type may be a scalar or vector type of scalar element type.</p><p>The parameters are:</p><ul><li><code>ptr</code> - the base address to store to. Must be uniform across subgroup.</li><li><code>val</code> - the value to store</li><li><code>cache_control</code> - an enumerator that sets the cache behaviour</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  xevm<span class=p>.</span>blockstore <span class=nv>%ptr</span><span class=p>,</span> <span class=nv>%val</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;{</span><span class=nl>cache_control=</span><span class=nv>#xevm.store_cache_control</span><span class=p>&lt;</span>L1uc_L2uc_L3uc<span class=p>&gt;}&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i16</span><span class=p>&gt;)</span>
</span></span></code></pre></div><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::StoreCacheControlAttr</td><td>Describe the cache settings for store operators</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>val</code></td><td>8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or fixed-length vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values of ranks 1</td></tr></tbody></table><h3 id=xevmblockstore2d-xevmblockstore2dop><code>xevm.blockstore2d</code> (xevm::BlockStore2dOp)&nbsp;<a class=headline-hash href=#xevmblockstore2d-xevmblockstore2dop>¶</a></h3><p><em>2D block store</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.blockstore2d` operands prop-dict attr-dict `:` `(` type(operands) `)`
</code></pre><p>The <code>xevm.blockstore2d</code> operation stores a two dimensional tile into a
larger matrix residing in global memory. The parameters are:</p><ul><li><code>ptr</code> - the base address of the target matrix where to store the tile</li><li><code>base_width</code> - the width of the base matrix in number of bytes.</li><li><code>base_height</code> - the number of rows in the base matrix</li><li><code>base_pitch</code> - the physical stride between the first columns of the current
row and the subsequent row in number of bytes.</li><li><code>x</code>, <code>y</code>, <code>tile_width</code>, <code>tile_height</code> - the starting offsets and shape of the tile to store
in number of elements.</li><li><code>elem_size_in_bits</code> - the size in bits of the matrix element<ul><li>32 for f32, tf32</li><li>16 for f16, int16, bf16</li><li>8 for int8</li></ul></li><li><code>cache_control</code> - an enumerator that sets the cache behaviour</li><li><code>stored_val</code> - the tile to store</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%base_width_c</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>64</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%base_height_c</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>8</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%base_pitch_c</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>64</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%y</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  xevm<span class=p>.</span>blockstore2d <span class=nv>%dst</span><span class=p>,</span> <span class=nv>%base_width_c</span><span class=p>,</span> <span class=nv>%base_height_c</span><span class=p>,</span> <span class=nv>%base_pitch_c</span><span class=p>,</span> <span class=nv>%x</span><span class=p>,</span> <span class=nv>%y</span><span class=p>,</span> <span class=nv>%src</span>
</span></span><span class=line><span class=cl>    <span class=p>&lt;{</span><span class=nl>elem_size_in_bits=</span><span class=m>32</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_width=</span><span class=m>16</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>tile_height=</span><span class=m>8</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=nl>cache_control=</span><span class=nv>#xevm.load_cache_control</span><span class=p>&lt;</span>Default<span class=p>&gt;}&gt;</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>&lt;</span><span class=m>1</span><span class=p>&gt;,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i32</span><span class=p>&gt;)</span>
</span></span></code></pre></div><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>elem_size_in_bits</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_width</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>tile_height</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::StoreCacheControlAttr</td><td>Describe the cache settings for store operators</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>base_width</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_height</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>base_pitch</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>x</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>y</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>stored_val</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr></tbody></table><h3 id=xevmgroup_countx-xevmgriddimxop><code>xevm.group_count.x</code> (xevm::GridDimXOp)&nbsp;<a class=headline-hash href=#xevmgroup_countx-xevmgriddimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_count.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmgroup_county-xevmgriddimyop><code>xevm.group_count.y</code> (xevm::GridDimYOp)&nbsp;<a class=headline-hash href=#xevmgroup_county-xevmgriddimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_count.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmgroup_countz-xevmgriddimzop><code>xevm.group_count.z</code> (xevm::GridDimZOp)&nbsp;<a class=headline-hash href=#xevmgroup_countz-xevmgriddimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_count.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmgroup_idx-xevmworkgroupidxop><code>xevm.group_id.x</code> (xevm::WorkgroupIdXOp)&nbsp;<a class=headline-hash href=#xevmgroup_idx-xevmworkgroupidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_id.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmgroup_idy-xevmworkgroupidyop><code>xevm.group_id.y</code> (xevm::WorkgroupIdYOp)&nbsp;<a class=headline-hash href=#xevmgroup_idy-xevmworkgroupidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_id.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmgroup_idz-xevmworkgroupidzop><code>xevm.group_id.z</code> (xevm::WorkgroupIdZOp)&nbsp;<a class=headline-hash href=#xevmgroup_idz-xevmworkgroupidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.group_id.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlane_id-xevmlaneidop><code>xevm.lane_id</code> (xevm::LaneIdOp)&nbsp;<a class=headline-hash href=#xevmlane_id-xevmlaneidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.lane_id` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_idx-xevmworkitemidxop><code>xevm.local_id.x</code> (xevm::WorkitemIdXOp)&nbsp;<a class=headline-hash href=#xevmlocal_idx-xevmworkitemidxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_id.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_idy-xevmworkitemidyop><code>xevm.local_id.y</code> (xevm::WorkitemIdYOp)&nbsp;<a class=headline-hash href=#xevmlocal_idy-xevmworkitemidyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_id.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_idz-xevmworkitemidzop><code>xevm.local_id.z</code> (xevm::WorkitemIdZOp)&nbsp;<a class=headline-hash href=#xevmlocal_idz-xevmworkitemidzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_id.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_sizex-xevmworkgroupdimxop><code>xevm.local_size.x</code> (xevm::WorkgroupDimXOp)&nbsp;<a class=headline-hash href=#xevmlocal_sizex-xevmworkgroupdimxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_size.x` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_sizey-xevmworkgroupdimyop><code>xevm.local_size.y</code> (xevm::WorkgroupDimYOp)&nbsp;<a class=headline-hash href=#xevmlocal_sizey-xevmworkgroupdimyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_size.y` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmlocal_sizez-xevmworkgroupdimzop><code>xevm.local_size.z</code> (xevm::WorkgroupDimZOp)&nbsp;<a class=headline-hash href=#xevmlocal_sizez-xevmworkgroupdimzop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.local_size.z` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmmemfence-xevmmemfenceop><code>xevm.memfence</code> (xevm::MemfenceOp)&nbsp;<a class=headline-hash href=#xevmmemfence-xevmmemfenceop>¶</a></h3><p><em>Work-item&rsquo;s memory fence.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.memfence` prop-dict  attr-dict
</code></pre><p>This operation ensures that all prior memory accesses of this
work-item to <code>addrspace</code> are visible to all other work-items in <code>scope</code>.
Parameters description:</p><ul><li><code>scope</code> - specify the memory scope at which all other work-items should observe
memory operations prior to the fence.</li><li><code>addrspace</code> - specify the address space of work-item&rsquo;s memory accesses
to be affected by the fence.</li></ul><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::xevm::MemScopeAttr</td><td>Describe memory scopes</td></tr><tr><td><code>addrspace</code></td><td>::mlir::xevm::AddrSpaceAttr</td><td>Describe address spaces</td></tr></table><h3 id=xevmmma-xevmmmaop><code>xevm.mma</code> (xevm::MMAOp)&nbsp;<a class=headline-hash href=#xevmmma-xevmmmaop>¶</a></h3><p><em>Subgroup matrix multiply-add</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.mma` $a `,` $b (`,` $c^)? ` `
              `{`
              `shape` `=` $shape `,`
              `types` `=` $types
              `}` attr-dict `:` functional-type(operands, results)
</code></pre><p>The <code>xevm.mma</code> is a cooperative operation where all threads/lanes in
a subgroup participates and carries out matrix multiplication plus accumulation:</p><p>D = C + A x B</p><p>where the A, B, C input matrices and the result D have shapes:
- D : MxN
- C : MxN
- A : MxK
- B : KxN</p><p>Parameters:</p><ul><li><code>a</code> - vector of matrix A elements.</li><li><code>b</code> - vector of matrix B elements.</li><li><code>c</code> - (optional) vector of matrix C elements.</li><li><code>shape</code> - the shape of the matrices, specified as <code>M</code>, <code>N</code>, and <code>K</code> values.</li><li><code>types</code> - the data types of the matrices, specified as <code>D</code>, <code>A</code>, <code>B</code>, and optionally <code>C</code>.</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%d</span> <span class=p>=</span> xevm<span class=p>.</span>mma <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>{</span> <span class=nl>shape=</span><span class=p>&lt;</span><span class=nl>m=</span><span class=m>8</span><span class=p>,</span> <span class=nl>n=</span><span class=m>16</span><span class=p>,</span> <span class=nl>k=</span><span class=m>16</span><span class=p>&gt;,</span> <span class=nl>types=</span><span class=p>&lt;</span><span class=nl>d=</span><span class=k>f32</span><span class=p>,</span> <span class=nl>a=</span><span class=k>f16</span><span class=p>,</span> <span class=nl>b=</span><span class=k>f16</span><span class=p>,</span> <span class=nl>c=</span><span class=k>f32</span><span class=p>&gt;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>         <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i16</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>shape</code></td><td>::mlir::xevm::MMAShapeAttr</td><td><details><summary></summary><pre><code>MMA operation is represented as D=AxB+C, where
  - A has the shape MxK.
  - B has the shape KxN.
  - D and C have the shape MxN.
This attribute encodes the shape of all matrices that participate in MMA.
</code></pre></details></td></tr><tr><td><code>types</code></td><td>::mlir::xevm::MMATypesAttr</td><td></td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr><tr><td style=text-align:center><code>b</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr><tr><td style=text-align:center><code>c</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>d</code></td><td>fixed-length vector of 8-bit integer or 16-bit integer or 32-bit integer or 32-bit float or tf32 type or 16-bit float or bfloat16 type values of ranks 1</td></tr></tbody></table><h3 id=xevmprefetch-xevmprefetchop><code>xevm.prefetch</code> (xevm::PrefetchOp)&nbsp;<a class=headline-hash href=#xevmprefetch-xevmprefetchop>¶</a></h3><p><em>Prefetch data into a cache subsystem.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.prefetch` operands prop-dict attr-dict `:` `(` type(operands) `)`
</code></pre><p>Work-item issues a prefetch from global memory to cache:</p><ul><li><code>ptr</code> - LLVM pointer with address space. Address space must be 1 (global)
or 4 (generic)</li><li><code>cache_control</code> - specify caching options</li></ul><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cache_control</code></td><td>::mlir::xevm::LoadCacheControlAttr</td><td>Describe the cache settings for load operators</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer in address space 1 or LLVM pointer in address space 4</td></tr></tbody></table><h3 id=xevmsubgroup_id-xevmsubgroupidop><code>xevm.subgroup_id</code> (xevm::SubgroupIdOp)&nbsp;<a class=headline-hash href=#xevmsubgroup_id-xevmsubgroupidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.subgroup_id` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h3 id=xevmsubgroup_size-xevmsubgroupsizeop><code>xevm.subgroup_size</code> (xevm::SubgroupSizeOp)&nbsp;<a class=headline-hash href=#xevmsubgroup_size-xevmsubgroupsizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `xevm.subgroup_size` (`range` $range^)? attr-dict `:` type($res)
</code></pre><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>range</code></td><td>::mlir::LLVM::ConstantRangeAttr</td><td><details><summary>A range of two integers, corresponding to LLVM's ConstantRange</summary><pre><code>A pair of two integers, mapping to the ConstantRange structure in LLVM IR,
which is allowed to wrap or be empty.
<p>The range represented is [Lower, Upper), and is either signed or unsigned
depending on context.</p>
<p><code>lower</code> and <code>upper</code> must have the same width.</p>
<p>Syntax:</p>
<pre tabindex=0><code>`&amp;lt;` `i`(width($lower)) $lower `,` $upper `&amp;gt;`
</code></pre><p></code></pre></p></details></td></tr></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>32-bit signless integer or 64-bit signless integer</td></tr></tbody></table><h2 id=attributes-23>Attributes&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h2><h3 id=addrspaceattr>AddrSpaceAttr&nbsp;<a class=headline-hash href=#addrspaceattr>¶</a></h3><p><em>Describe address spaces</em></p><p>Syntax:</p><pre tabindex=0><code>#xevm.addr_space&lt;
  mlir::xevm::AddrSpace   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>mlir::xevm::AddrSpace</code></td><td>an enum of type AddrSpace</td></tr></tbody></table><h3 id=loadcachecontrolattr>LoadCacheControlAttr&nbsp;<a class=headline-hash href=#loadcachecontrolattr>¶</a></h3><p><em>Describe the cache settings for load operators</em></p><p>Syntax:</p><pre tabindex=0><code>#xevm.load_cache_control&lt;
  ::mlir::xevm::LoadCacheControl   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xevm::LoadCacheControl</code></td><td>an enum of type LoadCacheControl</td></tr></tbody></table><h3 id=mmashapeattr>MMAShapeAttr&nbsp;<a class=headline-hash href=#mmashapeattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#xevm.mma_shape&lt;
  int,   # m
  int,   # n
  int   # k
&gt;
</code></pre><p>MMA operation is represented as D=AxB+C, where</p><ul><li>A has the shape MxK.</li><li>B has the shape KxN.</li><li>D and C have the shape MxN.
This attribute encodes the shape of all matrices that participate in MMA.</li></ul><h4 id=parameters-2>Parameters:&nbsp;<a class=headline-hash href=#parameters-2>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>m</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>n</td><td style=text-align:center><code>int</code></td><td></td></tr><tr><td style=text-align:center>k</td><td style=text-align:center><code>int</code></td><td></td></tr></tbody></table><h3 id=mmatypesattr>MMATypesAttr&nbsp;<a class=headline-hash href=#mmatypesattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#xevm.mma_types&lt;
  xevm::ElemType,   # d
  xevm::ElemType,   # a
  xevm::ElemType,   # b
  xevm::ElemType   # c
&gt;
</code></pre><h4 id=parameters-3>Parameters:&nbsp;<a class=headline-hash href=#parameters-3>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>d</td><td style=text-align:center><code>xevm::ElemType</code></td><td></td></tr><tr><td style=text-align:center>a</td><td style=text-align:center><code>xevm::ElemType</code></td><td></td></tr><tr><td style=text-align:center>b</td><td style=text-align:center><code>xevm::ElemType</code></td><td></td></tr><tr><td style=text-align:center>c</td><td style=text-align:center><code>xevm::ElemType</code></td><td></td></tr></tbody></table><h3 id=memscopeattr>MemScopeAttr&nbsp;<a class=headline-hash href=#memscopeattr>¶</a></h3><p><em>Describe memory scopes</em></p><p>Syntax:</p><pre tabindex=0><code>#xevm.mem_scope&lt;
  ::mlir::xevm::MemScope   # value
&gt;
</code></pre><h4 id=parameters-4>Parameters:&nbsp;<a class=headline-hash href=#parameters-4>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xevm::MemScope</code></td><td>an enum of type MemScope</td></tr></tbody></table><h3 id=storecachecontrolattr>StoreCacheControlAttr&nbsp;<a class=headline-hash href=#storecachecontrolattr>¶</a></h3><p><em>Describe the cache settings for store operators</em></p><p>Syntax:</p><pre tabindex=0><code>#xevm.store_cache_control&lt;
  ::mlir::xevm::StoreCacheControl   # value
&gt;
</code></pre><h4 id=parameters-5>Parameters:&nbsp;<a class=headline-hash href=#parameters-5>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::xevm::StoreCacheControl</code></td><td>an enum of type StoreCacheControl</td></tr></tbody></table><h3 id=xevmtargetattr>XeVMTargetAttr&nbsp;<a class=headline-hash href=#xevmtargetattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#xevm.target&lt;
  int,   # O
  ::llvm::StringRef,   # triple
  ::llvm::StringRef,   # chip
  ::mlir::DictionaryAttr,   # flags
  ::mlir::ArrayAttr   # linkFiles
&gt;
</code></pre><p>GPU target attribute for controlling compilation of Intel GPU targets. All
parameters decay into default values if not present.</p><p>Examples:</p><ol><li>Target with default values.</li></ol><pre tabindex=0><code>  gpu.module @mymodule [#xevm.target] attributes {...} {
    ...
  }
</code></pre><h4 id=parameters-6>Parameters:&nbsp;<a class=headline-hash href=#parameters-6>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>O</td><td style=text-align:center><code>int</code></td><td>Optimization level to apply.</td></tr><tr><td style=text-align:center>triple</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target triple.</td></tr><tr><td style=text-align:center>chip</td><td style=text-align:center><code>::llvm::StringRef</code></td><td>Target chip.</td></tr><tr><td style=text-align:center>flags</td><td style=text-align:center><code>::mlir::DictionaryAttr</code></td><td>Target specific flags.</td></tr><tr><td style=text-align:center>linkFiles</td><td style=text-align:center><code>::mlir::ArrayAttr</code></td><td>Files to link to the LLVM module.</td></tr></tbody></table><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=addrspace>AddrSpace&nbsp;<a class=headline-hash href=#addrspace>¶</a></h3><p><em>Address spaces</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>PRIVATE</td><td style=text-align:center><code>0</code></td><td>private</td></tr><tr><td style=text-align:center>GLOBAL</td><td style=text-align:center><code>1</code></td><td>global</td></tr><tr><td style=text-align:center>CONSTANT</td><td style=text-align:center><code>2</code></td><td>constant</td></tr><tr><td style=text-align:center>SHARED</td><td style=text-align:center><code>3</code></td><td>shared</td></tr><tr><td style=text-align:center>GENERIC</td><td style=text-align:center><code>4</code></td><td>generic</td></tr></tbody></table><h3 id=elemtype>ElemType&nbsp;<a class=headline-hash href=#elemtype>¶</a></h3><p><em>XeVM element type</em></p><h4 id=cases-1>Cases:&nbsp;<a class=headline-hash href=#cases-1>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>BF16</td><td style=text-align:center><code>8</code></td><td>bf16</td></tr><tr><td style=text-align:center>F16</td><td style=text-align:center><code>9</code></td><td>f16</td></tr><tr><td style=text-align:center>S8</td><td style=text-align:center><code>10</code></td><td>s8</td></tr><tr><td style=text-align:center>U8</td><td style=text-align:center><code>11</code></td><td>u8</td></tr><tr><td style=text-align:center>S4</td><td style=text-align:center><code>12</code></td><td>s4</td></tr><tr><td style=text-align:center>U4</td><td style=text-align:center><code>13</code></td><td>u4</td></tr><tr><td style=text-align:center>TF32</td><td style=text-align:center><code>14</code></td><td>tf32</td></tr><tr><td style=text-align:center>F32</td><td style=text-align:center><code>15</code></td><td>f32</td></tr><tr><td style=text-align:center>S32</td><td style=text-align:center><code>16</code></td><td>s32</td></tr></tbody></table><h3 id=loadcachecontrol>LoadCacheControl&nbsp;<a class=headline-hash href=#loadcachecontrol>¶</a></h3><p><em>XeVM load ops cache control</em></p><h4 id=cases-2>Cases:&nbsp;<a class=headline-hash href=#cases-2>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>L1UC_L2UC_L3UC</td><td style=text-align:center><code>1</code></td><td>L1uc_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1UC_L2UC_L3C</td><td style=text-align:center><code>2</code></td><td>L1uc_L2uc_L3c</td></tr><tr><td style=text-align:center>L1UC_L2C_L3UC</td><td style=text-align:center><code>3</code></td><td>L1uc_L2c_L3uc</td></tr><tr><td style=text-align:center>L1UC_L2C_L3C</td><td style=text-align:center><code>4</code></td><td>L1uc_L2c_L3c</td></tr><tr><td style=text-align:center>L1C_L2UC_L3UC</td><td style=text-align:center><code>5</code></td><td>L1c_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1C_L2UC_L3C</td><td style=text-align:center><code>6</code></td><td>L1c_L2uc_L3c</td></tr><tr><td style=text-align:center>L1C_L2C_L3UC</td><td style=text-align:center><code>7</code></td><td>L1c_L2c_L3uc</td></tr><tr><td style=text-align:center>L1C_L2C_L3C</td><td style=text-align:center><code>8</code></td><td>L1c_L2c_L3c</td></tr><tr><td style=text-align:center>L1S_L2UC_L3UC</td><td style=text-align:center><code>9</code></td><td>L1s_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1S_L2UC_L3C</td><td style=text-align:center><code>10</code></td><td>L1s_L2uc_L3c</td></tr><tr><td style=text-align:center>L1S_L2C_L3UC</td><td style=text-align:center><code>11</code></td><td>L1s_L2c_L3uc</td></tr><tr><td style=text-align:center>L1S_L2C_L3C</td><td style=text-align:center><code>12</code></td><td>L1s_L2c_L3c</td></tr><tr><td style=text-align:center>INVALIDATE_READ</td><td style=text-align:center><code>13</code></td><td>ir</td></tr></tbody></table><h3 id=memscope>MemScope&nbsp;<a class=headline-hash href=#memscope>¶</a></h3><p><em>XeVM memory scope</em></p><h4 id=cases-3>Cases:&nbsp;<a class=headline-hash href=#cases-3>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>LANE</td><td style=text-align:center><code>0</code></td><td>lane</td></tr><tr><td style=text-align:center>SUBGROUP</td><td style=text-align:center><code>1</code></td><td>subgroup</td></tr><tr><td style=text-align:center>WORKGROUP</td><td style=text-align:center><code>2</code></td><td>workgroup</td></tr><tr><td style=text-align:center>CLUSTER</td><td style=text-align:center><code>3</code></td><td>cluster</td></tr><tr><td style=text-align:center>DEVICE</td><td style=text-align:center><code>4</code></td><td>device</td></tr><tr><td style=text-align:center>SYSTEM</td><td style=text-align:center><code>5</code></td><td>system</td></tr></tbody></table><h3 id=storecachecontrol>StoreCacheControl&nbsp;<a class=headline-hash href=#storecachecontrol>¶</a></h3><p><em>XeVM store ops cache control</em></p><h4 id=cases-4>Cases:&nbsp;<a class=headline-hash href=#cases-4>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>L1UC_L2UC_L3UC</td><td style=text-align:center><code>1</code></td><td>L1uc_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1UC_L2UC_L3WB</td><td style=text-align:center><code>2</code></td><td>L1uc_L2uc_L3wb</td></tr><tr><td style=text-align:center>L1UC_L2WB_L3UC</td><td style=text-align:center><code>3</code></td><td>L1uc_L2wb_L3uc</td></tr><tr><td style=text-align:center>L1UC_L2WB_L3WB</td><td style=text-align:center><code>4</code></td><td>L1uc_L2wb_L3wb</td></tr><tr><td style=text-align:center>L1WT_L2UC_L3UC</td><td style=text-align:center><code>5</code></td><td>L1wt_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1WT_L2UC_L3WB</td><td style=text-align:center><code>6</code></td><td>L1wt_L2uc_L3wb</td></tr><tr><td style=text-align:center>L1WT_L2WB_L3UC</td><td style=text-align:center><code>7</code></td><td>L1wt_L2wb_L3uc</td></tr><tr><td style=text-align:center>L1WT_L2WB_L3WB</td><td style=text-align:center><code>8</code></td><td>L1wt_L2wb_L3wb</td></tr><tr><td style=text-align:center>L1S_L2UC_L3UC</td><td style=text-align:center><code>9</code></td><td>L1s_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1S_L2UC_L3WB</td><td style=text-align:center><code>10</code></td><td>L1s_L2uc_L3wb</td></tr><tr><td style=text-align:center>L1S_L2WB_L3UC</td><td style=text-align:center><code>11</code></td><td>L1s_L2wb_L3uc</td></tr><tr><td style=text-align:center>L1S_L2WB_L3WB</td><td style=text-align:center><code>12</code></td><td>L1s_L2wb_L3wb</td></tr><tr><td style=text-align:center>L1WB_L2UC_L3UC</td><td style=text-align:center><code>13</code></td><td>L1wb_L2uc_L3uc</td></tr><tr><td style=text-align:center>L1WB_L2WB_L3UC</td><td style=text-align:center><code>14</code></td><td>L1wb_L2wb_L3uc</td></tr><tr><td style=text-align:center>L1WB_L2UC_L3WB</td><td style=text-align:center><code>15</code></td><td>L1wb_L2uc_L3wb</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/XeGPU/ title="'xegpu' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'xegpu' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Builtin/ title="Builtin Dialect">Next - Builtin Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>