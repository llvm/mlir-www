<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'irdl' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/IRDL/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'irdl' Dialect</h1><p><em>IR Definition Language Dialect</em></p><p>IRDL is an SSA-based declarative representation of dynamic dialects.
It allows the definition of dialects, operations, attributes, and types,
with a declarative description of their verifiers. IRDL code is meant to
be generated and not written by hand. As such, the design focuses on ease
of generation/analysis instead of ease of writing/reading.</p><p>Users can define a new dialect with <code>irdl.dialect</code>, operations with
<code>irdl.operation</code>, types with <code>irdl.type</code>, and attributes with
<code>irdl.attribute</code>.</p><p>An example dialect is shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@mul</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%2</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This program defines a <code>cmath</code> dialect that defines a <code>complex</code> type, and
a <code>mul</code> operation. Both express constraints over their parameters using
SSA constraint operations. Informally, one can see those SSA values as
constraint variables that evaluate to a single type at constraint
evaluation. For example, the result of the <code>irdl.any_of</code> stored in <code>%2</code>
in the <code>mul</code> operation will collapse into either <code>f32</code> or <code>f64</code> for the
entirety of this instance of <code>mul</code> constraint evaluation. As such,
both operands and the result of <code>mul</code> must be of equal type (and not just
satisfy the same constraint).</p><p>IRDL variables are handle over <code>mlir::Attribute</code>. In order to support
manipulating <code>mlir::Type</code>, IRDL wraps all types in an <code>mlir::TypeAttr</code>
attribute. The rationale of this is to simplify the dialect.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#irdlall_of-irdlallofop><code>irdl.all_of</code> (irdl::AllOfOp)</a></li><li><a href=#irdlany-irdlanyop><code>irdl.any</code> (irdl::AnyOp)</a></li><li><a href=#irdlany_of-irdlanyofop><code>irdl.any_of</code> (irdl::AnyOfOp)</a></li><li><a href=#irdlattribute-irdlattributeop><code>irdl.attribute</code> (irdl::AttributeOp)</a></li><li><a href=#irdlattributes-irdlattributesop><code>irdl.attributes</code> (irdl::AttributesOp)</a></li><li><a href=#irdlbase-irdlbaseop><code>irdl.base</code> (irdl::BaseOp)</a></li><li><a href=#irdlc_pred-irdlcpredop><code>irdl.c_pred</code> (irdl::CPredOp)</a></li><li><a href=#irdldialect-irdldialectop><code>irdl.dialect</code> (irdl::DialectOp)</a></li><li><a href=#irdlis-irdlisop><code>irdl.is</code> (irdl::IsOp)</a></li><li><a href=#irdloperands-irdloperandsop><code>irdl.operands</code> (irdl::OperandsOp)</a></li><li><a href=#irdloperation-irdloperationop><code>irdl.operation</code> (irdl::OperationOp)</a></li><li><a href=#irdlparameters-irdlparametersop><code>irdl.parameters</code> (irdl::ParametersOp)</a></li><li><a href=#irdlparametric-irdlparametricop><code>irdl.parametric</code> (irdl::ParametricOp)</a></li><li><a href=#irdlregion-irdlregionop><code>irdl.region</code> (irdl::RegionOp)</a></li><li><a href=#irdlregions-irdlregionsop><code>irdl.regions</code> (irdl::RegionsOp)</a></li><li><a href=#irdlresults-irdlresultsop><code>irdl.results</code> (irdl::ResultsOp)</a></li><li><a href=#irdltype-irdltypeop><code>irdl.type</code> (irdl::TypeOp)</a></li></ul></li><li><a href=#attributes-14>Attributes</a><ul><li><a href=#variadicityarrayattr>VariadicityArrayAttr</a></li><li><a href=#variadicityattr>VariadicityAttr</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#attributetype>AttributeType</a></li><li><a href=#regiontype>RegionType</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#variadicity>Variadicity</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/IRDL/IR/IRDLOps.td>source</a></p><h3 id=irdlall_of-irdlallofop><code>irdl.all_of</code> (irdl::AllOfOp)&nbsp;<a class=headline-hash href=#irdlall_of-irdlallofop>¶</a></h3><p><em>Constraints to the intersection of the provided constraints</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.all_of` `(` $args `)` ` ` attr-dict
</code></pre><p><code>irdl.all_of</code> defines a constraint that accepts any type or attribute that
satisfies all of its provided constraints.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_f32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=c>// is 32-bit
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%4</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%5</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=c>// is a float
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=nv>%6</span> <span class=p>=</span> irdl<span class=p>.</span>all_of<span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=c>// is a 32-bit float
</span></span></span><span class=line><span class=cl><span class=c></span>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code> that
has one parameter that must be 32-bit long and a float (in other
words, that must be <code>f32</code>).</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>VerifyConstraintInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlany-irdlanyop><code>irdl.any</code> (irdl::AnyOp)&nbsp;<a class=headline-hash href=#irdlany-irdlanyop>¶</a></h3><p><em>Accept any type or attribute</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.any` attr-dict
</code></pre><p><code>irdl.any</code> defines a constraint that accepts any type or attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_flexible</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex_flexible</code> inside the dialect
<code>cmath</code> that has a single parameter that can be any attribute.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>VerifyConstraintInterface</code></p><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlany_of-irdlanyofop><code>irdl.any_of</code> (irdl::AnyOfOp)&nbsp;<a class=headline-hash href=#irdlany_of-irdlanyofop>¶</a></h3><p><em>Constraints to the union of the provided constraints</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.any_of` `(` $args `)` ` ` attr-dict
</code></pre><p><code>irdl.any_of</code> defines a constraint that accepts any type or attribute that
satisfies at least one of its provided type constraints.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%4</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code> that
has a single type parameter that can be either <code>i32</code>, <code>i64</code>, <code>f32</code> or
<code>f64</code>.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>VerifyConstraintInterface</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlattribute-irdlattributeop><code>irdl.attribute</code> (irdl::AttributeOp)&nbsp;<a class=headline-hash href=#irdlattribute-irdlattributeop>¶</a></h3><p><em>Define a new attribute</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.attribute` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.attribute</code> defines a new attribute belonging to the <code>irdl.dialect</code>
parent.</p><p>The attribute parameters can be defined with an <code>irdl.parameters</code> operation
in the optional region.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@testd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>attribute <span class=nf>@enum_attr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=s>&#34;foo&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=s>&#34;bar&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an <code>enum_attr</code> attribute inside the <code>testd</code>
dialect. The attribute has one <code>StringAttr</code> parameter that should be
either a <code>"foo"</code> or a <code>"bar"</code>.</p><p>Traits: <code>AtMostOneChildOf&lt;ParametersOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlattributes-irdlattributesop><code>irdl.attributes</code> (irdl::AttributesOp)&nbsp;<a class=headline-hash href=#irdlattributes-irdlattributesop>¶</a></h3><p><em>Define the attributes of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.attributes` custom&lt;AttributesOp&gt;($attributeValues, $attributeValueNames) attr-dict
</code></pre><p><code>irdl.attributes</code> defines the attributes of the <code>irdl.operation</code> parent
operation definition.</p><p>In the following example, <code>irdl.attributes</code> defines the attributes of the
<code>attr_op</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@attr_op</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>attibutes <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;attr1&#34;</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;attr2&#34;</span> <span class=p>=</span> <span class=nv>%1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The operation will expect an arbitrary attribute &ldquo;attr1&rdquo; and an
attribute &ldquo;attr2&rdquo; with value <code>i64</code>.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>attributeValueNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attributeValues</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlbase-irdlbaseop><code>irdl.base</code> (irdl::BaseOp)&nbsp;<a class=headline-hash href=#irdlbase-irdlbaseop>¶</a></h3><p><em>Constraints an attribute/type base</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.base` ($base_ref^)? ($base_name^)? ` ` attr-dict
</code></pre><p><code>irdl.base</code> defines a constraint that only accepts a single type
or attribute base, e.g. an <code>IntegerType</code>. The attribute base is defined
either by a symbolic reference to the corresponding IRDL definition,
or by the name of the base. Named bases are prefixed with <code>!</code> or <code>#</code>
respectively for types and attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>base <span class=s>&#34;!builtin.integer&#34;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_wrapper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>base <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>cmath.complex</code> type that expects a single
parameter, which is a type with base name <code>builtin.integer</code>, which is the
name of an <code>IntegerType</code> type.
It also defines a <code>cmath.complex_wrapper</code> type that expects a single
parameter, which is a type of base type <code>cmath.complex</code>.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>VerifyConstraintInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>base_ref</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td><code>base_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlc_pred-irdlcpredop><code>irdl.c_pred</code> (irdl::CPredOp)&nbsp;<a class=headline-hash href=#irdlc_pred-irdlcpredop>¶</a></h3><p><em>Constraints an attribute using a C++ predicate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.c_pred` $pred ` ` attr-dict
</code></pre><p><code>irdl.c_pred</code> defines a constraint that is written in C++.</p><p>Dialects using this operation cannot be registered at runtime, as it relies
on C++ code.</p><p>Special placeholders can be used to refer to entities in the context where
this predicate is used. They serve as &ldquo;hooks&rdquo; to the enclosing environment.
The following special placeholders are supported in constraints for an op:</p><ul><li><code>$_builder</code> will be replaced by a mlir::Builder instance.</li><li><code>$_op</code> will be replaced by the current operation.</li><li><code>$_self</code> will be replaced with the entity this predicate is attached to.
Compared to ODS, <code>$_self</code> is always of type <code>mlir::Attribute</code>, and types
are manipulated as <code>TypeAttr</code> attributes.</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>type <span class=nf>@op_with_attr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>c_pred <span class=s>&#34;::llvm::isa&lt;::mlir::IntegerAttr&gt;($_self)&#34;</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this example, @op_with_attr is defined as a type with a single
parameter, which is an <code>IntegerAttr</code>, as constrained by the C++ predicate.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdldialect-irdldialectop><code>irdl.dialect</code> (irdl::DialectOp)&nbsp;<a class=headline-hash href=#irdldialect-irdldialectop>¶</a></h3><p><em>Define a new dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.dialect` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p>The <code>irdl.dialect</code> operation defines a dialect. All operations, attributes,
and types defined inside its region will be part of the dialect.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>cmath</code> dialect.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlis-irdlisop><code>irdl.is</code> (irdl::IsOp)&nbsp;<a class=headline-hash href=#irdlis-irdlisop>¶</a></h3><p><em>Constraints an attribute/type to be a specific attribute instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.is` $expected ` ` attr-dict
</code></pre><p><code>irdl.is</code> defines a constraint that only accepts a specific instance of a
type or attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>complex_i32</code> type inside the dialect <code>cmath</code>
that can only have a <code>i32</code> as its parameter.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VerifyConstraintInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>expected</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdloperands-irdloperandsop><code>irdl.operands</code> (irdl::OperandsOp)&nbsp;<a class=headline-hash href=#irdloperands-irdloperandsop>¶</a></h3><p><em>Define the operands of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.operands` `` custom&lt;NamedValueListWithVariadicity&gt;($args, $names, $variadicity) attr-dict
</code></pre><p><code>irdl.operands</code> define the operands of the <code>irdl.operation</code> parent operation
definition. Each operand is named after an identifier.</p><p>In the following example, <code>irdl.operands</code> defines the operands of the
<code>mul</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@mul</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span>res<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span>lhs<span class=p>:</span> <span class=nv>%1</span><span class=p>,</span> rhs<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>mul</code> operation will expect two operands of type <code>cmath.complex</code>, that
have the same type, and return a result of the same type.</p><p>The operands can also be marked as variadic or optional:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>operands<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> bar<span class=p>:</span> single <span class=nv>%1</span><span class=p>,</span> baz<span class=p>:</span> optional <span class=nv>%2</span><span class=p>,</span> qux<span class=p>:</span> variadic <span class=nv>%3</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, foo and bar are required single operands, baz is an optional operand,
and qux is a variadic operand.</p><p>When more than one operand is marked as optional or variadic, the operation
will expect a &lsquo;operandSegmentSizes&rsquo; attribute that defines the number of
operands in each segment.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>variadicity</code></td><td>::mlir::irdl::VariadicityArrayAttr</td><td></td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdloperation-irdloperationop><code>irdl.operation</code> (irdl::OperationOp)&nbsp;<a class=headline-hash href=#irdloperation-irdloperationop>¶</a></h3><p><em>Define a new operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.operation` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.operation</code> defines a new operation belonging to the <code>irdl.dialect</code>
parent.</p><p>Operations can define constraints on their operands and results with the
<code>irdl.results</code> and <code>irdl.operands</code> operations. If these operations are not
present in the region, the results or operands are expected to be empty.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@norm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an operation <code>norm</code> inside the dialect <code>cmath</code>.
The operation expects a single operand of base type <code>cmath.complex</code>, and
returns a single result of the element type of the operand.</p><p>Traits: <code>AtMostOneChildOf&lt;OperandsOp, ResultsOp, AttributesOp, RegionsOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlparameters-irdlparametersop><code>irdl.parameters</code> (irdl::ParametersOp)&nbsp;<a class=headline-hash href=#irdlparameters-irdlparametersop>¶</a></h3><p><em>Define the constraints on parameters of a type/attribute definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.parameters` `` custom&lt;NamedValueList&gt;($args, $names) attr-dict
</code></pre><p><code>irdl.parameters</code> defines the constraints on parameters of a type or
attribute definition. Each parameter is named after an identifier.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span>elem<span class=p>:</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code>. The
type has a single parameter <code>elem</code> that should be either <code>i32</code> or <code>i64</code>.</p><p>Traits: <code>HasParent&lt;AttributeOp, TypeOp></code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlparametric-irdlparametricop><code>irdl.parametric</code> (irdl::ParametricOp)&nbsp;<a class=headline-hash href=#irdlparametric-irdlparametricop>¶</a></h3><p><em>Constraints an attribute/type base and its parameters</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.parametric` $base_type `&lt;` $args `&gt;` ` ` attr-dict
</code></pre><p><code>irdl.parametric</code> defines a constraint that accepts only a single type
or attribute base. The attribute base is defined by a symbolic reference
to the corresponding definition. It will additionally constraint the
parameters of the type/attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@norm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an operation <code>norm</code> inside the dialect <code>cmath</code> that
for any <code>T</code> takes a <code>cmath.complex</code> with parameter <code>T</code> and returns a <code>T</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code>, <code>VerifyConstraintInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>base_type</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlregion-irdlregionop><code>irdl.region</code> (irdl::RegionOp)&nbsp;<a class=headline-hash href=#irdlregion-irdlregionop>¶</a></h3><p><em>Define a region of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.region` ``(`(` $entryBlockArgs $constrainedArguments^ `)`)?
              ``(` ` `with` `size` $numberOfBlocks^)? attr-dict
</code></pre><p>The irdl.region construct defines a set of characteristics
that a region of an operation should satify. Each region is named after
an identifier.</p><p>These characteristics include constraints for the entry block arguments
of the region and the total number of blocks it contains.
The number of blocks must be a non-zero and non-negative integer,
and it is optional by default.
The set of constraints for the entry block arguments may be optional or
empty. If no parentheses are provided, the set is assumed to be optional,
and the arguments are not constrained in any way. If parentheses are
provided with no arguments, it means that the region must have
no entry block arguments</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@op_with_regions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r0</span> <span class=p>=</span> irdl<span class=p>.</span>region
</span></span><span class=line><span class=cl>      <span class=nv>%r1</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nv>%v0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>      <span class=nv>%v1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r2</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>(</span><span class=nv>%v0</span><span class=p>,</span> <span class=nv>%v1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r3</span> <span class=p>=</span> irdl<span class=p>.</span>region with size <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      irdl<span class=p>.</span>regions<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%r0</span><span class=p>,</span> bar<span class=p>:</span> <span class=nv>%r1</span><span class=p>,</span> baz<span class=p>:</span> <span class=nv>%r2</span><span class=p>,</span> qux<span class=p>:</span> <span class=nv>%r3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above snippet demonstrates an operation named <code>@op_with_regions</code>,
which is constrained to have four regions.</p><ul><li>Region <code>foo</code> doesn&rsquo;t have any constraints on the arguments
or the number of blocks.</li><li>Region <code>bar</code> should have an empty set of arguments.</li><li>Region <code>baz</code> should have two arguments of types <code>i32</code> and <code>i64</code>.</li><li>Region <code>qux</code> should contain exactly three blocks.</li></ul><p>Traits: <code>HasParent&lt;OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>VerifyRegionInterface</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>numberOfBlocks</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>constrainedArguments</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>entryBlockArgs</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to a region definition</td></tr></tbody></table><h3 id=irdlregions-irdlregionsop><code>irdl.regions</code> (irdl::RegionsOp)&nbsp;<a class=headline-hash href=#irdlregions-irdlregionsop>¶</a></h3><p><em>Define the regions of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.regions` `` custom&lt;NamedValueList&gt;($args, $names) attr-dict
</code></pre><p><code>irdl.regions</code> defines the regions of an operation by accepting
values produced by <code>irdl.region</code> operation as arguments. Each
region has an identifier as name.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@op_with_regions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%r1</span> <span class=p>=</span> irdl<span class=p>.</span>region with size <span class=m>3</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%r2</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>regions<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%r1</span><span class=p>,</span> bar<span class=p>:</span> <span class=nv>%r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the snippet above the operation is constrained to have two regions.
The first region (<code>foo</code>) should contain three blocks.
The second region (<code>bar</code>) should have one region with one argument.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to a region definition</td></tr></tbody></table><h3 id=irdlresults-irdlresultsop><code>irdl.results</code> (irdl::ResultsOp)&nbsp;<a class=headline-hash href=#irdlresults-irdlresultsop>¶</a></h3><p><em>Define the results of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.results` `` custom&lt;NamedValueListWithVariadicity&gt;($args, $names, $variadicity) attr-dict
</code></pre><p><code>irdl.results</code> define the results of the <code>irdl.operation</code> parent operation
definition. Each result is named after an identifier.</p><p>In the following example, <code>irdl.results</code> defines the results of the
<code>get_values</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>/// Returns the real and imaginary parts of a complex number.
</span></span></span><span class=line><span class=cl><span class=c></span>  irdl<span class=p>.</span>operation <span class=nf>@get_values</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span>re<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> im<span class=p>:</span> <span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span>complex<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The operation will expect one operand of the <code>cmath.complex</code> type, and two
results that have the underlying type of the <code>cmath.complex</code>.</p><p>The results can also be marked as variadic or optional:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>results<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> bar<span class=p>:</span> single <span class=nv>%1</span><span class=p>,</span> baz<span class=p>:</span> optional <span class=nv>%2</span><span class=p>,</span> qux<span class=p>:</span> variadic <span class=nv>%3</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, foo and bar are required single results, baz is an optional result,
and qux is a variadic result.</p><p>When more than one result is marked as optional or variadic, the operation
will expect a &lsquo;resultSegmentSizes&rsquo; attribute that defines the number of
results in each segment.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>variadicity</code></td><td>::mlir::irdl::VariadicityArrayAttr</td><td></td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdltype-irdltypeop><code>irdl.type</code> (irdl::TypeOp)&nbsp;<a class=headline-hash href=#irdltype-irdltypeop>¶</a></h3><p><em>Define a new type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.type` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.type</code> defines a new type belonging to the <code>irdl.dialect</code> parent.</p><p>The type parameters can be defined with an <code>irdl.parameters</code> operation in
the optional region.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code>. The
type has a single parameter that should be either <code>i32</code> or <code>i64</code>.</p><p>Traits: <code>AtMostOneChildOf&lt;ParametersOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h2 id=attributes-14>Attributes&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h2><h3 id=variadicityarrayattr>VariadicityArrayAttr&nbsp;<a class=headline-hash href=#variadicityarrayattr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>#irdl.variadicity_array&lt;
  ::llvm::ArrayRef&lt;VariadicityAttr&gt;   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::llvm::ArrayRef&lt;VariadicityAttr></code></td><td></td></tr></tbody></table><h3 id=variadicityattr>VariadicityAttr&nbsp;<a class=headline-hash href=#variadicityattr>¶</a></h3><p><em>A variadicity kind. Can be either &lsquo;single&rsquo;, &lsquo;optional&rsquo;, or &lsquo;variadic&rsquo;</em></p><p>Syntax:</p><pre tabindex=0><code>#irdl.variadicity&lt;
  ::mlir::irdl::Variadicity   # value
&gt;
</code></pre><p>A <code>irdl.variadicity</code> attribute specifies that the associated operand or
result definition is either a single definition (the default), an
optional definition, or a variadic definition.</p><p>For instance:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>operands <span class=p>(</span><span class=nv>%arg1</span><span class=p>,</span> single <span class=nv>%arg2</span><span class=p>,</span> optional <span class=nv>%arg3</span><span class=p>,</span> variadic <span class=nv>%arg4</span><span class=p>)</span>
</span></span></code></pre></div><p>In this example, both %arg1 and %arg2 are single operands, %arg3 is an
optional operand, and %arg4 is a variadic operand.</p><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::irdl::Variadicity</code></td><td>an enum of type Variadicity</td></tr></tbody></table><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><h3 id=attributetype>AttributeType&nbsp;<a class=headline-hash href=#attributetype>¶</a></h3><p><em>IRDL handle to an <code>mlir::Attribute</code></em></p><p>Syntax: <code>!irdl.attribute</code></p><p>This type represents a handle to an instance of an <code>mlir::Attribute</code>,
so it can be used in an IRDL operation, type, or attribute definition.
This type can also represent a handle to an instance of an <code>mlir::Type</code>,
by wrapping it in a <code>mlir::TypeAttr</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@norm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here, <code>%0</code> and <code>%1</code> are both of type <code>!irdl.attribute</code>. Note that in
particular, <code>%1</code> will be a handle to a <code>mlir::TypeAttr</code> wrapping an
instance of a <code>cmath.complex</code> type.</p><h3 id=regiontype>RegionType&nbsp;<a class=headline-hash href=#regiontype>¶</a></h3><p><em>IRDL handle to a region definition</em></p><p>Syntax: <code>!irdl.region</code></p><p>This type represents a region constraint. It is produced by
the <code>irdl.region</code> operation and consumed by the <code>irdl.regions</code> operation.
The region can be constrained on the number of arguments
and the number of blocks.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@op_with_regions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%r1</span> <span class=p>=</span> irdl<span class=p>.</span>region with size <span class=m>3</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%r2</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>regions<span class=p>(</span><span class=nv>%r1</span><span class=p>,</span> <span class=nv>%r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Here we have <code>%r1</code> and <code>%r2</code>, both of which have the type <code>!irdl.region</code>.</p><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=variadicity>Variadicity&nbsp;<a class=headline-hash href=#variadicity>¶</a></h3><p><em>Variadicity kind</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>single</td><td style=text-align:center><code>0</code></td><td>single</td></tr><tr><td style=text-align:center>optional</td><td style=text-align:center><code>1</code></td><td>optional</td></tr><tr><td style=text-align:center>variadic</td><td style=text-align:center><code>2</code></td><td>variadic</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/IndexOps/ title="'index' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'index' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Linalg/ title="'linalg' Dialect">Next - 'linalg' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>