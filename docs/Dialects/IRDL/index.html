<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'irdl' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/IRDL/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'irdl' Dialect</h1><p><nav id=TableOfContents><ul><li><a href=#basics>Basics</a></li><li><a href=#principles>Principles</a></li><li><a href=#constraints-and-combinators>Constraints and combinators</a></li><li><a href=#motivating-use-cases>Motivating use cases</a></li><li><a href=#operations>Operations</a><ul><li><a href=#irdlall_of-irdlallofop><code>irdl.all_of</code> (irdl::AllOfOp)</a></li><li><a href=#irdlany_of-irdlanyofop><code>irdl.any_of</code> (irdl::AnyOfOp)</a></li><li><a href=#irdlany-irdlanyop><code>irdl.any</code> (irdl::AnyOp)</a></li><li><a href=#irdlattribute-irdlattributeop><code>irdl.attribute</code> (irdl::AttributeOp)</a></li><li><a href=#irdlattributes-irdlattributesop><code>irdl.attributes</code> (irdl::AttributesOp)</a></li><li><a href=#irdlbase-irdlbaseop><code>irdl.base</code> (irdl::BaseOp)</a></li><li><a href=#irdlc_pred-irdlcpredop><code>irdl.c_pred</code> (irdl::CPredOp)</a></li><li><a href=#irdldialect-irdldialectop><code>irdl.dialect</code> (irdl::DialectOp)</a></li><li><a href=#irdlis-irdlisop><code>irdl.is</code> (irdl::IsOp)</a></li><li><a href=#irdloperands-irdloperandsop><code>irdl.operands</code> (irdl::OperandsOp)</a></li><li><a href=#irdloperation-irdloperationop><code>irdl.operation</code> (irdl::OperationOp)</a></li><li><a href=#irdlparameters-irdlparametersop><code>irdl.parameters</code> (irdl::ParametersOp)</a></li><li><a href=#irdlparametric-irdlparametricop><code>irdl.parametric</code> (irdl::ParametricOp)</a></li><li><a href=#irdlregion-irdlregionop><code>irdl.region</code> (irdl::RegionOp)</a></li><li><a href=#irdlregions-irdlregionsop><code>irdl.regions</code> (irdl::RegionsOp)</a></li><li><a href=#irdlresults-irdlresultsop><code>irdl.results</code> (irdl::ResultsOp)</a></li><li><a href=#irdltype-irdltypeop><code>irdl.type</code> (irdl::TypeOp)</a></li></ul></li></ul></nav><h2 id=basics>Basics&nbsp;<a class=headline-hash href=#basics>¶</a></h2><p>The IRDL (<em>Intermediate Representation Definition Language</em>) dialect allows
defining MLIR dialects as MLIR programs. Nested operations are used to
represent dialect structure: dialects contain operations, types and
attributes, themselves containing type parameters, operands, results, etc.
Each of those concepts are mapped to MLIR operations in the IRDL dialect, as
shown in the example dialect below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>        <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>        <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operation <span class=nf>@mul</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>        <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>        <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%2</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>        irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>This program defines a <code>cmath</code> dialect that defines a <code>complex</code> type, and
a <code>mul</code> operation. Both express constraints over their parameters using
SSA constraint operations. Informally, one can see those SSA values as
constraint variables that evaluate to a single type at constraint
evaluation. For example, the result of the <code>irdl.any_of</code> stored in <code>%2</code>
in the <code>mul</code> operation will collapse into either <code>f32</code> or <code>f64</code> for the
entirety of this instance of <code>mul</code> constraint evaluation. As such,
both operands and the result of <code>mul</code> must be of equal type (and not just
satisfy the same constraint). For more information, see
<a href=#constraints-and-combinators>constraints and combinators</a>.</p><p>In order to simplify the dialect, IRDL variables are handles over
<code>mlir::Attribute</code>. In order to support manipulating <code>mlir::Type</code>,
IRDL wraps all types in an <code>mlir::TypeAttr</code> attribute.</p><h2 id=principles>Principles&nbsp;<a class=headline-hash href=#principles>¶</a></h2><p>The core principles of IRDL are the following, in no particular order:</p><ul><li><strong>Portability.</strong> IRDL dialects should be self-contained, such that dialects
can be easily distributed with minimal assumptions on which compiler
infrastructure (or which commit of MLIR) is used.</li><li><strong>Introspection.</strong> The IRDL dialect definition mechanism should strive
towards offering as much introspection abilities as possible. Dialects
should be as easy to manipulate, generate, and analyze as possible.</li><li><strong>Runtime declaration support</strong>. The specification of IRDL dialects should
offer the ability to have them be loaded at runtime, via dynamic registration
or JIT compilation. Compatibility with dynamic workflows should not hinder
the ability to compile IRDL dialects into ahead-of-time declarations.</li><li><strong>Reliability.</strong> Concepts in IRDL should be consistent and predictable, with
as much focus on high-level simplicity as possible. Consequently, IRDL
definitions that verify should work out of the box, and those that do not
verify should provide clear and understandable errors in all circumstances.</li></ul><p>While IRDL simplifies IR definition, it remains an IR itself and thus does not
require to be comfortably user-writeable.</p><h2 id=constraints-and-combinators>Constraints and combinators&nbsp;<a class=headline-hash href=#constraints-and-combinators>¶</a></h2><p>Attribute, type and operation verifiers are expressed in terms of constraint
variables. Constraint variables are defined as the results of constraint
operations (like <code>irdl.is</code> or constraint combinators).</p><p>Constraint variables act as variables: as such, matching against the same
constraint variable multiple times can only succeed if the matching type or
attribute is the same as the one that previously matched. In the following
example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>type <span class=nf>@foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%ty</span> <span class=p>=</span> irdl<span class=p>.</span>any_type
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span>param1<span class=p>:</span> <span class=nv>%ty</span><span class=p>,</span> param2<span class=p>:</span> <span class=nv>%ty</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>only types with two equal parameters will successfully match (<code>foo&lt;i32, i32></code>
would match while <code>foo&lt;i32, i64></code> would fail, even though both i32 and i64
individually satisfy the <code>irdl.any_type</code> constraint). This constraint variable
mechanism allows to easily express a requirement on type or attribute equality.</p><p>To declare more complex verifiers, IRDL provides constraint-combinator
operations such as <code>irdl.any_of</code>, <code>irdl.all_of</code> or <code>irdl.parametric</code>. These
combinators can be used to combine constraint variables into new constraint
variables. Like all uses of constraint variables, their constraint variable
operands enforce equality of matched types of attributes as explained in the
previous paragraph.</p><h2 id=motivating-use-cases>Motivating use cases&nbsp;<a class=headline-hash href=#motivating-use-cases>¶</a></h2><p>To illustrate the rationale behind IRDL, the following list describes examples
of intended use cases for IRDL, in no particular order:</p><ul><li><strong>Fuzzer generation.</strong> With declarative verifier definitions, it is possible
to compile IRDL dialects into compiler fuzzers that generate only programs
passing verifiers.</li><li><strong>Portable dialects between compiler infrastructures.</strong> Some compiler
infrastructures are independent from MLIR but are otherwise IR-compatible.
Portable IRDL dialects allow to share the dialect definitions between MLIR
and other compiler infrastructures without needing to maintain multiple
potentially out-of-sync definitions.</li><li><strong>Dialect simplification.</strong> Because IRDL definitions can easily be
mechanically modified, it is possible to simplify the definition of dialects
based on which operations are actually used, leading to smaller compilers.</li><li><strong>SMT analysis.</strong> Because IRDL dialect definitions are declarative, their
definition can be lowered to alternative representations like SMT, allowing
analysis of the behavior of transforms taking verifiers into account.</li></ul><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/IRDL/IR/IRDLOps.td>source</a></p><h3 id=irdlall_of-irdlallofop><code>irdl.all_of</code> (irdl::AllOfOp)&nbsp;<a class=headline-hash href=#irdlall_of-irdlallofop>¶</a></h3><p><em>Constraints to the intersection of the provided constraints</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.all_of` `(` $args `)` ` ` attr-dict
</code></pre><p><code>irdl.all_of</code> defines a constraint that accepts any type or attribute that
satisfies all of its provided constraints.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_f32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=c>// is 32-bit
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%4</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%5</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%3</span><span class=p>,</span> <span class=nv>%4</span><span class=p>)</span> <span class=c>// is a float
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>    <span class=nv>%6</span> <span class=p>=</span> irdl<span class=p>.</span>all_of<span class=p>(</span><span class=nv>%2</span><span class=p>,</span> <span class=nv>%5</span><span class=p>)</span> <span class=c>// is a 32-bit float
</span></span></span><span class=line><span class=cl><span class=c></span>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%6</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code> that
has one parameter that must be 32-bit long and a float (in other
words, that must be <code>f32</code>).</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>VerifyConstraintInterface</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlany_of-irdlanyofop><code>irdl.any_of</code> (irdl::AnyOfOp)&nbsp;<a class=headline-hash href=#irdlany_of-irdlanyofop>¶</a></h3><p><em>Constraints to the union of the provided constraints</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.any_of` `(` $args `)` ` ` attr-dict
</code></pre><p><code>irdl.any_of</code> defines a constraint that accepts any type or attribute that
satisfies at least one of its provided type constraints.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%3</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>f64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%4</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span><span class=p>,</span> <span class=nv>%3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code> that
has a single type parameter that can be either <code>i32</code>, <code>i64</code>, <code>f32</code> or
<code>f64</code>.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>VerifyConstraintInterface</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlany-irdlanyop><code>irdl.any</code> (irdl::AnyOp)&nbsp;<a class=headline-hash href=#irdlany-irdlanyop>¶</a></h3><p><em>Accept any type or attribute</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.any` attr-dict
</code></pre><p><code>irdl.any</code> defines a constraint that accepts any type or attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_flexible</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex_flexible</code> inside the dialect
<code>cmath</code> that has a single parameter that can be any attribute.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>VerifyConstraintInterface</code></p><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlattribute-irdlattributeop><code>irdl.attribute</code> (irdl::AttributeOp)&nbsp;<a class=headline-hash href=#irdlattribute-irdlattributeop>¶</a></h3><p><em>Define a new attribute</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.attribute` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.attribute</code> defines a new attribute belonging to the <code>irdl.dialect</code>
parent.</p><p>The attribute parameters can be defined with an <code>irdl.parameters</code> operation
in the optional region.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@testd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>attribute <span class=nf>@enum_attr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=s>&#34;foo&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=s>&#34;bar&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an <code>enum_attr</code> attribute inside the <code>testd</code>
dialect. The attribute has one <code>StringAttr</code> parameter that should be
either a <code>"foo"</code> or a <code>"bar"</code>.</p><p>Traits: <code>AtMostOneChildOf&lt;ParametersOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlattributes-irdlattributesop><code>irdl.attributes</code> (irdl::AttributesOp)&nbsp;<a class=headline-hash href=#irdlattributes-irdlattributesop>¶</a></h3><p><em>Define the attributes of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.attributes` custom&lt;AttributesOp&gt;($attributeValues, $attributeValueNames) attr-dict
</code></pre><p><code>irdl.attributes</code> defines the attributes of the <code>irdl.operation</code> parent
operation definition.</p><p>In the following example, <code>irdl.attributes</code> defines the attributes of the
<code>attr_op</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@attr_op</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>attibutes <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;attr1&#34;</span> <span class=p>=</span> <span class=nv>%0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=s>&#34;attr2&#34;</span> <span class=p>=</span> <span class=nv>%1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The operation will expect an arbitrary attribute &ldquo;attr1&rdquo; and an
attribute &ldquo;attr2&rdquo; with value <code>i64</code>.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>attributeValueNames</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>attributeValues</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlbase-irdlbaseop><code>irdl.base</code> (irdl::BaseOp)&nbsp;<a class=headline-hash href=#irdlbase-irdlbaseop>¶</a></h3><p><em>Constraints an attribute/type base</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.base` ($base_ref^)? ($base_name^)? ` ` attr-dict
</code></pre><p><code>irdl.base</code> defines a constraint that only accepts a single type
or attribute base, e.g. an <code>IntegerType</code>. The attribute base is defined
either by a symbolic reference to the corresponding IRDL definition,
or by the name of the base. Named bases are prefixed with <code>!</code> or <code>#</code>
respectively for types and attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>base <span class=s>&#34;!builtin.integer&#34;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_wrapper</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>base <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>cmath.complex</code> type that expects a single
parameter, which is a type with base name <code>builtin.integer</code>, which is the
name of an <code>IntegerType</code> type.
It also defines a <code>cmath.complex_wrapper</code> type that expects a single
parameter, which is a type of base type <code>cmath.complex</code>.</p><p>Traits: <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>SymbolUserOpInterface</code>, <code>VerifyConstraintInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>base_ref</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td><code>base_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlc_pred-irdlcpredop><code>irdl.c_pred</code> (irdl::CPredOp)&nbsp;<a class=headline-hash href=#irdlc_pred-irdlcpredop>¶</a></h3><p><em>Constraints an attribute using a C++ predicate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.c_pred` $pred ` ` attr-dict
</code></pre><p><code>irdl.c_pred</code> defines a constraint that is written in C++.</p><p>Dialects using this operation cannot be registered at runtime, as it relies
on C++ code.</p><p>Special placeholders can be used to refer to entities in the context where
this predicate is used. They serve as &ldquo;hooks&rdquo; to the enclosing environment.
The following special placeholders are supported in constraints for an op:</p><ul><li><code>$_builder</code> will be replaced by a mlir::Builder instance.</li><li><code>$_op</code> will be replaced by the current operation.</li><li><code>$_self</code> will be replaced with the entity this predicate is attached to.
Compared to ODS, <code>$_self</code> is always of type <code>mlir::Attribute</code>, and types
are manipulated as <code>TypeAttr</code> attributes.</li></ul><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>type <span class=nf>@op_with_attr</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>c_pred <span class=s>&#34;::llvm::isa&lt;::mlir::IntegerAttr&gt;($_self)&#34;</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In this example, @op_with_attr is defined as a type with a single
parameter, which is an <code>IntegerAttr</code>, as constrained by the C++ predicate.</p><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pred</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdldialect-irdldialectop><code>irdl.dialect</code> (irdl::DialectOp)&nbsp;<a class=headline-hash href=#irdldialect-irdldialectop>¶</a></h3><p><em>Define a new dialect</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.dialect` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p>The <code>irdl.dialect</code> operation defines a dialect. All operations, attributes,
and types defined inside its region will be part of the dialect.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>cmath</code> dialect.</p><p>Traits: <code>IsolatedFromAbove</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlis-irdlisop><code>irdl.is</code> (irdl::IsOp)&nbsp;<a class=headline-hash href=#irdlis-irdlisop>¶</a></h3><p><em>Constraints an attribute/type to be a specific attribute instance</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.is` $expected ` ` attr-dict
</code></pre><p><code>irdl.is</code> defines a constraint that only accepts a specific instance of a
type or attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex_i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a <code>complex_i32</code> type inside the dialect <code>cmath</code>
that can only have a <code>i32</code> as its parameter.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VerifyConstraintInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>expected</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdloperands-irdloperandsop><code>irdl.operands</code> (irdl::OperandsOp)&nbsp;<a class=headline-hash href=#irdloperands-irdloperandsop>¶</a></h3><p><em>Define the operands of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.operands` `` custom&lt;NamedValueListWithVariadicity&gt;($args, $names, $variadicity) attr-dict
</code></pre><p><code>irdl.operands</code> define the operands of the <code>irdl.operation</code> parent operation
definition. Each operand is named after an identifier.</p><p>In the following example, <code>irdl.operands</code> defines the operands of the
<code>mul</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@mul</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span>res<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span>lhs<span class=p>:</span> <span class=nv>%1</span><span class=p>,</span> rhs<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>mul</code> operation will expect two operands of type <code>cmath.complex</code>, that
have the same type, and return a result of the same type.</p><p>The operands can also be marked as variadic or optional:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>operands<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> bar<span class=p>:</span> single <span class=nv>%1</span><span class=p>,</span> baz<span class=p>:</span> optional <span class=nv>%2</span><span class=p>,</span> qux<span class=p>:</span> variadic <span class=nv>%3</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, foo and bar are required single operands, baz is an optional operand,
and qux is a variadic operand.</p><p>When more than one operand is marked as optional or variadic, the operation
will expect a &lsquo;operandSegmentSizes&rsquo; attribute that defines the number of
operands in each segment.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>variadicity</code></td><td>::mlir::irdl::VariadicityArrayAttr</td><td></td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdloperation-irdloperationop><code>irdl.operation</code> (irdl::OperationOp)&nbsp;<a class=headline-hash href=#irdloperation-irdloperationop>¶</a></h3><p><em>Define a new operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.operation` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.operation</code> defines a new operation belonging to the <code>irdl.dialect</code>
parent.</p><p>Operations can define constraints on their operands and results with the
<code>irdl.results</code> and <code>irdl.operands</code> operations. If these operations are not
present in the region, the results or operands are expected to be empty.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@norm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an operation <code>norm</code> inside the dialect <code>cmath</code>.
The operation expects a single operand of base type <code>cmath.complex</code>, and
returns a single result of the element type of the operand.</p><p>Traits: <code>AtMostOneChildOf&lt;OperandsOp, ResultsOp, AttributesOp, RegionsOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=irdlparameters-irdlparametersop><code>irdl.parameters</code> (irdl::ParametersOp)&nbsp;<a class=headline-hash href=#irdlparameters-irdlparametersop>¶</a></h3><p><em>Define the constraints on parameters of a type/attribute definition</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.parameters` `` custom&lt;NamedValueList&gt;($args, $names) attr-dict
</code></pre><p><code>irdl.parameters</code> defines the constraints on parameters of a type or
attribute definition. Each parameter is named after an identifier.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span>elem<span class=p>:</span> <span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code>. The
type has a single parameter <code>elem</code> that should be either <code>i32</code> or <code>i64</code>.</p><p>Traits: <code>HasParent&lt;AttributeOp, TypeOp></code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlparametric-irdlparametricop><code>irdl.parametric</code> (irdl::ParametricOp)&nbsp;<a class=headline-hash href=#irdlparametric-irdlparametricop>¶</a></h3><p><em>Constraints an attribute/type base and its parameters</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.parametric` $base_type `&lt;` $args `&gt;` ` ` attr-dict
</code></pre><p><code>irdl.parametric</code> defines a constraint that accepts only a single type
or attribute base. The attribute base is defined by a symbolic reference
to the corresponding definition. It will additionally constraint the
parameters of the type/attribute.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@norm</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span><span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines an operation <code>norm</code> inside the dialect <code>cmath</code> that
for any <code>T</code> takes a <code>cmath.complex</code> with parameter <code>T</code> and returns a <code>T</code>.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>HasParent&lt;TypeOp, AttributeOp, OperationOp></code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code>, <code>VerifyConstraintInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>base_type</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdlregion-irdlregionop><code>irdl.region</code> (irdl::RegionOp)&nbsp;<a class=headline-hash href=#irdlregion-irdlregionop>¶</a></h3><p><em>Define a region of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.region` ``(`(` $entryBlockArgs $constrainedArguments^ `)`)?
              ``(` ` `with` `size` $numberOfBlocks^)? attr-dict
</code></pre><p>The irdl.region construct defines a set of characteristics
that a region of an operation should satify. Each region is named after
an identifier.</p><p>These characteristics include constraints for the entry block arguments
of the region and the total number of blocks it contains.
The number of blocks must be a non-zero and non-negative integer,
and it is optional by default.
The set of constraints for the entry block arguments may be optional or
empty. If no parentheses are provided, the set is assumed to be optional,
and the arguments are not constrained in any way. If parentheses are
provided with no arguments, it means that the region must have
no entry block arguments</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@op_with_regions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r0</span> <span class=p>=</span> irdl<span class=p>.</span>region
</span></span><span class=line><span class=cl>      <span class=nv>%r1</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>()</span>
</span></span><span class=line><span class=cl>      <span class=nv>%v0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>      <span class=nv>%v1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r2</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>(</span><span class=nv>%v0</span><span class=p>,</span> <span class=nv>%v1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nv>%r3</span> <span class=p>=</span> irdl<span class=p>.</span>region with size <span class=m>3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      irdl<span class=p>.</span>regions<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%r0</span><span class=p>,</span> bar<span class=p>:</span> <span class=nv>%r1</span><span class=p>,</span> baz<span class=p>:</span> <span class=nv>%r2</span><span class=p>,</span> qux<span class=p>:</span> <span class=nv>%r3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above snippet demonstrates an operation named <code>@op_with_regions</code>,
which is constrained to have four regions.</p><ul><li>Region <code>foo</code> doesn&rsquo;t have any constraints on the arguments
or the number of blocks.</li><li>Region <code>bar</code> should have an empty set of arguments.</li><li>Region <code>baz</code> should have two arguments of types <code>i32</code> and <code>i64</code>.</li><li>Region <code>qux</code> should contain exactly three blocks.</li></ul><p>Traits: <code>HasParent&lt;OperationOp></code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>VerifyRegionInterface</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>numberOfBlocks</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>constrainedArguments</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>entryBlockArgs</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>output</code></td><td>IRDL handle to a region definition</td></tr></tbody></table><h3 id=irdlregions-irdlregionsop><code>irdl.regions</code> (irdl::RegionsOp)&nbsp;<a class=headline-hash href=#irdlregions-irdlregionsop>¶</a></h3><p><em>Define the regions of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.regions` `` custom&lt;NamedValueList&gt;($args, $names) attr-dict
</code></pre><p><code>irdl.regions</code> defines the regions of an operation by accepting
values produced by <code>irdl.region</code> operation as arguments. Each
region has an identifier as name.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@example</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>operation <span class=nf>@op_with_regions</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%r1</span> <span class=p>=</span> irdl<span class=p>.</span>region with size <span class=m>3</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%r2</span> <span class=p>=</span> irdl<span class=p>.</span>region<span class=p>(</span><span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>regions<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%r1</span><span class=p>,</span> bar<span class=p>:</span> <span class=nv>%r2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>In the snippet above the operation is constrained to have two regions.
The first region (<code>foo</code>) should contain three blocks.
The second region (<code>bar</code>) should have one region with one argument.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to a region definition</td></tr></tbody></table><h3 id=irdlresults-irdlresultsop><code>irdl.results</code> (irdl::ResultsOp)&nbsp;<a class=headline-hash href=#irdlresults-irdlresultsop>¶</a></h3><p><em>Define the results of an operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.results` `` custom&lt;NamedValueListWithVariadicity&gt;($args, $names, $variadicity) attr-dict
</code></pre><p><code>irdl.results</code> define the results of the <code>irdl.operation</code> parent operation
definition. Each result is named after an identifier.</p><p>In the following example, <code>irdl.results</code> defines the results of the
<code>get_values</code> operation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span> <span class=err>/</span><span class=p>*</span> <span class=p>...</span> <span class=p>*</span><span class=err>/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>/// Returns the real and imaginary parts of a complex number.
</span></span></span><span class=line><span class=cl><span class=c></span>  irdl<span class=p>.</span>operation <span class=nf>@get_values</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>any
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>parametric <span class=nf>@cmath</span><span class=p>::</span><span class=nf>@complex</span><span class=p>&lt;</span><span class=nv>%0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>results<span class=p>(</span>re<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> im<span class=p>:</span> <span class=nv>%0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>operands<span class=p>(</span>complex<span class=p>:</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The operation will expect one operand of the <code>cmath.complex</code> type, and two
results that have the underlying type of the <code>cmath.complex</code>.</p><p>The results can also be marked as variadic or optional:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>results<span class=p>(</span>foo<span class=p>:</span> <span class=nv>%0</span><span class=p>,</span> bar<span class=p>:</span> single <span class=nv>%1</span><span class=p>,</span> baz<span class=p>:</span> optional <span class=nv>%2</span><span class=p>,</span> qux<span class=p>:</span> variadic <span class=nv>%3</span><span class=p>)</span>
</span></span></code></pre></div><p>Here, foo and bar are required single results, baz is an optional result,
and qux is a variadic result.</p><p>When more than one result is marked as optional or variadic, the operation
will expect a &lsquo;resultSegmentSizes&rsquo; attribute that defines the number of
results in each segment.</p><p>Traits: <code>HasParent&lt;OperationOp></code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>names</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr><tr><td><code>variadicity</code></td><td>::mlir::irdl::VariadicityArrayAttr</td><td></td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of IRDL handle to an <code>mlir::Attribute</code></td></tr></tbody></table><h3 id=irdltype-irdltypeop><code>irdl.type</code> (irdl::TypeOp)&nbsp;<a class=headline-hash href=#irdltype-irdltypeop>¶</a></h3><p><em>Define a new type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `irdl.type` $sym_name attr-dict-with-keyword custom&lt;SingleBlockRegion&gt;($body)
</code></pre><p><code>irdl.type</code> defines a new type belonging to the <code>irdl.dialect</code> parent.</p><p>The type parameters can be defined with an <code>irdl.parameters</code> operation in
the optional region.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>irdl<span class=p>.</span>dialect <span class=nf>@cmath</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  irdl<span class=p>.</span>type <span class=nf>@complex</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> irdl<span class=p>.</span>is <span class=k>i64</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> irdl<span class=p>.</span>any_of<span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    irdl<span class=p>.</span>parameters<span class=p>(</span><span class=nv>%2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above program defines a type <code>complex</code> inside the dialect <code>cmath</code>. The
type has a single parameter that should be either <code>i32</code> or <code>i64</code>.</p><p>Traits: <code>AtMostOneChildOf&lt;ParametersOp></code>, <code>HasParent&lt;DialectOp></code>, <code>NoRegionArguments</code>, <code>NoTerminator</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/IndexOps/ title="'index' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'index' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/Linalg/ title="'linalg' Dialect">Next - 'linalg' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>