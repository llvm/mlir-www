<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'arm_sve' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ArmSVE/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'arm_sve' Dialect</h1><p><em>Basic dialect to target Arm SVE architectures</em></p><p>This dialect contains the definitions necessary to target specific Arm SVE
scalable vector operations.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#arm_sveconvert_from_svbool-arm_sveconvertfromsvboolop><code>arm_sve.convert_from_svbool</code> (arm_sve::ConvertFromSvboolOp)</a></li><li><a href=#arm_sveconvert_to_svbool-arm_sveconverttosvboolop><code>arm_sve.convert_to_svbool</code> (arm_sve::ConvertToSvboolOp)</a></li><li><a href=#arm_svedupq_lane-arm_svedupqlaneop><code>arm_sve.dupq_lane</code> (arm_sve::DupQLaneOp)</a></li><li><a href=#arm_sveintradd-arm_svescalablemaskedaddiintrop><code>arm_sve.intr.add</code> (arm_sve::ScalableMaskedAddIIntrOp)</a></li><li><a href=#arm_sveintrbfmmla-arm_svebfmmlaop><code>arm_sve.intr.bfmmla</code> (arm_sve::BfmmlaOp)</a></li><li><a href=#arm_sveintrconvertfromsvbool-arm_sveconvertfromsvboolintrop><code>arm_sve.intr.convert.from.svbool</code> (arm_sve::ConvertFromSvboolIntrOp)</a></li><li><a href=#arm_sveintrconverttosvbool-arm_sveconverttosvboolintrop><code>arm_sve.intr.convert.to.svbool</code> (arm_sve::ConvertToSvboolIntrOp)</a></li><li><a href=#arm_sveintrdupq_lane-arm_svedupqlaneintrop><code>arm_sve.intr.dupq_lane</code> (arm_sve::DupQLaneIntrOp)</a></li><li><a href=#arm_sveintrfadd-arm_svescalablemaskedaddfintrop><code>arm_sve.intr.fadd</code> (arm_sve::ScalableMaskedAddFIntrOp)</a></li><li><a href=#arm_sveintrfdiv-arm_svescalablemaskeddivfintrop><code>arm_sve.intr.fdiv</code> (arm_sve::ScalableMaskedDivFIntrOp)</a></li><li><a href=#arm_sveintrfmul-arm_svescalablemaskedmulfintrop><code>arm_sve.intr.fmul</code> (arm_sve::ScalableMaskedMulFIntrOp)</a></li><li><a href=#arm_sveintrfsub-arm_svescalablemaskedsubfintrop><code>arm_sve.intr.fsub</code> (arm_sve::ScalableMaskedSubFIntrOp)</a></li><li><a href=#arm_sveintrmul-arm_svescalablemaskedmuliintrop><code>arm_sve.intr.mul</code> (arm_sve::ScalableMaskedMulIIntrOp)</a></li><li><a href=#arm_sveintrpsel-arm_svepselintrop><code>arm_sve.intr.psel</code> (arm_sve::PselIntrOp)</a></li><li><a href=#arm_sveintrsdiv-arm_svescalablemaskedsdiviintrop><code>arm_sve.intr.sdiv</code> (arm_sve::ScalableMaskedSDivIIntrOp)</a></li><li><a href=#arm_sveintrsdot-arm_svesdotintrop><code>arm_sve.intr.sdot</code> (arm_sve::SdotIntrOp)</a></li><li><a href=#arm_sveintrsmmla-arm_svesmmlaintrop><code>arm_sve.intr.smmla</code> (arm_sve::SmmlaIntrOp)</a></li><li><a href=#arm_sveintrsub-arm_svescalablemaskedsubiintrop><code>arm_sve.intr.sub</code> (arm_sve::ScalableMaskedSubIIntrOp)</a></li><li><a href=#arm_sveintrudiv-arm_svescalablemaskedudiviintrop><code>arm_sve.intr.udiv</code> (arm_sve::ScalableMaskedUDivIIntrOp)</a></li><li><a href=#arm_sveintrudot-arm_sveudotintrop><code>arm_sve.intr.udot</code> (arm_sve::UdotIntrOp)</a></li><li><a href=#arm_sveintrummla-arm_sveummlaintrop><code>arm_sve.intr.ummla</code> (arm_sve::UmmlaIntrOp)</a></li><li><a href=#arm_sveintrusmmla-arm_sveusmmlaintrop><code>arm_sve.intr.usmmla</code> (arm_sve::UsmmlaIntrOp)</a></li><li><a href=#arm_sveintrwhilelt-arm_svewhileltintrop><code>arm_sve.intr.whilelt</code> (arm_sve::WhileLTIntrOp)</a></li><li><a href=#arm_sveintrzipx2-arm_svezipx2introp><code>arm_sve.intr.zip.x2</code> (arm_sve::ZipX2IntrOp)</a></li><li><a href=#arm_sveintrzipx4-arm_svezipx4introp><code>arm_sve.intr.zip.x4</code> (arm_sve::ZipX4IntrOp)</a></li><li><a href=#arm_svemaskedaddf-arm_svescalablemaskedaddfop><code>arm_sve.masked.addf</code> (arm_sve::ScalableMaskedAddFOp)</a></li><li><a href=#arm_svemaskedaddi-arm_svescalablemaskedaddiop><code>arm_sve.masked.addi</code> (arm_sve::ScalableMaskedAddIOp)</a></li><li><a href=#arm_svemaskeddivf-arm_svescalablemaskeddivfop><code>arm_sve.masked.divf</code> (arm_sve::ScalableMaskedDivFOp)</a></li><li><a href=#arm_svemaskeddivi_signed-arm_svescalablemaskedsdiviop><code>arm_sve.masked.divi_signed</code> (arm_sve::ScalableMaskedSDivIOp)</a></li><li><a href=#arm_svemaskeddivi_unsigned-arm_svescalablemaskedudiviop><code>arm_sve.masked.divi_unsigned</code> (arm_sve::ScalableMaskedUDivIOp)</a></li><li><a href=#arm_svemaskedmulf-arm_svescalablemaskedmulfop><code>arm_sve.masked.mulf</code> (arm_sve::ScalableMaskedMulFOp)</a></li><li><a href=#arm_svemaskedmuli-arm_svescalablemaskedmuliop><code>arm_sve.masked.muli</code> (arm_sve::ScalableMaskedMulIOp)</a></li><li><a href=#arm_svemaskedsubf-arm_svescalablemaskedsubfop><code>arm_sve.masked.subf</code> (arm_sve::ScalableMaskedSubFOp)</a></li><li><a href=#arm_svemaskedsubi-arm_svescalablemaskedsubiop><code>arm_sve.masked.subi</code> (arm_sve::ScalableMaskedSubIOp)</a></li><li><a href=#arm_svepsel-arm_svepselop><code>arm_sve.psel</code> (arm_sve::PselOp)</a></li><li><a href=#arm_svesdot-arm_svesdotop><code>arm_sve.sdot</code> (arm_sve::SdotOp)</a></li><li><a href=#arm_svesmmla-arm_svesmmlaop><code>arm_sve.smmla</code> (arm_sve::SmmlaOp)</a></li><li><a href=#arm_sveudot-arm_sveudotop><code>arm_sve.udot</code> (arm_sve::UdotOp)</a></li><li><a href=#arm_sveummla-arm_sveummlaop><code>arm_sve.ummla</code> (arm_sve::UmmlaOp)</a></li><li><a href=#arm_sveusmmla-arm_sveusmmlaop><code>arm_sve.usmmla</code> (arm_sve::UsmmlaOp)</a></li><li><a href=#arm_svezipx2-arm_svezipx2op><code>arm_sve.zip.x2</code> (arm_sve::ZipX2Op)</a></li><li><a href=#arm_svezipx4-arm_svezipx4op><code>arm_sve.zip.x4</code> (arm_sve::ZipX4Op)</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/ArmSVE/IR/ArmSVE.td>source</a></p><h3 id=arm_sveconvert_from_svbool-arm_sveconvertfromsvboolop><code>arm_sve.convert_from_svbool</code> (arm_sve::ConvertFromSvboolOp)&nbsp;<a class=headline-hash href=#arm_sveconvert_from_svbool-arm_sveconvertfromsvboolop>¶</a></h3><p><em>Convert a svbool type to a SVE predicate type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.convert_from_svbool` $source attr-dict `:` type($result)
</code></pre><p>Converts svbool types (<code>vector&lt;[16]xi1></code> or vectors of that type, e.g.
<code>vector&lt;2x3x[16]xi1></code>) to SVE predicate types. Note: Only the trailing
dimension can be scalable.</p><p>Example 1: Convert a 1-D svbool mask to a SVE predicate.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%source</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>load <span class=nv>%memref</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sve<span class=p>.</span>convert_from_svbool <span class=nv>%source</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Convert a 2-D svbool mask to a mask of SVE predicates.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%source</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>load <span class=nv>%memref</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>2x?x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=p>[</span><span class=m>16</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sve<span class=p>.</span>convert_from_svbool <span class=nv>%source</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=p>[</span><span class=m>8</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span></code></pre></div><hr><p>A <code>svbool</code> is the smallest SVE predicate type that has a in-memory
representation (and maps to a full predicate register). In MLIR <code>svbool</code> is
represented as <code>vector&lt;[16]xi1></code>. Smaller SVE predicate types
(<code>vector&lt;[1|2|4|8]xi1></code>) must be stored as a <code>svbool</code> then converted back to
the original predicate type after loading.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>trailing scalable vector of 1-bit signless integer values with dim -1 having a size of {16}</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>trailing scalable vector of 1-bit signless integer values with dim -1 having a size of {16, 8, 4, 2, 1}</td></tr></tbody></table><h3 id=arm_sveconvert_to_svbool-arm_sveconverttosvboolop><code>arm_sve.convert_to_svbool</code> (arm_sve::ConvertToSvboolOp)&nbsp;<a class=headline-hash href=#arm_sveconvert_to_svbool-arm_sveconverttosvboolop>¶</a></h3><p><em>Convert a SVE predicate type to a svbool type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.convert_to_svbool` $source attr-dict `:` type($source)
</code></pre><p>Converts SVE predicate types (or vectors of predicate types, e.g.
<code>vector&lt;4x[4]xi1></code>) to svbool types. Note: Only the trailing dimension can
be scalable.</p><p>Example 1: Convert a 1-D SVE predicate to a svbool mask.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%source</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>create_mask <span class=nv>%dim_size</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sve<span class=p>.</span>convert_to_svbool <span class=nv>%source</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// =&gt; Results in vector&lt;[16]xi1&gt;
</span></span></span></code></pre></div><p>Example 2: Convert a 2-D mask of SVE predicates to a svbool mask.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%source</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>create_mask <span class=nv>%c2</span><span class=p>,</span> <span class=nv>%dim_size</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=p>[</span><span class=m>2</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sve<span class=p>.</span>convert_to_svbool <span class=nv>%source</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x</span><span class=p>[</span><span class=m>2</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// =&gt; Results in vector&lt;2x[16]xi1&gt;
</span></span></span></code></pre></div><hr><p>A <code>svbool</code> is the smallest SVE predicate type that has a in-memory
representation (and maps to a full predicate register). In MLIR <code>svbool</code> is
represented as <code>vector&lt;[16]xi1></code>. Smaller SVE predicate types
(<code>vector&lt;[1|2|4|8]xi1></code>) must be converted to a <code>svbool</code> before they can be
stored.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>source</code></td><td>trailing scalable vector of 1-bit signless integer values with dim -1 having a size of {16, 8, 4, 2, 1}</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>trailing scalable vector of 1-bit signless integer values with dim -1 having a size of {16}</td></tr></tbody></table><h3 id=arm_svedupq_lane-arm_svedupqlaneop><code>arm_sve.dupq_lane</code> (arm_sve::DupQLaneOp)&nbsp;<a class=headline-hash href=#arm_svedupq_lane-arm_svedupqlaneop>¶</a></h3><p><em>Broadcast indexed 128-bit segment to vector</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.dupq_lane` $src `[` $lane `]` attr-dict `:` type($dst)
</code></pre><p>This operation fills each 128-bit segment of a vector with the elements
from the indexed 128-bit segment of the source vector. If the VL is
128 bits the operation is a NOP. If the index exceeds the number of
128-bit segments in a vector the result is an all-zeroes vector.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// VL == 256
</span></span></span><span class=line><span class=cl><span class=c>// %X = [A B C D x x x x]
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%Y</span> <span class=p>=</span> arm_sve<span class=p>.</span>dupq_lane <span class=nv>%X</span><span class=p>[</span><span class=m>0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// Y = [A B C D A B C D]
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=c>// %U = [x x x x x x x x A B C D E F G H]
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%V</span> <span class=p>=</span> arm_sve<span class=p>.</span>dupq_lane <span class=nv>%U</span><span class=p>[</span><span class=m>1</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// %V = [A B C D E F H A B C D E F H]
</span></span></span></code></pre></div><p>Note: The semantics of the operation match those of the <code>svdupq_lane</code> instrinsics.
<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=svdupq_lane">Source</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lane</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><h3 id=arm_sveintradd-arm_svescalablemaskedaddiintrop><code>arm_sve.intr.add</code> (arm_sve::ScalableMaskedAddIIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintradd-arm_svescalablemaskedaddiintrop>¶</a></h3><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrbfmmla-arm_svebfmmlaop><code>arm_sve.intr.bfmmla</code> (arm_sve::BfmmlaOp)&nbsp;<a class=headline-hash href=#arm_sveintrbfmmla-arm_svebfmmlaop>¶</a></h3><p><em>BFloat16 matrix multiply-accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.intr.bfmmla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($res)
</code></pre><p>BFMMLA: BFloat16 matrix multiply-accumulate into 2×2 matrices";</p><p>This operation multiplies the 2x4 BFloat16 matrix held in each 128-bit
segment of the first source vector by the 4x2 BFloat16 matrix in the
corresponding segment of the second source vector, then accumulates
this intermediate result with the 2x2 Float32 matrix in the corresponding
segment of the accumulator vector, yielding the final 2x2 Float32
segment of the result.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit float values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of bfloat16 type values of length 8</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 32-bit float values of length 4</td></tr></tbody></table><h3 id=arm_sveintrconvertfromsvbool-arm_sveconvertfromsvboolintrop><code>arm_sve.intr.convert.from.svbool</code> (arm_sve::ConvertFromSvboolIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrconvertfromsvbool-arm_sveconvertfromsvboolintrop>¶</a></h3><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>svbool</code></td><td>vector&lt;[16]xi1></td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrconverttosvbool-arm_sveconverttosvboolintrop><code>arm_sve.intr.convert.to.svbool</code> (arm_sve::ConvertToSvboolIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrconverttosvbool-arm_sveconverttosvboolintrop>¶</a></h3><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>vector&lt;[1]xi1>, vector&lt;[2]xi1>, vector&lt;[4]xi1>, vector&lt;[8]xi1>, or vector&lt;[16]xi1></td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrdupq_lane-arm_svedupqlaneintrop><code>arm_sve.intr.dupq_lane</code> (arm_sve::DupQLaneIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrdupq_lane-arm_svedupqlaneintrop>¶</a></h3><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lane</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>v</code></td><td>of ranks 1</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrfadd-arm_svescalablemaskedaddfintrop><code>arm_sve.intr.fadd</code> (arm_sve::ScalableMaskedAddFIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrfadd-arm_svescalablemaskedaddfintrop>¶</a></h3><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrfdiv-arm_svescalablemaskeddivfintrop><code>arm_sve.intr.fdiv</code> (arm_sve::ScalableMaskedDivFIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrfdiv-arm_svescalablemaskeddivfintrop>¶</a></h3><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrfmul-arm_svescalablemaskedmulfintrop><code>arm_sve.intr.fmul</code> (arm_sve::ScalableMaskedMulFIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrfmul-arm_svescalablemaskedmulfintrop>¶</a></h3><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrfsub-arm_svescalablemaskedsubfintrop><code>arm_sve.intr.fsub</code> (arm_sve::ScalableMaskedSubFIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrfsub-arm_svescalablemaskedsubfintrop>¶</a></h3><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrmul-arm_svescalablemaskedmuliintrop><code>arm_sve.intr.mul</code> (arm_sve::ScalableMaskedMulIIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrmul-arm_svescalablemaskedmuliintrop>¶</a></h3><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrpsel-arm_svepselintrop><code>arm_sve.intr.psel</code> (arm_sve::PselIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrpsel-arm_svepselintrop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>p1</code></td><td>vector&lt;[16]xi1></td></tr><tr><td style=text-align:center><code>p2</code></td><td>vector&lt;[1]xi1>, vector&lt;[2]xi1>, vector&lt;[4]xi1>, vector&lt;[8]xi1>, or vector&lt;[16]xi1></td></tr><tr><td style=text-align:center><code>index</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrsdiv-arm_svescalablemaskedsdiviintrop><code>arm_sve.intr.sdiv</code> (arm_sve::ScalableMaskedSDivIIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsdiv-arm_svescalablemaskedsdiviintrop>¶</a></h3><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrsdot-arm_svesdotintrop><code>arm_sve.intr.sdot</code> (arm_sve::SdotIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsdot-arm_svesdotintrop>¶</a></h3><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrsmmla-arm_svesmmlaintrop><code>arm_sve.intr.smmla</code> (arm_sve::SmmlaIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsmmla-arm_svesmmlaintrop>¶</a></h3><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrsub-arm_svescalablemaskedsubiintrop><code>arm_sve.intr.sub</code> (arm_sve::ScalableMaskedSubIIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrsub-arm_svescalablemaskedsubiintrop>¶</a></h3><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrudiv-arm_svescalablemaskedudiviintrop><code>arm_sve.intr.udiv</code> (arm_sve::ScalableMaskedUDivIIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrudiv-arm_svescalablemaskedudiviintrop>¶</a></h3><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrudot-arm_sveudotintrop><code>arm_sve.intr.udot</code> (arm_sve::UdotIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrudot-arm_sveudotintrop>¶</a></h3><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrummla-arm_sveummlaintrop><code>arm_sve.intr.ummla</code> (arm_sve::UmmlaIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrummla-arm_sveummlaintrop>¶</a></h3><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrusmmla-arm_sveusmmlaintrop><code>arm_sve.intr.usmmla</code> (arm_sve::UsmmlaIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrusmmla-arm_sveusmmlaintrop>¶</a></h3><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center>«unnamed»</td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrwhilelt-arm_svewhileltintrop><code>arm_sve.intr.whilelt</code> (arm_sve::WhileLTIntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrwhilelt-arm_svewhileltintrop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>64-bit signless integer</td></tr><tr><td style=text-align:center><code>n</code></td><td>64-bit signless integer</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrzipx2-arm_svezipx2introp><code>arm_sve.intr.zip.x2</code> (arm_sve::ZipX2IntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrzipx2-arm_svezipx2introp>¶</a></h3><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>v1</code></td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center><code>v2</code></td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_sveintrzipx4-arm_svezipx4introp><code>arm_sve.intr.zip.x4</code> (arm_sve::ZipX4IntrOp)&nbsp;<a class=headline-hash href=#arm_sveintrzipx4-arm_svezipx4introp>¶</a></h3><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>v1</code></td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center><code>v2</code></td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center><code>v3</code></td><td>scalable vector of any type values</td></tr><tr><td style=text-align:center><code>v4</code></td><td>scalable vector of any type values</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_svemaskedaddf-arm_svescalablemaskedaddfop><code>arm_sve.masked.addf</code> (arm_sve::ScalableMaskedAddFOp)&nbsp;<a class=headline-hash href=#arm_svemaskedaddf-arm_svescalablemaskedaddfop>¶</a></h3><p><em>Masked addition for scalable vectors of floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.addf` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.addf</code> operation takes one scalable vector mask
and two scalable vector operands, and perform floating point addition on active lanes. Inactive lanes will keep the value of
the first operand.</p><p>Traits: <code>Commutative</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of floating-point values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h3 id=arm_svemaskedaddi-arm_svescalablemaskedaddiop><code>arm_sve.masked.addi</code> (arm_sve::ScalableMaskedAddIOp)&nbsp;<a class=headline-hash href=#arm_svemaskedaddi-arm_svescalablemaskedaddiop>¶</a></h3><p><em>Masked addition for scalable vectors of integers</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.addi` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.addi</code> operation takes one scalable vector mask
and two scalable vector operands, and perform integer addition on active lanes. Inactive lanes will keep the value of
the first operand.</p><p>Traits: <code>Commutative</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_svemaskeddivf-arm_svescalablemaskeddivfop><code>arm_sve.masked.divf</code> (arm_sve::ScalableMaskedDivFOp)&nbsp;<a class=headline-hash href=#arm_svemaskeddivf-arm_svescalablemaskeddivfop>¶</a></h3><p><em>Masked division for scalable vectors of floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.divf` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.divf</code> operation takes one scalable vector mask
and two scalable vector operands, and perform floating point division on active lanes. Inactive lanes will keep the value of
the first operand.</p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of floating-point values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h3 id=arm_svemaskeddivi_signed-arm_svescalablemaskedsdiviop><code>arm_sve.masked.divi_signed</code> (arm_sve::ScalableMaskedSDivIOp)&nbsp;<a class=headline-hash href=#arm_svemaskeddivi_signed-arm_svescalablemaskedsdiviop>¶</a></h3><p><em>Masked signed division for scalable vectors of integers</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.divi_signed` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.divi_signed</code> operation takes one scalable vector mask
and two scalable vector operands, and perform integer signed division on active lanes. Inactive lanes will keep the value of
the first operand.</p><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_svemaskeddivi_unsigned-arm_svescalablemaskedudiviop><code>arm_sve.masked.divi_unsigned</code> (arm_sve::ScalableMaskedUDivIOp)&nbsp;<a class=headline-hash href=#arm_svemaskeddivi_unsigned-arm_svescalablemaskedudiviop>¶</a></h3><p><em>Masked unsigned division for scalable vectors of integers</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.divi_unsigned` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.divi_unsigned</code> operation takes one scalable vector mask
and two scalable vector operands, and perform integer unsigned division on active lanes. Inactive lanes will keep the value of
the first operand.</p><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_svemaskedmulf-arm_svescalablemaskedmulfop><code>arm_sve.masked.mulf</code> (arm_sve::ScalableMaskedMulFOp)&nbsp;<a class=headline-hash href=#arm_svemaskedmulf-arm_svescalablemaskedmulfop>¶</a></h3><p><em>Masked multiplication for scalable vectors of floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.mulf` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.mulf</code> operation takes one scalable vector mask
and two scalable vector operands, and perform floating point multiplication on active lanes. Inactive lanes will keep the value of
the first operand.</p><p>Traits: <code>Commutative</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of floating-point values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h3 id=arm_svemaskedmuli-arm_svescalablemaskedmuliop><code>arm_sve.masked.muli</code> (arm_sve::ScalableMaskedMulIOp)&nbsp;<a class=headline-hash href=#arm_svemaskedmuli-arm_svescalablemaskedmuliop>¶</a></h3><p><em>Masked multiplication for scalable vectors of integers</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.muli` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.muli</code> operation takes one scalable vector mask
and two scalable vector operands, and perform integer multiplication on active lanes. Inactive lanes will keep the value of
the first operand.</p><p>Traits: <code>Commutative</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_svemaskedsubf-arm_svescalablemaskedsubfop><code>arm_sve.masked.subf</code> (arm_sve::ScalableMaskedSubFOp)&nbsp;<a class=headline-hash href=#arm_svemaskedsubf-arm_svescalablemaskedsubfop>¶</a></h3><p><em>Masked subtraction for scalable vectors of floats</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.subf` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.subf</code> operation takes one scalable vector mask
and two scalable vector operands, and perform floating point subtraction on active lanes. Inactive lanes will keep the value of
the first operand.</p><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of floating-point values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of floating-point values</td></tr></tbody></table><h3 id=arm_svemaskedsubi-arm_svescalablemaskedsubiop><code>arm_sve.masked.subi</code> (arm_sve::ScalableMaskedSubIOp)&nbsp;<a class=headline-hash href=#arm_svemaskedsubi-arm_svescalablemaskedsubiop>¶</a></h3><p><em>Masked subtraction for scalable vectors of integers</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.masked.subi` $mask `,` $src1 `,` $src2 attr-dict `:` type($mask) `,` type($res)
</code></pre><p>The <code>arm_sve.masked.subi</code> operation takes one scalable vector mask
and two scalable vector operands, and perform integer subtraction on active lanes. Inactive lanes will keep the value of
the first operand.</p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>mask</code></td><td>scalable vector of 1-bit signless integer values</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_svepsel-arm_svepselop><code>arm_sve.psel</code> (arm_sve::PselOp)&nbsp;<a class=headline-hash href=#arm_svepsel-arm_svepselop>¶</a></h3><p><em>Predicate select</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.psel` $p1 `,` $p2 `[` $index `]` attr-dict `:` type($p1) `,` type($p2)
</code></pre><p>This operation returns the input predicate <code>p1</code> or an all-false predicate
based on the bit at <code>p2[index]</code>. Informally, the semantics are:</p><pre tabindex=0><code>if p2[index % num_elements(p2)] == 1:
  return p1 : type(p1)
return all-false : type(p1)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Note: p1 and p2 can have different sizes.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%pd</span> <span class=p>=</span> arm_sve<span class=p>.</span>psel <span class=nv>%p1</span><span class=p>,</span> <span class=nv>%p2</span><span class=p>[</span><span class=nv>%index</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi1<span class=p>&gt;</span>
</span></span></code></pre></div><p>Note: This requires SME or SVE2.1 (<code>+sme</code> or <code>+sve2p1</code> in LLVM target features).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>p1</code></td><td>vector&lt;[1]xi1>, vector&lt;[2]xi1>, vector&lt;[4]xi1>, vector&lt;[8]xi1>, or vector&lt;[16]xi1></td></tr><tr><td style=text-align:center><code>p2</code></td><td>vector&lt;[1]xi1>, vector&lt;[2]xi1>, vector&lt;[4]xi1>, vector&lt;[8]xi1>, or vector&lt;[16]xi1></td></tr><tr><td style=text-align:center><code>index</code></td><td>index</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[1]xi1>, vector&lt;[2]xi1>, vector&lt;[4]xi1>, vector&lt;[8]xi1>, or vector&lt;[16]xi1></td></tr></tbody></table><h3 id=arm_svesdot-arm_svesdotop><code>arm_sve.sdot</code> (arm_sve::SdotOp)&nbsp;<a class=headline-hash href=#arm_svesdot-arm_svesdotop>¶</a></h3><p><em>Vector-vector dot product and accumulate op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.sdot` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>SDOT: Signed integer addition of dot product.</p><p>This function maps to the SDOT instruction, and it takes signless integer
operands that the operation interprets as signed. It partitions the second
and third vector inputs into groups of four elements. They calculate the dot
product of each group (without loss of precision) and then add each result
to the overlapping element of the first vector input.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr></tbody></table><h3 id=arm_svesmmla-arm_svesmmlaop><code>arm_sve.smmla</code> (arm_sve::SmmlaOp)&nbsp;<a class=headline-hash href=#arm_svesmmla-arm_svesmmlaop>¶</a></h3><p><em>Matrix-matrix multiply and accumulate op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.smmla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>SMMLA: Signed integer matrix multiply-accumulate.</p><p>This function maps to the SMMLA instruction, and it takes signless integer
operands that the operation interprets as signed. It partitions the inputs
into 128-bit quadwords, with the first input containing a row-by-row 2×2
matrix of 32-bit integers, the second input containing a row-by-row 2×8
matrix of 8-bit integers, and the third input containing a column-by-column
8×2 matrix of 8-bit integers. For each quadword, they multiply the second
input matrix by the third input matrix using natural arithmetic and then add
the result to the first input using modular arithmetic.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=arm_sveudot-arm_sveudotop><code>arm_sve.udot</code> (arm_sve::UdotOp)&nbsp;<a class=headline-hash href=#arm_sveudot-arm_sveudotop>¶</a></h3><p><em>Vector-vector dot product and accumulate op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.udot` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>UDOT: Unsigned integer addition of dot product.</p><p>This function maps to the UDOT instruction, and it takes signless integer
operands that the operation interprets as unsigned. It partitions the second
and third vector inputs into groups of four elements. They calculate the dot
product of each group (without loss of precision) and then add each result
to the overlapping element of the first vector input.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer or 16-bit signless integer values of length 16/8</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer or 64-bit signless integer values of length 4/2</td></tr></tbody></table><h3 id=arm_sveummla-arm_sveummlaop><code>arm_sve.ummla</code> (arm_sve::UmmlaOp)&nbsp;<a class=headline-hash href=#arm_sveummla-arm_sveummlaop>¶</a></h3><p><em>Matrix-matrix multiply and accumulate op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.ummla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>UMMLA: Unsigned integer matrix multiply-accumulate.</p><p>This function maps to the UMMLA instruction, and it takes signless integer
operands that the operation interprets as unsigned. It partitions the inputs
into 128-bit quadwords, with the first input containing a row-by-row 2×2
matrix of 32-bit integers, the second input containing a row-by-row 2×8
matrix of 8-bit integers, and the third input containing a column-by-column
8×2 matrix of 8-bit integers. For each quadword, they multiply the second
input matrix by the third input matrix using natural arithmetic and then add
the result to the first input using modular arithmetic.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=arm_sveusmmla-arm_sveusmmlaop><code>arm_sve.usmmla</code> (arm_sve::UsmmlaOp)&nbsp;<a class=headline-hash href=#arm_sveusmmla-arm_sveusmmlaop>¶</a></h3><p><em>Matrix-matrix multiply and accumulate op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.usmmla` $acc `,` $src1 `,` $src2 attr-dict `:` type($src1) `to` type($dst)
</code></pre><p>USMMLA: Unsigned by signed integer matrix multiply-accumulate.</p><p>The unsigned by signed integer matrix multiply-accumulate operation
multiplies the 2×8 matrix of unsigned 8-bit integer values held
the first source vector by the 8×2 matrix of signed 8-bit integer
values in the second source vector. The resulting 2×2 widened 32-bit
integer matrix product is then added to the 32-bit integer matrix
accumulator.</p><p>Source:
<a href=https://developer.arm.com/documentation/100987/0000>https://developer.arm.com/documentation/100987/0000</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>acc</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr><tr><td style=text-align:center><code>src1</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr><tr><td style=text-align:center><code>src2</code></td><td>scalable vector of 8-bit signless integer values of length 16</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>scalable vector of 32-bit signless integer values of length 4</td></tr></tbody></table><h3 id=arm_svezipx2-arm_svezipx2op><code>arm_sve.zip.x2</code> (arm_sve::ZipX2Op)&nbsp;<a class=headline-hash href=#arm_svezipx2-arm_svezipx2op>¶</a></h3><p><em>Multi-vector two-way zip op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.zip.x2` $sourceV1 `,` $sourceV2 attr-dict `:` type($sourceV1)
</code></pre><p>This operation interleaves elements from two input SVE vectors, returning
two new SVE vectors (<code>resultV1</code> and <code>resultV2</code>), which contain the low and
high halves of the result respectively.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// sourceV1 = [ A1, A2, A3, ... An ]
</span></span></span><span class=line><span class=cl><span class=c>// sourceV2 = [ B1, B2, B3, ... Bn ]
</span></span></span><span class=line><span class=cl><span class=c>// (resultV1, resultV2) = [ A1, B1, A2, B2, A3, B3, ... An, Bn ]
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%resultV1</span><span class=p>,</span> <span class=nv>%resultV2</span> <span class=p>=</span> arm_sve<span class=p>.</span>zip<span class=p>.</span>x2 <span class=nv>%sourceV1</span><span class=p>,</span> <span class=nv>%sourceV2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Note: This requires SME 2 (<code>+sme2</code> in LLVM target features)</p><p><a href="https://developer.arm.com/documentation/ddi0602/2023-12/SME-Instructions/ZIP--two-registers---Interleave-elements-from-two-vectors-?lang=en">Source</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sourceV1</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>sourceV2</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>resultV1</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>resultV2</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><h3 id=arm_svezipx4-arm_svezipx4op><code>arm_sve.zip.x4</code> (arm_sve::ZipX4Op)&nbsp;<a class=headline-hash href=#arm_svezipx4-arm_svezipx4op>¶</a></h3><p><em>Multi-vector four-way zip op</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sve.zip.x4` $sourceV1 `,` $sourceV2 `,` $sourceV3 `,` $sourceV4 attr-dict
              `:` type($sourceV1)
</code></pre><p>This operation interleaves elements from four input SVE vectors, returning
four new SVE vectors, each of which contain a quarter of the result. The
first quarter will be in <code>resultV1</code>, second in <code>resultV2</code>, third in
<code>resultV3</code>, and fourth in <code>resultV4</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// sourceV1 = [ A1, A2, ... An ]
</span></span></span><span class=line><span class=cl><span class=c>// sourceV2 = [ B1, B2, ... Bn ]
</span></span></span><span class=line><span class=cl><span class=c>// sourceV3 = [ C1, C2, ... Cn ]
</span></span></span><span class=line><span class=cl><span class=c>// sourceV4 = [ D1, D2, ... Dn ]
</span></span></span><span class=line><span class=cl><span class=c>// (resultV1, resultV2, resultV3, resultV4)
</span></span></span><span class=line><span class=cl><span class=c>//   = [ A1, B1, C1, D1, A2, B2, C2, D2, ... An, Bn, Cn, Dn ]
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%resultV1</span><span class=p>,</span> <span class=nv>%resultV2</span><span class=p>,</span> <span class=nv>%resultV3</span><span class=p>,</span> <span class=nv>%resultV4</span> <span class=p>=</span> arm_sve<span class=p>.</span>zip<span class=p>.</span>x4
</span></span><span class=line><span class=cl>  <span class=nv>%sourceV1</span><span class=p>,</span> <span class=nv>%sourceV2</span><span class=p>,</span> <span class=nv>%sourceV3</span><span class=p>,</span> <span class=nv>%sourceV4</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p><strong>Warning:</strong> The result of this op is undefined for 64-bit elements on
hardware with less than 256-bit vectors!</p><p>Note: This requires SME 2 (<code>+sme2</code> in LLVM target features)</p><p><a href="https://developer.arm.com/documentation/ddi0602/2023-12/SME-Instructions/ZIP--four-registers---Interleave-elements-from-four-vectors-?lang=en">Source</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sourceV1</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>sourceV2</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>sourceV3</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>sourceV4</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>resultV1</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>resultV2</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>resultV3</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr><tr><td style=text-align:center><code>resultV4</code></td><td>an SVE vector with element size &lt;= 64-bit</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/ArmNeon/ title="'arm_neon' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'arm_neon' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/ArmSME/ title="'ArmSME' Dialect">Next - 'ArmSME' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>