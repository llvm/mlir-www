<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'llvm' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/LLVM/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'llvm' Dialect</h1><p>This dialect maps
<a href=https://llvm.org/docs/LangRef.html>LLVM IR</a> into MLIR by
defining the corresponding operations and types. LLVM IR metadata is usually
represented as MLIR attributes, which offer additional structure verification.</p><p>We use &ldquo;LLVM IR&rdquo; to designate the
<a href=https://llvm.org/docs/LangRef.html>intermediate representation of LLVM</a> and
&ldquo;LLVM <em>dialect</em>&rdquo; or &ldquo;LLVM IR <em>dialect</em>&rdquo; to refer to this MLIR dialect.</p><p>Unless explicitly stated otherwise, the semantics of the LLVM dialect operations
must correspond to the semantics of LLVM IR instructions and any divergence is
considered a bug. The dialect also contains auxiliary operations that smoothen
the differences in the IR structure, e.g., MLIR does not have <code>phi</code> operations
and LLVM IR does not have a <code>constant</code> operation. These auxiliary operations are
systematically prefixed with <code>mlir</code>, e.g. <code>llvm.mlir.constant</code> where <code>llvm.</code> is
the dialect namespace prefix.</p><p><nav id=TableOfContents><ul><li><a href=#dependency-on-llvm-ir>Dependency on LLVM IR</a></li><li><a href=#module-structure>Module Structure</a><ul><li><a href=#data-layout-and-triple>Data Layout and Triple</a></li><li><a href=#functions>Functions</a></li><li><a href=#phi-nodes-and-block-arguments>PHI Nodes and Block Arguments</a></li><li><a href=#context-level-values>Context-Level Values</a></li><li><a href=#globals>Globals</a></li><li><a href=#linkage>Linkage</a></li><li><a href=#attribute-pass-through>Attribute Pass-Through</a></li></ul></li><li><a href=#types>Types</a><ul><li><a href=#built-in-type-compatibility>Built-in Type Compatibility</a></li><li><a href=#additional-simple-types>Additional Simple Types</a></li><li><a href=#additional-parametric-types>Additional Parametric Types</a></li><li><a href=#vector-types>Vector Types</a></li><li><a href=#structure-types>Structure Types</a></li><li><a href=#unsupported-types>Unsupported Types</a></li></ul></li><li><a href=#operations>Operations</a><ul><li><a href=#llvmashr-llvmashrop><code>llvm.ashr</code> (LLVM::AShrOp)</a></li><li><a href=#llvmadd-llvmaddop><code>llvm.add</code> (LLVM::AddOp)</a></li><li><a href=#llvmaddrspacecast-llvmaddrspacecastop><code>llvm.addrspacecast</code> (LLVM::AddrSpaceCastOp)</a></li><li><a href=#llvmmliraddressof-llvmaddressofop><code>llvm.mlir.addressof</code> (LLVM::AddressOfOp)</a></li><li><a href=#llvmmliralias-llvmaliasop><code>llvm.mlir.alias</code> (LLVM::AliasOp)</a></li><li><a href=#llvmalloca-llvmallocaop><code>llvm.alloca</code> (LLVM::AllocaOp)</a></li><li><a href=#llvmand-llvmandop><code>llvm.and</code> (LLVM::AndOp)</a></li><li><a href=#llvmcmpxchg-llvmatomiccmpxchgop><code>llvm.cmpxchg</code> (LLVM::AtomicCmpXchgOp)</a></li><li><a href=#llvmatomicrmw-llvmatomicrmwop><code>llvm.atomicrmw</code> (LLVM::AtomicRMWOp)</a></li><li><a href=#llvmbitcast-llvmbitcastop><code>llvm.bitcast</code> (LLVM::BitcastOp)</a></li><li><a href=#llvmblockaddress-llvmblockaddressop><code>llvm.blockaddress</code> (LLVM::BlockAddressOp)</a></li><li><a href=#llvmblocktag-llvmblocktagop><code>llvm.blocktag</code> (LLVM::BlockTagOp)</a></li><li><a href=#llvmbr-llvmbrop><code>llvm.br</code> (LLVM::BrOp)</a></li><li><a href=#llvmcall_intrinsic-llvmcallintrinsicop><code>llvm.call_intrinsic</code> (LLVM::CallIntrinsicOp)</a></li><li><a href=#llvmcall-llvmcallop><code>llvm.call</code> (LLVM::CallOp)</a></li><li><a href=#llvmcomdat-llvmcomdatop><code>llvm.comdat</code> (LLVM::ComdatOp)</a></li><li><a href=#llvmcomdat_selector-llvmcomdatselectorop><code>llvm.comdat_selector</code> (LLVM::ComdatSelectorOp)</a></li><li><a href=#llvmcond_br-llvmcondbrop><code>llvm.cond_br</code> (LLVM::CondBrOp)</a></li><li><a href=#llvmmlirconstant-llvmconstantop><code>llvm.mlir.constant</code> (LLVM::ConstantOp)</a></li><li><a href=#llvmdso_local_equivalent-llvmdsolocalequivalentop><code>llvm.dso_local_equivalent</code> (LLVM::DSOLocalEquivalentOp)</a></li><li><a href=#llvmextractelement-llvmextractelementop><code>llvm.extractelement</code> (LLVM::ExtractElementOp)</a></li><li><a href=#llvmextractvalue-llvmextractvalueop><code>llvm.extractvalue</code> (LLVM::ExtractValueOp)</a></li><li><a href=#llvmfadd-llvmfaddop><code>llvm.fadd</code> (LLVM::FAddOp)</a></li><li><a href=#llvmfcmp-llvmfcmpop><code>llvm.fcmp</code> (LLVM::FCmpOp)</a></li><li><a href=#llvmfdiv-llvmfdivop><code>llvm.fdiv</code> (LLVM::FDivOp)</a></li><li><a href=#llvmfmul-llvmfmulop><code>llvm.fmul</code> (LLVM::FMulOp)</a></li><li><a href=#llvmfneg-llvmfnegop><code>llvm.fneg</code> (LLVM::FNegOp)</a></li><li><a href=#llvmfpext-llvmfpextop><code>llvm.fpext</code> (LLVM::FPExtOp)</a></li><li><a href=#llvmfptosi-llvmfptosiop><code>llvm.fptosi</code> (LLVM::FPToSIOp)</a></li><li><a href=#llvmfptoui-llvmfptouiop><code>llvm.fptoui</code> (LLVM::FPToUIOp)</a></li><li><a href=#llvmfptrunc-llvmfptruncop><code>llvm.fptrunc</code> (LLVM::FPTruncOp)</a></li><li><a href=#llvmfrem-llvmfremop><code>llvm.frem</code> (LLVM::FRemOp)</a></li><li><a href=#llvmfsub-llvmfsubop><code>llvm.fsub</code> (LLVM::FSubOp)</a></li><li><a href=#llvmfence-llvmfenceop><code>llvm.fence</code> (LLVM::FenceOp)</a></li><li><a href=#llvmfreeze-llvmfreezeop><code>llvm.freeze</code> (LLVM::FreezeOp)</a></li><li><a href=#llvmgetelementptr-llvmgepop><code>llvm.getelementptr</code> (LLVM::GEPOp)</a></li><li><a href=#llvmmlirglobal_ctors-llvmglobalctorsop><code>llvm.mlir.global_ctors</code> (LLVM::GlobalCtorsOp)</a></li><li><a href=#llvmmlirglobal_dtors-llvmglobaldtorsop><code>llvm.mlir.global_dtors</code> (LLVM::GlobalDtorsOp)</a></li><li><a href=#llvmmlirglobal-llvmglobalop><code>llvm.mlir.global</code> (LLVM::GlobalOp)</a></li><li><a href=#llvmicmp-llvmicmpop><code>llvm.icmp</code> (LLVM::ICmpOp)</a></li><li><a href=#llvmmlirifunc-llvmifuncop><code>llvm.mlir.ifunc</code> (LLVM::IFuncOp)</a></li><li><a href=#llvmindirectbr-llvmindirectbrop><code>llvm.indirectbr</code> (LLVM::IndirectBrOp)</a></li><li><a href=#llvminline_asm-llvminlineasmop><code>llvm.inline_asm</code> (LLVM::InlineAsmOp)</a></li><li><a href=#llvminsertelement-llvminsertelementop><code>llvm.insertelement</code> (LLVM::InsertElementOp)</a></li><li><a href=#llvminsertvalue-llvminsertvalueop><code>llvm.insertvalue</code> (LLVM::InsertValueOp)</a></li><li><a href=#llvminttoptr-llvminttoptrop><code>llvm.inttoptr</code> (LLVM::IntToPtrOp)</a></li><li><a href=#llvminvoke-llvminvokeop><code>llvm.invoke</code> (LLVM::InvokeOp)</a></li><li><a href=#llvmfunc-llvmllvmfuncop><code>llvm.func</code> (LLVM::LLVMFuncOp)</a></li><li><a href=#llvmlshr-llvmlshrop><code>llvm.lshr</code> (LLVM::LShrOp)</a></li><li><a href=#llvmlandingpad-llvmlandingpadop><code>llvm.landingpad</code> (LLVM::LandingpadOp)</a></li><li><a href=#llvmlinker_options-llvmlinkeroptionsop><code>llvm.linker_options</code> (LLVM::LinkerOptionsOp)</a></li><li><a href=#llvmload-llvmloadop><code>llvm.load</code> (LLVM::LoadOp)</a></li><li><a href=#llvmmodule_flags-llvmmoduleflagsop><code>llvm.module_flags</code> (LLVM::ModuleFlagsOp)</a></li><li><a href=#llvmmul-llvmmulop><code>llvm.mul</code> (LLVM::MulOp)</a></li><li><a href=#llvmmlirnone-llvmnonetokenop><code>llvm.mlir.none</code> (LLVM::NoneTokenOp)</a></li><li><a href=#llvmor-llvmorop><code>llvm.or</code> (LLVM::OrOp)</a></li><li><a href=#llvmmlirpoison-llvmpoisonop><code>llvm.mlir.poison</code> (LLVM::PoisonOp)</a></li><li><a href=#llvmptrtoint-llvmptrtointop><code>llvm.ptrtoint</code> (LLVM::PtrToIntOp)</a></li><li><a href=#llvmresume-llvmresumeop><code>llvm.resume</code> (LLVM::ResumeOp)</a></li><li><a href=#llvmreturn-llvmreturnop><code>llvm.return</code> (LLVM::ReturnOp)</a></li><li><a href=#llvmsdiv-llvmsdivop><code>llvm.sdiv</code> (LLVM::SDivOp)</a></li><li><a href=#llvmsext-llvmsextop><code>llvm.sext</code> (LLVM::SExtOp)</a></li><li><a href=#llvmsitofp-llvmsitofpop><code>llvm.sitofp</code> (LLVM::SIToFPOp)</a></li><li><a href=#llvmsrem-llvmsremop><code>llvm.srem</code> (LLVM::SRemOp)</a></li><li><a href=#llvmselect-llvmselectop><code>llvm.select</code> (LLVM::SelectOp)</a></li><li><a href=#llvmshl-llvmshlop><code>llvm.shl</code> (LLVM::ShlOp)</a></li><li><a href=#llvmshufflevector-llvmshufflevectorop><code>llvm.shufflevector</code> (LLVM::ShuffleVectorOp)</a></li><li><a href=#llvmstore-llvmstoreop><code>llvm.store</code> (LLVM::StoreOp)</a></li><li><a href=#llvmsub-llvmsubop><code>llvm.sub</code> (LLVM::SubOp)</a></li><li><a href=#llvmswitch-llvmswitchop><code>llvm.switch</code> (LLVM::SwitchOp)</a></li><li><a href=#llvmtrunc-llvmtruncop><code>llvm.trunc</code> (LLVM::TruncOp)</a></li><li><a href=#llvmudiv-llvmudivop><code>llvm.udiv</code> (LLVM::UDivOp)</a></li><li><a href=#llvmuitofp-llvmuitofpop><code>llvm.uitofp</code> (LLVM::UIToFPOp)</a></li><li><a href=#llvmurem-llvmuremop><code>llvm.urem</code> (LLVM::URemOp)</a></li><li><a href=#llvmmlirundef-llvmundefop><code>llvm.mlir.undef</code> (LLVM::UndefOp)</a></li><li><a href=#llvmunreachable-llvmunreachableop><code>llvm.unreachable</code> (LLVM::UnreachableOp)</a></li><li><a href=#llvmva_arg-llvmvaargop><code>llvm.va_arg</code> (LLVM::VaArgOp)</a></li><li><a href=#llvmxor-llvmxorop><code>llvm.xor</code> (LLVM::XOrOp)</a></li><li><a href=#llvmzext-llvmzextop><code>llvm.zext</code> (LLVM::ZExtOp)</a></li><li><a href=#llvmmlirzero-llvmzeroop><code>llvm.mlir.zero</code> (LLVM::ZeroOp)</a></li></ul></li><li><a href=#operations-for-llvm-ir-intrinsics>Operations for LLVM IR Intrinsics</a><ul><li><a href=#llvmintracos-llvmacosop><code>llvm.intr.acos</code> (LLVM::ACosOp)</a></li><li><a href=#llvmintrasin-llvmasinop><code>llvm.intr.asin</code> (LLVM::ASinOp)</a></li><li><a href=#llvmintratan2-llvmatan2op><code>llvm.intr.atan2</code> (LLVM::ATan2Op)</a></li><li><a href=#llvmintratan-llvmatanop><code>llvm.intr.atan</code> (LLVM::ATanOp)</a></li><li><a href=#llvmintrabs-llvmabsop><code>llvm.intr.abs</code> (LLVM::AbsOp)</a></li><li><a href=#llvmintrannotation-llvmannotation><code>llvm.intr.annotation</code> (LLVM::Annotation)</a></li><li><a href=#llvmintrassume-llvmassumeop><code>llvm.intr.assume</code> (LLVM::AssumeOp)</a></li><li><a href=#llvmintrbitreverse-llvmbitreverseop><code>llvm.intr.bitreverse</code> (LLVM::BitReverseOp)</a></li><li><a href=#llvmintrbswap-llvmbyteswapop><code>llvm.intr.bswap</code> (LLVM::ByteSwapOp)</a></li><li><a href=#llvmintrexperimentalconstrainedfpext-llvmconstrainedfpextintr><code>llvm.intr.experimental.constrained.fpext</code> (LLVM::ConstrainedFPExtIntr)</a></li><li><a href=#llvmintrexperimentalconstrainedfptrunc-llvmconstrainedfptruncintr><code>llvm.intr.experimental.constrained.fptrunc</code> (LLVM::ConstrainedFPTruncIntr)</a></li><li><a href=#llvmintrexperimentalconstrainedsitofp-llvmconstrainedsitofp><code>llvm.intr.experimental.constrained.sitofp</code> (LLVM::ConstrainedSIToFP)</a></li><li><a href=#llvmintrexperimentalconstraineduitofp-llvmconstraineduitofp><code>llvm.intr.experimental.constrained.uitofp</code> (LLVM::ConstrainedUIToFP)</a></li><li><a href=#llvmintrcopysign-llvmcopysignop><code>llvm.intr.copysign</code> (LLVM::CopySignOp)</a></li><li><a href=#llvmintrcoroalign-llvmcoroalignop><code>llvm.intr.coro.align</code> (LLVM::CoroAlignOp)</a></li><li><a href=#llvmintrcorobegin-llvmcorobeginop><code>llvm.intr.coro.begin</code> (LLVM::CoroBeginOp)</a></li><li><a href=#llvmintrcoroend-llvmcoroendop><code>llvm.intr.coro.end</code> (LLVM::CoroEndOp)</a></li><li><a href=#llvmintrcorofree-llvmcorofreeop><code>llvm.intr.coro.free</code> (LLVM::CoroFreeOp)</a></li><li><a href=#llvmintrcoroid-llvmcoroidop><code>llvm.intr.coro.id</code> (LLVM::CoroIdOp)</a></li><li><a href=#llvmintrcoropromise-llvmcoropromiseop><code>llvm.intr.coro.promise</code> (LLVM::CoroPromiseOp)</a></li><li><a href=#llvmintrcororesume-llvmcororesumeop><code>llvm.intr.coro.resume</code> (LLVM::CoroResumeOp)</a></li><li><a href=#llvmintrcorosave-llvmcorosaveop><code>llvm.intr.coro.save</code> (LLVM::CoroSaveOp)</a></li><li><a href=#llvmintrcorosize-llvmcorosizeop><code>llvm.intr.coro.size</code> (LLVM::CoroSizeOp)</a></li><li><a href=#llvmintrcorosuspend-llvmcorosuspendop><code>llvm.intr.coro.suspend</code> (LLVM::CoroSuspendOp)</a></li><li><a href=#llvmintrcos-llvmcosop><code>llvm.intr.cos</code> (LLVM::CosOp)</a></li><li><a href=#llvmintrcosh-llvmcoshop><code>llvm.intr.cosh</code> (LLVM::CoshOp)</a></li><li><a href=#llvmintrctlz-llvmcountleadingzerosop><code>llvm.intr.ctlz</code> (LLVM::CountLeadingZerosOp)</a></li><li><a href=#llvmintrcttz-llvmcounttrailingzerosop><code>llvm.intr.cttz</code> (LLVM::CountTrailingZerosOp)</a></li><li><a href=#llvmintrctpop-llvmctpopop><code>llvm.intr.ctpop</code> (LLVM::CtPopOp)</a></li><li><a href=#llvmintrdbgdeclare-llvmdbgdeclareop><code>llvm.intr.dbg.declare</code> (LLVM::DbgDeclareOp)</a></li><li><a href=#llvmintrdbglabel-llvmdbglabelop><code>llvm.intr.dbg.label</code> (LLVM::DbgLabelOp)</a></li><li><a href=#llvmintrdbgvalue-llvmdbgvalueop><code>llvm.intr.dbg.value</code> (LLVM::DbgValueOp)</a></li><li><a href=#llvmintrdebugtrap-llvmdebugtrap><code>llvm.intr.debugtrap</code> (LLVM::DebugTrap)</a></li><li><a href=#llvmintrehtypeidfor-llvmehtypeidforop><code>llvm.intr.eh.typeid.for</code> (LLVM::EhTypeidForOp)</a></li><li><a href=#llvmintrexp10-llvmexp10op><code>llvm.intr.exp10</code> (LLVM::Exp10Op)</a></li><li><a href=#llvmintrexp2-llvmexp2op><code>llvm.intr.exp2</code> (LLVM::Exp2Op)</a></li><li><a href=#llvmintrexp-llvmexpop><code>llvm.intr.exp</code> (LLVM::ExpOp)</a></li><li><a href=#llvmintrexpect-llvmexpectop><code>llvm.intr.expect</code> (LLVM::ExpectOp)</a></li><li><a href=#llvmintrexpectwithprobability-llvmexpectwithprobabilityop><code>llvm.intr.expect.with.probability</code> (LLVM::ExpectWithProbabilityOp)</a></li><li><a href=#llvmintrfabs-llvmfabsop><code>llvm.intr.fabs</code> (LLVM::FAbsOp)</a></li><li><a href=#llvmintrceil-llvmfceilop><code>llvm.intr.ceil</code> (LLVM::FCeilOp)</a></li><li><a href=#llvmintrfloor-llvmffloorop><code>llvm.intr.floor</code> (LLVM::FFloorOp)</a></li><li><a href=#llvmintrfma-llvmfmaop><code>llvm.intr.fma</code> (LLVM::FMAOp)</a></li><li><a href=#llvmintrfmuladd-llvmfmuladdop><code>llvm.intr.fmuladd</code> (LLVM::FMulAddOp)</a></li><li><a href=#llvmintrtrunc-llvmftruncop><code>llvm.intr.trunc</code> (LLVM::FTruncOp)</a></li><li><a href=#llvmintrfrexp-llvmfractionexpop><code>llvm.intr.frexp</code> (LLVM::FractionExpOp)</a></li><li><a href=#llvmintrfshl-llvmfshlop><code>llvm.intr.fshl</code> (LLVM::FshlOp)</a></li><li><a href=#llvmintrfshr-llvmfshrop><code>llvm.intr.fshr</code> (LLVM::FshrOp)</a></li><li><a href=#llvmintrgetactivelanemask-llvmgetactivelanemaskop><code>llvm.intr.get.active.lane.mask</code> (LLVM::GetActiveLaneMaskOp)</a></li><li><a href=#llvmintrinvariantend-llvminvariantendop><code>llvm.intr.invariant.end</code> (LLVM::InvariantEndOp)</a></li><li><a href=#llvmintrinvariantstart-llvminvariantstartop><code>llvm.intr.invariant.start</code> (LLVM::InvariantStartOp)</a></li><li><a href=#llvmintrisconstant-llvmisconstantop><code>llvm.intr.is.constant</code> (LLVM::IsConstantOp)</a></li><li><a href=#llvmintrisfpclass-llvmisfpclass><code>llvm.intr.is.fpclass</code> (LLVM::IsFPClass)</a></li><li><a href=#llvmintrlaunderinvariantgroup-llvmlaunderinvariantgroupop><code>llvm.intr.launder.invariant.group</code> (LLVM::LaunderInvariantGroupOp)</a></li><li><a href=#llvmintrlifetimeend-llvmlifetimeendop><code>llvm.intr.lifetime.end</code> (LLVM::LifetimeEndOp)</a></li><li><a href=#llvmintrlifetimestart-llvmlifetimestartop><code>llvm.intr.lifetime.start</code> (LLVM::LifetimeStartOp)</a></li><li><a href=#llvmintrllrint-llvmllrintop><code>llvm.intr.llrint</code> (LLVM::LlrintOp)</a></li><li><a href=#llvmintrllround-llvmllroundop><code>llvm.intr.llround</code> (LLVM::LlroundOp)</a></li><li><a href=#llvmintrldexp-llvmloadexpop><code>llvm.intr.ldexp</code> (LLVM::LoadExpOp)</a></li><li><a href=#llvmintrlog10-llvmlog10op><code>llvm.intr.log10</code> (LLVM::Log10Op)</a></li><li><a href=#llvmintrlog2-llvmlog2op><code>llvm.intr.log2</code> (LLVM::Log2Op)</a></li><li><a href=#llvmintrlog-llvmlogop><code>llvm.intr.log</code> (LLVM::LogOp)</a></li><li><a href=#llvmintrlrint-llvmlrintop><code>llvm.intr.lrint</code> (LLVM::LrintOp)</a></li><li><a href=#llvmintrlround-llvmlroundop><code>llvm.intr.lround</code> (LLVM::LroundOp)</a></li><li><a href=#llvmintrmaskedload-llvmmaskedloadop><code>llvm.intr.masked.load</code> (LLVM::MaskedLoadOp)</a></li><li><a href=#llvmintrmaskedstore-llvmmaskedstoreop><code>llvm.intr.masked.store</code> (LLVM::MaskedStoreOp)</a></li><li><a href=#llvmintrmatrixcolumnmajorload-llvmmatrixcolumnmajorloadop><code>llvm.intr.matrix.column.major.load</code> (LLVM::MatrixColumnMajorLoadOp)</a></li><li><a href=#llvmintrmatrixcolumnmajorstore-llvmmatrixcolumnmajorstoreop><code>llvm.intr.matrix.column.major.store</code> (LLVM::MatrixColumnMajorStoreOp)</a></li><li><a href=#llvmintrmatrixmultiply-llvmmatrixmultiplyop><code>llvm.intr.matrix.multiply</code> (LLVM::MatrixMultiplyOp)</a></li><li><a href=#llvmintrmatrixtranspose-llvmmatrixtransposeop><code>llvm.intr.matrix.transpose</code> (LLVM::MatrixTransposeOp)</a></li><li><a href=#llvmintrmaxnum-llvmmaxnumop><code>llvm.intr.maxnum</code> (LLVM::MaxNumOp)</a></li><li><a href=#llvmintrmaximum-llvmmaximumop><code>llvm.intr.maximum</code> (LLVM::MaximumOp)</a></li><li><a href=#llvmintrmemcpyinline-llvmmemcpyinlineop><code>llvm.intr.memcpy.inline</code> (LLVM::MemcpyInlineOp)</a></li><li><a href=#llvmintrmemcpy-llvmmemcpyop><code>llvm.intr.memcpy</code> (LLVM::MemcpyOp)</a></li><li><a href=#llvmintrmemmove-llvmmemmoveop><code>llvm.intr.memmove</code> (LLVM::MemmoveOp)</a></li><li><a href=#llvmintrmemsetinline-llvmmemsetinlineop><code>llvm.intr.memset.inline</code> (LLVM::MemsetInlineOp)</a></li><li><a href=#llvmintrmemset-llvmmemsetop><code>llvm.intr.memset</code> (LLVM::MemsetOp)</a></li><li><a href=#llvmintrminnum-llvmminnumop><code>llvm.intr.minnum</code> (LLVM::MinNumOp)</a></li><li><a href=#llvmintrminimum-llvmminimumop><code>llvm.intr.minimum</code> (LLVM::MinimumOp)</a></li><li><a href=#llvmintrnearbyint-llvmnearbyintop><code>llvm.intr.nearbyint</code> (LLVM::NearbyintOp)</a></li><li><a href=#llvmintrexperimentalnoaliasscopedecl-llvmnoaliasscopedeclop><code>llvm.intr.experimental.noalias.scope.decl</code> (LLVM::NoAliasScopeDeclOp)</a></li><li><a href=#llvmintrpowi-llvmpowiop><code>llvm.intr.powi</code> (LLVM::PowIOp)</a></li><li><a href=#llvmintrpow-llvmpowop><code>llvm.intr.pow</code> (LLVM::PowOp)</a></li><li><a href=#llvmintrprefetch-llvmprefetch><code>llvm.intr.prefetch</code> (LLVM::Prefetch)</a></li><li><a href=#llvmintrptrannotation-llvmptrannotation><code>llvm.intr.ptr.annotation</code> (LLVM::PtrAnnotation)</a></li><li><a href=#llvmintrptrmask-llvmptrmaskop><code>llvm.intr.ptrmask</code> (LLVM::PtrMaskOp)</a></li><li><a href=#llvmintrrint-llvmrintop><code>llvm.intr.rint</code> (LLVM::RintOp)</a></li><li><a href=#llvmintrroundeven-llvmroundevenop><code>llvm.intr.roundeven</code> (LLVM::RoundEvenOp)</a></li><li><a href=#llvmintrround-llvmroundop><code>llvm.intr.round</code> (LLVM::RoundOp)</a></li><li><a href=#llvmintrsaddsat-llvmsaddsat><code>llvm.intr.sadd.sat</code> (LLVM::SAddSat)</a></li><li><a href=#llvmintrsaddwithoverflow-llvmsaddwithoverflowop><code>llvm.intr.sadd.with.overflow</code> (LLVM::SAddWithOverflowOp)</a></li><li><a href=#llvmintrsmax-llvmsmaxop><code>llvm.intr.smax</code> (LLVM::SMaxOp)</a></li><li><a href=#llvmintrsmin-llvmsminop><code>llvm.intr.smin</code> (LLVM::SMinOp)</a></li><li><a href=#llvmintrsmulwithoverflow-llvmsmulwithoverflowop><code>llvm.intr.smul.with.overflow</code> (LLVM::SMulWithOverflowOp)</a></li><li><a href=#llvmintrssacopy-llvmssacopyop><code>llvm.intr.ssa.copy</code> (LLVM::SSACopyOp)</a></li><li><a href=#llvmintrsshlsat-llvmsshlsat><code>llvm.intr.sshl.sat</code> (LLVM::SSHLSat)</a></li><li><a href=#llvmintrssubsat-llvmssubsat><code>llvm.intr.ssub.sat</code> (LLVM::SSubSat)</a></li><li><a href=#llvmintrssubwithoverflow-llvmssubwithoverflowop><code>llvm.intr.ssub.with.overflow</code> (LLVM::SSubWithOverflowOp)</a></li><li><a href=#llvmintrsin-llvmsinop><code>llvm.intr.sin</code> (LLVM::SinOp)</a></li><li><a href=#llvmintrsinh-llvmsinhop><code>llvm.intr.sinh</code> (LLVM::SinhOp)</a></li><li><a href=#llvmintrsqrt-llvmsqrtop><code>llvm.intr.sqrt</code> (LLVM::SqrtOp)</a></li><li><a href=#llvmintrstackrestore-llvmstackrestoreop><code>llvm.intr.stackrestore</code> (LLVM::StackRestoreOp)</a></li><li><a href=#llvmintrstacksave-llvmstacksaveop><code>llvm.intr.stacksave</code> (LLVM::StackSaveOp)</a></li><li><a href=#llvmintrstepvector-llvmstepvectorop><code>llvm.intr.stepvector</code> (LLVM::StepVectorOp)</a></li><li><a href=#llvmintrstripinvariantgroup-llvmstripinvariantgroupop><code>llvm.intr.strip.invariant.group</code> (LLVM::StripInvariantGroupOp)</a></li><li><a href=#llvmintrtan-llvmtanop><code>llvm.intr.tan</code> (LLVM::TanOp)</a></li><li><a href=#llvmintrtanh-llvmtanhop><code>llvm.intr.tanh</code> (LLVM::TanhOp)</a></li><li><a href=#llvmintrthreadlocaladdress-llvmthreadlocaladdressop><code>llvm.intr.threadlocal.address</code> (LLVM::ThreadlocalAddressOp)</a></li><li><a href=#llvmintrtrap-llvmtrap><code>llvm.intr.trap</code> (LLVM::Trap)</a></li><li><a href=#llvmintruaddsat-llvmuaddsat><code>llvm.intr.uadd.sat</code> (LLVM::UAddSat)</a></li><li><a href=#llvmintruaddwithoverflow-llvmuaddwithoverflowop><code>llvm.intr.uadd.with.overflow</code> (LLVM::UAddWithOverflowOp)</a></li><li><a href=#llvmintrubsantrap-llvmubsantrap><code>llvm.intr.ubsantrap</code> (LLVM::UBSanTrap)</a></li><li><a href=#llvmintrumax-llvmumaxop><code>llvm.intr.umax</code> (LLVM::UMaxOp)</a></li><li><a href=#llvmintrumin-llvmuminop><code>llvm.intr.umin</code> (LLVM::UMinOp)</a></li><li><a href=#llvmintrumulwithoverflow-llvmumulwithoverflowop><code>llvm.intr.umul.with.overflow</code> (LLVM::UMulWithOverflowOp)</a></li><li><a href=#llvmintrushlsat-llvmushlsat><code>llvm.intr.ushl.sat</code> (LLVM::USHLSat)</a></li><li><a href=#llvmintrusubsat-llvmusubsat><code>llvm.intr.usub.sat</code> (LLVM::USubSat)</a></li><li><a href=#llvmintrusubwithoverflow-llvmusubwithoverflowop><code>llvm.intr.usub.with.overflow</code> (LLVM::USubWithOverflowOp)</a></li><li><a href=#llvmintrvpashr-llvmvpashrop><code>llvm.intr.vp.ashr</code> (LLVM::VPAShrOp)</a></li><li><a href=#llvmintrvpadd-llvmvpaddop><code>llvm.intr.vp.add</code> (LLVM::VPAddOp)</a></li><li><a href=#llvmintrvpand-llvmvpandop><code>llvm.intr.vp.and</code> (LLVM::VPAndOp)</a></li><li><a href=#llvmintrvpfadd-llvmvpfaddop><code>llvm.intr.vp.fadd</code> (LLVM::VPFAddOp)</a></li><li><a href=#llvmintrvpfdiv-llvmvpfdivop><code>llvm.intr.vp.fdiv</code> (LLVM::VPFDivOp)</a></li><li><a href=#llvmintrvpfmuladd-llvmvpfmuladdop><code>llvm.intr.vp.fmuladd</code> (LLVM::VPFMulAddOp)</a></li><li><a href=#llvmintrvpfmul-llvmvpfmulop><code>llvm.intr.vp.fmul</code> (LLVM::VPFMulOp)</a></li><li><a href=#llvmintrvpfneg-llvmvpfnegop><code>llvm.intr.vp.fneg</code> (LLVM::VPFNegOp)</a></li><li><a href=#llvmintrvpfpext-llvmvpfpextop><code>llvm.intr.vp.fpext</code> (LLVM::VPFPExtOp)</a></li><li><a href=#llvmintrvpfptosi-llvmvpfptosiop><code>llvm.intr.vp.fptosi</code> (LLVM::VPFPToSIOp)</a></li><li><a href=#llvmintrvpfptoui-llvmvpfptouiop><code>llvm.intr.vp.fptoui</code> (LLVM::VPFPToUIOp)</a></li><li><a href=#llvmintrvpfptrunc-llvmvpfptruncop><code>llvm.intr.vp.fptrunc</code> (LLVM::VPFPTruncOp)</a></li><li><a href=#llvmintrvpfrem-llvmvpfremop><code>llvm.intr.vp.frem</code> (LLVM::VPFRemOp)</a></li><li><a href=#llvmintrvpfsub-llvmvpfsubop><code>llvm.intr.vp.fsub</code> (LLVM::VPFSubOp)</a></li><li><a href=#llvmintrvpfma-llvmvpfmaop><code>llvm.intr.vp.fma</code> (LLVM::VPFmaOp)</a></li><li><a href=#llvmintrvpinttoptr-llvmvpinttoptrop><code>llvm.intr.vp.inttoptr</code> (LLVM::VPIntToPtrOp)</a></li><li><a href=#llvmintrvplshr-llvmvplshrop><code>llvm.intr.vp.lshr</code> (LLVM::VPLShrOp)</a></li><li><a href=#llvmintrvpload-llvmvploadop><code>llvm.intr.vp.load</code> (LLVM::VPLoadOp)</a></li><li><a href=#llvmintrvpmerge-llvmvpmergeminop><code>llvm.intr.vp.merge</code> (LLVM::VPMergeMinOp)</a></li><li><a href=#llvmintrvpmul-llvmvpmulop><code>llvm.intr.vp.mul</code> (LLVM::VPMulOp)</a></li><li><a href=#llvmintrvpor-llvmvporop><code>llvm.intr.vp.or</code> (LLVM::VPOrOp)</a></li><li><a href=#llvmintrvpptrtoint-llvmvpptrtointop><code>llvm.intr.vp.ptrtoint</code> (LLVM::VPPtrToIntOp)</a></li><li><a href=#llvmintrvpreduceadd-llvmvpreduceaddop><code>llvm.intr.vp.reduce.add</code> (LLVM::VPReduceAddOp)</a></li><li><a href=#llvmintrvpreduceand-llvmvpreduceandop><code>llvm.intr.vp.reduce.and</code> (LLVM::VPReduceAndOp)</a></li><li><a href=#llvmintrvpreducefadd-llvmvpreducefaddop><code>llvm.intr.vp.reduce.fadd</code> (LLVM::VPReduceFAddOp)</a></li><li><a href=#llvmintrvpreducefmax-llvmvpreducefmaxop><code>llvm.intr.vp.reduce.fmax</code> (LLVM::VPReduceFMaxOp)</a></li><li><a href=#llvmintrvpreducefmin-llvmvpreducefminop><code>llvm.intr.vp.reduce.fmin</code> (LLVM::VPReduceFMinOp)</a></li><li><a href=#llvmintrvpreducefmul-llvmvpreducefmulop><code>llvm.intr.vp.reduce.fmul</code> (LLVM::VPReduceFMulOp)</a></li><li><a href=#llvmintrvpreducemul-llvmvpreducemulop><code>llvm.intr.vp.reduce.mul</code> (LLVM::VPReduceMulOp)</a></li><li><a href=#llvmintrvpreduceor-llvmvpreduceorop><code>llvm.intr.vp.reduce.or</code> (LLVM::VPReduceOrOp)</a></li><li><a href=#llvmintrvpreducesmax-llvmvpreducesmaxop><code>llvm.intr.vp.reduce.smax</code> (LLVM::VPReduceSMaxOp)</a></li><li><a href=#llvmintrvpreducesmin-llvmvpreducesminop><code>llvm.intr.vp.reduce.smin</code> (LLVM::VPReduceSMinOp)</a></li><li><a href=#llvmintrvpreduceumax-llvmvpreduceumaxop><code>llvm.intr.vp.reduce.umax</code> (LLVM::VPReduceUMaxOp)</a></li><li><a href=#llvmintrvpreduceumin-llvmvpreduceuminop><code>llvm.intr.vp.reduce.umin</code> (LLVM::VPReduceUMinOp)</a></li><li><a href=#llvmintrvpreducexor-llvmvpreducexorop><code>llvm.intr.vp.reduce.xor</code> (LLVM::VPReduceXorOp)</a></li><li><a href=#llvmintrvpsdiv-llvmvpsdivop><code>llvm.intr.vp.sdiv</code> (LLVM::VPSDivOp)</a></li><li><a href=#llvmintrvpsext-llvmvpsextop><code>llvm.intr.vp.sext</code> (LLVM::VPSExtOp)</a></li><li><a href=#llvmintrvpsitofp-llvmvpsitofpop><code>llvm.intr.vp.sitofp</code> (LLVM::VPSIToFPOp)</a></li><li><a href=#llvmintrvpsmax-llvmvpsmaxop><code>llvm.intr.vp.smax</code> (LLVM::VPSMaxOp)</a></li><li><a href=#llvmintrvpsmin-llvmvpsminop><code>llvm.intr.vp.smin</code> (LLVM::VPSMinOp)</a></li><li><a href=#llvmintrvpsrem-llvmvpsremop><code>llvm.intr.vp.srem</code> (LLVM::VPSRemOp)</a></li><li><a href=#llvmintrvpselect-llvmvpselectminop><code>llvm.intr.vp.select</code> (LLVM::VPSelectMinOp)</a></li><li><a href=#llvmintrvpshl-llvmvpshlop><code>llvm.intr.vp.shl</code> (LLVM::VPShlOp)</a></li><li><a href=#llvmintrvpstore-llvmvpstoreop><code>llvm.intr.vp.store</code> (LLVM::VPStoreOp)</a></li><li><a href=#llvmintrexperimentalvpstridedload-llvmvpstridedloadop><code>llvm.intr.experimental.vp.strided.load</code> (LLVM::VPStridedLoadOp)</a></li><li><a href=#llvmintrexperimentalvpstridedstore-llvmvpstridedstoreop><code>llvm.intr.experimental.vp.strided.store</code> (LLVM::VPStridedStoreOp)</a></li><li><a href=#llvmintrvpsub-llvmvpsubop><code>llvm.intr.vp.sub</code> (LLVM::VPSubOp)</a></li><li><a href=#llvmintrvptrunc-llvmvptruncop><code>llvm.intr.vp.trunc</code> (LLVM::VPTruncOp)</a></li><li><a href=#llvmintrvpudiv-llvmvpudivop><code>llvm.intr.vp.udiv</code> (LLVM::VPUDivOp)</a></li><li><a href=#llvmintrvpuitofp-llvmvpuitofpop><code>llvm.intr.vp.uitofp</code> (LLVM::VPUIToFPOp)</a></li><li><a href=#llvmintrvpumax-llvmvpumaxop><code>llvm.intr.vp.umax</code> (LLVM::VPUMaxOp)</a></li><li><a href=#llvmintrvpumin-llvmvpuminop><code>llvm.intr.vp.umin</code> (LLVM::VPUMinOp)</a></li><li><a href=#llvmintrvpurem-llvmvpuremop><code>llvm.intr.vp.urem</code> (LLVM::VPURemOp)</a></li><li><a href=#llvmintrvpxor-llvmvpxorop><code>llvm.intr.vp.xor</code> (LLVM::VPXorOp)</a></li><li><a href=#llvmintrvpzext-llvmvpzextop><code>llvm.intr.vp.zext</code> (LLVM::VPZExtOp)</a></li><li><a href=#llvmintrvacopy-llvmvacopyop><code>llvm.intr.vacopy</code> (LLVM::VaCopyOp)</a></li><li><a href=#llvmintrvaend-llvmvaendop><code>llvm.intr.vaend</code> (LLVM::VaEndOp)</a></li><li><a href=#llvmintrvastart-llvmvastartop><code>llvm.intr.vastart</code> (LLVM::VaStartOp)</a></li><li><a href=#llvmintrvarannotation-llvmvarannotation><code>llvm.intr.var.annotation</code> (LLVM::VarAnnotation)</a></li><li><a href=#llvmintrmaskedcompressstore-llvmmasked_compressstore><code>llvm.intr.masked.compressstore</code> (LLVM::masked_compressstore)</a></li><li><a href=#llvmintrmaskedexpandload-llvmmasked_expandload><code>llvm.intr.masked.expandload</code> (LLVM::masked_expandload)</a></li><li><a href=#llvmintrmaskedgather-llvmmasked_gather><code>llvm.intr.masked.gather</code> (LLVM::masked_gather)</a></li><li><a href=#llvmintrmaskedscatter-llvmmasked_scatter><code>llvm.intr.masked.scatter</code> (LLVM::masked_scatter)</a></li><li><a href=#llvmintrvectordeinterleave2-llvmvector_deinterleave2><code>llvm.intr.vector.deinterleave2</code> (LLVM::vector_deinterleave2)</a></li><li><a href=#llvmintrvectorextract-llvmvector_extract><code>llvm.intr.vector.extract</code> (LLVM::vector_extract)</a></li><li><a href=#llvmintrvectorinsert-llvmvector_insert><code>llvm.intr.vector.insert</code> (LLVM::vector_insert)</a></li><li><a href=#llvmintrvectorinterleave2-llvmvector_interleave2><code>llvm.intr.vector.interleave2</code> (LLVM::vector_interleave2)</a></li><li><a href=#llvmintrvectorreduceadd-llvmvector_reduce_add><code>llvm.intr.vector.reduce.add</code> (LLVM::vector_reduce_add)</a></li><li><a href=#llvmintrvectorreduceand-llvmvector_reduce_and><code>llvm.intr.vector.reduce.and</code> (LLVM::vector_reduce_and)</a></li><li><a href=#llvmintrvectorreducefadd-llvmvector_reduce_fadd><code>llvm.intr.vector.reduce.fadd</code> (LLVM::vector_reduce_fadd)</a></li><li><a href=#llvmintrvectorreducefmax-llvmvector_reduce_fmax><code>llvm.intr.vector.reduce.fmax</code> (LLVM::vector_reduce_fmax)</a></li><li><a href=#llvmintrvectorreducefmaximum-llvmvector_reduce_fmaximum><code>llvm.intr.vector.reduce.fmaximum</code> (LLVM::vector_reduce_fmaximum)</a></li><li><a href=#llvmintrvectorreducefmin-llvmvector_reduce_fmin><code>llvm.intr.vector.reduce.fmin</code> (LLVM::vector_reduce_fmin)</a></li><li><a href=#llvmintrvectorreducefminimum-llvmvector_reduce_fminimum><code>llvm.intr.vector.reduce.fminimum</code> (LLVM::vector_reduce_fminimum)</a></li><li><a href=#llvmintrvectorreducefmul-llvmvector_reduce_fmul><code>llvm.intr.vector.reduce.fmul</code> (LLVM::vector_reduce_fmul)</a></li><li><a href=#llvmintrvectorreducemul-llvmvector_reduce_mul><code>llvm.intr.vector.reduce.mul</code> (LLVM::vector_reduce_mul)</a></li><li><a href=#llvmintrvectorreduceor-llvmvector_reduce_or><code>llvm.intr.vector.reduce.or</code> (LLVM::vector_reduce_or)</a></li><li><a href=#llvmintrvectorreducesmax-llvmvector_reduce_smax><code>llvm.intr.vector.reduce.smax</code> (LLVM::vector_reduce_smax)</a></li><li><a href=#llvmintrvectorreducesmin-llvmvector_reduce_smin><code>llvm.intr.vector.reduce.smin</code> (LLVM::vector_reduce_smin)</a></li><li><a href=#llvmintrvectorreduceumax-llvmvector_reduce_umax><code>llvm.intr.vector.reduce.umax</code> (LLVM::vector_reduce_umax)</a></li><li><a href=#llvmintrvectorreduceumin-llvmvector_reduce_umin><code>llvm.intr.vector.reduce.umin</code> (LLVM::vector_reduce_umin)</a></li><li><a href=#llvmintrvectorreducexor-llvmvector_reduce_xor><code>llvm.intr.vector.reduce.xor</code> (LLVM::vector_reduce_xor)</a></li><li><a href=#llvmintrvscale-llvmvscale><code>llvm.intr.vscale</code> (LLVM::vscale)</a></li><li><a href=#debug-info>Debug Info</a></li></ul></li></ul></nav><h2 id=dependency-on-llvm-ir>Dependency on LLVM IR&nbsp;<a class=headline-hash href=#dependency-on-llvm-ir>¶</a></h2><p>LLVM dialect is not expected to depend on any object that requires an
<code>LLVMContext</code>, such as an LLVM IR instruction or type. Instead, MLIR provides
thread-safe alternatives compatible with the rest of the infrastructure. The
dialect is allowed to depend on the LLVM IR objects that don&rsquo;t require a
context, such as data layout and triple description.</p><h2 id=module-structure>Module Structure&nbsp;<a class=headline-hash href=#module-structure>¶</a></h2><p>IR modules use the built-in MLIR <code>ModuleOp</code> and support all its features. In
particular, modules can be named, nested and are subject to symbol visibility.
Modules can contain any operations, including LLVM functions and globals.</p><h3 id=data-layout-and-triple>Data Layout and Triple&nbsp;<a class=headline-hash href=#data-layout-and-triple>¶</a></h3><p>An IR module may have an optional data layout and triple information attached
using MLIR attributes <code>llvm.data_layout</code> and <code>llvm.triple</code>, respectively. Both
are string attributes with the
<a href=https://llvm.org/docs/LangRef.html#data-layout>same syntax</a> as in LLVM IR and
are verified to be correct. They can be defined as follows.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module attributes <span class=p>{</span><span class=nl>llvm.data_layout =</span> <span class=s>&#34;e&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=nl>llvm.target_triple =</span> <span class=s>&#34;aarch64-linux-android&#34;</span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// module contents
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span>
</span></span></code></pre></div><h3 id=functions>Functions&nbsp;<a class=headline-hash href=#functions>¶</a></h3><p>LLVM functions are represented by a special operation, <code>llvm.func</code>, that has
syntax similar to that of the built-in function operation but supports
LLVM-related features such as linkage and variadic argument lists. See detailed
description in the operation list
<a href=#llvmfunc-llvmllvmfuncop>below</a>.</p><h3 id=phi-nodes-and-block-arguments>PHI Nodes and Block Arguments&nbsp;<a class=headline-hash href=#phi-nodes-and-block-arguments>¶</a></h3><p>MLIR uses block arguments instead of PHI nodes to communicate values between
blocks. Therefore, the LLVM dialect has no operation directly equivalent to
<code>phi</code> in LLVM IR. Instead, all terminators can pass values as successor operands
as these values will be forwarded as block arguments when the control flow is
transferred.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>addi <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%cst</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>br <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%0</span><span class=p>:</span> <span class=k>i32</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// If the control flow comes from ^bb1, %arg1 == %0.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>:</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span></code></pre></div><p>is equivalent to LLVM IR</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-llvm data-lang=llvm><span class=line><span class=cl><span class=n>%0</span><span class=err>:</span>
</span></span><span class=line><span class=cl>  <span class=n>%1</span> <span class=p>=</span> <span class=k>add</span> <span class=k>i32</span> <span class=nv>%arg0</span><span class=p>,</span> <span class=nv>%cst</span>
</span></span><span class=line><span class=cl>  <span class=k>br</span> <span class=n>%3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>%3</span><span class=err>:</span>
</span></span><span class=line><span class=cl>  <span class=nv>%arg1</span> <span class=p>=</span> <span class=k>phi</span> <span class=p>[</span><span class=n>%1</span><span class=p>,</span> <span class=n>%0</span><span class=p>],</span> <span class=err>//</span><span class=p>...</span>
</span></span></code></pre></div><p>Since there is no need to use the block identifier to differentiate the source
of different values, the LLVM dialect supports terminators that transfer the
control flow to the same block with different arguments. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>cond_br <span class=nv>%cond</span><span class=p>,</span> <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%0</span><span class=p>:</span> <span class=k>i32</span><span class=p>],</span> <span class=nl>^bb2</span><span class=p>[</span><span class=nv>%1</span><span class=p>:</span> <span class=k>i32</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nl>^bb2</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=c>// ...
</span></span></span></code></pre></div><h3 id=context-level-values>Context-Level Values&nbsp;<a class=headline-hash href=#context-level-values>¶</a></h3><p>Some value kinds in LLVM IR, such as constants and undefs, are uniqued in
context and used directly in relevant operations. MLIR does not support such
values for thread-safety and concept parsimony reasons. Instead, regular values
are produced by dedicated operations that have the corresponding semantics:
<a href=#llvmmlirconstant-llvmconstantop><code>llvm.mlir.constant</code></a>,
<a href=#llvmmlirundef-llvmundefop><code>llvm.mlir.undef</code></a>,
<a href=#llvmmlirpoison-llvmpoisonop><code>llvm.mlir.poison</code></a>,
<a href=#llvmmlirzero-llvmzeroop><code>llvm.mlir.zero</code></a>. Note how these operations are
prefixed with <code>mlir.</code> to indicate that they don&rsquo;t belong to LLVM IR but are only
necessary to model it in MLIR. The values produced by these operations are
usable just like any other value.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create an undefined value of structure type with a 32-bit integer followed
</span></span></span><span class=line><span class=cl><span class=c>// by a float.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Null pointer.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>zero <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Create an zero initialized value of structure type with a 32-bit integer
</span></span></span><span class=line><span class=cl><span class=c>// followed by a float.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>zero <span class=p>:</span>  <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Constant 42 as i32.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Splat dense vector constant.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Note that constants list the type twice. This is an artifact of the LLVM dialect
not using built-in types, which are used for typed MLIR attributes. The syntax
will be reevaluated after considering composite constants.</p><h3 id=globals>Globals&nbsp;<a class=headline-hash href=#globals>¶</a></h3><p>Global variables are also defined using a special operation,
<a href=#llvmmlirglobal-llvmglobalop><code>llvm.mlir.global</code></a>, located at the module
level. Globals are MLIR symbols and are identified by their name.</p><p>Since functions need to be isolated-from-above, i.e. values defined outside the
function cannot be directly used inside the function, an additional operation,
<a href=#llvmmliraddressof-llvmaddressofop><code>llvm.mlir.addressof</code></a>, is provided to
locally define a value containing the <em>address</em> of a global. The actual value
can then be loaded from that pointer, or a new value can be stored into it if
the global is not declared constant. This is similar to LLVM IR where globals
are accessed through name and have a pointer type.</p><h3 id=linkage>Linkage&nbsp;<a class=headline-hash href=#linkage>¶</a></h3><p>Module-level named objects in the LLVM dialect, namely functions and globals,
have an optional <em>linkage</em> attribute derived from LLVM IR
<a href=https://llvm.org/docs/LangRef.html#linkage-types>linkage types</a>. Linkage is
specified by the same keyword as in LLVM IR and is located between the operation
name (<code>llvm.func</code> or <code>llvm.global</code>) and the symbol name. If no linkage keyword
is present, <code>external</code> linkage is assumed by default. Linkage is <em>distinct</em> from
MLIR symbol visibility.</p><h3 id=attribute-pass-through>Attribute Pass-Through&nbsp;<a class=headline-hash href=#attribute-pass-through>¶</a></h3><p><strong>WARNING:</strong> this feature MUST NOT be used for any real workload. It is
exclusively intended for quick prototyping. After that, attributes must be
introduced as proper first-class concepts in the dialect.</p><p>The LLVM dialect provides a mechanism to forward function-level attributes to
LLVM IR using the <code>passthrough</code> attribute. This is an array attribute containing
either string attributes or array attributes. In the former case, the value of
the string is interpreted as the name of LLVM IR function attribute. In the
latter case, the array is expected to contain exactly two string attributes, the
first corresponding to the name of LLVM IR function attribute, and the second
corresponding to its value. Note that even integer LLVM IR function attributes
have their value represented in the string form.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@func</span><span class=p>()</span> attributes <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nl>passthrough =</span> <span class=p>[</span><span class=s>&#34;readonly&#34;</span><span class=p>,</span>           <span class=c>// value-less attribute
</span></span></span><span class=line><span class=cl><span class=c></span>                 <span class=p>[</span><span class=s>&#34;alignstack&#34;</span><span class=p>,</span> <span class=s>&#34;4&#34;</span><span class=p>],</span>  <span class=c>// integer attribute with value
</span></span></span><span class=line><span class=cl><span class=c></span>                 <span class=p>[</span><span class=s>&#34;other&#34;</span><span class=p>,</span> <span class=s>&#34;attr&#34;</span><span class=p>]]</span>    <span class=c>// attribute unknown to LLVM
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>}</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>If the attribute is not known to LLVM IR, it will be attached as a string
attribute.</p><h2 id=types>Types&nbsp;<a class=headline-hash href=#types>¶</a></h2><p>LLVM dialect uses built-in types whenever possible and defines a set of
complementary types, which correspond to the LLVM IR types that cannot be
directly represented with built-in types. Similarly to other MLIR context-owned
objects, the creation and manipulation of LLVM dialect types is thread-safe.</p><p>MLIR does not support module-scoped named type declarations, e.g. <code>%s = type {i32, i32}</code> in LLVM IR. Instead, types must be fully specified at each use,
except for recursive types where only the first reference to a named type needs
to be fully specified. MLIR
<a href=/docs/LangRef/#type-aliases>type aliases</a> can be
used to achieve more compact syntax.</p><p>The general syntax of LLVM dialect types is <code>!llvm.</code>, followed by a type kind
identifier (e.g., <code>ptr</code> for pointer or <code>struct</code> for structure) and by an
optional list of type parameters in angle brackets. The dialect follows MLIR
style for types with nested angle brackets and keyword specifiers rather than
using different bracket styles to differentiate types. Types inside the angle
brackets may omit the <code>!llvm.</code> prefix for brevity: the parser first attempts to
find a type (starting with <code>!</code> or a built-in type) and falls back to accepting a
keyword. For example, <code>!llvm.struct&lt;(!llvm.ptr, f32)></code> and
<code>!llvm.struct&lt;(ptr, f32)></code> are equivalent, with the latter being the canonical
form, and denote a struct containing a pointer and a float.</p><h3 id=built-in-type-compatibility>Built-in Type Compatibility&nbsp;<a class=headline-hash href=#built-in-type-compatibility>¶</a></h3><p>LLVM dialect accepts a subset of built-in types that are referred to as <em>LLVM
dialect-compatible types</em>. The following types are compatible:</p><ul><li>Signless integers - <code>iN</code> (<code>IntegerType</code>).</li><li>Floating point types - <code>bfloat</code>, <code>half</code>, <code>float</code>, <code>double</code> , <code>f80</code>, <code>f128</code>
(<code>FloatType</code>).</li><li>1D vectors of signless integers or floating point types - <code>vector&lt;NxT></code>
(<code>VectorType</code>).</li></ul><p>Note that only a subset of types that can be represented by a given class is
compatible. For example, signed and unsigned integers are not compatible. LLVM
provides a function, <code>bool LLVM::isCompatibleType(Type)</code>, that can be used as a
compatibility check.</p><p>Each LLVM IR type corresponds to <em>exactly one</em> MLIR type, either built-in or
LLVM dialect type. For example, because <code>i32</code> is LLVM-compatible, there is no
<code>!llvm.i32</code> type. However, <code>!llvm.struct&lt;(T, ...)></code> is defined in the LLVM
dialect as there is no corresponding built-in type.</p><h3 id=additional-simple-types>Additional Simple Types&nbsp;<a class=headline-hash href=#additional-simple-types>¶</a></h3><p>The following non-parametric types derived from the LLVM IR are available in the
LLVM dialect:</p><ul><li><code>!llvm.ppc_fp128</code> (<code>LLVMPPCFP128Type</code>) - 128-bit floating-point value (two
64 bits).</li><li><code>!llvm.token</code> (<code>LLVMTokenType</code>) - a non-inspectable value associated with an
operation.</li><li><code>!llvm.metadata</code> (<code>LLVMMetadataType</code>) - LLVM IR metadata, to be used only if
the metadata cannot be represented as structured MLIR attributes.</li><li><code>!llvm.void</code> (<code>LLVMVoidType</code>) - does not represent any value; can only
appear in function results.</li></ul><p>These types represent a single value (or an absence thereof in case of <code>void</code>)
and correspond to their LLVM IR counterparts.</p><h3 id=additional-parametric-types>Additional Parametric Types&nbsp;<a class=headline-hash href=#additional-parametric-types>¶</a></h3><p>These types are parameterized by the types they contain, e.g., the pointee or
the element type, which can be either compatible built-in or LLVM dialect types.</p><h4 id=pointer-types>Pointer Types&nbsp;<a class=headline-hash href=#pointer-types>¶</a></h4><p>Pointer types specify an address in memory.</p><p>Pointers are
<a href=https://llvm.org/docs/OpaquePointers.html>opaque</a>, i.e., do not
indicate the type of the data pointed to, and are intended to simplify LLVM IR
by encoding behavior relevant to the pointee type into operations rather than
into types. Pointers can optionally be parametrized with an address space. The
address space is an integer, but this choice may be reconsidered if MLIR
implements named address spaces. The syntax of pointer types is as follows:</p><pre tabindex=0><code>  llvm-ptr-type ::= `!llvm.ptr` (`&lt;` integer-literal `&gt;`)?
</code></pre><p>where the optional group containing the integer literal corresponds to the
address space. All cases are represented by <code>LLVMPointerType</code> internally.</p><h4 id=array-types>Array Types&nbsp;<a class=headline-hash href=#array-types>¶</a></h4><p>Array types represent sequences of elements in memory. Array elements can be
addressed with a value unknown at compile time, and can be nested. Only 1D
arrays are allowed though.</p><p>Array types are parameterized by the fixed size and the element type.
Syntactically, their representation is the following:</p><pre tabindex=0><code>  llvm-array-type ::= `!llvm.array&lt;` integer-literal `x` type `&gt;`
</code></pre><p>and they are internally represented as <code>LLVMArrayType</code>.</p><h4 id=function-types>Function Types&nbsp;<a class=headline-hash href=#function-types>¶</a></h4><p>Function types represent the type of a function, i.e. its signature.</p><p>Function types are parameterized by the result type, the list of argument types
and by an optional &ldquo;variadic&rdquo; flag. Unlike built-in <code>FunctionType</code>, LLVM dialect
functions (<code>LLVMFunctionType</code>) always have single result, which may be
<code>!llvm.void</code> if the function does not return anything. The syntax is as follows:</p><pre tabindex=0><code>  llvm-func-type ::= `!llvm.func&lt;` type `(` type-list (`,` `...`)? `)` `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>()&gt;</span>           <span class=c>// a function with no arguments;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i32</span> <span class=p>(</span><span class=k>f32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>    <span class=c>// a function with two arguments and a result;
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=p>...)&gt;</span>   <span class=c>// a variadic function with at least one argument.
</span></span></span></code></pre></div><p>In the LLVM dialect, functions are not first-class objects and one cannot have a
value of function type. Instead, one can take the address of a function and
operate on pointers to functions.</p><h3 id=vector-types>Vector Types&nbsp;<a class=headline-hash href=#vector-types>¶</a></h3><p>Vector types represent sequences of elements, typically when multiple data
elements are processed by a single instruction (SIMD). Vectors are thought of as
stored in registers and therefore vector elements can only be addressed through
constant indices.</p><p>Vector types are parameterized by the size, which may be either <em>fixed</em> or a
multiple of some fixed size in case of <em>scalable</em> vectors, and the element type.
Vectors cannot be nested and only 1D vectors are supported. Scalable vectors are
still considered 1D.</p><p>The LLVM dialect uses built-in vector type.</p><p>The following functions are provided to operate on any kind of the vector types
compatible with the LLVM dialect:</p><ul><li><code>bool LLVM::isCompatibleVectorType(Type)</code> - checks whether a type is a
vector type compatible with the LLVM dialect;</li><li><code>llvm::ElementCount LLVM::getVectorNumElements(Type)</code> - returns the number
of elements in any vector type compatible with the LLVM dialect;</li></ul><h4 id=examples-of-compatible-vector-types>Examples of Compatible Vector Types&nbsp;<a class=headline-hash href=#examples-of-compatible-vector-types>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>vector</span><span class=p>&lt;</span><span class=m>42 x</span> <span class=k>i32</span><span class=p>&gt;</span>                   <span class=c>// Vector of 42 32-bit integers.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>42 x</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>&gt;</span>             <span class=c>// Vector of 42 pointers.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span> <span class=p>x</span> <span class=k>i32</span><span class=p>&gt;</span>                  <span class=c>// Scalable vector of 32-bit integers with
</span></span></span><span class=line><span class=cl><span class=c></span>                                   <span class=c>// size divisible by 4.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2 x</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;&gt;</span>   <span class=c>// Array of 2 vectors of 2 32-bit integers.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>2 x</span> vec<span class=p>&lt;</span><span class=m>2 x</span> ptr<span class=p>&gt;&gt;</span> <span class=c>// Array of 2 vectors of 2 pointers.
</span></span></span></code></pre></div><h3 id=structure-types>Structure Types&nbsp;<a class=headline-hash href=#structure-types>¶</a></h3><p>The structure type is used to represent a collection of data members together in
memory. The elements of a structure may be any type that has a size.</p><p>Structure types are represented in a single dedicated class
mlir::LLVM::LLVMStructType. Internally, the struct type stores a (potentially
empty) name, a (potentially empty) list of contained types and a bitmask
indicating whether the struct is named, opaque, packed or uninitialized.
Structure types that don&rsquo;t have a name are referred to as <em>literal</em> structs.
Such structures are uniquely identified by their contents. <em>Identified</em> structs
on the other hand are uniquely identified by the name.</p><h4 id=identified-structure-types>Identified Structure Types&nbsp;<a class=headline-hash href=#identified-structure-types>¶</a></h4><p>Identified structure types are uniqued using their name in a given context.
Attempting to construct an identified structure with the same name a structure
that already exists in the context <em>will result in the existing structure being
returned</em>. <strong>MLIR does not auto-rename identified structs in case of name
conflicts</strong> because there is no naming scope equivalent to a module in LLVM IR
since MLIR modules can be arbitrarily nested.</p><p>Programmatically, identified structures can be constructed in an <em>uninitialized</em>
state. In this case, they are given a name but the body must be set up by a
later call, using MLIR&rsquo;s type mutation mechanism. Such uninitialized types can
be used in type construction, but must be eventually initialized for IR to be
valid. This mechanism allows for constructing <em>recursive</em> or mutually referring
structure types: an uninitialized type can be used in its own initialization.</p><p>Once the type is initialized, its body cannot be changed anymore. Any further
attempts to modify the body will fail and return failure to the caller <em>unless
the type is initialized with the exact same body</em>. Type initialization is
thread-safe; however, if a concurrent thread initializes the type before the
current thread, the initialization may return failure.</p><p>The syntax for identified structure types is as follows.</p><pre tabindex=0><code>llvm-ident-struct-type ::= `!llvm.struct&lt;` string-literal, `opaque` `&gt;`
                         | `!llvm.struct&lt;` string-literal, `packed`?
                           `(` type-or-ref-list  `)` `&gt;`
type-or-ref-list ::= &lt;maybe empty comma-separated list of type-or-ref&gt;
type-or-ref ::= &lt;any compatible type with optional !llvm.&gt;
              | `!llvm.`? `struct&lt;` string-literal `&gt;`
</code></pre><h4 id=literal-structure-types>Literal Structure Types&nbsp;<a class=headline-hash href=#literal-structure-types>¶</a></h4><p>Literal structures are uniqued according to the list of elements they contain,
and can optionally be packed. The syntax for such structs is as follows.</p><pre tabindex=0><code>llvm-literal-struct-type ::= `!llvm.struct&lt;` `packed`? `(` type-list `)` `&gt;`
type-list ::= &lt;maybe empty comma-separated list of types with optional !llvm.&gt;
</code></pre><p>Literal structs cannot be recursive, but can contain other structs. Therefore,
they must be constructed in a single step with the entire list of contained
elements provided.</p><h4 id=examples-of-structure-types>Examples of Structure Types&nbsp;<a class=headline-hash href=#examples-of-structure-types>¶</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;&gt;</span>                  <span class=c>// NOT allowed
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;()&gt;</span>                <span class=c>// empty, literal
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;</span>             <span class=c>// literal
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>)&gt;)&gt;</span>   <span class=c>// struct containing a struct
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span>packed <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>  <span class=c>// packed struct
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>&gt;</span>               <span class=c>// recursive reference, only allowed within
</span></span></span><span class=line><span class=cl><span class=c></span>                                <span class=c>// another struct, NOT allowed at top level
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=p>()&gt;</span>           <span class=c>// empty, named (necessary to differentiate from
</span></span></span><span class=line><span class=cl><span class=c></span>                                <span class=c>// recursive reference)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> opaque<span class=p>&gt;</span>       <span class=c>// opaque, named
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> ptr<span class=p>)&gt;</span>        <span class=c>// named
</span></span></span><span class=line><span class=cl><span class=c></span><span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;</span><span class=s>&#34;a&#34;</span><span class=p>,</span> packed <span class=p>(</span><span class=k>i8</span><span class=p>,</span> <span class=k>i32</span><span class=p>)&gt;</span>  <span class=c>// named, packed
</span></span></span></code></pre></div><h3 id=unsupported-types>Unsupported Types&nbsp;<a class=headline-hash href=#unsupported-types>¶</a></h3><p>LLVM IR <code>label</code> type does not have a counterpart in the LLVM dialect since, in
MLIR, blocks are not values and don&rsquo;t need a type.</p><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p>All operations in the LLVM IR dialect have a custom form in MLIR. The mnemonic
of an operation is that used in LLVM IR prefixed with &ldquo;<code>llvm.</code>&rdquo;.</p><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/LLVMIR/LLVMOps.td>source</a></p><h3 id=llvmashr-llvmashrop><code>llvm.ashr</code> (LLVM::AShrOp)&nbsp;<a class=headline-hash href=#llvmashr-llvmashrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.ashr` (`exact` $isExact^)? $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ExactFlagInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmadd-llvmaddop><code>llvm.add</code> (LLVM::AddOp)&nbsp;<a class=headline-hash href=#llvmadd-llvmaddop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.add` $lhs `,` $rhs ($overflowFlags^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerOverflowFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmaddrspacecast-llvmaddrspacecastop><code>llvm.addrspacecast</code> (LLVM::AddrSpaceCastOp)&nbsp;<a class=headline-hash href=#llvmaddrspacecast-llvmaddrspacecastop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.addrspacecast` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>PromotableOpInterface</code>, <code>ViewLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvmmliraddressof-llvmaddressofop><code>llvm.mlir.addressof</code> (LLVM::AddressOfOp)&nbsp;<a class=headline-hash href=#llvmmliraddressof-llvmaddressofop>¶</a></h3><p><em>Creates a pointer pointing to a global, alias or a function</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.addressof` $global_name attr-dict `:` qualified(type($res))
</code></pre><p>Creates an SSA value containing a pointer to a global value (function,
variable or alias). The global value can be defined after its first
referenced. If the global value is a constant, storing into it is not
allowed.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=kt>func</span> <span class=nf>@foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// Get the address of a global variable.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Use it as a regular pointer.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Get the address of a function.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@foo</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// The function address can be used for indirect calls.
</span></span></span><span class=line><span class=cl><span class=c></span>  llvm<span class=p>.</span>call <span class=nv>%2</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Get the address of an aliased global.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const_alias</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Define the global.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@const</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Define an alias.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>alias <span class=nf>@const_alias</span> <span class=p>:</span> <span class=k>i32</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>global_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmmliralias-llvmaliasop><code>llvm.mlir.alias</code> (LLVM::AliasOp)&nbsp;<a class=headline-hash href=#llvmmliralias-llvmaliasop>¶</a></h3><p><em>LLVM dialect alias.</em></p><p><code>llvm.mlir.alias</code> is a top level operation that defines a global alias for
global variables and functions. The operation is always initialized by
using a initializer region which could be a direct map to another global
value or contain some address computation on top of it.</p><p>It uses a symbol for its value, which will be uniqued by the module
with respect to other symbols in it.</p><p>Similarly to functions and globals, they can also have a linkage attribute.
This attribute is placed between <code>llvm.mlir.alias</code> and the symbol name. If
the attribute is omitted, <code>external</code> linkage is assumed by default.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Global alias use @-identifiers.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>alias external <span class=nf>@foo_alias</span> <span class=p>{</span><span class=nl>addr_space =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@some_function</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// More complex initialization.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>alias linkonce_odr hidden <span class=nf>@glob</span>
</span></span><span class=line><span class=cl><span class=p>{</span><span class=nl>addr_space =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> dso_local<span class=p>}</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>32 x</span> <span class=k>i32</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>1234</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@glob.private</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>ptrtoint <span class=nv>%1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr to <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%2</span><span class=p>,</span> <span class=nv>%0</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>inttoptr <span class=nv>%3</span> <span class=p>:</span> <span class=k>i64</span> to <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%4</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;ReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alias_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>linkage</code></td><td>::mlir::LLVM::LinkageAttr</td><td>LLVM Linkage specification</td></tr><tr><td><code>dso_local</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>thread_local_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>unnamed_addr</code></td><td>::mlir::LLVM::UnnamedAddrAttr</td><td>LLVM GlobalValue UnnamedAddr</td></tr><tr><td><code>visibility_</code></td><td>::mlir::LLVM::VisibilityAttr</td><td>LLVM GlobalValue Visibility</td></tr></table><h3 id=llvmalloca-llvmallocaop><code>llvm.alloca</code> (LLVM::AllocaOp)&nbsp;<a class=headline-hash href=#llvmalloca-llvmallocaop>¶</a></h3><p>Interfaces: <code>DestructurableAllocationOpInterface</code>, <code>PromotableAllocationOpInterface</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>elem_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>inalloca</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arraySize</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmand-llvmandop><code>llvm.and</code> (LLVM::AndOp)&nbsp;<a class=headline-hash href=#llvmand-llvmandop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.and` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmcmpxchg-llvmatomiccmpxchgop><code>llvm.cmpxchg</code> (LLVM::AtomicCmpXchgOp)&nbsp;<a class=headline-hash href=#llvmcmpxchg-llvmatomiccmpxchgop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.cmpxchg` (`weak` $weak^)? (`volatile` $volatile_^)? $ptr `,` $cmp `,` $val
              (`syncscope` `(` $syncscope^ `)`)? $success_ordering $failure_ordering
              attr-dict `:` qualified(type($ptr)) `,` type($val)
</code></pre><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>success_ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>failure_ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>syncscope</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>weak</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>volatile_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>cmp</code></td><td>signless integer or LLVM pointer type</td></tr><tr><td style=text-align:center><code>val</code></td><td>signless integer or LLVM pointer type</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM structure type</td></tr></tbody></table><h3 id=llvmatomicrmw-llvmatomicrmwop><code>llvm.atomicrmw</code> (LLVM::AtomicRMWOp)&nbsp;<a class=headline-hash href=#llvmatomicrmw-llvmatomicrmwop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.atomicrmw` (`volatile` $volatile_^)? $bin_op $ptr `,` $val
              (`syncscope` `(` $syncscope^ `)`)? $ordering attr-dict `:`
              qualified(type($ptr)) `,` type($val)
</code></pre><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>bin_op</code></td><td>::mlir::LLVM::AtomicBinOpAttr</td><td>llvm.atomicrmw binary operations</td></tr><tr><td><code>ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>syncscope</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>volatile_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM pointer type or signless integer or LLVM dialect-compatible fixed-length vector type</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM pointer type or signless integer or LLVM dialect-compatible fixed-length vector type</td></tr></tbody></table><h3 id=llvmbitcast-llvmbitcastop><code>llvm.bitcast</code> (LLVM::BitcastOp)&nbsp;<a class=headline-hash href=#llvmbitcast-llvmbitcastop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.bitcast` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>PromotableOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>LLVM-compatible non-aggregate type</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM-compatible non-aggregate type</td></tr></tbody></table><h3 id=llvmblockaddress-llvmblockaddressop><code>llvm.blockaddress</code> (LLVM::BlockAddressOp)&nbsp;<a class=headline-hash href=#llvmblockaddress-llvmblockaddressop>¶</a></h3><p><em>Creates a LLVM blockaddress ptr</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.blockaddress` $block_addr
              attr-dict `:` qualified(type($res))
</code></pre><p>Creates an SSA value containing a pointer to a basic block. The block
address information (function and block) is given by the <code>BlockAddressAttr</code>
attribute. This operation assumes an existing <code>llvm.blocktag</code> operation
identifying an existing MLIR block within a function. Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global private <span class=nf>@g</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>blockaddress <span class=p>&lt;</span><span class=nl>function =</span> <span class=nf>@fn</span><span class=p>,</span> <span class=nl>tag =</span> <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>0</span><span class=p>&gt;&gt;</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@fn</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>br <span class=nl>^bb1
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>  <span class=c>// pred: ^bb0
</span></span></span><span class=line><span class=cl><span class=c></span>  llvm<span class=p>.</span>blocktag <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>block_addr</code></td><td>::mlir::LLVM::BlockAddressAttr</td><td><details><summary></summary><pre><code>Describes a block address identified by a pair of `$function` and `$tag`.
</code></pre></details></td></tr></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmblocktag-llvmblocktagop><code>llvm.blocktag</code> (LLVM::BlockTagOp)&nbsp;<a class=headline-hash href=#llvmblocktag-llvmblocktagop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.blocktag` $tag attr-dict
</code></pre><p>This operation uses a <code>tag</code> to uniquely identify an MLIR block in a
function. The same tag is used by <code>llvm.blockaddress</code> in order to compute
the target address.</p><p>A given function should have at most one <code>llvm.blocktag</code> operation with a
given <code>tag</code>. This operation cannot be used as a terminator.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@f</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%addr</span> <span class=p>=</span> llvm<span class=p>.</span>blockaddress <span class=p>&lt;</span><span class=nl>function =</span> <span class=nf>@f</span><span class=p>,</span> <span class=nl>tag =</span> <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>1</span><span class=p>&gt;&gt;</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>br <span class=nl>^bb1
</span></span></span><span class=line><span class=cl><span class=nl>^bb1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>blocktag <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%addr</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tag</code></td><td>::mlir::LLVM::BlockTagAttr</td><td></td></tr></table><h3 id=llvmbr-llvmbrop><code>llvm.br</code> (LLVM::BrOp)&nbsp;<a class=headline-hash href=#llvmbr-llvmbrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>loop_annotation</code></td><td>::mlir::LLVM::LoopAnnotationAttr</td><td><details><summary></summary><pre><code>This attributes encapsulates &quot;loop metadata&quot;. It is meant to decorate
branches that are &quot;latches&quot; (loop backedges) and maps to the `!llvm.loop`
metadatas: https://llvm.org/docs/LangRef.html#llvm-loop
It stores annotations in attribute parameters and groups related options in
nested attributes to provide structured access.
</code></pre></details></td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>destOperands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=successors>Successors:&nbsp;<a class=headline-hash href=#successors>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmcall_intrinsic-llvmcallintrinsicop><code>llvm.call_intrinsic</code> (LLVM::CallIntrinsicOp)&nbsp;<a class=headline-hash href=#llvmcall_intrinsic-llvmcallintrinsicop>¶</a></h3><p><em>Call to an LLVM intrinsic function.</em></p><p>Call the specified llvm intrinsic. If the intrinsic is overloaded, use
the MLIR function type of this op to determine which intrinsic to call.</p><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>FastmathFlagsInterface</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>intrin</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr><tr><td><code>op_bundle_sizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>op_bundle_tags</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>args</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>op_bundle_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>results</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmcall-llvmcallop><code>llvm.call</code> (LLVM::CallOp)&nbsp;<a class=headline-hash href=#llvmcall-llvmcallop>¶</a></h3><p><em>Call to an LLVM function.</em></p><p>In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect
implements this behavior by providing a variadic <code>call</code> operation for 0- and
1-result functions. Even though MLIR supports multi-result functions, LLVM
IR dialect disallows them.</p><p>The <code>call</code> instruction supports both direct and indirect calls. Direct calls
start with a function name (<code>@</code>-prefixed) and indirect calls start with an
SSA value (<code>%</code>-prefixed). The direct callee, if present, is stored as a
function attribute <code>callee</code>. For indirect calls, the callee is of <code>!llvm.ptr</code> type
and is stored as the first value in <code>callee_operands</code>. If and only if the
callee is a variadic function, the <code>var_callee_type</code> attribute must carry
the variadic LLVM function type. The trailing type list contains the
optional indirect callee type and the MLIR function type, which differs from
the LLVM function type that uses an explicit void type to model functions
that do not return a value.</p><p>If this operatin has the <code>no_inline</code> attribute, then this specific function call
will never be inlined. The opposite behavior will occur if the call has <code>always_inline</code>
attribute. The <code>inline_hint</code> attribute indicates that it is desirable to inline
this function call.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Direct call without arguments and with one result.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Direct call with arguments and without a result.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>call <span class=nf>@bar</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Indirect call with an argument and without a result.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@foo</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>llvm<span class=p>.</span>call <span class=nv>%1</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>(</span><span class=k>f32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Direct variadic call.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>call <span class=nf>@printf</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> vararg<span class=p>(!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>i32</span> <span class=p>(</span>ptr<span class=p>,</span> <span class=p>...)&gt;)</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Indirect variadic call
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>call <span class=nv>%1</span><span class=p>(</span><span class=nv>%0</span><span class=p>)</span> vararg<span class=p>(!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span>void <span class=p>(...)&gt;)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>(</span><span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>CallOpInterface</code>, <code>FastmathFlagsInterface</code>, <code>SymbolUserOpInterface</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>var_callee_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of LLVM function type</td></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr><tr><td><code>CConv</code></td><td>::mlir::LLVM::CConvAttr</td><td>LLVM Calling Convention specification</td></tr><tr><td><code>TailCallKind</code></td><td>::mlir::LLVM::TailCallKindAttr</td><td>LLVM Calling Convention specification</td></tr><tr><td><code>memory_effects</code></td><td>::mlir::LLVM::MemoryEffectsAttr</td><td></td></tr><tr><td><code>convergent</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>no_unwind</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>will_return</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>op_bundle_sizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>op_bundle_tags</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>no_inline</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>always_inline</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>inline_hint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>op_bundle_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmcomdat-llvmcomdatop><code>llvm.comdat</code> (LLVM::ComdatOp)&nbsp;<a class=headline-hash href=#llvmcomdat-llvmcomdatop>¶</a></h3><p><em>LLVM dialect comdat region</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.comdat` $sym_name $body attr-dict
</code></pre><p>Provides access to object file COMDAT section/group functionality.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>comdat <span class=nf>@__llvm_comdat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>comdat_selector <span class=nf>@any</span> any
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global internal <span class=kt>constant</span> <span class=nf>@has_any_comdat</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> comdat<span class=p>(</span><span class=nf>@__llvm_comdat</span><span class=p>::</span><span class=nf>@any</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>NoRegionArguments</code>, <code>NoTerminator</code>, <code>SymbolTable</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=llvmcomdat_selector-llvmcomdatselectorop><code>llvm.comdat_selector</code> (LLVM::ComdatSelectorOp)&nbsp;<a class=headline-hash href=#llvmcomdat_selector-llvmcomdatselectorop>¶</a></h3><p><em>LLVM dialect comdat selector declaration</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.comdat_selector` $sym_name $comdat attr-dict
</code></pre><p>Provides access to object file COMDAT section/group functionality.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>comdat <span class=nf>@__llvm_comdat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>comdat_selector <span class=nf>@any</span> any
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global internal <span class=kt>constant</span> <span class=nf>@has_any_comdat</span><span class=p>(</span><span class=m>1</span> <span class=p>:</span> <span class=k>i64</span><span class=p>)</span> comdat<span class=p>(</span><span class=nf>@__llvm_comdat</span><span class=p>::</span><span class=nf>@any</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>comdat</code></td><td>::mlir::LLVM::comdat::ComdatAttr</td><td>LLVM Comdat Types</td></tr></table><h3 id=llvmcond_br-llvmcondbrop><code>llvm.cond_br</code> (LLVM::CondBrOp)&nbsp;<a class=headline-hash href=#llvmcond_br-llvmcondbrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.cond_br` $condition ( `weights` `(` $branch_weights^ `)` )? `,`
              $trueDest (`(` $trueDestOperands^ `:` type($trueDestOperands) `)`)? `,`
              $falseDest (`(` $falseDestOperands^ `:` type($falseDestOperands) `)`)?
              attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>WeightedBranchOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>branch_weights</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>loop_annotation</code></td><td>::mlir::LLVM::LoopAnnotationAttr</td><td><details><summary></summary><pre><code>This attributes encapsulates &quot;loop metadata&quot;. It is meant to decorate
branches that are &quot;latches&quot; (loop backedges) and maps to the `!llvm.loop`
metadatas: https://llvm.org/docs/LangRef.html#llvm-loop
It stores annotations in attribute parameters and groups related options in
nested attributes to provide structured access.
</code></pre></details></td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueDestOperands</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>falseDestOperands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=successors-1>Successors:&nbsp;<a class=headline-hash href=#successors-1>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>trueDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>falseDest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmmlirconstant-llvmconstantop><code>llvm.mlir.constant</code> (LLVM::ConstantOp)&nbsp;<a class=headline-hash href=#llvmmlirconstant-llvmconstantop>¶</a></h3><p><em>Defines a constant of LLVM type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.constant` `(` $value `)` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class constant values. Therefore,
all constants must be created as SSA values before being used in other
operations. <code>llvm.mlir.constant</code> creates such values for scalars, vectors,
strings, structs, and array of structs. It has a mandatory <code>value</code> attribute
whose type depends on the type of the constant value. The type of the constant
value must correspond to the attribute type converted to LLVM IR type.</p><p>When creating constant scalars, the <code>value</code> attribute must be either an
integer attribute or a floating point attribute. The type of the attribute
may be omitted for <code>i64</code> and <code>f64</code> types that are implied.</p><p>When creating constant vectors, the <code>value</code> attribute must be either an
array attribute, a dense attribute, or a sparse attribute that contains
integers or floats. The number of elements in the result vector must match
the number of elements in the attribute.</p><p>When creating constant strings, the <code>value</code> attribute must be a string
attribute. The type of the constant must be an LLVM array of <code>i8</code>s, and the
length of the array must match the length of the attribute.</p><p>When creating constant structs, the <code>value</code> attribute must be an array
attribute that contains integers or floats. The type of the constant must be
an LLVM struct type. The number of fields in the struct must match the
number of elements in the attribute, and the type of each LLVM struct field
must correspond to the type of the corresponding attribute element converted
to LLVM IR.</p><p>When creating an array of structs, the <code>value</code> attribute must be an array
attribute, itself containing zero, or undef, or array attributes for each
potential nested array type, and the elements of the leaf array attributes
for must match the struct element types or be zero or undef attributes.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Integer constant, internal i32 is mandatory
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// It&#39;s okay to omit i64.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Floating point constant.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>42.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Splat dense vector constant.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmdso_local_equivalent-llvmdsolocalequivalentop><code>llvm.dso_local_equivalent</code> (LLVM::DSOLocalEquivalentOp)&nbsp;<a class=headline-hash href=#llvmdso_local_equivalent-llvmdsolocalequivalentop>¶</a></h3><p><em>Creates a LLVM dso_local_equivalent ptr</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.dso_local_equivalent` $function_name attr-dict `:` qualified(type($res))
</code></pre><p>Creates an SSA value containing a pointer to a global value (function or
alias to function). It represents a function which is functionally
equivalent to a given function, but is always defined in the current
linkage unit. The target function may not have <code>extern_weak</code> linkage.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global external <span class=kt>constant</span> <span class=nf>@const</span><span class=p>()</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@const</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>ptrtoint <span class=nv>%0</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr to <span class=k>i64</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>dso_local_equivalent <span class=nf>@func</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%4</span> <span class=p>=</span> llvm<span class=p>.</span>ptrtoint <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr to <span class=k>i64</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%4</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SymbolUserOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>function_name</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmextractelement-llvmextractelementop><code>llvm.extractelement</code> (LLVM::ExtractElementOp)&nbsp;<a class=headline-hash href=#llvmextractelement-llvmextractelementop>¶</a></h3><p><em>Extract an element from an LLVM vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.extractelement` $vector `[` $position `:` type($position) `]` attr-dict `:` type($vector)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>position</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmextractvalue-llvmextractvalueop><code>llvm.extractvalue</code> (LLVM::ExtractValueOp)&nbsp;<a class=headline-hash href=#llvmextractvalue-llvmextractvalueop>¶</a></h3><p><em>Extract a value from an LLVM struct.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.extractvalue` $container `` $position attr-dict `:` type($container)
              custom&lt;InsertExtractValueElementType&gt;(type($res), ref(type($container)),
              ref($position))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>position</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>container</code></td><td>LLVM aggregate type</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmfadd-llvmfaddop><code>llvm.fadd</code> (LLVM::FAddOp)&nbsp;<a class=headline-hash href=#llvmfadd-llvmfaddop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fadd` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfcmp-llvmfcmpop><code>llvm.fcmp</code> (LLVM::FCmpOp)&nbsp;<a class=headline-hash href=#llvmfcmp-llvmfcmpop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::LLVM::FCmpPredicateAttr</td><td>llvm.fcmp comparison predicate</td></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>1-bit signless integer or LLVM dialect-compatible vector of 1-bit signless integer</td></tr></tbody></table><h3 id=llvmfdiv-llvmfdivop><code>llvm.fdiv</code> (LLVM::FDivOp)&nbsp;<a class=headline-hash href=#llvmfdiv-llvmfdivop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fdiv` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfmul-llvmfmulop><code>llvm.fmul</code> (LLVM::FMulOp)&nbsp;<a class=headline-hash href=#llvmfmul-llvmfmulop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fmul` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfneg-llvmfnegop><code>llvm.fneg</code> (LLVM::FNegOp)&nbsp;<a class=headline-hash href=#llvmfneg-llvmfnegop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fneg` $operand attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfpext-llvmfpextop><code>llvm.fpext</code> (LLVM::FPExtOp)&nbsp;<a class=headline-hash href=#llvmfpext-llvmfpextop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fpext` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfptosi-llvmfptosiop><code>llvm.fptosi</code> (LLVM::FPToSIOp)&nbsp;<a class=headline-hash href=#llvmfptosi-llvmfptosiop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fptosi` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmfptoui-llvmfptouiop><code>llvm.fptoui</code> (LLVM::FPToUIOp)&nbsp;<a class=headline-hash href=#llvmfptoui-llvmfptouiop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fptoui` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmfptrunc-llvmfptruncop><code>llvm.fptrunc</code> (LLVM::FPTruncOp)&nbsp;<a class=headline-hash href=#llvmfptrunc-llvmfptruncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fptrunc` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfrem-llvmfremop><code>llvm.frem</code> (LLVM::FRemOp)&nbsp;<a class=headline-hash href=#llvmfrem-llvmfremop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.frem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfsub-llvmfsubop><code>llvm.fsub</code> (LLVM::FSubOp)&nbsp;<a class=headline-hash href=#llvmfsub-llvmfsubop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fsub` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmfence-llvmfenceop><code>llvm.fence</code> (LLVM::FenceOp)&nbsp;<a class=headline-hash href=#llvmfence-llvmfenceop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.fence` (`syncscope` `(` $syncscope^ `)`)? $ordering attr-dict
</code></pre><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>syncscope</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr></table><h3 id=llvmfreeze-llvmfreezeop><code>llvm.freeze</code> (LLVM::FreezeOp)&nbsp;<a class=headline-hash href=#llvmfreeze-llvmfreezeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.freeze` $val attr-dict `:` type($val)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmgetelementptr-llvmgepop><code>llvm.getelementptr</code> (LLVM::GEPOp)&nbsp;<a class=headline-hash href=#llvmgetelementptr-llvmgepop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.getelementptr` ($noWrapFlags^)?
              $base `[` custom&lt;GEPIndices&gt;($dynamicIndices, $rawConstantIndices) `]` attr-dict
              `:` functional-type(operands, results) `,` $elem_type
</code></pre><p>This operation mirrors LLVM IRs &lsquo;getelementptr&rsquo; operation that is used to
perform pointer arithmetic.</p><p>Like in LLVM IR, it is possible to use both constants as well as SSA values
as indices. In the case of indexing within a structure, it is required to
either use constant indices directly, or supply a constant SSA value.</p><p>The no-wrap flags can be used to specify the low-level pointer arithmetic
overflow behavior that LLVM uses after lowering the operation to LLVM IR.
Valid options include &lsquo;inbounds&rsquo; (pointer arithmetic must be within object
bounds), &rsquo;nusw&rsquo; (no unsigned signed wrap), and &rsquo;nuw&rsquo; (no unsigned wrap).
Note that &lsquo;inbounds&rsquo; implies &rsquo;nusw&rsquo; which is ensured by the enum
definition. The flags can be set individually or in combination.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// GEP with an SSA value offset
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%1</span><span class=p>[</span><span class=nv>%2</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// GEP with a constant offset and the inbounds attribute set
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr inbounds <span class=nv>%1</span><span class=p>[</span><span class=m>3</span><span class=p>]</span> <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// GEP with constant offsets into a structure
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%1</span><span class=p>[</span><span class=m>0</span><span class=p>,</span> <span class=m>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>DestructurableAccessorOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>PromotableOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code>, <code>ViewLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rawConstantIndices</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>elem_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>dynamicIndices</code></td><td>variadic of signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvmmlirglobal_ctors-llvmglobalctorsop><code>llvm.mlir.global_ctors</code> (LLVM::GlobalCtorsOp)&nbsp;<a class=headline-hash href=#llvmmlirglobal_ctors-llvmglobalctorsop>¶</a></h3><p><em>LLVM dialect global_ctors.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.global_ctors` `ctors` `=` $ctors
              `,` `priorities` `=` $priorities
              `,` `data` `=` $data
              attr-dict
</code></pre><p>Specifies a list of constructor functions, priorities, and associated data.
The functions referenced by this array will be called in ascending order
of priority (i.e. lowest first) when the module is loaded. The order of
functions with the same priority is not defined. This operation is
translated to LLVM&rsquo;s global_ctors global variable. The initializer
functions are run at load time. However, if the associated data is not
<code>#llvm.zero</code>, functions only run if the data is not discarded.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@ctor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global_ctors <span class=nl>ctors =</span> <span class=p>[</span><span class=nf>@ctor</span><span class=p>],</span> <span class=nl>priorities =</span> <span class=p>[</span><span class=m>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                               <span class=nl>data =</span> <span class=p>[</span><span class=nv>#llvm.zero</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>ctors</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr><tr><td><code>priorities</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td><code>data</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h3 id=llvmmlirglobal_dtors-llvmglobaldtorsop><code>llvm.mlir.global_dtors</code> (LLVM::GlobalDtorsOp)&nbsp;<a class=headline-hash href=#llvmmlirglobal_dtors-llvmglobaldtorsop>¶</a></h3><p><em>LLVM dialect global_dtors.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.global_dtors` `dtors` `=` $dtors
              `,` `priorities` `=` $priorities
              `,` `data` `=` $data
              attr-dict
</code></pre><p>Specifies a list of destructor functions and priorities. The functions
referenced by this array will be called in descending order of priority
(i.e. highest first) when the module is unloaded. The order of functions
with the same priority is not defined. This operation is translated to
LLVM&rsquo;s global_dtors global variable. The destruction functions are run at
load time. However, if the associated data is not <code>#llvm.zero</code>, functions
only run if the data is not discarded.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@dtor</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global_dtors <span class=nl>dtors =</span> <span class=p>[</span><span class=nf>@dtor</span><span class=p>],</span> <span class=nl>priorities =</span> <span class=p>[</span><span class=m>0</span><span class=p>],</span>
</span></span><span class=line><span class=cl>                               <span class=nl>data =</span> <span class=p>[</span><span class=nv>#llvm.zero</span><span class=p>]</span>
</span></span></code></pre></div><p>Interfaces: <code>SymbolUserOpInterface</code></p><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dtors</code></td><td>::mlir::ArrayAttr</td><td>flat symbol ref array attribute</td></tr><tr><td><code>priorities</code></td><td>::mlir::ArrayAttr</td><td>32-bit integer array attribute</td></tr><tr><td><code>data</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h3 id=llvmmlirglobal-llvmglobalop><code>llvm.mlir.global</code> (LLVM::GlobalOp)&nbsp;<a class=headline-hash href=#llvmmlirglobal-llvmglobalop>¶</a></h3><p><em>LLVM dialect global.</em></p><p>Since MLIR allows for arbitrary operations to be present at the top level,
global variables are defined using the <code>llvm.mlir.global</code> operation. Both
global constants and variables can be defined, and the value may also be
initialized in both cases.</p><p>There are two forms of initialization syntax. Simple constants that can be
represented as MLIR attributes can be given in-line:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
</span></span></code></pre></div><p>This initialization and type syntax is similar to <code>llvm.mlir.constant</code> and
may use two types: one for MLIR attribute and another for the LLVM value.
These types must be compatible.</p><p>More complex constants that cannot be represented as MLIR attributes can be
given in an initializer region:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// This global is initialized with the equivalent of:
</span></span></span><span class=line><span class=cl><span class=c>//   i32* getelementptr (i32* @g2, i32 2)
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>     <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=c>// The initializer region must end with `llvm.return`.
</span></span></span><span class=line><span class=cl><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Only one of the initializer attribute or initializer region may be provided.</p><p><code>llvm.mlir.global</code> must appear at top-level of the enclosing module. It uses
an @-identifier for its value, which will be uniqued by the module with
respect to other @-identifiers in it.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Global values use @-identifiers.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@cst</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Non-constant values must also be initialized.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@variable</span><span class=p>(</span><span class=m>32.0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Strings are expected to be of wrapped LLVM i8 array type and do not
</span></span></span><span class=line><span class=cl><span class=c>// automatically include the trailing zero.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@string</span><span class=p>(</span><span class=s>&#34;abc&#34;</span><span class=p>)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>3 x</span> <span class=k>i8</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// For strings globals, the trailing type may be omitted.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@no_trailing_type</span><span class=p>(</span><span class=s>&#34;foo bar&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A complex initializer is constructed with an initializer region.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=kt>constant</span> <span class=nf>@int_gep</span><span class=p>()</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@g2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>getelementptr <span class=nv>%0</span><span class=p>[</span><span class=nv>%1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>     <span class=p>:</span> <span class=p>(!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Similarly to functions, globals have a linkage attribute. In the custom
syntax, this attribute is placed between <code>llvm.mlir.global</code> and the optional
<code>constant</code> keyword. If the attribute is omitted, <code>external</code> linkage is
assumed by default.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A constant with internal linkage will not participate in linking.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global internal <span class=kt>constant</span> <span class=nf>@cst</span><span class=p>(</span><span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// By default, &#34;external&#34; linkage is assumed and the global participates in
</span></span></span><span class=line><span class=cl><span class=c>// symbol resolution at link-time.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global <span class=nf>@glob</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>f32</span><span class=p>)</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Alignment is optional
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global private <span class=kt>constant</span> <span class=nf>@y</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>8 x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Like global variables in LLVM IR, globals can have an (optional)
alignment attribute using keyword <code>alignment</code>. The integer value of the
alignment must be a positive integer that is a power of 2.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Alignment is optional
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>global private <span class=kt>constant</span> <span class=nf>@y</span><span class=p>(</span>dense<span class=p>&lt;</span><span class=m>1.0</span><span class=p>&gt;</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>8x</span><span class=k>f32</span><span class=p>&gt;)</span> <span class=p>{</span> <span class=nl>alignment =</span> <span class=m>32</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>}</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>array<span class=p>&lt;</span><span class=m>8 x</span> <span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code>, <code>SingleBlockImplicitTerminator&lt;ReturnOp></code>, <code>SingleBlock</code></p><p>Interfaces: <code>Symbol</code></p><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>global_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>constant</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>linkage</code></td><td>::mlir::LLVM::LinkageAttr</td><td>LLVM Linkage specification</td></tr><tr><td><code>dso_local</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>thread_local_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>externally_initialized</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>value</code></td><td>::mlir::Attribute</td><td>any attribute</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>addr_space</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr><tr><td><code>unnamed_addr</code></td><td>::mlir::LLVM::UnnamedAddrAttr</td><td>LLVM GlobalValue UnnamedAddr</td></tr><tr><td><code>section</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>comdat</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td><code>dbg_exprs</code></td><td>::mlir::ArrayAttr</td><td>an array of variable expressions</td></tr><tr><td><code>visibility_</code></td><td>::mlir::LLVM::VisibilityAttr</td><td>LLVM GlobalValue Visibility</td></tr></table><h3 id=llvmicmp-llvmicmpop><code>llvm.icmp</code> (LLVM::ICmpOp)&nbsp;<a class=headline-hash href=#llvmicmp-llvmicmpop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameTypeOperands</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::LLVM::ICmpPredicateAttr</td><td>llvm.icmp comparison predicate</td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer or LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer or LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>1-bit signless integer or LLVM dialect-compatible vector of 1-bit signless integer</td></tr></tbody></table><h3 id=llvmmlirifunc-llvmifuncop><code>llvm.mlir.ifunc</code> (LLVM::IFuncOp)&nbsp;<a class=headline-hash href=#llvmmlirifunc-llvmifuncop>¶</a></h3><p><em>LLVM dialect ifunc</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.ifunc` custom&lt;LLVMLinkage&gt;($linkage) ($visibility_^)? ($unnamed_addr^)?
              $sym_name `:` $i_func_type `,` $resolver_type $resolver attr-dict
</code></pre><p><code>llvm.mlir.ifunc</code> is a top level operation that defines a global ifunc.
It defines a new symbol and takes a symbol refering to a resolver function.
IFuncs can be called as regular functions. The function type is the same
as the IFuncType. The symbol is resolved at runtime by calling a resolver
function.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// IFuncs resolve a symbol at runtime using a resovler function.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>mlir<span class=p>.</span>ifunc external <span class=nf>@foo</span><span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span><span class=kt>func</span><span class=p>&lt;</span><span class=k>f32</span> <span class=p>(</span><span class=k>i64</span><span class=p>)&gt;,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=nf>@resolver</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo_1</span><span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo_2</span><span class=p>(</span><span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@resolve_foo</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=p>!</span>llvm<span class=p>.</span>ptr attributes <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@foo_2</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>addressof <span class=nf>@foo_1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// ... Logic selecting from foo_{1, 2}
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=c>// Return function pointer to the selected function
</span></span></span><span class=line><span class=cl><span class=c></span>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%7</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@use_foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c>// IFuncs are called as regular functions
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%res</span> <span class=p>=</span> llvm<span class=p>.</span>call <span class=nf>@foo</span><span class=p>(</span><span class=nv>%value</span><span class=p>)</span> <span class=p>:</span> <span class=k>i64</span> <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>IsolatedFromAbove</code></p><p>Interfaces: <code>SymbolUserOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>i_func_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>resolver</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>resolver_type</code></td><td>::mlir::TypeAttr</td><td>any type attribute</td></tr><tr><td><code>linkage</code></td><td>::mlir::LLVM::LinkageAttr</td><td>LLVM Linkage specification</td></tr><tr><td><code>dso_local</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>address_space</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute whose value is non-negative</td></tr><tr><td><code>unnamed_addr</code></td><td>::mlir::LLVM::UnnamedAddrAttr</td><td>LLVM GlobalValue UnnamedAddr</td></tr><tr><td><code>visibility_</code></td><td>::mlir::LLVM::VisibilityAttr</td><td>LLVM GlobalValue Visibility</td></tr></table><h3 id=llvmindirectbr-llvmindirectbrop><code>llvm.indirectbr</code> (LLVM::IndirectBrOp)&nbsp;<a class=headline-hash href=#llvmindirectbr-llvmindirectbrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.indirectbr` $addr `:` type($addr) `,`
              custom&lt;IndirectBrOpSucessors&gt;(ref(type($addr)),
              $successors,
              $succOperands,
              type($succOperands))
              attr-dict
</code></pre><p>Transfer control flow to address in <code>$addr</code>. A list of possible target
blocks in <code>$successors</code> can be provided and maybe used as a hint in LLVM:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@g</span><span class=p>(...</span>
</span></span><span class=line><span class=cl>  <span class=nv>%dest</span> <span class=p>=</span> llvm<span class=p>.</span>blockaddress <span class=p>&lt;</span><span class=nl>function =</span> <span class=nf>@g</span><span class=p>,</span> <span class=nl>tag =</span> <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>0</span><span class=p>&gt;&gt;</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>indirectbr <span class=nv>%dest</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=nl>^head
</span></span></span><span class=line><span class=cl><span class=nl>  </span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nl>^head</span><span class=p>:</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span>blocktag <span class=p>&lt;</span><span class=nl>id =</span> <span class=m>0</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span></code></pre></div><p>It also supports a list of operands that can be passed to a target block:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  llvm<span class=p>.</span>indirectbr <span class=nv>%dest</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>,</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=nl>^head</span><span class=p>(</span><span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=nl>^tail</span><span class=p>(</span><span class=nv>%arg1</span><span class=p>,</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nl>^head</span><span class=p>(</span><span class=nv>%r0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%r0</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=nl>^tail</span><span class=p>(</span><span class=nv>%r1</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nv>%r2</span> <span class=p>:</span> <span class=k>i32</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameVariadicOperandSize</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>indbr_operand_segments</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>succOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=successors-2>Successors:&nbsp;<a class=headline-hash href=#successors-2>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>successors</code></td><td>any successor</td></tr></tbody></table><h3 id=llvminline_asm-llvminlineasmop><code>llvm.inline_asm</code> (LLVM::InlineAsmOp)&nbsp;<a class=headline-hash href=#llvminline_asm-llvminlineasmop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.inline_asm` (`has_side_effects` $has_side_effects^)?
              (`is_align_stack` $is_align_stack^)?
              (`tail_call_kind` `=` $tail_call_kind^)?
              (`asm_dialect` `=` $asm_dialect^)?
              (`operand_attrs` `=` $operand_attrs^)?
              attr-dict
              $asm_string `,` $constraints
              operands `:` functional-type(operands, results)
</code></pre><p>The InlineAsmOp mirrors the underlying LLVM semantics with a notable
exception: the embedded <code>asm_string</code> is not allowed to define or reference
any symbol or any global variable: only the operands of the op may be read,
written, or referenced.
Attempting to define or reference any symbol or any global behavior is
considered undefined behavior at this time.
If <code>tail_call_kind</code> is used, the operation behaves like the specified
tail call kind. The <code>musttail</code> kind it&rsquo;s not available for this operation,
since it isn&rsquo;t supported by LLVM&rsquo;s inline asm.</p><p>Interfaces: <code>MemoryEffectOpInterface</code></p><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>asm_string</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>constraints</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>has_side_effects</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>is_align_stack</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>tail_call_kind</code></td><td>::mlir::LLVM::TailCallKindAttr</td><td>LLVM Calling Convention specification</td></tr><tr><td><code>asm_dialect</code></td><td>::mlir::LLVM::AsmDialectAttr</td><td>ATT (0) or Intel (1) asm dialect</td></tr><tr><td><code>operand_attrs</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvminsertelement-llvminsertelementop><code>llvm.insertelement</code> (LLVM::InsertElementOp)&nbsp;<a class=headline-hash href=#llvminsertelement-llvminsertelementop>¶</a></h3><p><em>Insert an element into an LLVM vector.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.insertelement` $value `,` $vector `[` $position `:` type($position) `]` attr-dict `:`
              type($vector)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>value</code></td><td>primitive LLVM type</td></tr><tr><td style=text-align:center><code>position</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvminsertvalue-llvminsertvalueop><code>llvm.insertvalue</code> (LLVM::InsertValueOp)&nbsp;<a class=headline-hash href=#llvminsertvalue-llvminsertvalueop>¶</a></h3><p><em>Insert a value into an LLVM struct.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.insertvalue` $value `,` $container `` $position attr-dict `:` type($container)
              custom&lt;InsertExtractValueElementType&gt;(type($value), ref(type($container)),
              ref($position))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>position</code></td><td>::mlir::DenseI64ArrayAttr</td><td>i64 dense array attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>container</code></td><td>LLVM aggregate type</td></tr><tr><td style=text-align:center><code>value</code></td><td>primitive LLVM type</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM aggregate type</td></tr></tbody></table><h3 id=llvminttoptr-llvminttoptrop><code>llvm.inttoptr</code> (LLVM::IntToPtrOp)&nbsp;<a class=headline-hash href=#llvminttoptr-llvminttoptrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.inttoptr` $arg (`dereferenceable` `` $dereferenceable^)? attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>DereferenceableOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>dereferenceable</code></td><td>::mlir::LLVM::DereferenceableAttr</td><td><details><summary>LLVM dereferenceable attribute</summary><pre><code>Defines `dereferenceable` or `dereferenceable_or_null` metadata that can
be set via the `DereferenceableOpInterface` on an `inttoptr` operation or
on a `load` operation which loads a pointer. The attribute is used to
denote that the result of these operations is dereferenceable up to a
certain number of bytes, represented by `$bytes`. The optional `$mayBeNull`
parameter is set to true if the attribute defines `dereferenceable_or_null`
metadata.
<p>See the following links for more details:

<a href=https://llvm.org/docs/LangRef.html#dereferenceable-metadata>https://llvm.org/docs/LangRef.html#dereferenceable-metadata</a>

<a href=https://llvm.org/docs/LangRef.html#dereferenceable-or-null-metadata>https://llvm.org/docs/LangRef.html#dereferenceable-or-null-metadata</a>
</code></pre></p></details></td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvminvoke-llvminvokeop><code>llvm.invoke</code> (LLVM::InvokeOp)&nbsp;<a class=headline-hash href=#llvminvoke-llvminvokeop>¶</a></h3><p>Traits: <code>AttrSizedOperandSegments</code>, <code>Terminator</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>BranchOpInterface</code>, <code>CallOpInterface</code>, <code>WeightedBranchOpInterface</code></p><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>var_callee_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of LLVM function type</td></tr><tr><td><code>callee</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>branch_weights</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>CConv</code></td><td>::mlir::LLVM::CConvAttr</td><td>LLVM Calling Convention specification</td></tr><tr><td><code>op_bundle_sizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>op_bundle_tags</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>callee_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>normalDestOperands</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>unwindDestOperands</code></td><td>variadic of LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>op_bundle_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=successors-3>Successors:&nbsp;<a class=headline-hash href=#successors-3>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>normalDest</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>unwindDest</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmfunc-llvmllvmfuncop><code>llvm.func</code> (LLVM::LLVMFuncOp)&nbsp;<a class=headline-hash href=#llvmfunc-llvmllvmfuncop>¶</a></h3><p><em>LLVM dialect function.</em></p><p>MLIR functions are defined by an operation that is not built into the IR
itself. The LLVM dialect provides an <code>llvm.func</code> operation to define
functions compatible with LLVM IR. These functions have LLVM dialect
function type but use MLIR syntax to express it. They are required to have
exactly one result type. LLVM function operation is intended to capture
additional properties of LLVM functions, such as linkage and calling
convention, that may be modeled differently by the built-in MLIR function.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// The type of @bar is !llvm&lt;&#34;i64 (i64)&#34;&gt;
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@bar</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span> <span class=nv>%arg0</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Type type of @foo is !llvm&lt;&#34;void (i64)&#34;&gt;
</span></span></span><span class=line><span class=cl><span class=c>// !llvm.void type is omitted
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%arg0</span><span class=p>:</span> <span class=k>i64</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A function with `internal` linkage.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span><span class=kt>func</span> internal <span class=nf>@internal_func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Traits: <code>AffineScope</code>, <code>AutomaticAllocationScope</code>, <code>IsolatedFromAbove</code></p><p>Interfaces: <code>ArgAndResultAttrsOpInterface</code>, <code>CallableOpInterface</code>, <code>FunctionOpInterface</code>, <code>Symbol</code></p><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>sym_name</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>sym_visibility</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>function_type</code></td><td>::mlir::TypeAttr</td><td>type attribute of LLVM function type</td></tr><tr><td><code>linkage</code></td><td>::mlir::LLVM::LinkageAttr</td><td>LLVM Linkage specification</td></tr><tr><td><code>dso_local</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>CConv</code></td><td>::mlir::LLVM::CConvAttr</td><td>LLVM Calling Convention specification</td></tr><tr><td><code>comdat</code></td><td>::mlir::SymbolRefAttr</td><td>symbol reference attribute</td></tr><tr><td><code>convergent</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>personality</code></td><td>::mlir::FlatSymbolRefAttr</td><td>flat symbol reference attribute</td></tr><tr><td><code>garbageCollector</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>passthrough</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>function_entry_count</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>memory_effects</code></td><td>::mlir::LLVM::MemoryEffectsAttr</td><td></td></tr><tr><td><code>visibility_</code></td><td>::mlir::LLVM::VisibilityAttr</td><td>LLVM GlobalValue Visibility</td></tr><tr><td><code>arm_streaming</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_locally_streaming</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_streaming_compatible</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_new_za</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_in_za</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_out_za</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_inout_za</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>arm_preserves_za</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>section</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>unnamed_addr</code></td><td>::mlir::LLVM::UnnamedAddrAttr</td><td>LLVM GlobalValue UnnamedAddr</td></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>vscale_range</code></td><td>::mlir::LLVM::VScaleRangeAttr</td><td></td></tr><tr><td><code>frame_pointer</code></td><td>::mlir::LLVM::FramePointerKindAttr</td><td></td></tr><tr><td><code>target_cpu</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>tune_cpu</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>reciprocal_estimates</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>prefer_vector_width</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>target_features</code></td><td>::mlir::LLVM::TargetFeaturesAttr</td><td><details><summary>LLVM target features attribute</summary><pre><code>Represents the LLVM target features as a list that can be checked within
passes/rewrites.
<p>Example:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#llvm.target_features</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=p>[</span><span class=err>&amp;</span>quot<span class=err>;+</span>sme<span class=err>&amp;</span>quot<span class=err>;</span><span class=p>,</span> <span class=err>&amp;</span>quot<span class=err>;+</span>sve<span class=err>&amp;</span>quot<span class=err>;</span><span class=p>,</span> <span class=err>&amp;</span>quot<span class=err>;+</span>sme<span class=err>-</span><span class=k>f64f64</span><span class=err>&amp;</span>quot<span class=err>;</span><span class=p>]</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span></code></pre></div><p>Then within a pass or rewrite the features active at an op can be queried:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>auto</span> <span class=n>targetFeatures</span> <span class=o>=</span> <span class=n>LLVM</span><span class=o>::</span><span class=n>TargetFeaturesAttr</span><span class=o>::</span><span class=n>featuresAt</span><span class=p>(</span><span class=n>op</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>targetFeatures</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=o>&amp;</span><span class=n>quot</span><span class=p>;</span><span class=o>+</span><span class=n>sme</span><span class=o>-</span><span class=n>f64f64</span><span class=o>&amp;</span><span class=n>quot</span><span class=p>;))</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>failure</span><span class=p>();</span>
</span></span></code></pre></div><p></code></pre></p></details></td></tr><tr><td><code>unsafe_fp_math</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>no_infs_fp_math</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>no_nans_fp_math</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>approx_func_fp_math</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>no_signed_zeros_fp_math</code></td><td>::mlir::BoolAttr</td><td>bool attribute</td></tr><tr><td><code>denormal_fp_math</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>denormal_fp_math_f32</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>fp_contract</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>instrument_function_entry</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>instrument_function_exit</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>no_inline</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>always_inline</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>no_unwind</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>will_return</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>optimize_none</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>vec_type_hint</code></td><td>::mlir::LLVM::VecTypeHintAttr</td><td><details><summary>Explicit vectorization compiler hint</summary><pre><code>A hint to the compiler that indicates most operations used in the function
are explictly vectorized using a particular vector type. `$hint` is the
vector or scalar type in particular. `$is_signed` can be used with integer
types to state whether the type is signed.
</code></pre></details></td></tr><tr><td><code>work_group_size_hint</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>reqd_work_group_size</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>intel_reqd_sub_group_size</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>uwtable_kind</code></td><td>::mlir::LLVM::UWTableKindAttr</td><td></td></tr></table><h3 id=llvmlshr-llvmlshrop><code>llvm.lshr</code> (LLVM::LShrOp)&nbsp;<a class=headline-hash href=#llvmlshr-llvmlshrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.lshr` (`exact` $isExact^)? $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ExactFlagInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmlandingpad-llvmlandingpadop><code>llvm.landingpad</code> (LLVM::LandingpadOp)&nbsp;<a class=headline-hash href=#llvmlandingpad-llvmlandingpadop>¶</a></h3><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>cleanup</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmlinker_options-llvmlinkeroptionsop><code>llvm.linker_options</code> (LLVM::LinkerOptionsOp)&nbsp;<a class=headline-hash href=#llvmlinker_options-llvmlinkeroptionsop>¶</a></h3><p><em>Options to pass to the linker when the object file is linked</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.linker_options` $options attr-dict
</code></pre><p>Pass the given options to the linker when the resulting object file is linked.
This is used extensively on Windows to determine the C runtime that the object
files should link against.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Link against the MSVC static threaded CRT.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>linker_options <span class=p>[</span><span class=s>&#34;/DEFAULTLIB:&#34;</span><span class=p>,</span> <span class=s>&#34;libcmt&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Link against aarch64 compiler-rt builtins
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>linker_options <span class=p>[</span><span class=s>&#34;-l&#34;</span><span class=p>,</span> <span class=s>&#34;clang_rt.builtins-aarch64&#34;</span><span class=p>]</span>
</span></span></code></pre></div><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>options</code></td><td>::mlir::ArrayAttr</td><td>string array attribute</td></tr></table><h3 id=llvmload-llvmloadop><code>llvm.load</code> (LLVM::LoadOp)&nbsp;<a class=headline-hash href=#llvmload-llvmloadop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.load` (`volatile` $volatile_^)? $addr
              (`atomic` (`syncscope` `(` $syncscope^ `)`)? $ordering^)?
              (`invariant` $invariant^)?
              (`invariant_group` $invariantGroup^)?
              (`dereferenceable` `` $dereferenceable^)?
              attr-dict `:` qualified(type($addr)) `-&gt;` type($res)
</code></pre><p>The <code>load</code> operation is used to read from memory. A load may be marked as
atomic, volatile, and/or nontemporal, and takes a number of optional
attributes that specify aliasing information.</p><p>An atomic load only supports a limited set of pointer, integer, and
floating point types, and requires an explicit alignment.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A volatile load of a float variable.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load volatile <span class=nv>%ptr</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A nontemporal load of a float variable.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%ptr</span> <span class=p>{</span>nontemporal<span class=p>}</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>-&gt;</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// An atomic load of an integer variable.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>load <span class=nv>%ptr</span> atomic monotonic <span class=p>{</span><span class=nl>alignment =</span> <span class=m>8</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr <span class=p>-&gt;</span> <span class=k>i64</span>
</span></span></code></pre></div><p>See the following link for more details:
<a href=https://llvm.org/docs/LangRef.html#load-instruction>https://llvm.org/docs/LangRef.html#load-instruction</a></p><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>DereferenceableOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>MemoryEffectOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-40>Attributes:&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>volatile_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>nontemporal</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>invariant</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>invariantGroup</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>syncscope</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>dereferenceable</code></td><td>::mlir::LLVM::DereferenceableAttr</td><td><details><summary>LLVM dereferenceable attribute</summary><pre><code>Defines `dereferenceable` or `dereferenceable_or_null` metadata that can
be set via the `DereferenceableOpInterface` on an `inttoptr` operation or
on a `load` operation which loads a pointer. The attribute is used to
denote that the result of these operations is dereferenceable up to a
certain number of bytes, represented by `$bytes`. The optional `$mayBeNull`
parameter is set to true if the attribute defines `dereferenceable_or_null`
metadata.
<p>See the following links for more details:

<a href=https://llvm.org/docs/LangRef.html#dereferenceable-metadata>https://llvm.org/docs/LangRef.html#dereferenceable-metadata</a>

<a href=https://llvm.org/docs/LangRef.html#dereferenceable-or-null-metadata>https://llvm.org/docs/LangRef.html#dereferenceable-or-null-metadata</a>
</code></pre></p></details></td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM type with size</td></tr></tbody></table><h3 id=llvmmodule_flags-llvmmoduleflagsop><code>llvm.module_flags</code> (LLVM::ModuleFlagsOp)&nbsp;<a class=headline-hash href=#llvmmodule_flags-llvmmoduleflagsop>¶</a></h3><p><em>Information about module properties</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.module_flags` $flags attr-dict
</code></pre><p>Represents the equivalent in MLIR for LLVM&rsquo;s <code>llvm.module.flags</code> metadata,
which requires a list of metadata triplets. Each triplet entry is described
by a <code>ModuleFlagAttr</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>llvm<span class=p>.</span>module<span class=p>.</span>flags <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=nv>#llvm.mlir.module_flag</span><span class=p>&lt;</span>error<span class=p>,</span> <span class=s>&#34;wchar_size&#34;</span><span class=p>,</span> <span class=m>4</span><span class=p>&gt;,</span>
</span></span><span class=line><span class=cl>  <span class=nv>#llvm.mlir.module_flag</span><span class=p>&lt;</span>max<span class=p>,</span> <span class=s>&#34;PIC Level&#34;</span><span class=p>,</span> <span class=m>2</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>]</span>
</span></span></code></pre></div><h4 id=attributes-41>Attributes:&nbsp;<a class=headline-hash href=#attributes-41>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>flags</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h3 id=llvmmul-llvmmulop><code>llvm.mul</code> (LLVM::MulOp)&nbsp;<a class=headline-hash href=#llvmmul-llvmmulop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mul` $lhs `,` $rhs ($overflowFlags^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerOverflowFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmmlirnone-llvmnonetokenop><code>llvm.mlir.none</code> (LLVM::NoneTokenOp)&nbsp;<a class=headline-hash href=#llvmmlirnone-llvmnonetokenop>¶</a></h3><p><em>Defines a value containing an empty token to LLVM type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.none` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class token values. They must be
explicitly created as SSA values using <code>llvm.mlir.none</code>. This operation has
no operands or attributes, and returns a none token value of a wrapped LLVM IR
pointer type.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>none <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>token
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM token type</td></tr></tbody></table><h3 id=llvmor-llvmorop><code>llvm.or</code> (LLVM::OrOp)&nbsp;<a class=headline-hash href=#llvmor-llvmorop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.or` (`disjoint` $isDisjoint^)? $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>DisjointFlagInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-42>Attributes:&nbsp;<a class=headline-hash href=#attributes-42>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isDisjoint</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmmlirpoison-llvmpoisonop><code>llvm.mlir.poison</code> (LLVM::PoisonOp)&nbsp;<a class=headline-hash href=#llvmmlirpoison-llvmpoisonop>¶</a></h3><p><em>Creates a poison value of LLVM dialect type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.poison` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class poison values. Such values
must be created as SSA values using <code>llvm.mlir.poison</code>. This operation has
no operands or attributes. It creates a poison value of the specified LLVM
IR dialect type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create a poison value for a structure with a 32-bit integer followed
</span></span></span><span class=line><span class=cl><span class=c>// by a float.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>poison <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmptrtoint-llvmptrtointop><code>llvm.ptrtoint</code> (LLVM::PtrToIntOp)&nbsp;<a class=headline-hash href=#llvmptrtoint-llvmptrtointop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.ptrtoint` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmresume-llvmresumeop><code>llvm.resume</code> (LLVM::ResumeOp)&nbsp;<a class=headline-hash href=#llvmresume-llvmresumeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.resume` $value attr-dict `:` type($value)
</code></pre><p>Traits: <code>Terminator</code></p><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmreturn-llvmreturnop><code>llvm.return</code> (LLVM::ReturnOp)&nbsp;<a class=headline-hash href=#llvmreturn-llvmreturnop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.return` attr-dict ($arg^ `:` type($arg))?
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ReturnLike</code>, <code>Terminator</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RegionBranchTerminatorOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmsdiv-llvmsdivop><code>llvm.sdiv</code> (LLVM::SDivOp)&nbsp;<a class=headline-hash href=#llvmsdiv-llvmsdivop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.sdiv` (`exact` $isExact^)? $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ExactFlagInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-43>Attributes:&nbsp;<a class=headline-hash href=#attributes-43>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmsext-llvmsextop><code>llvm.sext</code> (LLVM::SExtOp)&nbsp;<a class=headline-hash href=#llvmsext-llvmsextop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.sext` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmsitofp-llvmsitofpop><code>llvm.sitofp</code> (LLVM::SIToFPOp)&nbsp;<a class=headline-hash href=#llvmsitofp-llvmsitofpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.sitofp` $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmsrem-llvmsremop><code>llvm.srem</code> (LLVM::SRemOp)&nbsp;<a class=headline-hash href=#llvmsrem-llvmsremop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.srem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmselect-llvmselectop><code>llvm.select</code> (LLVM::SelectOp)&nbsp;<a class=headline-hash href=#llvmselect-llvmselectop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.select` operands attr-dict `:` type($condition) `,` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SelectLikeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-44>Attributes:&nbsp;<a class=headline-hash href=#attributes-44>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>1-bit signless integer or LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>trueValue</code></td><td>LLVM dialect-compatible type</td></tr><tr><td style=text-align:center><code>falseValue</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmshl-llvmshlop><code>llvm.shl</code> (LLVM::ShlOp)&nbsp;<a class=headline-hash href=#llvmshl-llvmshlop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.shl` $lhs `,` $rhs ($overflowFlags^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerOverflowFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmshufflevector-llvmshufflevectorop><code>llvm.shufflevector</code> (LLVM::ShuffleVectorOp)&nbsp;<a class=headline-hash href=#llvmshufflevector-llvmshufflevectorop>¶</a></h3><p><em>Construct a permutation of two vectors.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.shufflevector` $v1 `,` $v2 $mask attr-dict `:` type($v1)
              custom&lt;ShuffleType&gt;(ref(type($v1)), type($res), ref($mask))
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-45>Attributes:&nbsp;<a class=headline-hash href=#attributes-45>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>mask</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>v1</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>v2</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmstore-llvmstoreop><code>llvm.store</code> (LLVM::StoreOp)&nbsp;<a class=headline-hash href=#llvmstore-llvmstoreop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.store` (`volatile` $volatile_^)? $value `,` $addr
              (`atomic` (`syncscope` `(` $syncscope^ `)`)? $ordering^)?
              (`invariant_group` $invariantGroup^)?
              attr-dict `:` type($value) `,` qualified(type($addr))
</code></pre><p>The <code>store</code> operation is used to write to memory. A store may be marked as
atomic, volatile, and/or nontemporal, and takes a number of optional
attributes that specify aliasing information.</p><p>An atomic store only supports a limited set of pointer, integer, and
floating point types, and requires an explicit alignment.</p><p>Examples:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// A volatile store of a float variable.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>store volatile <span class=nv>%val</span><span class=p>,</span> <span class=nv>%ptr</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// A nontemporal store of a float variable.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>store <span class=nv>%val</span><span class=p>,</span> <span class=nv>%ptr</span> <span class=p>{</span>nontemporal<span class=p>}</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// An atomic store of an integer variable.
</span></span></span><span class=line><span class=cl><span class=c></span>llvm<span class=p>.</span>store <span class=nv>%val</span><span class=p>,</span> <span class=nv>%ptr</span> atomic monotonic <span class=p>{</span><span class=nl>alignment =</span> <span class=m>8</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span></code></pre></div><p>See the following link for more details:
<a href=https://llvm.org/docs/LangRef.html#store-instruction>https://llvm.org/docs/LangRef.html#store-instruction</a></p><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>MemoryEffectOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-46>Attributes:&nbsp;<a class=headline-hash href=#attributes-46>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr><tr><td><code>volatile_</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>nontemporal</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>invariantGroup</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr><tr><td><code>ordering</code></td><td>::mlir::LLVM::AtomicOrderingAttr</td><td>Atomic ordering for LLVM's memory model</td></tr><tr><td><code>syncscope</code></td><td>::mlir::StringAttr</td><td>string attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>LLVM type with size</td></tr><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmsub-llvmsubop><code>llvm.sub</code> (LLVM::SubOp)&nbsp;<a class=headline-hash href=#llvmsub-llvmsubop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.sub` $lhs `,` $rhs ($overflowFlags^)? attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>IntegerOverflowFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmswitch-llvmswitchop><code>llvm.switch</code> (LLVM::SwitchOp)&nbsp;<a class=headline-hash href=#llvmswitch-llvmswitchop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.switch` $value `:` type($value) `,`
              $defaultDestination (`(` $defaultOperands^ `:` type($defaultOperands) `)`)?
              custom&lt;SwitchOpCases&gt;(ref(type($value)), $case_values, $caseDestinations,
              $caseOperands, type($caseOperands))
              attr-dict
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code>, <code>Terminator</code></p><p>Interfaces: <code>BranchOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>WeightedBranchOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-47>Attributes:&nbsp;<a class=headline-hash href=#attributes-47>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>case_values</code></td><td>::mlir::DenseIntElementsAttr</td><td>integer elements attribute</td></tr><tr><td><code>case_operand_segments</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>branch_weights</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>defaultOperands</code></td><td>variadic of any type</td></tr><tr><td style=text-align:center><code>caseOperands</code></td><td>variadic of any type</td></tr></tbody></table><h4 id=successors-4>Successors:&nbsp;<a class=headline-hash href=#successors-4>¶</a></h4><table><thead><tr><th style=text-align:center>Successor</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>defaultDestination</code></td><td>any successor</td></tr><tr><td style=text-align:center><code>caseDestinations</code></td><td>any successor</td></tr></tbody></table><h3 id=llvmtrunc-llvmtruncop><code>llvm.trunc</code> (LLVM::TruncOp)&nbsp;<a class=headline-hash href=#llvmtrunc-llvmtruncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.trunc` $arg ($overflowFlags^)? attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>IntegerOverflowFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-51>Results:&nbsp;<a class=headline-hash href=#results-51>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmudiv-llvmudivop><code>llvm.udiv</code> (LLVM::UDivOp)&nbsp;<a class=headline-hash href=#llvmudiv-llvmudivop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.udiv` (`exact` $isExact^)? $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>ExactFlagInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-48>Attributes:&nbsp;<a class=headline-hash href=#attributes-48>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-52>Results:&nbsp;<a class=headline-hash href=#results-52>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmuitofp-llvmuitofpop><code>llvm.uitofp</code> (LLVM::UIToFPOp)&nbsp;<a class=headline-hash href=#llvmuitofp-llvmuitofpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.uitofp` (`nneg` $nonNeg^)? $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>NonNegFlagInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-49>Attributes:&nbsp;<a class=headline-hash href=#attributes-49>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>nonNeg</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-53>Results:&nbsp;<a class=headline-hash href=#results-53>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h3 id=llvmurem-llvmuremop><code>llvm.urem</code> (LLVM::URemOp)&nbsp;<a class=headline-hash href=#llvmurem-llvmuremop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.urem` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-54>Results:&nbsp;<a class=headline-hash href=#results-54>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmmlirundef-llvmundefop><code>llvm.mlir.undef</code> (LLVM::UndefOp)&nbsp;<a class=headline-hash href=#llvmmlirundef-llvmundefop>¶</a></h3><p><em>Creates an undefined value of LLVM dialect type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.undef` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class undefined values. Such values
must be created as SSA values using <code>llvm.mlir.undef</code>. This operation has no
operands or attributes. It creates an undefined value of the specified LLVM
IR dialect type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create a structure with a 32-bit integer followed by a float.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>undef <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-55>Results:&nbsp;<a class=headline-hash href=#results-55>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmunreachable-llvmunreachableop><code>llvm.unreachable</code> (LLVM::UnreachableOp)&nbsp;<a class=headline-hash href=#llvmunreachable-llvmunreachableop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.unreachable` attr-dict
</code></pre><p>Traits: <code>Terminator</code></p><h3 id=llvmva_arg-llvmvaargop><code>llvm.va_arg</code> (LLVM::VaArgOp)&nbsp;<a class=headline-hash href=#llvmva_arg-llvmvaargop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.va_arg` $arg attr-dict `:` functional-type($arg, $res)
</code></pre><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-56>Results:&nbsp;<a class=headline-hash href=#results-56>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmxor-llvmxorop><code>llvm.xor</code> (LLVM::XOrOp)&nbsp;<a class=headline-hash href=#llvmxor-llvmxorop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.xor` $lhs `,` $rhs attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-57>Results:&nbsp;<a class=headline-hash href=#results-57>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmzext-llvmzextop><code>llvm.zext</code> (LLVM::ZExtOp)&nbsp;<a class=headline-hash href=#llvmzext-llvmzextop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.zext` (`nneg` $nonNeg^)? $arg attr-dict `:` type($arg) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>NonNegFlagInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-50>Attributes:&nbsp;<a class=headline-hash href=#attributes-50>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>nonNeg</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-58>Results:&nbsp;<a class=headline-hash href=#results-58>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmmlirzero-llvmzeroop><code>llvm.mlir.zero</code> (LLVM::ZeroOp)&nbsp;<a class=headline-hash href=#llvmmlirzero-llvmzeroop>¶</a></h3><p><em>Creates a zero-initialized value of LLVM dialect type.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.mlir.zero` attr-dict `:` type($res)
</code></pre><p>Unlike LLVM IR, MLIR does not have first-class zero-initialized values.
Such values must be created as SSA values using <code>llvm.mlir.zero</code>. This
operation has no operands or attributes. It creates a zero-initialized
value of the specified LLVM IR dialect type.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create a zero-initialized value for a structure with a 32-bit integer
</span></span></span><span class=line><span class=cl><span class=c>// followed by a float.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span>zero <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>struct<span class=p>&lt;(</span><span class=k>i32</span><span class=p>,</span> <span class=k>f32</span><span class=p>)&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-59>Results:&nbsp;<a class=headline-hash href=#results-59>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h2 id=operations-for-llvm-ir-intrinsics>Operations for LLVM IR Intrinsics&nbsp;<a class=headline-hash href=#operations-for-llvm-ir-intrinsics>¶</a></h2><p>MLIR operation system is open making it unnecessary to introduce a hard bound
between &ldquo;core&rdquo; operations and &ldquo;intrinsics&rdquo;. General LLVM IR intrinsics are
modeled as first-class operations in the LLVM dialect. Target-specific LLVM IR
intrinsics, e.g., NVVM or ROCDL, are modeled as separate dialects.</p><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/LLVMIR/LLVMIntrinsicOps.td>source</a></p><h3 id=llvmintracos-llvmacosop><code>llvm.intr.acos</code> (LLVM::ACosOp)&nbsp;<a class=headline-hash href=#llvmintracos-llvmacosop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.acos` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-51>Attributes:&nbsp;<a class=headline-hash href=#attributes-51>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-60>Results:&nbsp;<a class=headline-hash href=#results-60>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrasin-llvmasinop><code>llvm.intr.asin</code> (LLVM::ASinOp)&nbsp;<a class=headline-hash href=#llvmintrasin-llvmasinop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.asin` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-52>Attributes:&nbsp;<a class=headline-hash href=#attributes-52>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-61>Results:&nbsp;<a class=headline-hash href=#results-61>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintratan2-llvmatan2op><code>llvm.intr.atan2</code> (LLVM::ATan2Op)&nbsp;<a class=headline-hash href=#llvmintratan2-llvmatan2op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.atan2` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-53>Attributes:&nbsp;<a class=headline-hash href=#attributes-53>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-62>Results:&nbsp;<a class=headline-hash href=#results-62>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintratan-llvmatanop><code>llvm.intr.atan</code> (LLVM::ATanOp)&nbsp;<a class=headline-hash href=#llvmintratan-llvmatanop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.atan` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-54>Attributes:&nbsp;<a class=headline-hash href=#attributes-54>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-63>Results:&nbsp;<a class=headline-hash href=#results-63>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrabs-llvmabsop><code>llvm.intr.abs</code> (LLVM::AbsOp)&nbsp;<a class=headline-hash href=#llvmintrabs-llvmabsop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-55>Attributes:&nbsp;<a class=headline-hash href=#attributes-55>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>is_int_min_poison</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-63>Operands:&nbsp;<a class=headline-hash href=#operands-63>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-64>Results:&nbsp;<a class=headline-hash href=#results-64>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrannotation-llvmannotation><code>llvm.intr.annotation</code> (LLVM::Annotation)&nbsp;<a class=headline-hash href=#llvmintrannotation-llvmannotation>¶</a></h3><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-64>Operands:&nbsp;<a class=headline-hash href=#operands-64>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>integer</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>annotation</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>fileName</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>line</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-65>Results:&nbsp;<a class=headline-hash href=#results-65>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>signless integer</td></tr></tbody></table><h3 id=llvmintrassume-llvmassumeop><code>llvm.intr.assume</code> (LLVM::AssumeOp)&nbsp;<a class=headline-hash href=#llvmintrassume-llvmassumeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.assume` $cond
              ( custom&lt;OpBundles&gt;($op_bundle_operands, type($op_bundle_operands),
              $op_bundle_tags)^ )?
              `:` type($cond) attr-dict
</code></pre><h4 id=attributes-56>Attributes:&nbsp;<a class=headline-hash href=#attributes-56>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>op_bundle_sizes</code></td><td>::mlir::DenseI32ArrayAttr</td><td>i32 dense array attribute</td></tr><tr><td><code>op_bundle_tags</code></td><td>::mlir::ArrayAttr</td><td>array attribute</td></tr></table><h4 id=operands-65>Operands:&nbsp;<a class=headline-hash href=#operands-65>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>op_bundle_operands</code></td><td>variadic of LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrbitreverse-llvmbitreverseop><code>llvm.intr.bitreverse</code> (LLVM::BitReverseOp)&nbsp;<a class=headline-hash href=#llvmintrbitreverse-llvmbitreverseop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.bitreverse` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-66>Operands:&nbsp;<a class=headline-hash href=#operands-66>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-66>Results:&nbsp;<a class=headline-hash href=#results-66>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrbswap-llvmbyteswapop><code>llvm.intr.bswap</code> (LLVM::ByteSwapOp)&nbsp;<a class=headline-hash href=#llvmintrbswap-llvmbyteswapop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.bswap` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-67>Operands:&nbsp;<a class=headline-hash href=#operands-67>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-67>Results:&nbsp;<a class=headline-hash href=#results-67>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalconstrainedfpext-llvmconstrainedfpextintr><code>llvm.intr.experimental.constrained.fpext</code> (LLVM::ConstrainedFPExtIntr)&nbsp;<a class=headline-hash href=#llvmintrexperimentalconstrainedfpext-llvmconstrainedfpextintr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.experimental.constrained.fpext` $arg_0 $fpExceptionBehavior attr-dict `:` type($arg_0) `to` type(results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FPExceptionBehaviorOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-57>Attributes:&nbsp;<a class=headline-hash href=#attributes-57>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fpExceptionBehavior</code></td><td>::mlir::LLVM::FPExceptionBehaviorAttr</td><td>LLVM Exception Behavior</td></tr></table><h4 id=operands-68>Operands:&nbsp;<a class=headline-hash href=#operands-68>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_0</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-68>Results:&nbsp;<a class=headline-hash href=#results-68>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalconstrainedfptrunc-llvmconstrainedfptruncintr><code>llvm.intr.experimental.constrained.fptrunc</code> (LLVM::ConstrainedFPTruncIntr)&nbsp;<a class=headline-hash href=#llvmintrexperimentalconstrainedfptrunc-llvmconstrainedfptruncintr>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.experimental.constrained.fptrunc` $arg_0 $roundingmode $fpExceptionBehavior attr-dict `:` type($arg_0) `to` type(results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FPExceptionBehaviorOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RoundingModeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-58>Attributes:&nbsp;<a class=headline-hash href=#attributes-58>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>roundingmode</code></td><td>::mlir::LLVM::RoundingModeAttr</td><td>LLVM Rounding Mode whose minimum value is 0</td></tr><tr><td><code>fpExceptionBehavior</code></td><td>::mlir::LLVM::FPExceptionBehaviorAttr</td><td>LLVM Exception Behavior</td></tr></table><h4 id=operands-69>Operands:&nbsp;<a class=headline-hash href=#operands-69>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_0</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-69>Results:&nbsp;<a class=headline-hash href=#results-69>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalconstrainedsitofp-llvmconstrainedsitofp><code>llvm.intr.experimental.constrained.sitofp</code> (LLVM::ConstrainedSIToFP)&nbsp;<a class=headline-hash href=#llvmintrexperimentalconstrainedsitofp-llvmconstrainedsitofp>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.experimental.constrained.sitofp` $arg_0 $roundingmode $fpExceptionBehavior attr-dict `:` type($arg_0) `to` type(results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FPExceptionBehaviorOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RoundingModeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-59>Attributes:&nbsp;<a class=headline-hash href=#attributes-59>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>roundingmode</code></td><td>::mlir::LLVM::RoundingModeAttr</td><td>LLVM Rounding Mode whose minimum value is 0</td></tr><tr><td><code>fpExceptionBehavior</code></td><td>::mlir::LLVM::FPExceptionBehaviorAttr</td><td>LLVM Exception Behavior</td></tr></table><h4 id=operands-70>Operands:&nbsp;<a class=headline-hash href=#operands-70>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_0</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-70>Results:&nbsp;<a class=headline-hash href=#results-70>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalconstraineduitofp-llvmconstraineduitofp><code>llvm.intr.experimental.constrained.uitofp</code> (LLVM::ConstrainedUIToFP)&nbsp;<a class=headline-hash href=#llvmintrexperimentalconstraineduitofp-llvmconstraineduitofp>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.experimental.constrained.uitofp` $arg_0 $roundingmode $fpExceptionBehavior attr-dict `:` type($arg_0) `to` type(results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FPExceptionBehaviorOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>RoundingModeOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-60>Attributes:&nbsp;<a class=headline-hash href=#attributes-60>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>roundingmode</code></td><td>::mlir::LLVM::RoundingModeAttr</td><td>LLVM Rounding Mode whose minimum value is 0</td></tr><tr><td><code>fpExceptionBehavior</code></td><td>::mlir::LLVM::FPExceptionBehaviorAttr</td><td>LLVM Exception Behavior</td></tr></table><h4 id=operands-71>Operands:&nbsp;<a class=headline-hash href=#operands-71>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_0</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-71>Results:&nbsp;<a class=headline-hash href=#results-71>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcopysign-llvmcopysignop><code>llvm.intr.copysign</code> (LLVM::CopySignOp)&nbsp;<a class=headline-hash href=#llvmintrcopysign-llvmcopysignop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.copysign` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-61>Attributes:&nbsp;<a class=headline-hash href=#attributes-61>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-72>Operands:&nbsp;<a class=headline-hash href=#operands-72>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-72>Results:&nbsp;<a class=headline-hash href=#results-72>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcoroalign-llvmcoroalignop><code>llvm.intr.coro.align</code> (LLVM::CoroAlignOp)&nbsp;<a class=headline-hash href=#llvmintrcoroalign-llvmcoroalignop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.align` attr-dict `:` type($res)
</code></pre><h4 id=results-73>Results:&nbsp;<a class=headline-hash href=#results-73>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcorobegin-llvmcorobeginop><code>llvm.intr.coro.begin</code> (LLVM::CoroBeginOp)&nbsp;<a class=headline-hash href=#llvmintrcorobegin-llvmcorobeginop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.begin` $token `,` $mem attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-73>Operands:&nbsp;<a class=headline-hash href=#operands-73>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>token</code></td><td>LLVM token type</td></tr><tr><td style=text-align:center><code>mem</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-74>Results:&nbsp;<a class=headline-hash href=#results-74>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcoroend-llvmcoroendop><code>llvm.intr.coro.end</code> (LLVM::CoroEndOp)&nbsp;<a class=headline-hash href=#llvmintrcoroend-llvmcoroendop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.end` $handle `,` $unwind `,` $retvals attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-74>Operands:&nbsp;<a class=headline-hash href=#operands-74>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>unwind</code></td><td>1-bit signless integer</td></tr><tr><td style=text-align:center><code>retvals</code></td><td>LLVM token type</td></tr></tbody></table><h4 id=results-75>Results:&nbsp;<a class=headline-hash href=#results-75>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcorofree-llvmcorofreeop><code>llvm.intr.coro.free</code> (LLVM::CoroFreeOp)&nbsp;<a class=headline-hash href=#llvmintrcorofree-llvmcorofreeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.free` $id `,` $handle attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-75>Operands:&nbsp;<a class=headline-hash href=#operands-75>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>id</code></td><td>LLVM token type</td></tr><tr><td style=text-align:center><code>handle</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-76>Results:&nbsp;<a class=headline-hash href=#results-76>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcoroid-llvmcoroidop><code>llvm.intr.coro.id</code> (LLVM::CoroIdOp)&nbsp;<a class=headline-hash href=#llvmintrcoroid-llvmcoroidop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.id` $align `,` $promise `,` $coroaddr `,` $fnaddrs attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-76>Operands:&nbsp;<a class=headline-hash href=#operands-76>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>align</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>promise</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>coroaddr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>fnaddrs</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-77>Results:&nbsp;<a class=headline-hash href=#results-77>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcoropromise-llvmcoropromiseop><code>llvm.intr.coro.promise</code> (LLVM::CoroPromiseOp)&nbsp;<a class=headline-hash href=#llvmintrcoropromise-llvmcoropromiseop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.promise` $handle `,` $align `,` $from attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-77>Operands:&nbsp;<a class=headline-hash href=#operands-77>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>align</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>from</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-78>Results:&nbsp;<a class=headline-hash href=#results-78>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrcororesume-llvmcororesumeop><code>llvm.intr.coro.resume</code> (LLVM::CoroResumeOp)&nbsp;<a class=headline-hash href=#llvmintrcororesume-llvmcororesumeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.resume` $handle attr-dict `:` qualified(type($handle))
</code></pre><h4 id=operands-78>Operands:&nbsp;<a class=headline-hash href=#operands-78>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrcorosave-llvmcorosaveop><code>llvm.intr.coro.save</code> (LLVM::CoroSaveOp)&nbsp;<a class=headline-hash href=#llvmintrcorosave-llvmcorosaveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.save` $handle attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-79>Operands:&nbsp;<a class=headline-hash href=#operands-79>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>handle</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-79>Results:&nbsp;<a class=headline-hash href=#results-79>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcorosize-llvmcorosizeop><code>llvm.intr.coro.size</code> (LLVM::CoroSizeOp)&nbsp;<a class=headline-hash href=#llvmintrcorosize-llvmcorosizeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.size` attr-dict `:` type($res)
</code></pre><h4 id=results-80>Results:&nbsp;<a class=headline-hash href=#results-80>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcorosuspend-llvmcorosuspendop><code>llvm.intr.coro.suspend</code> (LLVM::CoroSuspendOp)&nbsp;<a class=headline-hash href=#llvmintrcorosuspend-llvmcorosuspendop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.coro.suspend` $save `,` $final attr-dict `:` type($res)
</code></pre><h4 id=operands-80>Operands:&nbsp;<a class=headline-hash href=#operands-80>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>save</code></td><td>LLVM token type</td></tr><tr><td style=text-align:center><code>final</code></td><td>1-bit signless integer</td></tr></tbody></table><h4 id=results-81>Results:&nbsp;<a class=headline-hash href=#results-81>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcos-llvmcosop><code>llvm.intr.cos</code> (LLVM::CosOp)&nbsp;<a class=headline-hash href=#llvmintrcos-llvmcosop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.cos` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-62>Attributes:&nbsp;<a class=headline-hash href=#attributes-62>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-81>Operands:&nbsp;<a class=headline-hash href=#operands-81>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-82>Results:&nbsp;<a class=headline-hash href=#results-82>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcosh-llvmcoshop><code>llvm.intr.cosh</code> (LLVM::CoshOp)&nbsp;<a class=headline-hash href=#llvmintrcosh-llvmcoshop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.cosh` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-63>Attributes:&nbsp;<a class=headline-hash href=#attributes-63>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-82>Operands:&nbsp;<a class=headline-hash href=#operands-82>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-83>Results:&nbsp;<a class=headline-hash href=#results-83>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrctlz-llvmcountleadingzerosop><code>llvm.intr.ctlz</code> (LLVM::CountLeadingZerosOp)&nbsp;<a class=headline-hash href=#llvmintrctlz-llvmcountleadingzerosop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-64>Attributes:&nbsp;<a class=headline-hash href=#attributes-64>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>is_zero_poison</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-83>Operands:&nbsp;<a class=headline-hash href=#operands-83>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-84>Results:&nbsp;<a class=headline-hash href=#results-84>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrcttz-llvmcounttrailingzerosop><code>llvm.intr.cttz</code> (LLVM::CountTrailingZerosOp)&nbsp;<a class=headline-hash href=#llvmintrcttz-llvmcounttrailingzerosop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-65>Attributes:&nbsp;<a class=headline-hash href=#attributes-65>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>is_zero_poison</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr></table><h4 id=operands-84>Operands:&nbsp;<a class=headline-hash href=#operands-84>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-85>Results:&nbsp;<a class=headline-hash href=#results-85>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrctpop-llvmctpopop><code>llvm.intr.ctpop</code> (LLVM::CtPopOp)&nbsp;<a class=headline-hash href=#llvmintrctpop-llvmctpopop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ctpop` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-85>Operands:&nbsp;<a class=headline-hash href=#operands-85>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-86>Results:&nbsp;<a class=headline-hash href=#results-86>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrdbgdeclare-llvmdbgdeclareop><code>llvm.intr.dbg.declare</code> (LLVM::DbgDeclareOp)&nbsp;<a class=headline-hash href=#llvmintrdbgdeclare-llvmdbgdeclareop>¶</a></h3><p><em>Describes how the address relates to a source language variable.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.dbg.declare` qualified($varInfo) (qualified($locationExpr)^)? `=` $addr `:` qualified(type($addr)) attr-dict
</code></pre><p>Interfaces: <code>PromotableOpInterface</code></p><h4 id=attributes-66>Attributes:&nbsp;<a class=headline-hash href=#attributes-66>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>varInfo</code></td><td>::mlir::LLVM::DILocalVariableAttr</td><td></td></tr><tr><td><code>locationExpr</code></td><td>::mlir::LLVM::DIExpressionAttr</td><td></td></tr></table><h4 id=operands-86>Operands:&nbsp;<a class=headline-hash href=#operands-86>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrdbglabel-llvmdbglabelop><code>llvm.intr.dbg.label</code> (LLVM::DbgLabelOp)&nbsp;<a class=headline-hash href=#llvmintrdbglabel-llvmdbglabelop>¶</a></h3><p><em>Relates the program to a debug information label.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.dbg.label` $label attr-dict
</code></pre><h4 id=attributes-67>Attributes:&nbsp;<a class=headline-hash href=#attributes-67>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>label</code></td><td>::mlir::LLVM::DILabelAttr</td><td></td></tr></table><h3 id=llvmintrdbgvalue-llvmdbgvalueop><code>llvm.intr.dbg.value</code> (LLVM::DbgValueOp)&nbsp;<a class=headline-hash href=#llvmintrdbgvalue-llvmdbgvalueop>¶</a></h3><p><em>Describes how the value relates to a source language variable.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.dbg.value` qualified($varInfo) (qualified($locationExpr)^)? `=` $value `:` qualified(type($value)) attr-dict
</code></pre><p>Interfaces: <code>PromotableOpInterface</code></p><h4 id=attributes-68>Attributes:&nbsp;<a class=headline-hash href=#attributes-68>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>varInfo</code></td><td>::mlir::LLVM::DILocalVariableAttr</td><td></td></tr><tr><td><code>locationExpr</code></td><td>::mlir::LLVM::DIExpressionAttr</td><td></td></tr></table><h4 id=operands-87>Operands:&nbsp;<a class=headline-hash href=#operands-87>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrdebugtrap-llvmdebugtrap><code>llvm.intr.debugtrap</code> (LLVM::DebugTrap)&nbsp;<a class=headline-hash href=#llvmintrdebugtrap-llvmdebugtrap>¶</a></h3><h3 id=llvmintrehtypeidfor-llvmehtypeidforop><code>llvm.intr.eh.typeid.for</code> (LLVM::EhTypeidForOp)&nbsp;<a class=headline-hash href=#llvmintrehtypeidfor-llvmehtypeidforop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.eh.typeid.for` $type_info attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=operands-88>Operands:&nbsp;<a class=headline-hash href=#operands-88>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>type_info</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-87>Results:&nbsp;<a class=headline-hash href=#results-87>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexp10-llvmexp10op><code>llvm.intr.exp10</code> (LLVM::Exp10Op)&nbsp;<a class=headline-hash href=#llvmintrexp10-llvmexp10op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.exp10` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-69>Attributes:&nbsp;<a class=headline-hash href=#attributes-69>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-89>Operands:&nbsp;<a class=headline-hash href=#operands-89>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-88>Results:&nbsp;<a class=headline-hash href=#results-88>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexp2-llvmexp2op><code>llvm.intr.exp2</code> (LLVM::Exp2Op)&nbsp;<a class=headline-hash href=#llvmintrexp2-llvmexp2op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.exp2` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-70>Attributes:&nbsp;<a class=headline-hash href=#attributes-70>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-90>Operands:&nbsp;<a class=headline-hash href=#operands-90>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-89>Results:&nbsp;<a class=headline-hash href=#results-89>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexp-llvmexpop><code>llvm.intr.exp</code> (LLVM::ExpOp)&nbsp;<a class=headline-hash href=#llvmintrexp-llvmexpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.exp` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-71>Attributes:&nbsp;<a class=headline-hash href=#attributes-71>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-91>Operands:&nbsp;<a class=headline-hash href=#operands-91>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-90>Results:&nbsp;<a class=headline-hash href=#results-90>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexpect-llvmexpectop><code>llvm.intr.expect</code> (LLVM::ExpectOp)&nbsp;<a class=headline-hash href=#llvmintrexpect-llvmexpectop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.expect` $val `,` $expected attr-dict `:` type($val)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-92>Operands:&nbsp;<a class=headline-hash href=#operands-92>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>expected</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-91>Results:&nbsp;<a class=headline-hash href=#results-91>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexpectwithprobability-llvmexpectwithprobabilityop><code>llvm.intr.expect.with.probability</code> (LLVM::ExpectWithProbabilityOp)&nbsp;<a class=headline-hash href=#llvmintrexpectwithprobability-llvmexpectwithprobabilityop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.expect.with.probability` $val `,` $expected `,` $prob attr-dict `:` type($val)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-72>Attributes:&nbsp;<a class=headline-hash href=#attributes-72>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>prob</code></td><td>::mlir::FloatAttr</td><td>64-bit float attribute</td></tr></table><h4 id=operands-93>Operands:&nbsp;<a class=headline-hash href=#operands-93>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>expected</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-92>Results:&nbsp;<a class=headline-hash href=#results-92>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfabs-llvmfabsop><code>llvm.intr.fabs</code> (LLVM::FAbsOp)&nbsp;<a class=headline-hash href=#llvmintrfabs-llvmfabsop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.fabs` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-73>Attributes:&nbsp;<a class=headline-hash href=#attributes-73>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-94>Operands:&nbsp;<a class=headline-hash href=#operands-94>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-93>Results:&nbsp;<a class=headline-hash href=#results-93>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrceil-llvmfceilop><code>llvm.intr.ceil</code> (LLVM::FCeilOp)&nbsp;<a class=headline-hash href=#llvmintrceil-llvmfceilop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ceil` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-74>Attributes:&nbsp;<a class=headline-hash href=#attributes-74>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-95>Operands:&nbsp;<a class=headline-hash href=#operands-95>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-94>Results:&nbsp;<a class=headline-hash href=#results-94>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfloor-llvmffloorop><code>llvm.intr.floor</code> (LLVM::FFloorOp)&nbsp;<a class=headline-hash href=#llvmintrfloor-llvmffloorop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.floor` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-75>Attributes:&nbsp;<a class=headline-hash href=#attributes-75>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-96>Operands:&nbsp;<a class=headline-hash href=#operands-96>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-95>Results:&nbsp;<a class=headline-hash href=#results-95>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfma-llvmfmaop><code>llvm.intr.fma</code> (LLVM::FMAOp)&nbsp;<a class=headline-hash href=#llvmintrfma-llvmfmaop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.fma` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-76>Attributes:&nbsp;<a class=headline-hash href=#attributes-76>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-97>Operands:&nbsp;<a class=headline-hash href=#operands-97>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>c</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-96>Results:&nbsp;<a class=headline-hash href=#results-96>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfmuladd-llvmfmuladdop><code>llvm.intr.fmuladd</code> (LLVM::FMulAddOp)&nbsp;<a class=headline-hash href=#llvmintrfmuladd-llvmfmuladdop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.fmuladd` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-77>Attributes:&nbsp;<a class=headline-hash href=#attributes-77>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-98>Operands:&nbsp;<a class=headline-hash href=#operands-98>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>c</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-97>Results:&nbsp;<a class=headline-hash href=#results-97>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrtrunc-llvmftruncop><code>llvm.intr.trunc</code> (LLVM::FTruncOp)&nbsp;<a class=headline-hash href=#llvmintrtrunc-llvmftruncop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.trunc` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-78>Attributes:&nbsp;<a class=headline-hash href=#attributes-78>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-99>Operands:&nbsp;<a class=headline-hash href=#operands-99>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-98>Results:&nbsp;<a class=headline-hash href=#results-98>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfrexp-llvmfractionexpop><code>llvm.intr.frexp</code> (LLVM::FractionExpOp)&nbsp;<a class=headline-hash href=#llvmintrfrexp-llvmfractionexpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.frexp` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-79>Attributes:&nbsp;<a class=headline-hash href=#attributes-79>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-100>Operands:&nbsp;<a class=headline-hash href=#operands-100>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-99>Results:&nbsp;<a class=headline-hash href=#results-99>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfshl-llvmfshlop><code>llvm.intr.fshl</code> (LLVM::FshlOp)&nbsp;<a class=headline-hash href=#llvmintrfshl-llvmfshlop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.fshl` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-101>Operands:&nbsp;<a class=headline-hash href=#operands-101>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-100>Results:&nbsp;<a class=headline-hash href=#results-100>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrfshr-llvmfshrop><code>llvm.intr.fshr</code> (LLVM::FshrOp)&nbsp;<a class=headline-hash href=#llvmintrfshr-llvmfshrop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.fshr` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-102>Operands:&nbsp;<a class=headline-hash href=#operands-102>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>c</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-101>Results:&nbsp;<a class=headline-hash href=#results-101>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrgetactivelanemask-llvmgetactivelanemaskop><code>llvm.intr.get.active.lane.mask</code> (LLVM::GetActiveLaneMaskOp)&nbsp;<a class=headline-hash href=#llvmintrgetactivelanemask-llvmgetactivelanemaskop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.get.active.lane.mask` $base `,` $n attr-dict `:` type($base) `,` type($n) `to` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-103>Operands:&nbsp;<a class=headline-hash href=#operands-103>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>n</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-102>Results:&nbsp;<a class=headline-hash href=#results-102>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrinvariantend-llvminvariantendop><code>llvm.intr.invariant.end</code> (LLVM::InvariantEndOp)&nbsp;<a class=headline-hash href=#llvmintrinvariantend-llvminvariantendop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.invariant.end` $start `,` $size `,` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Interfaces: <code>PromotableOpInterface</code></p><h4 id=attributes-80>Attributes:&nbsp;<a class=headline-hash href=#attributes-80>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-104>Operands:&nbsp;<a class=headline-hash href=#operands-104>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>start</code></td><td>LLVM pointer in address space 0</td></tr><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrinvariantstart-llvminvariantstartop><code>llvm.intr.invariant.start</code> (LLVM::InvariantStartOp)&nbsp;<a class=headline-hash href=#llvmintrinvariantstart-llvminvariantstartop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.invariant.start` $size `,` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Interfaces: <code>InferTypeOpInterface</code>, <code>PromotableOpInterface</code></p><h4 id=attributes-81>Attributes:&nbsp;<a class=headline-hash href=#attributes-81>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-105>Operands:&nbsp;<a class=headline-hash href=#operands-105>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-103>Results:&nbsp;<a class=headline-hash href=#results-103>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer in address space 0</td></tr></tbody></table><h3 id=llvmintrisconstant-llvmisconstantop><code>llvm.intr.is.constant</code> (LLVM::IsConstantOp)&nbsp;<a class=headline-hash href=#llvmintrisconstant-llvmisconstantop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-106>Operands:&nbsp;<a class=headline-hash href=#operands-106>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h4 id=results-104>Results:&nbsp;<a class=headline-hash href=#results-104>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>1-bit signless integer</td></tr></tbody></table><h3 id=llvmintrisfpclass-llvmisfpclass><code>llvm.intr.is.fpclass</code> (LLVM::IsFPClass)&nbsp;<a class=headline-hash href=#llvmintrisfpclass-llvmisfpclass>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-82>Attributes:&nbsp;<a class=headline-hash href=#attributes-82>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>bit</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-107>Operands:&nbsp;<a class=headline-hash href=#operands-107>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-105>Results:&nbsp;<a class=headline-hash href=#results-105>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlaunderinvariantgroup-llvmlaunderinvariantgroupop><code>llvm.intr.launder.invariant.group</code> (LLVM::LaunderInvariantGroupOp)&nbsp;<a class=headline-hash href=#llvmintrlaunderinvariantgroup-llvmlaunderinvariantgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.launder.invariant.group` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>PromotableOpInterface</code></p><h4 id=operands-108>Operands:&nbsp;<a class=headline-hash href=#operands-108>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-106>Results:&nbsp;<a class=headline-hash href=#results-106>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrlifetimeend-llvmlifetimeendop><code>llvm.intr.lifetime.end</code> (LLVM::LifetimeEndOp)&nbsp;<a class=headline-hash href=#llvmintrlifetimeend-llvmlifetimeendop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.lifetime.end` $size `,` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Interfaces: <code>PromotableOpInterface</code></p><h4 id=attributes-83>Attributes:&nbsp;<a class=headline-hash href=#attributes-83>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-109>Operands:&nbsp;<a class=headline-hash href=#operands-109>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrlifetimestart-llvmlifetimestartop><code>llvm.intr.lifetime.start</code> (LLVM::LifetimeStartOp)&nbsp;<a class=headline-hash href=#llvmintrlifetimestart-llvmlifetimestartop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.lifetime.start` $size `,` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Interfaces: <code>PromotableOpInterface</code></p><h4 id=attributes-84>Attributes:&nbsp;<a class=headline-hash href=#attributes-84>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>size</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-110>Operands:&nbsp;<a class=headline-hash href=#operands-110>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrllrint-llvmllrintop><code>llvm.intr.llrint</code> (LLVM::LlrintOp)&nbsp;<a class=headline-hash href=#llvmintrllrint-llvmllrintop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.llrint` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-111>Operands:&nbsp;<a class=headline-hash href=#operands-111>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-107>Results:&nbsp;<a class=headline-hash href=#results-107>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrllround-llvmllroundop><code>llvm.intr.llround</code> (LLVM::LlroundOp)&nbsp;<a class=headline-hash href=#llvmintrllround-llvmllroundop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.llround` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-112>Operands:&nbsp;<a class=headline-hash href=#operands-112>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type</td></tr></tbody></table><h4 id=results-108>Results:&nbsp;<a class=headline-hash href=#results-108>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrldexp-llvmloadexpop><code>llvm.intr.ldexp</code> (LLVM::LoadExpOp)&nbsp;<a class=headline-hash href=#llvmintrldexp-llvmloadexpop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ldexp` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-85>Attributes:&nbsp;<a class=headline-hash href=#attributes-85>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-113>Operands:&nbsp;<a class=headline-hash href=#operands-113>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>power</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-109>Results:&nbsp;<a class=headline-hash href=#results-109>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlog10-llvmlog10op><code>llvm.intr.log10</code> (LLVM::Log10Op)&nbsp;<a class=headline-hash href=#llvmintrlog10-llvmlog10op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.log10` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-86>Attributes:&nbsp;<a class=headline-hash href=#attributes-86>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-114>Operands:&nbsp;<a class=headline-hash href=#operands-114>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-110>Results:&nbsp;<a class=headline-hash href=#results-110>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlog2-llvmlog2op><code>llvm.intr.log2</code> (LLVM::Log2Op)&nbsp;<a class=headline-hash href=#llvmintrlog2-llvmlog2op>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.log2` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-87>Attributes:&nbsp;<a class=headline-hash href=#attributes-87>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-115>Operands:&nbsp;<a class=headline-hash href=#operands-115>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-111>Results:&nbsp;<a class=headline-hash href=#results-111>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlog-llvmlogop><code>llvm.intr.log</code> (LLVM::LogOp)&nbsp;<a class=headline-hash href=#llvmintrlog-llvmlogop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.log` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-88>Attributes:&nbsp;<a class=headline-hash href=#attributes-88>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-116>Operands:&nbsp;<a class=headline-hash href=#operands-116>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-112>Results:&nbsp;<a class=headline-hash href=#results-112>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlrint-llvmlrintop><code>llvm.intr.lrint</code> (LLVM::LrintOp)&nbsp;<a class=headline-hash href=#llvmintrlrint-llvmlrintop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.lrint` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-117>Operands:&nbsp;<a class=headline-hash href=#operands-117>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-113>Results:&nbsp;<a class=headline-hash href=#results-113>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrlround-llvmlroundop><code>llvm.intr.lround</code> (LLVM::LroundOp)&nbsp;<a class=headline-hash href=#llvmintrlround-llvmlroundop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.lround` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-118>Operands:&nbsp;<a class=headline-hash href=#operands-118>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-114>Results:&nbsp;<a class=headline-hash href=#results-114>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrmaskedload-llvmmaskedloadop><code>llvm.intr.masked.load</code> (LLVM::MaskedLoadOp)&nbsp;<a class=headline-hash href=#llvmintrmaskedload-llvmmaskedloadop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.masked.load` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-89>Attributes:&nbsp;<a class=headline-hash href=#attributes-89>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>nontemporal</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-119>Operands:&nbsp;<a class=headline-hash href=#operands-119>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>pass_thru</code></td><td>variadic of LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-115>Results:&nbsp;<a class=headline-hash href=#results-115>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrmaskedstore-llvmmaskedstoreop><code>llvm.intr.masked.store</code> (LLVM::MaskedStoreOp)&nbsp;<a class=headline-hash href=#llvmintrmaskedstore-llvmmaskedstoreop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.masked.store` $value `,` $data `,` $mask attr-dict `:` type($value) `,` type($mask) `into` qualified(type($data))
</code></pre><h4 id=attributes-90>Attributes:&nbsp;<a class=headline-hash href=#attributes-90>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-120>Operands:&nbsp;<a class=headline-hash href=#operands-120>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>data</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr></tbody></table><h3 id=llvmintrmatrixcolumnmajorload-llvmmatrixcolumnmajorloadop><code>llvm.intr.matrix.column.major.load</code> (LLVM::MatrixColumnMajorLoadOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixcolumnmajorload-llvmmatrixcolumnmajorloadop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.matrix.column.major.load` $data `,` `&lt;` `stride` `=` $stride `&gt;` attr-dict`:` type($res) `from` qualified(type($data)) `stride` type($stride)
</code></pre><h4 id=attributes-91>Attributes:&nbsp;<a class=headline-hash href=#attributes-91>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>columns</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-121>Operands:&nbsp;<a class=headline-hash href=#operands-121>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>data</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-116>Results:&nbsp;<a class=headline-hash href=#results-116>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrmatrixcolumnmajorstore-llvmmatrixcolumnmajorstoreop><code>llvm.intr.matrix.column.major.store</code> (LLVM::MatrixColumnMajorStoreOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixcolumnmajorstore-llvmmatrixcolumnmajorstoreop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.matrix.column.major.store` $matrix `,` $data `,` `&lt;` `stride` `=` $stride `&gt;` attr-dict`:` type($matrix) `to` qualified(type($data)) `stride` type($stride)
</code></pre><h4 id=attributes-92>Attributes:&nbsp;<a class=headline-hash href=#attributes-92>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>columns</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-122>Operands:&nbsp;<a class=headline-hash href=#operands-122>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>data</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>signless integer</td></tr></tbody></table><h3 id=llvmintrmatrixmultiply-llvmmatrixmultiplyop><code>llvm.intr.matrix.multiply</code> (LLVM::MatrixMultiplyOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixmultiply-llvmmatrixmultiplyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.matrix.multiply` $lhs `,` $rhs attr-dict `:` `(` type($lhs) `,` type($rhs) `)` `-&gt;` type($res)
</code></pre><h4 id=attributes-93>Attributes:&nbsp;<a class=headline-hash href=#attributes-93>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>lhs_rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>lhs_columns</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>rhs_columns</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-123>Operands:&nbsp;<a class=headline-hash href=#operands-123>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-117>Results:&nbsp;<a class=headline-hash href=#results-117>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrmatrixtranspose-llvmmatrixtransposeop><code>llvm.intr.matrix.transpose</code> (LLVM::MatrixTransposeOp)&nbsp;<a class=headline-hash href=#llvmintrmatrixtranspose-llvmmatrixtransposeop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.matrix.transpose` $matrix attr-dict `:` type($matrix) `into` type($res)
</code></pre><h4 id=attributes-94>Attributes:&nbsp;<a class=headline-hash href=#attributes-94>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rows</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>columns</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-124>Operands:&nbsp;<a class=headline-hash href=#operands-124>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>matrix</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-118>Results:&nbsp;<a class=headline-hash href=#results-118>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrmaxnum-llvmmaxnumop><code>llvm.intr.maxnum</code> (LLVM::MaxNumOp)&nbsp;<a class=headline-hash href=#llvmintrmaxnum-llvmmaxnumop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.maxnum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-95>Attributes:&nbsp;<a class=headline-hash href=#attributes-95>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-125>Operands:&nbsp;<a class=headline-hash href=#operands-125>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-119>Results:&nbsp;<a class=headline-hash href=#results-119>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrmaximum-llvmmaximumop><code>llvm.intr.maximum</code> (LLVM::MaximumOp)&nbsp;<a class=headline-hash href=#llvmintrmaximum-llvmmaximumop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.maximum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-96>Attributes:&nbsp;<a class=headline-hash href=#attributes-96>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-126>Operands:&nbsp;<a class=headline-hash href=#operands-126>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-120>Results:&nbsp;<a class=headline-hash href=#results-120>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrmemcpyinline-llvmmemcpyinlineop><code>llvm.intr.memcpy.inline</code> (LLVM::MemcpyInlineOp)&nbsp;<a class=headline-hash href=#llvmintrmemcpyinline-llvmmemcpyinlineop>¶</a></h3><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-97>Attributes:&nbsp;<a class=headline-hash href=#attributes-97>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>len</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-127>Operands:&nbsp;<a class=headline-hash href=#operands-127>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>src</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrmemcpy-llvmmemcpyop><code>llvm.intr.memcpy</code> (LLVM::MemcpyOp)&nbsp;<a class=headline-hash href=#llvmintrmemcpy-llvmmemcpyop>¶</a></h3><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-98>Attributes:&nbsp;<a class=headline-hash href=#attributes-98>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-128>Operands:&nbsp;<a class=headline-hash href=#operands-128>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>src</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>len</code></td><td>signless integer</td></tr></tbody></table><h3 id=llvmintrmemmove-llvmmemmoveop><code>llvm.intr.memmove</code> (LLVM::MemmoveOp)&nbsp;<a class=headline-hash href=#llvmintrmemmove-llvmmemmoveop>¶</a></h3><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-99>Attributes:&nbsp;<a class=headline-hash href=#attributes-99>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-129>Operands:&nbsp;<a class=headline-hash href=#operands-129>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>src</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>len</code></td><td>signless integer</td></tr></tbody></table><h3 id=llvmintrmemsetinline-llvmmemsetinlineop><code>llvm.intr.memset.inline</code> (LLVM::MemsetInlineOp)&nbsp;<a class=headline-hash href=#llvmintrmemsetinline-llvmmemsetinlineop>¶</a></h3><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-100>Attributes:&nbsp;<a class=headline-hash href=#attributes-100>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>len</code></td><td>::mlir::IntegerAttr</td><td>arbitrary integer attribute</td></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-130>Operands:&nbsp;<a class=headline-hash href=#operands-130>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>val</code></td><td>8-bit signless integer</td></tr></tbody></table><h3 id=llvmintrmemset-llvmmemsetop><code>llvm.intr.memset</code> (LLVM::MemsetOp)&nbsp;<a class=headline-hash href=#llvmintrmemset-llvmmemsetop>¶</a></h3><p>Interfaces: <code>AccessGroupOpInterface</code>, <code>AliasAnalysisOpInterface</code>, <code>ArgAndResultAttrsOpInterface</code>, <code>DestructurableAccessorOpInterface</code>, <code>PromotableMemOpInterface</code>, <code>SafeMemorySlotAccessOpInterface</code></p><h4 id=attributes-101>Attributes:&nbsp;<a class=headline-hash href=#attributes-101>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isVolatile</code></td><td>::mlir::IntegerAttr</td><td>1-bit signless integer attribute</td></tr><tr><td><code>access_groups</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect access group metadata array</td></tr><tr><td><code>alias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>noalias_scopes</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect alias scope array</td></tr><tr><td><code>tbaa</code></td><td>::mlir::ArrayAttr</td><td>LLVM dialect TBAA tag metadata array</td></tr><tr><td><code>arg_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr><tr><td><code>res_attrs</code></td><td>::mlir::ArrayAttr</td><td>Array of dictionary attributes</td></tr></table><h4 id=operands-131>Operands:&nbsp;<a class=headline-hash href=#operands-131>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dst</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>val</code></td><td>8-bit signless integer</td></tr><tr><td style=text-align:center><code>len</code></td><td>signless integer</td></tr></tbody></table><h3 id=llvmintrminnum-llvmminnumop><code>llvm.intr.minnum</code> (LLVM::MinNumOp)&nbsp;<a class=headline-hash href=#llvmintrminnum-llvmminnumop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.minnum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-102>Attributes:&nbsp;<a class=headline-hash href=#attributes-102>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-132>Operands:&nbsp;<a class=headline-hash href=#operands-132>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-121>Results:&nbsp;<a class=headline-hash href=#results-121>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrminimum-llvmminimumop><code>llvm.intr.minimum</code> (LLVM::MinimumOp)&nbsp;<a class=headline-hash href=#llvmintrminimum-llvmminimumop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.minimum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-103>Attributes:&nbsp;<a class=headline-hash href=#attributes-103>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-133>Operands:&nbsp;<a class=headline-hash href=#operands-133>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-122>Results:&nbsp;<a class=headline-hash href=#results-122>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrnearbyint-llvmnearbyintop><code>llvm.intr.nearbyint</code> (LLVM::NearbyintOp)&nbsp;<a class=headline-hash href=#llvmintrnearbyint-llvmnearbyintop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.nearbyint` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-104>Attributes:&nbsp;<a class=headline-hash href=#attributes-104>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-134>Operands:&nbsp;<a class=headline-hash href=#operands-134>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-123>Results:&nbsp;<a class=headline-hash href=#results-123>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalnoaliasscopedecl-llvmnoaliasscopedeclop><code>llvm.intr.experimental.noalias.scope.decl</code> (LLVM::NoAliasScopeDeclOp)&nbsp;<a class=headline-hash href=#llvmintrexperimentalnoaliasscopedecl-llvmnoaliasscopedeclop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.experimental.noalias.scope.decl` $scope attr-dict
</code></pre><h4 id=attributes-105>Attributes:&nbsp;<a class=headline-hash href=#attributes-105>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>scope</code></td><td>::mlir::LLVM::AliasScopeAttr</td><td><details><summary>LLVM dialect alias scope</summary><pre><code>Defines an alias scope that can be attached to a memory-accessing operation.
Such scopes can be used in combination with `noalias` metadata to indicate
that sets of memory-affecting operations in one scope do not alias with
memory-affecting operations in another scope.
<p>Example:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>#domain</span> <span class=p>=</span> <span class=nv>#llvm.alias_scope_domain</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=nl>id =</span> distinct<span class=p>[</span><span class=m>1</span><span class=p>]</span><span class=err>&amp;</span>lt<span class=err>;&amp;</span>gt<span class=err>;</span><span class=p>,</span> <span class=nl>description =</span> <span class=err>&amp;</span>quot<span class=err>;</span>Optional domain description<span class=err>&amp;</span>quot<span class=err>;&amp;</span>gt<span class=err>;</span>
</span></span><span class=line><span class=cl><span class=nv>#scope1</span> <span class=p>=</span> <span class=nv>#llvm.alias_scope</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=nl>id =</span> distinct<span class=p>[</span><span class=m>2</span><span class=p>]</span><span class=err>&amp;</span>lt<span class=err>;&amp;</span>gt<span class=err>;</span><span class=p>,</span> <span class=nl>domain =</span> <span class=nv>#domain</span><span class=err>&amp;</span>gt<span class=err>;</span>
</span></span><span class=line><span class=cl><span class=nv>#scope2</span> <span class=p>=</span> <span class=nv>#llvm.alias_scope</span><span class=err>&amp;</span>lt<span class=err>;</span><span class=nl>id =</span> distinct<span class=p>[</span><span class=m>3</span><span class=p>]</span><span class=err>&amp;</span>lt<span class=err>;&amp;</span>gt<span class=err>;</span><span class=p>,</span> <span class=nl>domain =</span> <span class=nv>#domain</span><span class=p>,</span> <span class=nl>description =</span> <span class=err>&amp;</span>quot<span class=err>;</span>Optional scope description<span class=err>&amp;</span>quot<span class=err>;&amp;</span>gt<span class=err>;</span>
</span></span><span class=line><span class=cl>llvm<span class=p>.</span><span class=kt>func</span> <span class=nf>@foo</span><span class=p>(</span><span class=nv>%ptr1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c0</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c4</span> <span class=p>=</span> llvm<span class=p>.</span>mlir<span class=p>.</span><span class=kt>constant</span><span class=p>(</span><span class=m>4</span> <span class=p>:</span> <span class=k>i32</span><span class=p>)</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> llvm<span class=p>.</span>ptrtoint <span class=nv>%ptr1</span> <span class=p>:</span> <span class=p>!</span>llvm<span class=p>.</span>ptr to <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> llvm<span class=p>.</span>add <span class=nv>%1</span><span class=p>,</span> <span class=nv>%c1</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>    <span class=nv>%ptr2</span> <span class=p>=</span> llvm<span class=p>.</span>inttoptr <span class=nv>%2</span> <span class=p>:</span> <span class=k>i32</span> to <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>    llvm<span class=p>.</span>store <span class=nv>%c0</span><span class=p>,</span> <span class=nv>%ptr1</span> <span class=p>{</span> <span class=nl>alias_scopes =</span> <span class=p>[</span><span class=nv>#scope1</span><span class=p>],</span> <span class=nl>llvm.noalias =</span> <span class=p>[</span><span class=nv>#scope2</span><span class=p>]</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>    llvm<span class=p>.</span>store <span class=nv>%c4</span><span class=p>,</span> <span class=nv>%ptr2</span> <span class=p>{</span> <span class=nl>alias_scopes =</span> <span class=p>[</span><span class=nv>#scope2</span><span class=p>],</span> <span class=nl>llvm.noalias =</span> <span class=p>[</span><span class=nv>#scope1</span><span class=p>]</span> <span class=p>}</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=p>!</span>llvm<span class=p>.</span>ptr
</span></span><span class=line><span class=cl>    llvm<span class=p>.</span><span class=kt>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The first attribute can either be a DistinctAttr or a StringAttr.</p><p>See the following link for more details:
<a href=https://llvm.org/docs/LangRef.html#noalias-and-alias-scope-metadata>https://llvm.org/docs/LangRef.html#noalias-and-alias-scope-metadata</a></code></pre></p></details></td></tr></table><h3 id=llvmintrpowi-llvmpowiop><code>llvm.intr.powi</code> (LLVM::PowIOp)&nbsp;<a class=headline-hash href=#llvmintrpowi-llvmpowiop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.powi` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-106>Attributes:&nbsp;<a class=headline-hash href=#attributes-106>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-135>Operands:&nbsp;<a class=headline-hash href=#operands-135>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>power</code></td><td>signless integer</td></tr></tbody></table><h4 id=results-124>Results:&nbsp;<a class=headline-hash href=#results-124>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrpow-llvmpowop><code>llvm.intr.pow</code> (LLVM::PowOp)&nbsp;<a class=headline-hash href=#llvmintrpow-llvmpowop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.pow` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-107>Attributes:&nbsp;<a class=headline-hash href=#attributes-107>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-136>Operands:&nbsp;<a class=headline-hash href=#operands-136>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr><tr><td style=text-align:center><code>b</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-125>Results:&nbsp;<a class=headline-hash href=#results-125>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrprefetch-llvmprefetch><code>llvm.intr.prefetch</code> (LLVM::Prefetch)&nbsp;<a class=headline-hash href=#llvmintrprefetch-llvmprefetch>¶</a></h3><h4 id=attributes-108>Attributes:&nbsp;<a class=headline-hash href=#attributes-108>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>rw</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>hint</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr><tr><td><code>cache</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-137>Operands:&nbsp;<a class=headline-hash href=#operands-137>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>addr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrptrannotation-llvmptrannotation><code>llvm.intr.ptr.annotation</code> (LLVM::PtrAnnotation)&nbsp;<a class=headline-hash href=#llvmintrptrannotation-llvmptrannotation>¶</a></h3><p>Interfaces: <code>InferTypeOpInterface</code></p><h4 id=operands-138>Operands:&nbsp;<a class=headline-hash href=#operands-138>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>annotation</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>fileName</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>line</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>attr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-126>Results:&nbsp;<a class=headline-hash href=#results-126>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrptrmask-llvmptrmaskop><code>llvm.intr.ptrmask</code> (LLVM::PtrMaskOp)&nbsp;<a class=headline-hash href=#llvmintrptrmask-llvmptrmaskop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ptrmask` $ptr `,` $mask attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-139>Operands:&nbsp;<a class=headline-hash href=#operands-139>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>integer or LLVM dialect-compatible vector of integer</td></tr></tbody></table><h4 id=results-127>Results:&nbsp;<a class=headline-hash href=#results-127>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type or LLVM dialect-compatible vector of LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrrint-llvmrintop><code>llvm.intr.rint</code> (LLVM::RintOp)&nbsp;<a class=headline-hash href=#llvmintrrint-llvmrintop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.rint` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-109>Attributes:&nbsp;<a class=headline-hash href=#attributes-109>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-140>Operands:&nbsp;<a class=headline-hash href=#operands-140>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-128>Results:&nbsp;<a class=headline-hash href=#results-128>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrroundeven-llvmroundevenop><code>llvm.intr.roundeven</code> (LLVM::RoundEvenOp)&nbsp;<a class=headline-hash href=#llvmintrroundeven-llvmroundevenop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.roundeven` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-110>Attributes:&nbsp;<a class=headline-hash href=#attributes-110>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-141>Operands:&nbsp;<a class=headline-hash href=#operands-141>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-129>Results:&nbsp;<a class=headline-hash href=#results-129>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrround-llvmroundop><code>llvm.intr.round</code> (LLVM::RoundOp)&nbsp;<a class=headline-hash href=#llvmintrround-llvmroundop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.round` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-111>Attributes:&nbsp;<a class=headline-hash href=#attributes-111>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-142>Operands:&nbsp;<a class=headline-hash href=#operands-142>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-130>Results:&nbsp;<a class=headline-hash href=#results-130>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsaddsat-llvmsaddsat><code>llvm.intr.sadd.sat</code> (LLVM::SAddSat)&nbsp;<a class=headline-hash href=#llvmintrsaddsat-llvmsaddsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.sadd.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-143>Operands:&nbsp;<a class=headline-hash href=#operands-143>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-131>Results:&nbsp;<a class=headline-hash href=#results-131>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsaddwithoverflow-llvmsaddwithoverflowop><code>llvm.intr.sadd.with.overflow</code> (LLVM::SAddWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrsaddwithoverflow-llvmsaddwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-144>Operands:&nbsp;<a class=headline-hash href=#operands-144>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-132>Results:&nbsp;<a class=headline-hash href=#results-132>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsmax-llvmsmaxop><code>llvm.intr.smax</code> (LLVM::SMaxOp)&nbsp;<a class=headline-hash href=#llvmintrsmax-llvmsmaxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.smax` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-145>Operands:&nbsp;<a class=headline-hash href=#operands-145>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-133>Results:&nbsp;<a class=headline-hash href=#results-133>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsmin-llvmsminop><code>llvm.intr.smin</code> (LLVM::SMinOp)&nbsp;<a class=headline-hash href=#llvmintrsmin-llvmsminop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.smin` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-146>Operands:&nbsp;<a class=headline-hash href=#operands-146>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-134>Results:&nbsp;<a class=headline-hash href=#results-134>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsmulwithoverflow-llvmsmulwithoverflowop><code>llvm.intr.smul.with.overflow</code> (LLVM::SMulWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrsmulwithoverflow-llvmsmulwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-147>Operands:&nbsp;<a class=headline-hash href=#operands-147>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-135>Results:&nbsp;<a class=headline-hash href=#results-135>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrssacopy-llvmssacopyop><code>llvm.intr.ssa.copy</code> (LLVM::SSACopyOp)&nbsp;<a class=headline-hash href=#llvmintrssacopy-llvmssacopyop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ssa.copy` $operand attr-dict `:` type($operand)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-148>Operands:&nbsp;<a class=headline-hash href=#operands-148>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>any type</td></tr></tbody></table><h4 id=results-136>Results:&nbsp;<a class=headline-hash href=#results-136>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsshlsat-llvmsshlsat><code>llvm.intr.sshl.sat</code> (LLVM::SSHLSat)&nbsp;<a class=headline-hash href=#llvmintrsshlsat-llvmsshlsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.sshl.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-149>Operands:&nbsp;<a class=headline-hash href=#operands-149>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-137>Results:&nbsp;<a class=headline-hash href=#results-137>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrssubsat-llvmssubsat><code>llvm.intr.ssub.sat</code> (LLVM::SSubSat)&nbsp;<a class=headline-hash href=#llvmintrssubsat-llvmssubsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ssub.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-150>Operands:&nbsp;<a class=headline-hash href=#operands-150>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-138>Results:&nbsp;<a class=headline-hash href=#results-138>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrssubwithoverflow-llvmssubwithoverflowop><code>llvm.intr.ssub.with.overflow</code> (LLVM::SSubWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrssubwithoverflow-llvmssubwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-151>Operands:&nbsp;<a class=headline-hash href=#operands-151>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-139>Results:&nbsp;<a class=headline-hash href=#results-139>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsin-llvmsinop><code>llvm.intr.sin</code> (LLVM::SinOp)&nbsp;<a class=headline-hash href=#llvmintrsin-llvmsinop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.sin` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-112>Attributes:&nbsp;<a class=headline-hash href=#attributes-112>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-152>Operands:&nbsp;<a class=headline-hash href=#operands-152>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-140>Results:&nbsp;<a class=headline-hash href=#results-140>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsinh-llvmsinhop><code>llvm.intr.sinh</code> (LLVM::SinhOp)&nbsp;<a class=headline-hash href=#llvmintrsinh-llvmsinhop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.sinh` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-113>Attributes:&nbsp;<a class=headline-hash href=#attributes-113>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-153>Operands:&nbsp;<a class=headline-hash href=#operands-153>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-141>Results:&nbsp;<a class=headline-hash href=#results-141>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrsqrt-llvmsqrtop><code>llvm.intr.sqrt</code> (LLVM::SqrtOp)&nbsp;<a class=headline-hash href=#llvmintrsqrt-llvmsqrtop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.sqrt` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-114>Attributes:&nbsp;<a class=headline-hash href=#attributes-114>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-154>Operands:&nbsp;<a class=headline-hash href=#operands-154>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-142>Results:&nbsp;<a class=headline-hash href=#results-142>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrstackrestore-llvmstackrestoreop><code>llvm.intr.stackrestore</code> (LLVM::StackRestoreOp)&nbsp;<a class=headline-hash href=#llvmintrstackrestore-llvmstackrestoreop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.stackrestore` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><h4 id=operands-155>Operands:&nbsp;<a class=headline-hash href=#operands-155>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrstacksave-llvmstacksaveop><code>llvm.intr.stacksave</code> (LLVM::StackSaveOp)&nbsp;<a class=headline-hash href=#llvmintrstacksave-llvmstacksaveop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.stacksave` attr-dict `:` qualified(type($res))
</code></pre><h4 id=results-143>Results:&nbsp;<a class=headline-hash href=#results-143>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrstepvector-llvmstepvectorop><code>llvm.intr.stepvector</code> (LLVM::StepVectorOp)&nbsp;<a class=headline-hash href=#llvmintrstepvector-llvmstepvectorop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.stepvector` attr-dict `:` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-144>Results:&nbsp;<a class=headline-hash href=#results-144>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h3 id=llvmintrstripinvariantgroup-llvmstripinvariantgroupop><code>llvm.intr.strip.invariant.group</code> (LLVM::StripInvariantGroupOp)&nbsp;<a class=headline-hash href=#llvmintrstripinvariantgroup-llvmstripinvariantgroupop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.strip.invariant.group` $ptr attr-dict `:` qualified(type($ptr))
</code></pre><p>Traits: <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>InferTypeOpInterface</code>, <code>PromotableOpInterface</code></p><h4 id=operands-156>Operands:&nbsp;<a class=headline-hash href=#operands-156>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-145>Results:&nbsp;<a class=headline-hash href=#results-145>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrtan-llvmtanop><code>llvm.intr.tan</code> (LLVM::TanOp)&nbsp;<a class=headline-hash href=#llvmintrtan-llvmtanop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.tan` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-115>Attributes:&nbsp;<a class=headline-hash href=#attributes-115>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-157>Operands:&nbsp;<a class=headline-hash href=#operands-157>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-146>Results:&nbsp;<a class=headline-hash href=#results-146>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrtanh-llvmtanhop><code>llvm.intr.tanh</code> (LLVM::TanhOp)&nbsp;<a class=headline-hash href=#llvmintrtanh-llvmtanhop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.tanh` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-116>Attributes:&nbsp;<a class=headline-hash href=#attributes-116>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-158>Operands:&nbsp;<a class=headline-hash href=#operands-158>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating point LLVM type or LLVM dialect-compatible vector of floating point LLVM type</td></tr></tbody></table><h4 id=results-147>Results:&nbsp;<a class=headline-hash href=#results-147>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrthreadlocaladdress-llvmthreadlocaladdressop><code>llvm.intr.threadlocal.address</code> (LLVM::ThreadlocalAddressOp)&nbsp;<a class=headline-hash href=#llvmintrthreadlocaladdress-llvmthreadlocaladdressop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-159>Operands:&nbsp;<a class=headline-hash href=#operands-159>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>global</code></td><td>LLVM pointer type</td></tr></tbody></table><h4 id=results-148>Results:&nbsp;<a class=headline-hash href=#results-148>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrtrap-llvmtrap><code>llvm.intr.trap</code> (LLVM::Trap)&nbsp;<a class=headline-hash href=#llvmintrtrap-llvmtrap>¶</a></h3><h3 id=llvmintruaddsat-llvmuaddsat><code>llvm.intr.uadd.sat</code> (LLVM::UAddSat)&nbsp;<a class=headline-hash href=#llvmintruaddsat-llvmuaddsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.uadd.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-160>Operands:&nbsp;<a class=headline-hash href=#operands-160>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-149>Results:&nbsp;<a class=headline-hash href=#results-149>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintruaddwithoverflow-llvmuaddwithoverflowop><code>llvm.intr.uadd.with.overflow</code> (LLVM::UAddWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintruaddwithoverflow-llvmuaddwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-161>Operands:&nbsp;<a class=headline-hash href=#operands-161>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-150>Results:&nbsp;<a class=headline-hash href=#results-150>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrubsantrap-llvmubsantrap><code>llvm.intr.ubsantrap</code> (LLVM::UBSanTrap)&nbsp;<a class=headline-hash href=#llvmintrubsantrap-llvmubsantrap>¶</a></h3><h4 id=attributes-117>Attributes:&nbsp;<a class=headline-hash href=#attributes-117>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>failureKind</code></td><td>::mlir::IntegerAttr</td><td>8-bit signless integer attribute</td></tr></table><h3 id=llvmintrumax-llvmumaxop><code>llvm.intr.umax</code> (LLVM::UMaxOp)&nbsp;<a class=headline-hash href=#llvmintrumax-llvmumaxop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.umax` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-162>Operands:&nbsp;<a class=headline-hash href=#operands-162>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-151>Results:&nbsp;<a class=headline-hash href=#results-151>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrumin-llvmuminop><code>llvm.intr.umin</code> (LLVM::UMinOp)&nbsp;<a class=headline-hash href=#llvmintrumin-llvmuminop>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.umin` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-163>Operands:&nbsp;<a class=headline-hash href=#operands-163>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-152>Results:&nbsp;<a class=headline-hash href=#results-152>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrumulwithoverflow-llvmumulwithoverflowop><code>llvm.intr.umul.with.overflow</code> (LLVM::UMulWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrumulwithoverflow-llvmumulwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-164>Operands:&nbsp;<a class=headline-hash href=#operands-164>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-153>Results:&nbsp;<a class=headline-hash href=#results-153>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrushlsat-llvmushlsat><code>llvm.intr.ushl.sat</code> (LLVM::USHLSat)&nbsp;<a class=headline-hash href=#llvmintrushlsat-llvmushlsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.ushl.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-165>Operands:&nbsp;<a class=headline-hash href=#operands-165>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-154>Results:&nbsp;<a class=headline-hash href=#results-154>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrusubsat-llvmusubsat><code>llvm.intr.usub.sat</code> (LLVM::USubSat)&nbsp;<a class=headline-hash href=#llvmintrusubsat-llvmusubsat>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.usub.sat` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-166>Operands:&nbsp;<a class=headline-hash href=#operands-166>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>a</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>b</code></td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-155>Results:&nbsp;<a class=headline-hash href=#results-155>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrusubwithoverflow-llvmusubwithoverflowop><code>llvm.intr.usub.with.overflow</code> (LLVM::USubWithOverflowOp)&nbsp;<a class=headline-hash href=#llvmintrusubwithoverflow-llvmusubwithoverflowop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-167>Operands:&nbsp;<a class=headline-hash href=#operands-167>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>signless integer or LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-156>Results:&nbsp;<a class=headline-hash href=#results-156>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpashr-llvmvpashrop><code>llvm.intr.vp.ashr</code> (LLVM::VPAShrOp)&nbsp;<a class=headline-hash href=#llvmintrvpashr-llvmvpashrop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-168>Operands:&nbsp;<a class=headline-hash href=#operands-168>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-157>Results:&nbsp;<a class=headline-hash href=#results-157>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpadd-llvmvpaddop><code>llvm.intr.vp.add</code> (LLVM::VPAddOp)&nbsp;<a class=headline-hash href=#llvmintrvpadd-llvmvpaddop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-169>Operands:&nbsp;<a class=headline-hash href=#operands-169>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-158>Results:&nbsp;<a class=headline-hash href=#results-158>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpand-llvmvpandop><code>llvm.intr.vp.and</code> (LLVM::VPAndOp)&nbsp;<a class=headline-hash href=#llvmintrvpand-llvmvpandop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-170>Operands:&nbsp;<a class=headline-hash href=#operands-170>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-159>Results:&nbsp;<a class=headline-hash href=#results-159>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfadd-llvmvpfaddop><code>llvm.intr.vp.fadd</code> (LLVM::VPFAddOp)&nbsp;<a class=headline-hash href=#llvmintrvpfadd-llvmvpfaddop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-171>Operands:&nbsp;<a class=headline-hash href=#operands-171>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-160>Results:&nbsp;<a class=headline-hash href=#results-160>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfdiv-llvmvpfdivop><code>llvm.intr.vp.fdiv</code> (LLVM::VPFDivOp)&nbsp;<a class=headline-hash href=#llvmintrvpfdiv-llvmvpfdivop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-172>Operands:&nbsp;<a class=headline-hash href=#operands-172>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-161>Results:&nbsp;<a class=headline-hash href=#results-161>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfmuladd-llvmvpfmuladdop><code>llvm.intr.vp.fmuladd</code> (LLVM::VPFMulAddOp)&nbsp;<a class=headline-hash href=#llvmintrvpfmuladd-llvmvpfmuladdop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-173>Operands:&nbsp;<a class=headline-hash href=#operands-173>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>op1</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>op2</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>op3</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-162>Results:&nbsp;<a class=headline-hash href=#results-162>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfmul-llvmvpfmulop><code>llvm.intr.vp.fmul</code> (LLVM::VPFMulOp)&nbsp;<a class=headline-hash href=#llvmintrvpfmul-llvmvpfmulop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-174>Operands:&nbsp;<a class=headline-hash href=#operands-174>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-163>Results:&nbsp;<a class=headline-hash href=#results-163>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfneg-llvmvpfnegop><code>llvm.intr.vp.fneg</code> (LLVM::VPFNegOp)&nbsp;<a class=headline-hash href=#llvmintrvpfneg-llvmvpfnegop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-175>Operands:&nbsp;<a class=headline-hash href=#operands-175>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>op</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-164>Results:&nbsp;<a class=headline-hash href=#results-164>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfpext-llvmvpfpextop><code>llvm.intr.vp.fpext</code> (LLVM::VPFPExtOp)&nbsp;<a class=headline-hash href=#llvmintrvpfpext-llvmvpfpextop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-176>Operands:&nbsp;<a class=headline-hash href=#operands-176>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-165>Results:&nbsp;<a class=headline-hash href=#results-165>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfptosi-llvmvpfptosiop><code>llvm.intr.vp.fptosi</code> (LLVM::VPFPToSIOp)&nbsp;<a class=headline-hash href=#llvmintrvpfptosi-llvmvpfptosiop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-177>Operands:&nbsp;<a class=headline-hash href=#operands-177>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-166>Results:&nbsp;<a class=headline-hash href=#results-166>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfptoui-llvmvpfptouiop><code>llvm.intr.vp.fptoui</code> (LLVM::VPFPToUIOp)&nbsp;<a class=headline-hash href=#llvmintrvpfptoui-llvmvpfptouiop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-178>Operands:&nbsp;<a class=headline-hash href=#operands-178>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-167>Results:&nbsp;<a class=headline-hash href=#results-167>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfptrunc-llvmvpfptruncop><code>llvm.intr.vp.fptrunc</code> (LLVM::VPFPTruncOp)&nbsp;<a class=headline-hash href=#llvmintrvpfptrunc-llvmvpfptruncop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-179>Operands:&nbsp;<a class=headline-hash href=#operands-179>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-168>Results:&nbsp;<a class=headline-hash href=#results-168>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfrem-llvmvpfremop><code>llvm.intr.vp.frem</code> (LLVM::VPFRemOp)&nbsp;<a class=headline-hash href=#llvmintrvpfrem-llvmvpfremop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-180>Operands:&nbsp;<a class=headline-hash href=#operands-180>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-169>Results:&nbsp;<a class=headline-hash href=#results-169>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfsub-llvmvpfsubop><code>llvm.intr.vp.fsub</code> (LLVM::VPFSubOp)&nbsp;<a class=headline-hash href=#llvmintrvpfsub-llvmvpfsubop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-181>Operands:&nbsp;<a class=headline-hash href=#operands-181>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-170>Results:&nbsp;<a class=headline-hash href=#results-170>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpfma-llvmvpfmaop><code>llvm.intr.vp.fma</code> (LLVM::VPFmaOp)&nbsp;<a class=headline-hash href=#llvmintrvpfma-llvmvpfmaop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-182>Operands:&nbsp;<a class=headline-hash href=#operands-182>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>op1</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>op2</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>op3</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-171>Results:&nbsp;<a class=headline-hash href=#results-171>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpinttoptr-llvmvpinttoptrop><code>llvm.intr.vp.inttoptr</code> (LLVM::VPIntToPtrOp)&nbsp;<a class=headline-hash href=#llvmintrvpinttoptr-llvmvpinttoptrop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-183>Operands:&nbsp;<a class=headline-hash href=#operands-183>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-172>Results:&nbsp;<a class=headline-hash href=#results-172>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvplshr-llvmvplshrop><code>llvm.intr.vp.lshr</code> (LLVM::VPLShrOp)&nbsp;<a class=headline-hash href=#llvmintrvplshr-llvmvplshrop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-184>Operands:&nbsp;<a class=headline-hash href=#operands-184>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-173>Results:&nbsp;<a class=headline-hash href=#results-173>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpload-llvmvploadop><code>llvm.intr.vp.load</code> (LLVM::VPLoadOp)&nbsp;<a class=headline-hash href=#llvmintrvpload-llvmvploadop>¶</a></h3><h4 id=operands-185>Operands:&nbsp;<a class=headline-hash href=#operands-185>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-174>Results:&nbsp;<a class=headline-hash href=#results-174>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpmerge-llvmvpmergeminop><code>llvm.intr.vp.merge</code> (LLVM::VPMergeMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpmerge-llvmvpmergeminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-186>Operands:&nbsp;<a class=headline-hash href=#operands-186>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>true_val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>false_val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-175>Results:&nbsp;<a class=headline-hash href=#results-175>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpmul-llvmvpmulop><code>llvm.intr.vp.mul</code> (LLVM::VPMulOp)&nbsp;<a class=headline-hash href=#llvmintrvpmul-llvmvpmulop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-187>Operands:&nbsp;<a class=headline-hash href=#operands-187>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-176>Results:&nbsp;<a class=headline-hash href=#results-176>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpor-llvmvporop><code>llvm.intr.vp.or</code> (LLVM::VPOrOp)&nbsp;<a class=headline-hash href=#llvmintrvpor-llvmvporop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-188>Operands:&nbsp;<a class=headline-hash href=#operands-188>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-177>Results:&nbsp;<a class=headline-hash href=#results-177>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpptrtoint-llvmvpptrtointop><code>llvm.intr.vp.ptrtoint</code> (LLVM::VPPtrToIntOp)&nbsp;<a class=headline-hash href=#llvmintrvpptrtoint-llvmvpptrtointop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-189>Operands:&nbsp;<a class=headline-hash href=#operands-189>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-178>Results:&nbsp;<a class=headline-hash href=#results-178>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreduceadd-llvmvpreduceaddop><code>llvm.intr.vp.reduce.add</code> (LLVM::VPReduceAddOp)&nbsp;<a class=headline-hash href=#llvmintrvpreduceadd-llvmvpreduceaddop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-190>Operands:&nbsp;<a class=headline-hash href=#operands-190>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-179>Results:&nbsp;<a class=headline-hash href=#results-179>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreduceand-llvmvpreduceandop><code>llvm.intr.vp.reduce.and</code> (LLVM::VPReduceAndOp)&nbsp;<a class=headline-hash href=#llvmintrvpreduceand-llvmvpreduceandop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-191>Operands:&nbsp;<a class=headline-hash href=#operands-191>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-180>Results:&nbsp;<a class=headline-hash href=#results-180>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducefadd-llvmvpreducefaddop><code>llvm.intr.vp.reduce.fadd</code> (LLVM::VPReduceFAddOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducefadd-llvmvpreducefaddop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-192>Operands:&nbsp;<a class=headline-hash href=#operands-192>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-181>Results:&nbsp;<a class=headline-hash href=#results-181>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducefmax-llvmvpreducefmaxop><code>llvm.intr.vp.reduce.fmax</code> (LLVM::VPReduceFMaxOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducefmax-llvmvpreducefmaxop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-193>Operands:&nbsp;<a class=headline-hash href=#operands-193>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-182>Results:&nbsp;<a class=headline-hash href=#results-182>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducefmin-llvmvpreducefminop><code>llvm.intr.vp.reduce.fmin</code> (LLVM::VPReduceFMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducefmin-llvmvpreducefminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-194>Operands:&nbsp;<a class=headline-hash href=#operands-194>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-183>Results:&nbsp;<a class=headline-hash href=#results-183>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducefmul-llvmvpreducefmulop><code>llvm.intr.vp.reduce.fmul</code> (LLVM::VPReduceFMulOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducefmul-llvmvpreducefmulop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-195>Operands:&nbsp;<a class=headline-hash href=#operands-195>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-184>Results:&nbsp;<a class=headline-hash href=#results-184>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducemul-llvmvpreducemulop><code>llvm.intr.vp.reduce.mul</code> (LLVM::VPReduceMulOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducemul-llvmvpreducemulop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-196>Operands:&nbsp;<a class=headline-hash href=#operands-196>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-185>Results:&nbsp;<a class=headline-hash href=#results-185>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreduceor-llvmvpreduceorop><code>llvm.intr.vp.reduce.or</code> (LLVM::VPReduceOrOp)&nbsp;<a class=headline-hash href=#llvmintrvpreduceor-llvmvpreduceorop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-197>Operands:&nbsp;<a class=headline-hash href=#operands-197>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-186>Results:&nbsp;<a class=headline-hash href=#results-186>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducesmax-llvmvpreducesmaxop><code>llvm.intr.vp.reduce.smax</code> (LLVM::VPReduceSMaxOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducesmax-llvmvpreducesmaxop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-198>Operands:&nbsp;<a class=headline-hash href=#operands-198>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-187>Results:&nbsp;<a class=headline-hash href=#results-187>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducesmin-llvmvpreducesminop><code>llvm.intr.vp.reduce.smin</code> (LLVM::VPReduceSMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducesmin-llvmvpreducesminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-199>Operands:&nbsp;<a class=headline-hash href=#operands-199>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-188>Results:&nbsp;<a class=headline-hash href=#results-188>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreduceumax-llvmvpreduceumaxop><code>llvm.intr.vp.reduce.umax</code> (LLVM::VPReduceUMaxOp)&nbsp;<a class=headline-hash href=#llvmintrvpreduceumax-llvmvpreduceumaxop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-200>Operands:&nbsp;<a class=headline-hash href=#operands-200>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-189>Results:&nbsp;<a class=headline-hash href=#results-189>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreduceumin-llvmvpreduceuminop><code>llvm.intr.vp.reduce.umin</code> (LLVM::VPReduceUMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpreduceumin-llvmvpreduceuminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-201>Operands:&nbsp;<a class=headline-hash href=#operands-201>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-190>Results:&nbsp;<a class=headline-hash href=#results-190>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpreducexor-llvmvpreducexorop><code>llvm.intr.vp.reduce.xor</code> (LLVM::VPReduceXorOp)&nbsp;<a class=headline-hash href=#llvmintrvpreducexor-llvmvpreducexorop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-202>Operands:&nbsp;<a class=headline-hash href=#operands-202>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>satrt_value</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-191>Results:&nbsp;<a class=headline-hash href=#results-191>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsdiv-llvmvpsdivop><code>llvm.intr.vp.sdiv</code> (LLVM::VPSDivOp)&nbsp;<a class=headline-hash href=#llvmintrvpsdiv-llvmvpsdivop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-203>Operands:&nbsp;<a class=headline-hash href=#operands-203>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-192>Results:&nbsp;<a class=headline-hash href=#results-192>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsext-llvmvpsextop><code>llvm.intr.vp.sext</code> (LLVM::VPSExtOp)&nbsp;<a class=headline-hash href=#llvmintrvpsext-llvmvpsextop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-204>Operands:&nbsp;<a class=headline-hash href=#operands-204>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-193>Results:&nbsp;<a class=headline-hash href=#results-193>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsitofp-llvmvpsitofpop><code>llvm.intr.vp.sitofp</code> (LLVM::VPSIToFPOp)&nbsp;<a class=headline-hash href=#llvmintrvpsitofp-llvmvpsitofpop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-205>Operands:&nbsp;<a class=headline-hash href=#operands-205>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-194>Results:&nbsp;<a class=headline-hash href=#results-194>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsmax-llvmvpsmaxop><code>llvm.intr.vp.smax</code> (LLVM::VPSMaxOp)&nbsp;<a class=headline-hash href=#llvmintrvpsmax-llvmvpsmaxop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-206>Operands:&nbsp;<a class=headline-hash href=#operands-206>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-195>Results:&nbsp;<a class=headline-hash href=#results-195>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsmin-llvmvpsminop><code>llvm.intr.vp.smin</code> (LLVM::VPSMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpsmin-llvmvpsminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-207>Operands:&nbsp;<a class=headline-hash href=#operands-207>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-196>Results:&nbsp;<a class=headline-hash href=#results-196>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpsrem-llvmvpsremop><code>llvm.intr.vp.srem</code> (LLVM::VPSRemOp)&nbsp;<a class=headline-hash href=#llvmintrvpsrem-llvmvpsremop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-208>Operands:&nbsp;<a class=headline-hash href=#operands-208>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-197>Results:&nbsp;<a class=headline-hash href=#results-197>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpselect-llvmvpselectminop><code>llvm.intr.vp.select</code> (LLVM::VPSelectMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpselect-llvmvpselectminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-209>Operands:&nbsp;<a class=headline-hash href=#operands-209>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>cond</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>true_val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>false_val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-198>Results:&nbsp;<a class=headline-hash href=#results-198>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpshl-llvmvpshlop><code>llvm.intr.vp.shl</code> (LLVM::VPShlOp)&nbsp;<a class=headline-hash href=#llvmintrvpshl-llvmvpshlop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-210>Operands:&nbsp;<a class=headline-hash href=#operands-210>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-199>Results:&nbsp;<a class=headline-hash href=#results-199>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpstore-llvmvpstoreop><code>llvm.intr.vp.store</code> (LLVM::VPStoreOp)&nbsp;<a class=headline-hash href=#llvmintrvpstore-llvmvpstoreop>¶</a></h3><h4 id=operands-211>Operands:&nbsp;<a class=headline-hash href=#operands-211>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=llvmintrexperimentalvpstridedload-llvmvpstridedloadop><code>llvm.intr.experimental.vp.strided.load</code> (LLVM::VPStridedLoadOp)&nbsp;<a class=headline-hash href=#llvmintrexperimentalvpstridedload-llvmvpstridedloadop>¶</a></h3><h4 id=operands-212>Operands:&nbsp;<a class=headline-hash href=#operands-212>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-200>Results:&nbsp;<a class=headline-hash href=#results-200>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrexperimentalvpstridedstore-llvmvpstridedstoreop><code>llvm.intr.experimental.vp.strided.store</code> (LLVM::VPStridedStoreOp)&nbsp;<a class=headline-hash href=#llvmintrexperimentalvpstridedstore-llvmvpstridedstoreop>¶</a></h3><h4 id=operands-213>Operands:&nbsp;<a class=headline-hash href=#operands-213>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>ptr</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>stride</code></td><td>signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=llvmintrvpsub-llvmvpsubop><code>llvm.intr.vp.sub</code> (LLVM::VPSubOp)&nbsp;<a class=headline-hash href=#llvmintrvpsub-llvmvpsubop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-214>Operands:&nbsp;<a class=headline-hash href=#operands-214>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-201>Results:&nbsp;<a class=headline-hash href=#results-201>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvptrunc-llvmvptruncop><code>llvm.intr.vp.trunc</code> (LLVM::VPTruncOp)&nbsp;<a class=headline-hash href=#llvmintrvptrunc-llvmvptruncop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-215>Operands:&nbsp;<a class=headline-hash href=#operands-215>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-202>Results:&nbsp;<a class=headline-hash href=#results-202>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpudiv-llvmvpudivop><code>llvm.intr.vp.udiv</code> (LLVM::VPUDivOp)&nbsp;<a class=headline-hash href=#llvmintrvpudiv-llvmvpudivop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-216>Operands:&nbsp;<a class=headline-hash href=#operands-216>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-203>Results:&nbsp;<a class=headline-hash href=#results-203>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpuitofp-llvmvpuitofpop><code>llvm.intr.vp.uitofp</code> (LLVM::VPUIToFPOp)&nbsp;<a class=headline-hash href=#llvmintrvpuitofp-llvmvpuitofpop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-217>Operands:&nbsp;<a class=headline-hash href=#operands-217>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-204>Results:&nbsp;<a class=headline-hash href=#results-204>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpumax-llvmvpumaxop><code>llvm.intr.vp.umax</code> (LLVM::VPUMaxOp)&nbsp;<a class=headline-hash href=#llvmintrvpumax-llvmvpumaxop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-218>Operands:&nbsp;<a class=headline-hash href=#operands-218>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-205>Results:&nbsp;<a class=headline-hash href=#results-205>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpumin-llvmvpuminop><code>llvm.intr.vp.umin</code> (LLVM::VPUMinOp)&nbsp;<a class=headline-hash href=#llvmintrvpumin-llvmvpuminop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-219>Operands:&nbsp;<a class=headline-hash href=#operands-219>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-206>Results:&nbsp;<a class=headline-hash href=#results-206>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpurem-llvmvpuremop><code>llvm.intr.vp.urem</code> (LLVM::VPURemOp)&nbsp;<a class=headline-hash href=#llvmintrvpurem-llvmvpuremop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-220>Operands:&nbsp;<a class=headline-hash href=#operands-220>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-207>Results:&nbsp;<a class=headline-hash href=#results-207>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpxor-llvmvpxorop><code>llvm.intr.vp.xor</code> (LLVM::VPXorOp)&nbsp;<a class=headline-hash href=#llvmintrvpxor-llvmvpxorop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-221>Operands:&nbsp;<a class=headline-hash href=#operands-221>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-208>Results:&nbsp;<a class=headline-hash href=#results-208>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvpzext-llvmvpzextop><code>llvm.intr.vp.zext</code> (LLVM::VPZExtOp)&nbsp;<a class=headline-hash href=#llvmintrvpzext-llvmvpzextop>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-222>Operands:&nbsp;<a class=headline-hash href=#operands-222>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>src</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>evl</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-209>Results:&nbsp;<a class=headline-hash href=#results-209>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvacopy-llvmvacopyop><code>llvm.intr.vacopy</code> (LLVM::VaCopyOp)&nbsp;<a class=headline-hash href=#llvmintrvacopy-llvmvacopyop>¶</a></h3><p><em>Copies the current argument position from <code>src_list</code> to <code>dest_list</code>.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vacopy` $src_list `to` $dest_list attr-dict `:` type(operands)
</code></pre><h4 id=operands-223>Operands:&nbsp;<a class=headline-hash href=#operands-223>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dest_list</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>src_list</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrvaend-llvmvaendop><code>llvm.intr.vaend</code> (LLVM::VaEndOp)&nbsp;<a class=headline-hash href=#llvmintrvaend-llvmvaendop>¶</a></h3><p><em>Destroys <code>arg_list</code>, which has been initialized by <code>intr.vastart</code> or <code>intr.vacopy</code>.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vaend` $arg_list attr-dict `:` qualified(type($arg_list))
</code></pre><h4 id=operands-224>Operands:&nbsp;<a class=headline-hash href=#operands-224>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_list</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrvastart-llvmvastartop><code>llvm.intr.vastart</code> (LLVM::VaStartOp)&nbsp;<a class=headline-hash href=#llvmintrvastart-llvmvastartop>¶</a></h3><p><em>Initializes <code>arg_list</code> for subsequent variadic argument extractions.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vastart` $arg_list attr-dict `:` qualified(type($arg_list))
</code></pre><h4 id=operands-225>Operands:&nbsp;<a class=headline-hash href=#operands-225>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>arg_list</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrvarannotation-llvmvarannotation><code>llvm.intr.var.annotation</code> (LLVM::VarAnnotation)&nbsp;<a class=headline-hash href=#llvmintrvarannotation-llvmvarannotation>¶</a></h3><h4 id=operands-226>Operands:&nbsp;<a class=headline-hash href=#operands-226>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>val</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>annotation</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>fileName</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>line</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>attr</code></td><td>LLVM pointer type</td></tr></tbody></table><h3 id=llvmintrmaskedcompressstore-llvmmasked_compressstore><code>llvm.intr.masked.compressstore</code> (LLVM::masked_compressstore)&nbsp;<a class=headline-hash href=#llvmintrmaskedcompressstore-llvmmasked_compressstore>¶</a></h3><h4 id=operands-227>Operands:&nbsp;<a class=headline-hash href=#operands-227>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr></tbody></table><h3 id=llvmintrmaskedexpandload-llvmmasked_expandload><code>llvm.intr.masked.expandload</code> (LLVM::masked_expandload)&nbsp;<a class=headline-hash href=#llvmintrmaskedexpandload-llvmmasked_expandload>¶</a></h3><h4 id=operands-228>Operands:&nbsp;<a class=headline-hash href=#operands-228>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>LLVM pointer type</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center>«unnamed»</td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-210>Results:&nbsp;<a class=headline-hash href=#results-210>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrmaskedgather-llvmmasked_gather><code>llvm.intr.masked.gather</code> (LLVM::masked_gather)&nbsp;<a class=headline-hash href=#llvmintrmaskedgather-llvmmasked_gather>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.masked.gather` operands attr-dict `:` functional-type(operands, results)
</code></pre><h4 id=attributes-118>Attributes:&nbsp;<a class=headline-hash href=#attributes-118>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-229>Operands:&nbsp;<a class=headline-hash href=#operands-229>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>ptrs</code></td><td>LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr><tr><td style=text-align:center><code>pass_thru</code></td><td>variadic of LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-211>Results:&nbsp;<a class=headline-hash href=#results-211>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrmaskedscatter-llvmmasked_scatter><code>llvm.intr.masked.scatter</code> (LLVM::masked_scatter)&nbsp;<a class=headline-hash href=#llvmintrmaskedscatter-llvmmasked_scatter>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.masked.scatter` $value `,` $ptrs `,` $mask attr-dict `:` type($value) `,` type($mask) `into` type($ptrs)
</code></pre><h4 id=attributes-119>Attributes:&nbsp;<a class=headline-hash href=#attributes-119>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>alignment</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-230>Operands:&nbsp;<a class=headline-hash href=#operands-230>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>value</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>ptrs</code></td><td>LLVM dialect-compatible vector of LLVM pointer type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>LLVM dialect-compatible vector of 1-bit signless integer</td></tr></tbody></table><h3 id=llvmintrvectordeinterleave2-llvmvector_deinterleave2><code>llvm.intr.vector.deinterleave2</code> (LLVM::vector_deinterleave2)&nbsp;<a class=headline-hash href=#llvmintrvectordeinterleave2-llvmvector_deinterleave2>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-231>Operands:&nbsp;<a class=headline-hash href=#operands-231>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vec</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-212>Results:&nbsp;<a class=headline-hash href=#results-212>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorextract-llvmvector_extract><code>llvm.intr.vector.extract</code> (LLVM::vector_extract)&nbsp;<a class=headline-hash href=#llvmintrvectorextract-llvmvector_extract>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.extract` $srcvec `[` $pos `]` attr-dict `:` type($res) `from` type($srcvec)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-120>Attributes:&nbsp;<a class=headline-hash href=#attributes-120>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pos</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-232>Operands:&nbsp;<a class=headline-hash href=#operands-232>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>srcvec</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-213>Results:&nbsp;<a class=headline-hash href=#results-213>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrvectorinsert-llvmvector_insert><code>llvm.intr.vector.insert</code> (LLVM::vector_insert)&nbsp;<a class=headline-hash href=#llvmintrvectorinsert-llvmvector_insert>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.insert` $srcvec `,` $dstvec `[` $pos `]` attr-dict `:` type($srcvec) `into` type($res)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-121>Attributes:&nbsp;<a class=headline-hash href=#attributes-121>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>pos</code></td><td>::mlir::IntegerAttr</td><td>64-bit signless integer attribute</td></tr></table><h4 id=operands-233>Operands:&nbsp;<a class=headline-hash href=#operands-233>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>dstvec</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>srcvec</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-214>Results:&nbsp;<a class=headline-hash href=#results-214>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h3 id=llvmintrvectorinterleave2-llvmvector_interleave2><code>llvm.intr.vector.interleave2</code> (LLVM::vector_interleave2)&nbsp;<a class=headline-hash href=#llvmintrvectorinterleave2-llvmvector_interleave2>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-234>Operands:&nbsp;<a class=headline-hash href=#operands-234>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vec1</code></td><td>LLVM dialect-compatible vector type</td></tr><tr><td style=text-align:center><code>vec2</code></td><td>LLVM dialect-compatible vector type</td></tr></tbody></table><h4 id=results-215>Results:&nbsp;<a class=headline-hash href=#results-215>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreduceadd-llvmvector_reduce_add><code>llvm.intr.vector.reduce.add</code> (LLVM::vector_reduce_add)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceadd-llvmvector_reduce_add>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-235>Operands:&nbsp;<a class=headline-hash href=#operands-235>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-216>Results:&nbsp;<a class=headline-hash href=#results-216>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreduceand-llvmvector_reduce_and><code>llvm.intr.vector.reduce.and</code> (LLVM::vector_reduce_and)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceand-llvmvector_reduce_and>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-236>Operands:&nbsp;<a class=headline-hash href=#operands-236>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-217>Results:&nbsp;<a class=headline-hash href=#results-217>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefadd-llvmvector_reduce_fadd><code>llvm.intr.vector.reduce.fadd</code> (LLVM::vector_reduce_fadd)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefadd-llvmvector_reduce_fadd>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-122>Attributes:&nbsp;<a class=headline-hash href=#attributes-122>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-237>Operands:&nbsp;<a class=headline-hash href=#operands-237>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>start_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>input</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-218>Results:&nbsp;<a class=headline-hash href=#results-218>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmax-llvmvector_reduce_fmax><code>llvm.intr.vector.reduce.fmax</code> (LLVM::vector_reduce_fmax)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmax-llvmvector_reduce_fmax>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.reduce.fmax` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-123>Attributes:&nbsp;<a class=headline-hash href=#attributes-123>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-238>Operands:&nbsp;<a class=headline-hash href=#operands-238>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-219>Results:&nbsp;<a class=headline-hash href=#results-219>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmaximum-llvmvector_reduce_fmaximum><code>llvm.intr.vector.reduce.fmaximum</code> (LLVM::vector_reduce_fmaximum)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmaximum-llvmvector_reduce_fmaximum>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.reduce.fmaximum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-124>Attributes:&nbsp;<a class=headline-hash href=#attributes-124>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-239>Operands:&nbsp;<a class=headline-hash href=#operands-239>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-220>Results:&nbsp;<a class=headline-hash href=#results-220>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmin-llvmvector_reduce_fmin><code>llvm.intr.vector.reduce.fmin</code> (LLVM::vector_reduce_fmin)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmin-llvmvector_reduce_fmin>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.reduce.fmin` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-125>Attributes:&nbsp;<a class=headline-hash href=#attributes-125>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-240>Operands:&nbsp;<a class=headline-hash href=#operands-240>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-221>Results:&nbsp;<a class=headline-hash href=#results-221>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefminimum-llvmvector_reduce_fminimum><code>llvm.intr.vector.reduce.fminimum</code> (LLVM::vector_reduce_fminimum)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefminimum-llvmvector_reduce_fminimum>¶</a></h3><p>Syntax:</p><pre tabindex=0><code>operation ::= `llvm.intr.vector.reduce.fminimum` `(` operands `)` attr-dict `:` functional-type(operands, results)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-126>Attributes:&nbsp;<a class=headline-hash href=#attributes-126>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-241>Operands:&nbsp;<a class=headline-hash href=#operands-241>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-222>Results:&nbsp;<a class=headline-hash href=#results-222>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducefmul-llvmvector_reduce_fmul><code>llvm.intr.vector.reduce.fmul</code> (LLVM::vector_reduce_fmul)&nbsp;<a class=headline-hash href=#llvmintrvectorreducefmul-llvmvector_reduce_fmul>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>FastmathFlagsInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-127>Attributes:&nbsp;<a class=headline-hash href=#attributes-127>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmathFlags</code></td><td>::mlir::LLVM::FastmathFlagsAttr</td><td>LLVM fastmath flags</td></tr></table><h4 id=operands-242>Operands:&nbsp;<a class=headline-hash href=#operands-242>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>start_value</code></td><td>floating-point</td></tr><tr><td style=text-align:center><code>input</code></td><td>LLVM dialect-compatible vector of floating-point</td></tr></tbody></table><h4 id=results-223>Results:&nbsp;<a class=headline-hash href=#results-223>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducemul-llvmvector_reduce_mul><code>llvm.intr.vector.reduce.mul</code> (LLVM::vector_reduce_mul)&nbsp;<a class=headline-hash href=#llvmintrvectorreducemul-llvmvector_reduce_mul>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-243>Operands:&nbsp;<a class=headline-hash href=#operands-243>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-224>Results:&nbsp;<a class=headline-hash href=#results-224>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreduceor-llvmvector_reduce_or><code>llvm.intr.vector.reduce.or</code> (LLVM::vector_reduce_or)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceor-llvmvector_reduce_or>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-244>Operands:&nbsp;<a class=headline-hash href=#operands-244>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-225>Results:&nbsp;<a class=headline-hash href=#results-225>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducesmax-llvmvector_reduce_smax><code>llvm.intr.vector.reduce.smax</code> (LLVM::vector_reduce_smax)&nbsp;<a class=headline-hash href=#llvmintrvectorreducesmax-llvmvector_reduce_smax>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-245>Operands:&nbsp;<a class=headline-hash href=#operands-245>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-226>Results:&nbsp;<a class=headline-hash href=#results-226>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducesmin-llvmvector_reduce_smin><code>llvm.intr.vector.reduce.smin</code> (LLVM::vector_reduce_smin)&nbsp;<a class=headline-hash href=#llvmintrvectorreducesmin-llvmvector_reduce_smin>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-246>Operands:&nbsp;<a class=headline-hash href=#operands-246>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-227>Results:&nbsp;<a class=headline-hash href=#results-227>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreduceumax-llvmvector_reduce_umax><code>llvm.intr.vector.reduce.umax</code> (LLVM::vector_reduce_umax)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceumax-llvmvector_reduce_umax>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-247>Operands:&nbsp;<a class=headline-hash href=#operands-247>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-228>Results:&nbsp;<a class=headline-hash href=#results-228>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreduceumin-llvmvector_reduce_umin><code>llvm.intr.vector.reduce.umin</code> (LLVM::vector_reduce_umin)&nbsp;<a class=headline-hash href=#llvmintrvectorreduceumin-llvmvector_reduce_umin>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-248>Operands:&nbsp;<a class=headline-hash href=#operands-248>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-229>Results:&nbsp;<a class=headline-hash href=#results-229>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvectorreducexor-llvmvector_reduce_xor><code>llvm.intr.vector.reduce.xor</code> (LLVM::vector_reduce_xor)&nbsp;<a class=headline-hash href=#llvmintrvectorreducexor-llvmvector_reduce_xor>¶</a></h3><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>SameOperandsAndResultElementType</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-249>Operands:&nbsp;<a class=headline-hash href=#operands-249>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>LLVM dialect-compatible vector of signless integer</td></tr></tbody></table><h4 id=results-230>Results:&nbsp;<a class=headline-hash href=#results-230>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=llvmintrvscale-llvmvscale><code>llvm.intr.vscale</code> (LLVM::vscale)&nbsp;<a class=headline-hash href=#llvmintrvscale-llvmvscale>¶</a></h3><h4 id=results-231>Results:&nbsp;<a class=headline-hash href=#results-231>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=debug-info>Debug Info&nbsp;<a class=headline-hash href=#debug-info>¶</a></h3><p>Debug information within the LLVM dialect is represented using locations in
combination with a set of attributes that mirror the DINode structure defined by
the debug info metadata within LLVM IR. Debug scoping information is attached
to LLVM IR dialect operations using a fused location (<code>FusedLoc</code>) whose metadata
holds the DIScopeAttr representing the debug scope. Similarly, the subprogram
of LLVM IR dialect <code>FuncOp</code> operations is attached using a fused location whose
metadata is a DISubprogramAttr.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/ title="Linalg OpDSL"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Linalg OpDSL</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/MathOps/ title="'math' Dialect">Next - 'math' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>