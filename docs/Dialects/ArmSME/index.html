<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'ArmSME' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ArmSME/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'ArmSME' Dialect</h1><p>Basic dialect to target Arm SME.</p><p>This dialect defines custom and LLVM IR intrinsic operations that are used to
target Arm Scalable Matrix Extension. Through the available conversion and
ArmSME passes you can, for example, lower a
<a href=https://mlir.llvm.org/docs/Dialects/Linalg/#linalgmatmul-linalgmatmulop>linalg.matmul</a>
operation to Arm SME
<a href=https://developer.arm.com/documentation/ddi0602/2023-03/SME-Instructions/FMOPA--widening---Half-precision-floating-point-sum-of-outer-products-and-accumulate->FMOPA</a>
(floating-point outer product) operations. See one of the in-tree end-to-end
integration tests for reference:</p><ul><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/test/Integration/Dialect/Linalg/CPU/ArmSME/matmul.mlir>Linalg/CPU/ArmSME/matmul.mlir</a></li><li><a href=https://github.com/llvm/llvm-project/blob/main/mlir/test/Integration/Dialect/Vector/CPU/ArmSME/outerproduct-f64.mlir>Vector/CPU/ArmSME/outerproduct-f64.mlir</a></li></ul><p>In order to run ArmSME integration tests, include these flags in the CMake
invocation when configuring LLVM and MLIR:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  -DMLIR_INCLUDE_INTEGRATION_TESTS<span class=o>=</span>On
</span></span><span class=line><span class=cl>  -DMLIR_RUN_ARM_SME_TESTS<span class=o>=</span>On
</span></span><span class=line><span class=cl>  -DARM_EMULATOR_EXECUTABLE<span class=o>=</span>&lt;path-to-emulator&gt;
</span></span></code></pre></div><p>These tests are run &ldquo;post-commit&rdquo; by the
<a href=https://lab.llvm.org/buildbot/#/builders/197>clang-aarch64-sve-vla</a> LLVM
BuildBot worker.</p><p><strong>References:</strong></p><ul><li><a href=https://developer.arm.com/documentation/ddi0616>The Scalable Matrix Extension (SME), for Armv9-A</a></li><li><a href=https://developer.arm.com/documentation/ddi0602/2023-03/SME-Instructions>A64 &ndash; SME Instructions (alphabetic order)</a></li></ul><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#arm_smecopy_tile-arm_smecopytileop><code>arm_sme.copy_tile</code> (arm_sme::CopyTileOp)</a></li><li><a href=#arm_smeextract_tile_slice-arm_smeextracttilesliceop><code>arm_sme.extract_tile_slice</code> (arm_sme::ExtractTileSliceOp)</a></li><li><a href=#arm_smefmopa_2way-arm_smefmopa2wayop><code>arm_sme.fmopa_2way</code> (arm_sme::FMopa2WayOp)</a></li><li><a href=#arm_smefmops_2way-arm_smefmops2wayop><code>arm_sme.fmops_2way</code> (arm_sme::FMops2WayOp)</a></li><li><a href=#arm_smeget_tile-arm_smegettileop><code>arm_sme.get_tile</code> (arm_sme::GetTileOp)</a></li><li><a href=#arm_smeinsert_tile_slice-arm_smeinserttilesliceop><code>arm_sme.insert_tile_slice</code> (arm_sme::InsertTileSliceOp)</a></li><li><a href=#arm_smeload_tile_slice-arm_smeloadtilesliceop><code>arm_sme.load_tile_slice</code> (arm_sme::LoadTileSliceOp)</a></li><li><a href=#arm_smeouterproduct-arm_smeouterproductop><code>arm_sme.outerproduct</code> (arm_sme::OuterProductOp)</a></li><li><a href=#arm_smesmopa_2way-arm_smesmopa2wayop><code>arm_sme.smopa_2way</code> (arm_sme::SMopa2WayOp)</a></li><li><a href=#arm_smesmopa_4way-arm_smesmopa4wayop><code>arm_sme.smopa_4way</code> (arm_sme::SMopa4WayOp)</a></li><li><a href=#arm_smesmops_2way-arm_smesmops2wayop><code>arm_sme.smops_2way</code> (arm_sme::SMops2WayOp)</a></li><li><a href=#arm_smesmops_4way-arm_smesmops4wayop><code>arm_sme.smops_4way</code> (arm_sme::SMops4WayOp)</a></li><li><a href=#arm_smestore_tile_slice-arm_smestoretilesliceop><code>arm_sme.store_tile_slice</code> (arm_sme::StoreTileSliceOp)</a></li><li><a href=#arm_smestreaming_vl-arm_smestreamingvlop><code>arm_sme.streaming_vl</code> (arm_sme::StreamingVLOp)</a></li><li><a href=#arm_smesumopa_4way-arm_smesumopa4wayop><code>arm_sme.sumopa_4way</code> (arm_sme::SuMopa4WayOp)</a></li><li><a href=#arm_smesumops_4way-arm_smesumops4wayop><code>arm_sme.sumops_4way</code> (arm_sme::SuMops4WayOp)</a></li><li><a href=#arm_smetile_load-arm_smetileloadop><code>arm_sme.tile_load</code> (arm_sme::TileLoadOp)</a></li><li><a href=#arm_smetile_store-arm_smetilestoreop><code>arm_sme.tile_store</code> (arm_sme::TileStoreOp)</a></li><li><a href=#arm_smeumopa_2way-arm_smeumopa2wayop><code>arm_sme.umopa_2way</code> (arm_sme::UMopa2WayOp)</a></li><li><a href=#arm_smeumopa_4way-arm_smeumopa4wayop><code>arm_sme.umopa_4way</code> (arm_sme::UMopa4WayOp)</a></li><li><a href=#arm_smeumops_2way-arm_smeumops2wayop><code>arm_sme.umops_2way</code> (arm_sme::UMops2WayOp)</a></li><li><a href=#arm_smeumops_4way-arm_smeumops4wayop><code>arm_sme.umops_4way</code> (arm_sme::UMops4WayOp)</a></li><li><a href=#arm_smeusmopa_4way-arm_smeusmopa4wayop><code>arm_sme.usmopa_4way</code> (arm_sme::UsMopa4WayOp)</a></li><li><a href=#arm_smeusmops_4way-arm_smeusmops4wayop><code>arm_sme.usmops_4way</code> (arm_sme::UsMops4WayOp)</a></li><li><a href=#arm_smezero-arm_smezeroop><code>arm_sme.zero</code> (arm_sme::ZeroOp)</a></li></ul></li><li><a href=#operations-for-llvm-ir-intrinsics>Operations for LLVM IR Intrinsics</a><ul><li><a href=#arm_smeintrcntsb-arm_smeaarch64_sme_cntsb><code>arm_sme.intr.cntsb</code> (arm_sme::aarch64_sme_cntsb)</a></li><li><a href=#arm_smeintrcntsd-arm_smeaarch64_sme_cntsd><code>arm_sme.intr.cntsd</code> (arm_sme::aarch64_sme_cntsd)</a></li><li><a href=#arm_smeintrcntsh-arm_smeaarch64_sme_cntsh><code>arm_sme.intr.cntsh</code> (arm_sme::aarch64_sme_cntsh)</a></li><li><a href=#arm_smeintrcntsw-arm_smeaarch64_sme_cntsw><code>arm_sme.intr.cntsw</code> (arm_sme::aarch64_sme_cntsw)</a></li><li><a href=#arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz><code>arm_sme.intr.ld1b.horiz</code> (arm_sme::aarch64_sme_ld1b_horiz)</a></li><li><a href=#arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert><code>arm_sme.intr.ld1b.vert</code> (arm_sme::aarch64_sme_ld1b_vert)</a></li><li><a href=#arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz><code>arm_sme.intr.ld1d.horiz</code> (arm_sme::aarch64_sme_ld1d_horiz)</a></li><li><a href=#arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert><code>arm_sme.intr.ld1d.vert</code> (arm_sme::aarch64_sme_ld1d_vert)</a></li><li><a href=#arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz><code>arm_sme.intr.ld1h.horiz</code> (arm_sme::aarch64_sme_ld1h_horiz)</a></li><li><a href=#arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert><code>arm_sme.intr.ld1h.vert</code> (arm_sme::aarch64_sme_ld1h_vert)</a></li><li><a href=#arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz><code>arm_sme.intr.ld1q.horiz</code> (arm_sme::aarch64_sme_ld1q_horiz)</a></li><li><a href=#arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert><code>arm_sme.intr.ld1q.vert</code> (arm_sme::aarch64_sme_ld1q_vert)</a></li><li><a href=#arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz><code>arm_sme.intr.ld1w.horiz</code> (arm_sme::aarch64_sme_ld1w_horiz)</a></li><li><a href=#arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert><code>arm_sme.intr.ld1w.vert</code> (arm_sme::aarch64_sme_ld1w_vert)</a></li><li><a href=#arm_smeintrmopa-arm_smeaarch64_sme_mopa><code>arm_sme.intr.mopa</code> (arm_sme::aarch64_sme_mopa)</a></li><li><a href=#arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide><code>arm_sme.intr.mopa.wide</code> (arm_sme::aarch64_sme_mopa_wide)</a></li><li><a href=#arm_smeintrmops-arm_smeaarch64_sme_mops><code>arm_sme.intr.mops</code> (arm_sme::aarch64_sme_mops)</a></li><li><a href=#arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide><code>arm_sme.intr.mops.wide</code> (arm_sme::aarch64_sme_mops_wide)</a></li><li><a href=#arm_smeintrreadhoriz-arm_smeaarch64_sme_read_horiz><code>arm_sme.intr.read.horiz</code> (arm_sme::aarch64_sme_read_horiz)</a></li><li><a href=#arm_smeintrreadvert-arm_smeaarch64_sme_read_vert><code>arm_sme.intr.read.vert</code> (arm_sme::aarch64_sme_read_vert)</a></li><li><a href=#arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide><code>arm_sme.intr.smopa.wide</code> (arm_sme::aarch64_sme_smopa_wide)</a></li><li><a href=#arm_smeintrsmopaza32-arm_smeaarch64_sme_smopa_za32><code>arm_sme.intr.smopa.za32</code> (arm_sme::aarch64_sme_smopa_za32)</a></li><li><a href=#arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide><code>arm_sme.intr.smops.wide</code> (arm_sme::aarch64_sme_smops_wide)</a></li><li><a href=#arm_smeintrsmopsza32-arm_smeaarch64_sme_smops_za32><code>arm_sme.intr.smops.za32</code> (arm_sme::aarch64_sme_smops_za32)</a></li><li><a href=#arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz><code>arm_sme.intr.st1b.horiz</code> (arm_sme::aarch64_sme_st1b_horiz)</a></li><li><a href=#arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert><code>arm_sme.intr.st1b.vert</code> (arm_sme::aarch64_sme_st1b_vert)</a></li><li><a href=#arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz><code>arm_sme.intr.st1d.horiz</code> (arm_sme::aarch64_sme_st1d_horiz)</a></li><li><a href=#arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert><code>arm_sme.intr.st1d.vert</code> (arm_sme::aarch64_sme_st1d_vert)</a></li><li><a href=#arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz><code>arm_sme.intr.st1h.horiz</code> (arm_sme::aarch64_sme_st1h_horiz)</a></li><li><a href=#arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert><code>arm_sme.intr.st1h.vert</code> (arm_sme::aarch64_sme_st1h_vert)</a></li><li><a href=#arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz><code>arm_sme.intr.st1q.horiz</code> (arm_sme::aarch64_sme_st1q_horiz)</a></li><li><a href=#arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert><code>arm_sme.intr.st1q.vert</code> (arm_sme::aarch64_sme_st1q_vert)</a></li><li><a href=#arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz><code>arm_sme.intr.st1w.horiz</code> (arm_sme::aarch64_sme_st1w_horiz)</a></li><li><a href=#arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert><code>arm_sme.intr.st1w.vert</code> (arm_sme::aarch64_sme_st1w_vert)</a></li><li><a href=#arm_smeintrstr-arm_smeaarch64_sme_str><code>arm_sme.intr.str</code> (arm_sme::aarch64_sme_str)</a></li><li><a href=#arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide><code>arm_sme.intr.sumopa.wide</code> (arm_sme::aarch64_sme_sumopa_wide)</a></li><li><a href=#arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide><code>arm_sme.intr.sumops.wide</code> (arm_sme::aarch64_sme_sumops_wide)</a></li><li><a href=#arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide><code>arm_sme.intr.umopa.wide</code> (arm_sme::aarch64_sme_umopa_wide)</a></li><li><a href=#arm_smeintrumopaza32-arm_smeaarch64_sme_umopa_za32><code>arm_sme.intr.umopa.za32</code> (arm_sme::aarch64_sme_umopa_za32)</a></li><li><a href=#arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide><code>arm_sme.intr.umops.wide</code> (arm_sme::aarch64_sme_umops_wide)</a></li><li><a href=#arm_smeintrumopsza32-arm_smeaarch64_sme_umops_za32><code>arm_sme.intr.umops.za32</code> (arm_sme::aarch64_sme_umops_za32)</a></li><li><a href=#arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide><code>arm_sme.intr.usmopa.wide</code> (arm_sme::aarch64_sme_usmopa_wide)</a></li><li><a href=#arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide><code>arm_sme.intr.usmops.wide</code> (arm_sme::aarch64_sme_usmops_wide)</a></li><li><a href=#arm_smeintrwritehoriz-arm_smeaarch64_sme_write_horiz><code>arm_sme.intr.write.horiz</code> (arm_sme::aarch64_sme_write_horiz)</a></li><li><a href=#arm_smeintrwritevert-arm_smeaarch64_sme_write_vert><code>arm_sme.intr.write.vert</code> (arm_sme::aarch64_sme_write_vert)</a></li><li><a href=#arm_smeintrzero-arm_smeaarch64_sme_zero><code>arm_sme.intr.zero</code> (arm_sme::aarch64_sme_zero)</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/ArmSME/IR/ArmSMEOps.td>source</a></p><h3 id=arm_smecopy_tile-arm_smecopytileop><code>arm_sme.copy_tile</code> (arm_sme::CopyTileOp)&nbsp;<a class=headline-hash href=#arm_smecopy_tile-arm_smecopytileop>¶</a></h3><p><em>Copies an SME tile value</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.copy_tile` $tile attr-dict `:` type($result)
</code></pre><p>Copies an SME &ldquo;virtual tile&rdquo; value to a new SSA value. This operation is
primarily intended to be used to normalize the IR prior to tile allocation.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%copy</span> <span class=p>=</span> arm_sme<span class=p>.</span>copy_tile <span class=nv>%tile</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smeextract_tile_slice-arm_smeextracttilesliceop><code>arm_sme.extract_tile_slice</code> (arm_sme::ExtractTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smeextract_tile_slice-arm_smeextracttilesliceop>¶</a></h3><p><em>Extract 1-D scalable vector from slice of 2-D tile</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.extract_tile_slice` $tile `[` $tile_slice_index `]` (`layout` `` $layout^)? attr-dict
              `:` type($result) `from` type($tile)
</code></pre><p>Extracts a 1-D scalable slice from a 2-D scalable tile at the given index.
A tile slice is a 1-D vector of horizontally or vertically contiguous
elements within a ZA tile.</p><p>An optional tile slice layout attribute specifies whether the tile slice is
horizontal (default) or vertical.</p><p>Example 1: Extract <code>vector&lt;[16]xi8></code> from tile horizontally at the given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%slice</span> <span class=p>=</span> arm_sme<span class=p>.</span>extract_tile_slice <span class=nv>%tile</span><span class=p>[</span><span class=nv>%tile_slice_index</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> from <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Extract <code>vector&lt;[2]xf64></code> from tile vertically at the given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%slice</span> <span class=p>=</span> arm_sme<span class=p>.</span>extract_tile_slice <span class=nv>%tile</span><span class=p>[</span><span class=nv>%tile_slice_index</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]</span>xf64<span class=p>&gt;</span> from <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xf64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that matches the size of a SVE vector</td></tr></tbody></table><h3 id=arm_smefmopa_2way-arm_smefmopa2wayop><code>arm_sme.fmopa_2way</code> (arm_sme::FMopa2WayOp)&nbsp;<a class=headline-hash href=#arm_smefmopa_2way-arm_smefmopa2wayop>¶</a></h3><p><em>Floating-point sum of 2 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.fmopa_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>This operation represents a sum of 2 widened outer products. It takes 2 1-D
scalable vectors as input and a 2-D scalable vector (ZA tile) as output.</p><p>For example (fp16 to fp32):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmopa_2way <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>The <code>lhs</code> encodes a matrix of shape SVLSx2 and the <code>rhs</code> a matrix of
2xSVLS, where SVLS (spec [1], section B2.1) is the number of 32-bit
elements in a vector of SVL bits. To illustrate, below is a breakdown of
this operation for fp16 to fp32, SVL=128 (i.e., vscale=1):</p><pre tabindex=0><code>                      LHS                          RHS
           [A0 A1 A2 A3 A4 A5 A6 A7]    [B0 B1 B2 B3 B4 B5 B6 B7]

----------------------------------------------------------------------------

                              implicit layout

                          [A0 A1]    |
                          [A2 A3]    |    [B0 B2 B4 B6]
                          [A4 A5]    |    [B1 B3 B5 B7]
                          [A6 A7]    |

----------------------------------------------------------------------------

                              2 outer products

                  Acol0 ⊗ Brow0      |           Acol1 ⊗ Brow1
                  -------------      |           -------------
                                     |
              [B0 B2 B4 B6]          |       [B1 B3 B5 B7]
                                     |
         [A0  [A0B0 A0B2 A0B4 A0B6]  |  [A1  [A1B1 A1B3 A1B5 A1B7]
          A2  [A2B0 A2B2 A2B4 A2B6]  |   A3  [A3B1 A3B3 A3B5 A3B7]
          A4  [A4B0 A4B2 A4B4 A4B6]  |   A5  [A5B1 A5B3 A5B5 A5B7]
          A6] [A6B0 A6B2 A6B4 A6B6]  |   A7] [A7B1 A7B3 A7B5 A7B7]
                                     |

----------------------------------------------------------------------------

                          sum of 2 outer products

                       Acol0 ⊗ Brow0 + Acol1 ⊗ Brow1

             [A0B0 + A1B1 A0B2 + A1B3 A0B4 + A1B5 A0B6 + A1B7]
             [A2B0 + A3B1 A2B2 + A3B3 A2B4 + A3B5 A2B6 + A3B7]
             [A4B0 + A5B1 A4B2 + A5B3 A4B4 + A5B5 A4B6 + A5B7]
             [A6B0 + A7B1 A6B2 + A7B3 A6B4 + A7B5 A6B6 + A7B7]

----------------------------------------------------------------------------
</code></pre><p>This operation enables the folding of 2 outer products chained via the
accumulator into a single outer product.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a0_ext</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%a0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b0_ext</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%b0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%a1_ext</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%a1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b1_ext</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%b1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a0_ext</span><span class=p>,</span> <span class=nv>%b0_ext</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a1_ext</span><span class=p>,</span> <span class=nv>%b1_ext</span> acc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>The 2 outer products in the example above can be fused into a single outer
product as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a_packed</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%a0</span><span class=p>,</span> <span class=nv>%a1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b_packed</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%b0</span><span class=p>,</span> <span class=nv>%b1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf16<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmopa_2way <span class=nv>%a_packed</span><span class=p>,</span> <span class=nv>%b_packed</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>This is implemented in the <code>-arm-sme-outer-product-fusion</code> pass.</p><p>Example: FP16 to FP32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmopa_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: BF16 to FP32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmopa_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xbf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xbf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/FMOPA--widening--2-way--FP16-to-FP32---Half-precision-floating-point-sum-of-outer-products-and-accumulate->FMOPA (widening, 2-way, FP16 to FP32)</a></td><td>+sme</td></tr><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/BFMOPA--widening---BFloat16-sum-of-outer-products-and-accumulate->BFMOPA (widening, 2-way, BF16 to FP32)</a></td><td>+sme</td></tr></tbody></table><p>[1]
<a href=https://developer.arm.com/documentation/ddi0616>https://developer.arm.com/documentation/ddi0616</a></p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit float or bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xf32> of 32-bit float values</td></tr></tbody></table><h3 id=arm_smefmops_2way-arm_smefmops2wayop><code>arm_sme.fmops_2way</code> (arm_sme::FMops2WayOp)&nbsp;<a class=headline-hash href=#arm_smefmops_2way-arm_smefmops2wayop>¶</a></h3><p><em>Floating-point sum of 2 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.fmops_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Equivalent to <code>fmopa_2way</code> but outer products are subtracted from
destination <code>result</code>.</p><p>Example: FP16 to FP32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmops_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: BF16 to FP32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>fmops_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xbf16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xbf16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smefmopa_2way-arm_smefmopa2wayop>fmopa_2way</a> for a detailed
description of 2-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/FMOPS--widening---Half-precision-floating-point-sum-of-outer-products-and-subtract->FMOPS (widening, 2-way, FP16 to FP32)</a></td><td>+sme</td></tr><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/BMOPS--Bitwise-exclusive-NOR-population-count-outer-product-and-subtract->BFMOPS (widening, 2-way, BF16 to FP32)</a></td><td>+sme</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit float or bfloat16 type values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xf32> of 32-bit float values</td></tr></tbody></table><h3 id=arm_smeget_tile-arm_smegettileop><code>arm_sme.get_tile</code> (arm_sme::GetTileOp)&nbsp;<a class=headline-hash href=#arm_smeget_tile-arm_smegettileop>¶</a></h3><p><em>Creates an undefined value of SME virtual tile type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.get_tile` attr-dict `:` type($tile)
</code></pre><p>Creates a new SME &ldquo;virtual tile&rdquo; value within a function. The contents of
the tile returned from this operation are undefined.</p><p>Example 1:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create an 8-bit element &#34;virtual tile&#34; value:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%za0_b</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile<span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create two 16-bit element &#34;virtual tiles&#34; values:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%za0_h</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]x[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%za1_h</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]x[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Create an 128-bit element &#34;virtual tile&#34; value:
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%za0_q</span> <span class=p>=</span> arm_sme<span class=p>.</span>get_tile <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smeinsert_tile_slice-arm_smeinserttilesliceop><code>arm_sme.insert_tile_slice</code> (arm_sme::InsertTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smeinsert_tile_slice-arm_smeinserttilesliceop>¶</a></h3><p><em>Insert 1-D scalable vector into slice of 2-D tile</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.insert_tile_slice` $vector `,` $tile `[` $tile_slice_index `]` (`layout` `` $layout^)?
              attr-dict `:` type($vector) `into` type($result)
</code></pre><p>Inserts a 1-D scalable vector into a slice of a 2-D scalable vector tile at
the given index. The type of the 1-D scalable vector to be inserted must
match the type of the tile slice. A tile slice is a 1-D vector of
horizontally or vertically contiguous elements within a ZA tile. The updated
tile is returned as the result.</p><p>An optional tile slice layout attribute specifies whether the tile slice is
horizontal (default) or vertical.</p><p>Example 1: Insert <code>vector&lt;[16]xi8></code> into tile horizontally at the given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>insert_tile_slice <span class=nv>%vector</span><span class=p>,</span> <span class=nv>%tile</span><span class=p>[</span><span class=nv>%tile_slice_index</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Insert <code>vector&lt;[2]xf64></code> into tile vertically at the given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>insert_tile_slice <span class=nv>%vector</span><span class=p>,</span> <span class=nv>%tile</span><span class=p>[</span><span class=nv>%tile_slice_index</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]</span>xf64<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xf64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>a vector type that matches the size of a SVE vector</td></tr><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smeload_tile_slice-arm_smeloadtilesliceop><code>arm_sme.load_tile_slice</code> (arm_sme::LoadTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smeload_tile_slice-arm_smeloadtilesliceop>¶</a></h3><p><em>Tile slice load and update operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.load_tile_slice` $base `[` $indices `]` `,` $mask `,` $tile `,` $tile_slice_index
              (`layout` `` $layout^)? attr-dict `:` type($base) `,` type($mask) `,`
              type($result)
</code></pre><p>Loads a 1D tile slice from memory into a 2D SME &ldquo;virtual tile&rdquo;. The tile
slice is defined by the dimension of the 2D scalable vector type pointed by
the index. A tile slice index describes where in the input tile the tile
slice is loaded to. An optional tile slice layout attribute specifies
whether the tile slice being loaded at the given index is horizontal
(default) or vertical. The updated tile is returned as the result.</p><p>The slice of memory read is defined by a base and indices and must be
contiguous. The memref must be either rank 1 or rank 2, have dynamic
dimensions since the operation is scalable, and the element type must be a
scalar that matches the element type of the result.</p><p>The provided <code>mask</code> is used to specify which elements of the tile slice
will be loaded.</p><p>Example 1: Load a vector&lt;[16]xi8> tile slice from memory into tile horizontally (default) at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Load a vector&lt;[4]xf32> tile slice from memory into tile vertically at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Load a vector&lt;[1]xi128> tile slice from memory into tile vertically at given index.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile_update</span> <span class=p>=</span> arm_sme<span class=p>.</span>load_tile_slice <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>],</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>InferTypeOpInterface</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>mask</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smeouterproduct-arm_smeouterproductop><code>arm_sme.outerproduct</code> (arm_sme::OuterProductOp)&nbsp;<a class=headline-hash href=#arm_smeouterproduct-arm_smeouterproductop>¶</a></h3><p><em>Outer product with optional fused add/sub</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.outerproduct` $lhs `,` $rhs
              oilist(
              `kind` `` $kind
              | `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs)
</code></pre><p>This operation represents an outer product that fits within an SME tile.
All operands must be SVE vectors and the result a SME tile. Unlike
<code>vector.outerproduct</code> masking is on the operands (rather than the result),
which mirrors the SME instructions.</p><p>Example 1: Unmasked outerproduct (without accumulator)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Not specifying an accumulator implicitly zeros the destination tile.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Unmasked outerproduct (with accumulator)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs acc<span class=p>(</span><span class=err>$</span>accumulator<span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Masked outerproduct</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs masks<span class=p>(</span><span class=err>$</span>lhsMask<span class=p>,</span> <span class=err>$</span>rhsMask<span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 4: Masked outerproduct (with accumulator)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs acc<span class=p>(</span><span class=err>$</span>accumulator<span class=p>)</span> masks<span class=p>(</span><span class=err>$</span>lhsMask<span class=p>,</span> <span class=err>$</span>rhsMask<span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>kind</code></td><td>::mlir::arm_sme::CombiningKindAttr</td><td>Kind of combining function</td></tr></table><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>a vector type that matches the size of a SVE vector</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>a vector type that matches the size of a SVE vector</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>acc</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smesmopa_2way-arm_smesmopa2wayop><code>arm_sme.smopa_2way</code> (arm_sme::SMopa2WayOp)&nbsp;<a class=headline-hash href=#arm_smesmopa_2way-arm_smesmopa2wayop>¶</a></h3><p><em>Signed integer sum of 2 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.smopa_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smopa_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smefmopa_2way-arm_smefmopa2wayop>fmopa_2way</a> for a detailed
description of 2-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SMOPA--2-way---Signed-integer-sum-of-outer-products-and-accumulate->SMOPA (2-way)</a></td><td>+sme2</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values</td></tr></tbody></table><h3 id=arm_smesmopa_4way-arm_smesmopa4wayop><code>arm_sme.smopa_4way</code> (arm_sme::SMopa4WayOp)&nbsp;<a class=headline-hash href=#arm_smesmopa_4way-arm_smesmopa4wayop>¶</a></h3><p><em>Signed integer sum of 4 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.smopa_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>This operation represents a sum of 4 widened outer products. It takes 2 1-D
scalable vectors as input and a 2-D scalable vector (ZA tile) as output.</p><p>For example (i8 to i32):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>The <code>lhs</code> encodes a matrix of shape SVLSx4 and the <code>rhs</code> a matrix of
4xSVLS, where SVLS (spec [1], section B2.1) is the number of 32-bit
elements in a vector of SVL bits. To illustrate, below is a breakdown of
this operation for i8 to i32, SVL=128 (i.e., vscale=1):</p><pre tabindex=0><code>                                    LHS
          [A0 A1 A2 A3 A4 A5 A6 A7 A8 A9 A10 A11 A12 A15 A14 A15]

                                    RHS
          [B0 B1 B2 B3 B4 B5 B6 B7 B8 B9 B10 B11 B12 B13 B14 B15]

----------------------------------------------------------------------------

                              implicit layout

                [A0   A1  A2  A3]    |    [B0 B4  B8 B12]
                [A4   A5  A6  A7]    |    [B1 B5  B9 B13]
                [A8   A9 A10 A11]    |    [B2 B6 B10 B14]
                [A12 A13 A14 A15]    |    [B3 B7 B11 B15]

----------------------------------------------------------------------------

                              4 outer products

             Acol0 ⊗ Brow0           |            Acol1 ⊗ Brow1
             -------------           |            -------------
                                     |
         [B0 B4 B8 B12]              |        [B1 B5 B9 B13]
                                     |
   [A0   [ A0B0  A0B4  A0B8  A0B12]  |  [A1   [ A1B1  A1B5  A1B9  A1B13]
    A4   [ A4B0  A4B4  A4B8  A4B12]  |   A5   [ A5B1  A5B5  A5B9  A5B13]
    A8   [ A8B0  A8B4  A8B8  A8B12]  |   A9   [ A9B1  A9B5  A9B9  A9B13]
    A12] [A12B0 A12B4 A12B8 A12B12]  |   A13] [A13B1 A13B5 A13B9 A13B13]
                                     |
             Acol2 ⊗ Brow2           |            Acol3 ⊗ Brow3
             -------------           |            -------------
                                     |
         [B2, B6, B10, B14]          |        [B3 B7 B11 B15]
                                     |
   [A2   [ A2B2  A2B6  A2B10  A2B14] |  [A3   [ A3B3  A3B7  A3B11  A3B15]
    A6   [ A6B2  A6B6  A6B10  A6B14] |   A7   [ A7B3  A7B7  A7B11  A7B15]
    A10  [A10B2 A10B6 A10B10 A10B14] |   A11  [A11B3 A11B7 A11B11 A11B15]
    A14] [A14B2 A14B6 A14B10 A14B14] |   A15] [A15B3 A15B7 A15B11 A15B15]
                                     |

----------------------------------------------------------------------------

                          sum of 4 outer products

       Acol0 ⊗ Brow0 + Acol1 ⊗ Brow1 + Acol2 ⊗ Brow2 + Acol3 ⊗ Brow3

 [ A0B0 +  A1B1 +  A2B2 +  A3B3 ... ...  A0B12 +  A1B13 +  A2B14 +  A3B15]
 [ A4B0 +  A5B1 +  A6B2 +  A7B3 ... ...  A4B12 +  A5B13 +  A6B14 +  A7B15]
 [ A8B0 +  A9B1 + A10B2 + A11B3 ... ...  A8B12 +  A9B13 + A10B14 + A11B15]
 [A12B0 + A13B1 + A14B2 + A15B3 ... ... A12B12 + A13B13 + A14B14 + A15B15]

----------------------------------------------------------------------------
</code></pre><p>This operation enables the folding of 4 outer products chained via the
accumulator into a single outer product.</p><p>For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%a0_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%a0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b0_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%b0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%a1_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%a1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b1_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%b1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%a2_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%a2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b2_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%b2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%a3_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%a3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%b3_ext</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%b3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a0_ext</span><span class=p>,</span> <span class=nv>%b0_ext</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a1_ext</span><span class=p>,</span> <span class=nv>%b1_ext</span> acc<span class=p>(</span><span class=nv>%0</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%2</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a2_ext</span><span class=p>,</span> <span class=nv>%b2_ext</span> acc<span class=p>(</span><span class=nv>%1</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arm_sme<span class=p>.</span>outerproduct <span class=nv>%a3_ext</span><span class=p>,</span> <span class=nv>%b3_ext</span> acc<span class=p>(</span><span class=nv>%2</span><span class=p>)</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>The 4 outer products in the example above can be fused into a single outer
product as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%lhs0</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%a0</span><span class=p>,</span> <span class=nv>%a2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%lhs1</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%a1</span><span class=p>,</span> <span class=nv>%a3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%lhs</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%lhs0</span><span class=p>,</span> <span class=nv>%lhs1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%rhs0</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%b0</span><span class=p>,</span> <span class=nv>%b2</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%rhs1</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%b1</span><span class=p>,</span> <span class=nv>%b3</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%rhs</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>interleave <span class=nv>%rhs0</span><span class=p>,</span> <span class=nv>%rhs1</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi8<span class=p>&gt;</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>smopa_4way <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>This is implemented in the <code>-arm-sme-outer-product-fusion</code> pass.</p><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SMOPA--4-way---Signed-integer-sum-of-outer-products-and-accumulate->SMOPA (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smesmops_2way-arm_smesmops2wayop><code>arm_sme.smops_2way</code> (arm_sme::SMops2WayOp)&nbsp;<a class=headline-hash href=#arm_smesmops_2way-arm_smesmops2wayop>¶</a></h3><p><em>Signed integer sum of 2 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.smops_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smops_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smefmopa_2way-arm_smefmopa2wayop>fmopa_2way</a> for a detailed
description of 2-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SMOPS--2-way---Signed-integer-sum-of-outer-products-and-subtract->SMOPS (2-way)</a></td><td>+sme2</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values</td></tr></tbody></table><h3 id=arm_smesmops_4way-arm_smesmops4wayop><code>arm_sme.smops_4way</code> (arm_sme::SMops4WayOp)&nbsp;<a class=headline-hash href=#arm_smesmops_4way-arm_smesmops4wayop>¶</a></h3><p><em>Signed integer sum of 4 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.smops_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Equivalent to <code>smopa_4way</code> but outer products are subtracted from
destination <code>result</code>.</p><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>smops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SMOPS--4-way---Signed-integer-sum-of-outer-products-and-subtract->SMOPS (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smestore_tile_slice-arm_smestoretilesliceop><code>arm_sme.store_tile_slice</code> (arm_sme::StoreTileSliceOp)&nbsp;<a class=headline-hash href=#arm_smestore_tile_slice-arm_smestoretilesliceop>¶</a></h3><p><em>Tile slice store operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.store_tile_slice` $tile `,` $tile_slice_index `,` $mask `,` $base `[` $indices `]` (`layout` `` $layout^)?
              attr-dict `:` type($base) `,` type($mask) `,` type($tile)
</code></pre><p>Stores a 1D tile slice from a 2D SME &ldquo;virtual tile&rdquo; into memory. The tile
slice is defined by the dimension of the 2D scalable vector type pointed by
the index. A tile slice index describes where in the input tile the tile
slice is stored from. An optional tile slice layout attribute specifies
whether the tile slice being stored from the given index is horizontal
(default) or vertical.</p><p>The slice of memory written is defined by a base and indices and must be
contiguous. The memref must be either rank 1 or rank 2, have dynamic
dimensions since the operation is scalable, and the element type must be a
scalar that matches the element type of the input tile.</p><p>The provided <code>mask</code> is used to specify which elements of the tile slice
will be stored.</p><p>Example 1: Store vector&lt;[16]xi8> horizontal (default) tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Store vector&lt;[4]xf32> vertical tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Store a vector&lt;[1]xi128> vertical tile slice from tile at given index to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>store_tile_slice <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%tile_slice_index</span><span class=p>,</span> <span class=nv>%mask</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]</span>xi1<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Interfaces: <code>ArmSMETileOpInterface</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile</code></td><td>a vector type that fits into a SME tile</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>index</td></tr><tr><td style=text-align:center><code>mask</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>base</code></td><td>memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr></tbody></table><h3 id=arm_smestreaming_vl-arm_smestreamingvlop><code>arm_sme.streaming_vl</code> (arm_sme::StreamingVLOp)&nbsp;<a class=headline-hash href=#arm_smestreaming_vl-arm_smestreamingvlop>¶</a></h3><p><em>Query the streaming vector length</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.streaming_vl` $type_size attr-dict
</code></pre><p>This operation returns the streaming vector length (SVL) for a given type
size. Unlike <code>vector.vscale</code> the value returned is invariant to the
streaming mode.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Streaming vector length in:
</span></span></span><span class=line><span class=cl><span class=c>// - bytes (8-bit, SVL.B)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%svl_b</span> <span class=p>=</span> arm_sme<span class=p>.</span>streaming_vl <span class=p>&lt;</span>byte<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// - half words (16-bit, SVL.H)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%svl_h</span> <span class=p>=</span> arm_sme<span class=p>.</span>streaming_vl <span class=p>&lt;</span>half<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// - words (32-bit, SVL.W)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%svl_w</span> <span class=p>=</span> arm_sme<span class=p>.</span>streaming_vl <span class=p>&lt;</span>word<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=c>// - double words (64-bit, SVL.D)
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%svl_d</span> <span class=p>=</span> arm_sme<span class=p>.</span>streaming_vl <span class=p>&lt;</span>double<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>type_size</code></td><td>::mlir::arm_sme::TypeSizeAttr</td><td>Size of a vector element type</td></tr></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>«unnamed»</td><td>index</td></tr></tbody></table><h3 id=arm_smesumopa_4way-arm_smesumopa4wayop><code>arm_sme.sumopa_4way</code> (arm_sme::SuMopa4WayOp)&nbsp;<a class=headline-hash href=#arm_smesumopa_4way-arm_smesumopa4wayop>¶</a></h3><p><em>Signed by unsigned integer sum of 4 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.sumopa_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>sumopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>sumopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SUMOPA--Signed-by-unsigned-integer-sum-of-outer-products-and-accumulate->SUMOPA (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smesumops_4way-arm_smesumops4wayop><code>arm_sme.sumops_4way</code> (arm_sme::SuMops4WayOp)&nbsp;<a class=headline-hash href=#arm_smesumops_4way-arm_smesumops4wayop>¶</a></h3><p><em>Signed by unsigned integer sum of 4 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.sumops_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>sumops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>sumops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/SUMOPS--Signed-by-unsigned-integer-sum-of-outer-products-and-subtract->SUMOPS (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smetile_load-arm_smetileloadop><code>arm_sme.tile_load</code> (arm_sme::TileLoadOp)&nbsp;<a class=headline-hash href=#arm_smetile_load-arm_smetileloadop>¶</a></h3><p><em>Tile load operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.tile_load` $base `[` $indices `]` (`,` $padding `,` $mask^)? (`layout` `` $layout^)?attr-dict `:` type($base) `,` type($result)
</code></pre><p>Loads a 2D SME &ldquo;virtual tile&rdquo; from memory defined by a base and indices,
with the shape defined by the 2D scalable vector type of the result tile.
An optional tile slice layout attribute specifies whether the slices of the
tile being loaded are horizontal (default) or vertical. The slice of memory
must be contiguous. The memref must be either rank 1 or rank 2 with dynamic
dimensions, since the operation is scalable, and the element type must be a
scalar that matches the element type of the result.</p><p>An optional SSA value <code>padding</code> of the same elemental type as the MemRef is
provided to specify a fallback value in the case of masking.</p><p>An optional SSA value <code>mask</code> may be specified to mask out elements read
from the MemRef. The <code>mask</code> type is an <code>i1</code> vector with a shape that
matches how elements are read from the MemRef. Elements whose corresponding
mask element is <code>0</code> are masked out and replaced with <code>padding</code>.</p><p>If either <code>padding</code> or <code>mask</code> are specified, both must be specified.</p><p>Example 1: Load an 8-bit element ZA tile with horizontal layout (default) from memory (ZA0.B).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Load a FP 32-bit element ZA tile with vertical layout from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Load a 128-bit element ZA tile with horizontal layout (default) from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>horizontal<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 4: Masked load of int 32-bit element ZA tile with horizontal layout (default) from memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%tile</span> <span class=p>=</span> arm_sme<span class=p>.</span>tile_load <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>],</span> <span class=nv>%pad</span><span class=p>,</span> <span class=nv>%mask</span> <span class=p>:</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>base</code></td><td>2D memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>padding</code></td><td>any type</td></tr><tr><td style=text-align:center><code>mask</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h3 id=arm_smetile_store-arm_smetilestoreop><code>arm_sme.tile_store</code> (arm_sme::TileStoreOp)&nbsp;<a class=headline-hash href=#arm_smetile_store-arm_smetilestoreop>¶</a></h3><p><em>Tile store operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.tile_store` $valueToStore `,` $base `[` $indices `]` (`,` $mask^)? (`layout` `` $layout^)?attr-dict `:` type($base) `,` type($valueToStore)
</code></pre><p>Stores a 2D SME &ldquo;virtual tile&rdquo; to memory defined by a base and indices,
with the shape defined by the 2D scalable vector type of the tile being
stored. An optional tile slice layout attribute specifies whether the
slices of the tile being stored are horizontal (default) or vertical. The
slice of memory must be contiguous. The memref must be either rank 1 or
rank 2 with dynamic dimensions, since the operation is scalable, and the
element type must be a scalar that matches the element type of the result.</p><p>An optional <code>mask</code> may be provided, the shape of which corresponds to the
<code>tile</code>, and selects which elements of the tile will be stored.</p><p>Example 1: Store an 8-bit element ZA tile with horizontal (default) layout to memory (ZA0.B).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Store a FP 32-bit element ZA tile with vertical layout to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 3: Store a 128-bit element ZA tile with horizontal (default) layout to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>]</span> layout<span class=p>&lt;</span>horizontal<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>1</span><span class=p>]x[</span><span class=m>1</span><span class=p>]</span>xi128<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>i128</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 4: Masked store a int 32-bit element ZA tile with vertical layout to memory.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arm_sme<span class=p>.</span>tile_store <span class=nv>%tile</span><span class=p>,</span> <span class=nv>%base</span><span class=p>[</span><span class=nv>%c0</span><span class=p>,</span> <span class=nv>%c0</span><span class=p>],</span> <span class=nv>%mask</span> layout<span class=p>&lt;</span>vertical<span class=p>&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xf32<span class=p>&gt;,</span> <span class=kt>memref</span><span class=p>&lt;</span><span class=m>?x?x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>layout</code></td><td>::mlir::arm_sme::TileSliceLayoutAttr</td><td>Layout of a tile slice</td></tr></table><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>valueToStore</code></td><td>a vector type that fits into a SME tile</td></tr><tr><td style=text-align:center><code>base</code></td><td>2D memref of any type values</td></tr><tr><td style=text-align:center><code>indices</code></td><td>variadic of index</td></tr><tr><td style=text-align:center><code>mask</code></td><td>vector of any type values</td></tr></tbody></table><h3 id=arm_smeumopa_2way-arm_smeumopa2wayop><code>arm_sme.umopa_2way</code> (arm_sme::UMopa2WayOp)&nbsp;<a class=headline-hash href=#arm_smeumopa_2way-arm_smeumopa2wayop>¶</a></h3><p><em>Unsiged integer sum of 2 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.umopa_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umopa_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smefmopa_2way-arm_smefmopa2wayop>fmopa_2way</a> for a detailed
description of 2-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/UMOPA--2-way---Unsigned-integer-sum-of-outer-products-and-accumulate->UMOPA (2-way)</a></td><td>+sme2</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values</td></tr></tbody></table><h3 id=arm_smeumopa_4way-arm_smeumopa4wayop><code>arm_sme.umopa_4way</code> (arm_sme::UMopa4WayOp)&nbsp;<a class=headline-hash href=#arm_smeumopa_4way-arm_smeumopa4wayop>¶</a></h3><p><em>Unsigned integer sum of 4 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.umopa_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/UMOPA--4-way---Unsigned-integer-sum-of-outer-products-and-accumulate->UMOPA (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smeumops_2way-arm_smeumops2wayop><code>arm_sme.umops_2way</code> (arm_sme::UMops2WayOp)&nbsp;<a class=headline-hash href=#arm_smeumops_2way-arm_smeumops2wayop>¶</a></h3><p><em>Unsiged integer sum of 2 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.umops_2way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umops_2way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smefmopa_2way-arm_smefmopa2wayop>fmopa_2way</a> for a detailed
description of 2-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/UMOPS--2-way---Unsigned-integer-sum-of-outer-products-and-subtract->UMOPS (2-way)</a></td><td>+sme2</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values</td></tr></tbody></table><h3 id=arm_smeumops_4way-arm_smeumops4wayop><code>arm_sme.umops_4way</code> (arm_sme::UMops4WayOp)&nbsp;<a class=headline-hash href=#arm_smeumops_4way-arm_smeumops4wayop>¶</a></h3><p><em>Unsigned integer sum of 4 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.umops_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>umops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/UMOPS--4-way---Unsigned-integer-sum-of-outer-products-and-subtract->UMOPS (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smeusmopa_4way-arm_smeusmopa4wayop><code>arm_sme.usmopa_4way</code> (arm_sme::UsMopa4WayOp)&nbsp;<a class=headline-hash href=#arm_smeusmopa_4way-arm_smeusmopa4wayop>¶</a></h3><p><em>Unsigned by signed integer sum of 4 outer products and accumulate</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.usmopa_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>usmopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>usmopa_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/USMOPA--Unsigned-by-signed-integer-sum-of-outer-products-and-accumulate->USMOPA (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smeusmops_4way-arm_smeusmops4wayop><code>arm_sme.usmops_4way</code> (arm_sme::UsMops4WayOp)&nbsp;<a class=headline-hash href=#arm_smeusmops_4way-arm_smeusmops4wayop>¶</a></h3><p><em>Unsigned by signed integer sum of 4 outer products and subtract</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.usmops_4way` $lhs `,` $rhs
              oilist(
              `acc` `` `(` $acc `)`
              | `masks` `` `(` $lhsMask `,` $rhsMask `)`
              ) attr-dict `:` type($lhs) `,` type($rhs) `into` type($result)
</code></pre><p>Example: I8 to I32</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>usmops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>4</span><span class=p>]x[</span><span class=m>4</span><span class=p>]</span>xi32<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example: I16 to I64</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%result</span> <span class=p>=</span> arm_sme<span class=p>.</span>usmops_4way <span class=err>$</span>lhs<span class=p>,</span> <span class=err>$</span>rhs <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>8</span><span class=p>]</span>xi16<span class=p>&gt;</span> into <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Refer to
<a href=#arm_smesmopa_4way-arm_smesmopa4wayop>smopa_4way</a> for a
detailed description of 4-way outer products.</p><table><thead><tr><th>Spec</th><th>Features</th></tr></thead><tbody><tr><td><a href=https://developer.arm.com/documentation/ddi0602/2023-09/SME-Instructions/USMOPS--Unsigned-by-signed-integer-sum-of-outer-products-and-subtract->USMOPS (4-way)</a></td><td>+sme (32-bit), +sme-i16i64 (64-bit)</td></tr></tbody></table><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>AttrSizedOperandSegments</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>of ranks 1scalable vector of 8-bit signless integer values of length 16 or of ranks 1scalable vector of 16-bit signless integer values of length 8</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>lhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>rhsMask</code></td><td>vector of any type values</td></tr><tr><td style=text-align:center><code>acc</code></td><td>vector of any type values</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>vector&lt;[4]x[4]xi32> of 32-bit signless integer values or vector&lt;[2]x[2]xi64> of 64-bit signless integer values</td></tr></tbody></table><h3 id=arm_smezero-arm_smezeroop><code>arm_sme.zero</code> (arm_sme::ZeroOp)&nbsp;<a class=headline-hash href=#arm_smezero-arm_smezeroop>¶</a></h3><p><em>Creates a zero-initialized value of SME virtual tile type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arm_sme.zero` attr-dict `:` type($res)
</code></pre><p>Creates a new SME &ldquo;virtual tile&rdquo; value within a function. The contents of
the tile returned from this operation are zero-initialized.</p><p>Example 1: Zero an 8-bit element ZA tile.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>zero <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>16</span><span class=p>]x[</span><span class=m>16</span><span class=p>]</span>xi8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Example 2: Zero a 64-bit element ZA tile.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%0</span> <span class=p>=</span> arm_sme<span class=p>.</span>zero <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;[</span><span class=m>2</span><span class=p>]x[</span><span class=m>2</span><span class=p>]</span>xi64<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code></p><p>Interfaces: <code>ArmSMETileOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>a vector type that fits into a SME tile</td></tr></tbody></table><h2 id=operations-for-llvm-ir-intrinsics>Operations for LLVM IR Intrinsics&nbsp;<a class=headline-hash href=#operations-for-llvm-ir-intrinsics>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/ArmSME/IR/ArmSMEIntrinsicOps.td>source</a></p><h3 id=arm_smeintrcntsb-arm_smeaarch64_sme_cntsb><code>arm_sme.intr.cntsb</code> (arm_sme::aarch64_sme_cntsb)&nbsp;<a class=headline-hash href=#arm_smeintrcntsb-arm_smeaarch64_sme_cntsb>¶</a></h3><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrcntsd-arm_smeaarch64_sme_cntsd><code>arm_sme.intr.cntsd</code> (arm_sme::aarch64_sme_cntsd)&nbsp;<a class=headline-hash href=#arm_smeintrcntsd-arm_smeaarch64_sme_cntsd>¶</a></h3><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrcntsh-arm_smeaarch64_sme_cntsh><code>arm_sme.intr.cntsh</code> (arm_sme::aarch64_sme_cntsh)&nbsp;<a class=headline-hash href=#arm_smeintrcntsh-arm_smeaarch64_sme_cntsh>¶</a></h3><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrcntsw-arm_smeaarch64_sme_cntsw><code>arm_sme.intr.cntsw</code> (arm_sme::aarch64_sme_cntsw)&nbsp;<a class=headline-hash href=#arm_smeintrcntsw-arm_smeaarch64_sme_cntsw>¶</a></h3><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz><code>arm_sme.intr.ld1b.horiz</code> (arm_sme::aarch64_sme_ld1b_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1bhoriz-arm_smeaarch64_sme_ld1b_horiz>¶</a></h3><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert><code>arm_sme.intr.ld1b.vert</code> (arm_sme::aarch64_sme_ld1b_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1bvert-arm_smeaarch64_sme_ld1b_vert>¶</a></h3><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz><code>arm_sme.intr.ld1d.horiz</code> (arm_sme::aarch64_sme_ld1d_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1dhoriz-arm_smeaarch64_sme_ld1d_horiz>¶</a></h3><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert><code>arm_sme.intr.ld1d.vert</code> (arm_sme::aarch64_sme_ld1d_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1dvert-arm_smeaarch64_sme_ld1d_vert>¶</a></h3><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz><code>arm_sme.intr.ld1h.horiz</code> (arm_sme::aarch64_sme_ld1h_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1hhoriz-arm_smeaarch64_sme_ld1h_horiz>¶</a></h3><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert><code>arm_sme.intr.ld1h.vert</code> (arm_sme::aarch64_sme_ld1h_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1hvert-arm_smeaarch64_sme_ld1h_vert>¶</a></h3><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz><code>arm_sme.intr.ld1q.horiz</code> (arm_sme::aarch64_sme_ld1q_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1qhoriz-arm_smeaarch64_sme_ld1q_horiz>¶</a></h3><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert><code>arm_sme.intr.ld1q.vert</code> (arm_sme::aarch64_sme_ld1q_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1qvert-arm_smeaarch64_sme_ld1q_vert>¶</a></h3><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz><code>arm_sme.intr.ld1w.horiz</code> (arm_sme::aarch64_sme_ld1w_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrld1whoriz-arm_smeaarch64_sme_ld1w_horiz>¶</a></h3><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert><code>arm_sme.intr.ld1w.vert</code> (arm_sme::aarch64_sme_ld1w_vert)&nbsp;<a class=headline-hash href=#arm_smeintrld1wvert-arm_smeaarch64_sme_ld1w_vert>¶</a></h3><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>load_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrmopa-arm_smeaarch64_sme_mopa><code>arm_sme.intr.mopa</code> (arm_sme::aarch64_sme_mopa)&nbsp;<a class=headline-hash href=#arm_smeintrmopa-arm_smeaarch64_sme_mopa>¶</a></h3><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide><code>arm_sme.intr.mopa.wide</code> (arm_sme::aarch64_sme_mopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrmopawide-arm_smeaarch64_sme_mopa_wide>¶</a></h3><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrmops-arm_smeaarch64_sme_mops><code>arm_sme.intr.mops</code> (arm_sme::aarch64_sme_mops)&nbsp;<a class=headline-hash href=#arm_smeintrmops-arm_smeaarch64_sme_mops>¶</a></h3><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide><code>arm_sme.intr.mops.wide</code> (arm_sme::aarch64_sme_mops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrmopswide-arm_smeaarch64_sme_mops_wide>¶</a></h3><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrreadhoriz-arm_smeaarch64_sme_read_horiz><code>arm_sme.intr.read.horiz</code> (arm_sme::aarch64_sme_read_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrreadhoriz-arm_smeaarch64_sme_read_horiz>¶</a></h3><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>a vector type that matches the size of a SVE vector</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrreadvert-arm_smeaarch64_sme_read_vert><code>arm_sme.intr.read.vert</code> (arm_sme::aarch64_sme_read_vert)&nbsp;<a class=headline-hash href=#arm_smeintrreadvert-arm_smeaarch64_sme_read_vert>¶</a></h3><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>vector</code></td><td>a vector type that matches the size of a SVE vector</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>res</code></td><td>LLVM dialect-compatible type</td></tr></tbody></table><h3 id=arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide><code>arm_sme.intr.smopa.wide</code> (arm_sme::aarch64_sme_smopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsmopawide-arm_smeaarch64_sme_smopa_wide>¶</a></h3><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrsmopaza32-arm_smeaarch64_sme_smopa_za32><code>arm_sme.intr.smopa.za32</code> (arm_sme::aarch64_sme_smopa_za32)&nbsp;<a class=headline-hash href=#arm_smeintrsmopaza32-arm_smeaarch64_sme_smopa_za32>¶</a></h3><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide><code>arm_sme.intr.smops.wide</code> (arm_sme::aarch64_sme_smops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsmopswide-arm_smeaarch64_sme_smops_wide>¶</a></h3><h4 id=attributes-26>Attributes:&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrsmopsza32-arm_smeaarch64_sme_smops_za32><code>arm_sme.intr.smops.za32</code> (arm_sme::aarch64_sme_smops_za32)&nbsp;<a class=headline-hash href=#arm_smeintrsmopsza32-arm_smeaarch64_sme_smops_za32>¶</a></h3><h4 id=attributes-27>Attributes:&nbsp;<a class=headline-hash href=#attributes-27>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz><code>arm_sme.intr.st1b.horiz</code> (arm_sme::aarch64_sme_st1b_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1bhoriz-arm_smeaarch64_sme_st1b_horiz>¶</a></h3><h4 id=attributes-28>Attributes:&nbsp;<a class=headline-hash href=#attributes-28>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert><code>arm_sme.intr.st1b.vert</code> (arm_sme::aarch64_sme_st1b_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1bvert-arm_smeaarch64_sme_st1b_vert>¶</a></h3><h4 id=attributes-29>Attributes:&nbsp;<a class=headline-hash href=#attributes-29>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz><code>arm_sme.intr.st1d.horiz</code> (arm_sme::aarch64_sme_st1d_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1dhoriz-arm_smeaarch64_sme_st1d_horiz>¶</a></h3><h4 id=attributes-30>Attributes:&nbsp;<a class=headline-hash href=#attributes-30>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert><code>arm_sme.intr.st1d.vert</code> (arm_sme::aarch64_sme_st1d_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1dvert-arm_smeaarch64_sme_st1d_vert>¶</a></h3><h4 id=attributes-31>Attributes:&nbsp;<a class=headline-hash href=#attributes-31>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz><code>arm_sme.intr.st1h.horiz</code> (arm_sme::aarch64_sme_st1h_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1hhoriz-arm_smeaarch64_sme_st1h_horiz>¶</a></h3><h4 id=attributes-32>Attributes:&nbsp;<a class=headline-hash href=#attributes-32>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert><code>arm_sme.intr.st1h.vert</code> (arm_sme::aarch64_sme_st1h_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1hvert-arm_smeaarch64_sme_st1h_vert>¶</a></h3><h4 id=attributes-33>Attributes:&nbsp;<a class=headline-hash href=#attributes-33>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz><code>arm_sme.intr.st1q.horiz</code> (arm_sme::aarch64_sme_st1q_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1qhoriz-arm_smeaarch64_sme_st1q_horiz>¶</a></h3><h4 id=attributes-34>Attributes:&nbsp;<a class=headline-hash href=#attributes-34>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert><code>arm_sme.intr.st1q.vert</code> (arm_sme::aarch64_sme_st1q_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1qvert-arm_smeaarch64_sme_st1q_vert>¶</a></h3><h4 id=attributes-35>Attributes:&nbsp;<a class=headline-hash href=#attributes-35>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz><code>arm_sme.intr.st1w.horiz</code> (arm_sme::aarch64_sme_st1w_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrst1whoriz-arm_smeaarch64_sme_st1w_horiz>¶</a></h3><h4 id=attributes-36>Attributes:&nbsp;<a class=headline-hash href=#attributes-36>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-50>Operands:&nbsp;<a class=headline-hash href=#operands-50>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert><code>arm_sme.intr.st1w.vert</code> (arm_sme::aarch64_sme_st1w_vert)&nbsp;<a class=headline-hash href=#arm_smeintrst1wvert-arm_smeaarch64_sme_st1w_vert>¶</a></h3><h4 id=attributes-37>Attributes:&nbsp;<a class=headline-hash href=#attributes-37>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-51>Operands:&nbsp;<a class=headline-hash href=#operands-51>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrstr-arm_smeaarch64_sme_str><code>arm_sme.intr.str</code> (arm_sme::aarch64_sme_str)&nbsp;<a class=headline-hash href=#arm_smeintrstr-arm_smeaarch64_sme_str>¶</a></h3><h4 id=operands-52>Operands:&nbsp;<a class=headline-hash href=#operands-52>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>index</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>store_address</code></td><td>LLVM pointer type</td></tr><tr><td style=text-align:center><code>offset</code></td><td>32-bit signless integer</td></tr></tbody></table><h3 id=arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide><code>arm_sme.intr.sumopa.wide</code> (arm_sme::aarch64_sme_sumopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsumopawide-arm_smeaarch64_sme_sumopa_wide>¶</a></h3><h4 id=attributes-38>Attributes:&nbsp;<a class=headline-hash href=#attributes-38>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-53>Operands:&nbsp;<a class=headline-hash href=#operands-53>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide><code>arm_sme.intr.sumops.wide</code> (arm_sme::aarch64_sme_sumops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrsumopswide-arm_smeaarch64_sme_sumops_wide>¶</a></h3><h4 id=attributes-39>Attributes:&nbsp;<a class=headline-hash href=#attributes-39>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-54>Operands:&nbsp;<a class=headline-hash href=#operands-54>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide><code>arm_sme.intr.umopa.wide</code> (arm_sme::aarch64_sme_umopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrumopawide-arm_smeaarch64_sme_umopa_wide>¶</a></h3><h4 id=attributes-40>Attributes:&nbsp;<a class=headline-hash href=#attributes-40>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-55>Operands:&nbsp;<a class=headline-hash href=#operands-55>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrumopaza32-arm_smeaarch64_sme_umopa_za32><code>arm_sme.intr.umopa.za32</code> (arm_sme::aarch64_sme_umopa_za32)&nbsp;<a class=headline-hash href=#arm_smeintrumopaza32-arm_smeaarch64_sme_umopa_za32>¶</a></h3><h4 id=attributes-41>Attributes:&nbsp;<a class=headline-hash href=#attributes-41>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-56>Operands:&nbsp;<a class=headline-hash href=#operands-56>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide><code>arm_sme.intr.umops.wide</code> (arm_sme::aarch64_sme_umops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrumopswide-arm_smeaarch64_sme_umops_wide>¶</a></h3><h4 id=attributes-42>Attributes:&nbsp;<a class=headline-hash href=#attributes-42>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-57>Operands:&nbsp;<a class=headline-hash href=#operands-57>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrumopsza32-arm_smeaarch64_sme_umops_za32><code>arm_sme.intr.umops.za32</code> (arm_sme::aarch64_sme_umops_za32)&nbsp;<a class=headline-hash href=#arm_smeintrumopsza32-arm_smeaarch64_sme_umops_za32>¶</a></h3><h4 id=attributes-43>Attributes:&nbsp;<a class=headline-hash href=#attributes-43>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-58>Operands:&nbsp;<a class=headline-hash href=#operands-58>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide><code>arm_sme.intr.usmopa.wide</code> (arm_sme::aarch64_sme_usmopa_wide)&nbsp;<a class=headline-hash href=#arm_smeintrusmopawide-arm_smeaarch64_sme_usmopa_wide>¶</a></h3><h4 id=attributes-44>Attributes:&nbsp;<a class=headline-hash href=#attributes-44>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-59>Operands:&nbsp;<a class=headline-hash href=#operands-59>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide><code>arm_sme.intr.usmops.wide</code> (arm_sme::aarch64_sme_usmops_wide)&nbsp;<a class=headline-hash href=#arm_smeintrusmopswide-arm_smeaarch64_sme_usmops_wide>¶</a></h3><h4 id=attributes-45>Attributes:&nbsp;<a class=headline-hash href=#attributes-45>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-60>Operands:&nbsp;<a class=headline-hash href=#operands-60>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_predicate</code></td><td>a vector type that is a supported predicate for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>lhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr><tr><td style=text-align:center><code>rhs_vector</code></td><td>a vector type that is a supported input for the SME MOP instructions</td></tr></tbody></table><h3 id=arm_smeintrwritehoriz-arm_smeaarch64_sme_write_horiz><code>arm_sme.intr.write.horiz</code> (arm_sme::aarch64_sme_write_horiz)&nbsp;<a class=headline-hash href=#arm_smeintrwritehoriz-arm_smeaarch64_sme_write_horiz>¶</a></h3><h4 id=attributes-46>Attributes:&nbsp;<a class=headline-hash href=#attributes-46>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-61>Operands:&nbsp;<a class=headline-hash href=#operands-61>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>vector</code></td><td>a vector type that matches the size of a SVE vector</td></tr></tbody></table><h3 id=arm_smeintrwritevert-arm_smeaarch64_sme_write_vert><code>arm_sme.intr.write.vert</code> (arm_sme::aarch64_sme_write_vert)&nbsp;<a class=headline-hash href=#arm_smeintrwritevert-arm_smeaarch64_sme_write_vert>¶</a></h3><h4 id=attributes-47>Attributes:&nbsp;<a class=headline-hash href=#attributes-47>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_id</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><h4 id=operands-62>Operands:&nbsp;<a class=headline-hash href=#operands-62>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>tile_slice_index</code></td><td>32-bit signless integer</td></tr><tr><td style=text-align:center><code>predicate</code></td><td>a vector type that matches the size of a SVE predicate</td></tr><tr><td style=text-align:center><code>vector</code></td><td>a vector type that matches the size of a SVE vector</td></tr></tbody></table><h3 id=arm_smeintrzero-arm_smeaarch64_sme_zero><code>arm_sme.intr.zero</code> (arm_sme::aarch64_sme_zero)&nbsp;<a class=headline-hash href=#arm_smeintrzero-arm_smeaarch64_sme_zero>¶</a></h3><h4 id=attributes-48>Attributes:&nbsp;<a class=headline-hash href=#attributes-48>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>tile_mask</code></td><td>::mlir::IntegerAttr</td><td>32-bit signless integer attribute</td></tr></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/ArmSVE/ title="'arm_sve' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'arm_sve' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/ title="'async' Dialect">Next - 'async' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>