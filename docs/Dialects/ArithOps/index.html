<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>'arith' Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/ArithOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li><li class=child><a href=/python-bindings/>Python Bindings API docs</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>'arith' Dialect</h1><p>The arith dialect is intended to hold basic integer and floating point
mathematical operations. This includes unary, binary, and ternary arithmetic
ops, bitwise and shift ops, cast ops, and compare ops. Operations in this
dialect also accept vectors and tensors of integers or floats. The dialect
assumes integers are represented by bitvectors with a two&rsquo;s complement
representation. Unless otherwise stated, the operations within this dialect
propagate poison values, i.e., if any of its inputs are poison, then the
output is poison. Unless otherwise stated, operations applied to <code>vector</code>
and <code>tensor</code> values propagates poison elementwise.</p><p><nav id=TableOfContents><ul><li><a href=#operations>Operations</a><ul><li><a href=#arithaddf-arithaddfop><code>arith.addf</code> (arith::AddFOp)</a></li><li><a href=#arithaddi-arithaddiop><code>arith.addi</code> (arith::AddIOp)</a></li><li><a href=#arithaddui_extended-arithadduiextendedop><code>arith.addui_extended</code> (arith::AddUIExtendedOp)</a></li><li><a href=#arithandi-arithandiop><code>arith.andi</code> (arith::AndIOp)</a></li><li><a href=#arithbitcast-arithbitcastop><code>arith.bitcast</code> (arith::BitcastOp)</a></li><li><a href=#arithceildivsi-arithceildivsiop><code>arith.ceildivsi</code> (arith::CeilDivSIOp)</a></li><li><a href=#arithceildivui-arithceildivuiop><code>arith.ceildivui</code> (arith::CeilDivUIOp)</a></li><li><a href=#arithcmpf-arithcmpfop><code>arith.cmpf</code> (arith::CmpFOp)</a></li><li><a href=#arithcmpi-arithcmpiop><code>arith.cmpi</code> (arith::CmpIOp)</a></li><li><a href=#arithconstant-arithconstantop><code>arith.constant</code> (arith::ConstantOp)</a></li><li><a href=#arithdivf-arithdivfop><code>arith.divf</code> (arith::DivFOp)</a></li><li><a href=#arithdivsi-arithdivsiop><code>arith.divsi</code> (arith::DivSIOp)</a></li><li><a href=#arithdivui-arithdivuiop><code>arith.divui</code> (arith::DivUIOp)</a></li><li><a href=#arithextf-arithextfop><code>arith.extf</code> (arith::ExtFOp)</a></li><li><a href=#arithextsi-arithextsiop><code>arith.extsi</code> (arith::ExtSIOp)</a></li><li><a href=#arithextui-arithextuiop><code>arith.extui</code> (arith::ExtUIOp)</a></li><li><a href=#arithfloordivsi-arithfloordivsiop><code>arith.floordivsi</code> (arith::FloorDivSIOp)</a></li><li><a href=#arithfptosi-arithfptosiop><code>arith.fptosi</code> (arith::FPToSIOp)</a></li><li><a href=#arithfptoui-arithfptouiop><code>arith.fptoui</code> (arith::FPToUIOp)</a></li><li><a href=#arithindex_cast-arithindexcastop><code>arith.index_cast</code> (arith::IndexCastOp)</a></li><li><a href=#arithindex_castui-arithindexcastuiop><code>arith.index_castui</code> (arith::IndexCastUIOp)</a></li><li><a href=#arithmaximumf-arithmaximumfop><code>arith.maximumf</code> (arith::MaximumFOp)</a></li><li><a href=#arithmaxnumf-arithmaxnumfop><code>arith.maxnumf</code> (arith::MaxNumFOp)</a></li><li><a href=#arithmaxsi-arithmaxsiop><code>arith.maxsi</code> (arith::MaxSIOp)</a></li><li><a href=#arithmaxui-arithmaxuiop><code>arith.maxui</code> (arith::MaxUIOp)</a></li><li><a href=#arithminimumf-arithminimumfop><code>arith.minimumf</code> (arith::MinimumFOp)</a></li><li><a href=#arithminnumf-arithminnumfop><code>arith.minnumf</code> (arith::MinNumFOp)</a></li><li><a href=#arithminsi-arithminsiop><code>arith.minsi</code> (arith::MinSIOp)</a></li><li><a href=#arithminui-arithminuiop><code>arith.minui</code> (arith::MinUIOp)</a></li><li><a href=#arithmulf-arithmulfop><code>arith.mulf</code> (arith::MulFOp)</a></li><li><a href=#arithmuli-arithmuliop><code>arith.muli</code> (arith::MulIOp)</a></li><li><a href=#arithmulsi_extended-arithmulsiextendedop><code>arith.mulsi_extended</code> (arith::MulSIExtendedOp)</a></li><li><a href=#arithmului_extended-arithmuluiextendedop><code>arith.mului_extended</code> (arith::MulUIExtendedOp)</a></li><li><a href=#arithnegf-arithnegfop><code>arith.negf</code> (arith::NegFOp)</a></li><li><a href=#arithori-arithoriop><code>arith.ori</code> (arith::OrIOp)</a></li><li><a href=#arithremf-arithremfop><code>arith.remf</code> (arith::RemFOp)</a></li><li><a href=#arithremsi-arithremsiop><code>arith.remsi</code> (arith::RemSIOp)</a></li><li><a href=#arithremui-arithremuiop><code>arith.remui</code> (arith::RemUIOp)</a></li><li><a href=#arithscaling_extf-arithscalingextfop><code>arith.scaling_extf</code> (arith::ScalingExtFOp)</a></li><li><a href=#arithscaling_truncf-arithscalingtruncfop><code>arith.scaling_truncf</code> (arith::ScalingTruncFOp)</a></li><li><a href=#arithselect-arithselectop><code>arith.select</code> (arith::SelectOp)</a></li><li><a href=#arithshli-arithshliop><code>arith.shli</code> (arith::ShLIOp)</a></li><li><a href=#arithshrsi-arithshrsiop><code>arith.shrsi</code> (arith::ShRSIOp)</a></li><li><a href=#arithshrui-arithshruiop><code>arith.shrui</code> (arith::ShRUIOp)</a></li><li><a href=#arithsitofp-arithsitofpop><code>arith.sitofp</code> (arith::SIToFPOp)</a></li><li><a href=#arithsubf-arithsubfop><code>arith.subf</code> (arith::SubFOp)</a></li><li><a href=#arithsubi-arithsubiop><code>arith.subi</code> (arith::SubIOp)</a></li><li><a href=#arithtruncf-arithtruncfop><code>arith.truncf</code> (arith::TruncFOp)</a></li><li><a href=#arithtrunci-arithtrunciop><code>arith.trunci</code> (arith::TruncIOp)</a></li><li><a href=#arithuitofp-arithuitofpop><code>arith.uitofp</code> (arith::UIToFPOp)</a></li><li><a href=#arithxori-arithxoriop><code>arith.xori</code> (arith::XOrIOp)</a></li></ul></li><li><a href=#attributes-26>Attributes</a><ul><li><a href=#fastmathflagsattr>FastMathFlagsAttr</a></li><li><a href=#integeroverflowflagsattr>IntegerOverflowFlagsAttr</a></li></ul></li><li><a href=#enums>Enums</a><ul><li><a href=#cmpfpredicate>CmpFPredicate</a></li><li><a href=#cmpipredicate>CmpIPredicate</a></li><li><a href=#integeroverflowflags>IntegerOverflowFlags</a></li><li><a href=#roundingmode>RoundingMode</a></li><li><a href=#atomicrmwkind>AtomicRMWKind</a></li><li><a href=#fastmathflags>FastMathFlags</a></li></ul></li></ul></nav><h2 id=operations>Operations&nbsp;<a class=headline-hash href=#operations>¶</a></h2><p><a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/Dialect/Arith/IR/ArithOps.td>source</a></p><h3 id=arithaddf-arithaddfop><code>arith.addf</code> (arith::AddFOp)&nbsp;<a class=headline-hash href=#arithaddf-arithaddfop>¶</a></h3><p><em>Floating point addition operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.addf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>addf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector addition, e.g. for Intel SSE.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>addf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes>Attributes:&nbsp;<a class=headline-hash href=#attributes>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands>Operands:&nbsp;<a class=headline-hash href=#operands>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results>Results:&nbsp;<a class=headline-hash href=#results>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithaddi-arithaddiop><code>arith.addi</code> (arith::AddIOp)&nbsp;<a class=headline-hash href=#arithaddi-arithaddiop>¶</a></h3><p><em>Integer addition operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.addi` $lhs `,` $rhs (`overflow` `` $overflowFlags^)?
              attr-dict `:` type($result)
</code></pre><p>Performs N-bit addition on the operands. The operands are interpreted as
unsigned bitvectors. The result is represented by a bitvector containing the
mathematical value of the addition modulo 2^n, where <code>n</code> is the bitwidth.
Because <code>arith</code> integers use a two&rsquo;s complement representation, this operation
is applicable on both signed and unsigned integer operands.</p><p>The <code>addi</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar type,
a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for
&ldquo;No Unsigned Wrap&rdquo; and &ldquo;No Signed Wrap&rdquo;, respectively. If the <code>nuw</code> and/or
<code>nsw</code> flags are present, and an unsigned/signed overflow occurs
(respectively), the result is poison.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Scalar addition with overflow flags.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> overflow<span class=p>&lt;</span>nsw<span class=p>,</span> nuw<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>addi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithIntegerOverflowFlagsInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-1>Attributes:&nbsp;<a class=headline-hash href=#attributes-1>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>overflowFlags</code></td><td>::mlir::arith::IntegerOverflowFlagsAttr</td><td>Integer overflow arith flags</td></tr></table><h4 id=operands-1>Operands:&nbsp;<a class=headline-hash href=#operands-1>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-1>Results:&nbsp;<a class=headline-hash href=#results-1>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithaddui_extended-arithadduiextendedop><code>arith.addui_extended</code> (arith::AddUIExtendedOp)&nbsp;<a class=headline-hash href=#arithaddui_extended-arithadduiextendedop>¶</a></h3><p><em>Extended unsigned integer addition operation returning sum and overflow bit</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.addui_extended` $lhs `,` $rhs attr-dict `:` type($sum) `,` type($overflow)
</code></pre><p>Performs (N+1)-bit addition on zero-extended operands. Returns two results:
the N-bit sum (same type as both operands), and the overflow bit
(boolean-like), where <code>1</code> indicates unsigned addition overflow, while <code>0</code>
indicates no overflow.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%sum</span><span class=p>,</span> <span class=nv>%overflow</span> <span class=p>=</span> arith<span class=p>.</span>addui_extended <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span><span class=p>,</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Vector element-wise addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%d</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>addui_extended <span class=nv>%e</span><span class=p>,</span> <span class=nv>%f</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise addition.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>addui_extended <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;,</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-2>Operands:&nbsp;<a class=headline-hash href=#operands-2>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-2>Results:&nbsp;<a class=headline-hash href=#results-2>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>sum</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>overflow</code></td><td>bool-like</td></tr></tbody></table><h3 id=arithandi-arithandiop><code>arith.andi</code> (arith::AndIOp)&nbsp;<a class=headline-hash href=#arithandi-arithandiop>¶</a></h3><p><em>Integer binary and</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.andi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>The <code>andi</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar
type, a vector whose element type is integer, or a tensor of integers. It
has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar integer bitwise and.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>andi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise bitwise integer and.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>andi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise bitwise integer and.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>andi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Idempotent</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-3>Operands:&nbsp;<a class=headline-hash href=#operands-3>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-3>Results:&nbsp;<a class=headline-hash href=#results-3>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithbitcast-arithbitcastop><code>arith.bitcast</code> (arith::BitcastOp)&nbsp;<a class=headline-hash href=#arithbitcast-arithbitcastop>¶</a></h3><p><em>Bitcast between values of equal bit width</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.bitcast` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Bitcast an integer or floating point value to an integer or floating point
value of equal bit width. When operating on vectors, casts elementwise.</p><p>Note that this implements a logical bitcast independent of target
endianness. This allows constant folding without target information and is
consitent with the bitcast constant folders in LLVM (see
<a href=https://github.com/llvm/llvm-project/blob/18c19414eb/llvm/lib/IR/ConstantFold.cpp#L168>https://github.com/llvm/llvm-project/blob/18c19414eb/llvm/lib/IR/ConstantFold.cpp#L168</a>)
For targets where the source and target type have the same endianness (which
is the standard), this cast will also change no bits at runtime, but it may
still require an operation, for example if the machine has different
floating point and integer register files. For targets that have a different
endianness for the source and target types (e.g. float is big-endian and
integer is little-endian) a proper lowering would add operations to swap the
order of words in addition to the bitcast.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-4>Operands:&nbsp;<a class=headline-hash href=#operands-4>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-integer-or-float-like or memref of signless-integer or float</td></tr></tbody></table><h4 id=results-4>Results:&nbsp;<a class=headline-hash href=#results-4>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-integer-or-float-like or memref of signless-integer or float</td></tr></tbody></table><h3 id=arithceildivsi-arithceildivsiop><code>arith.ceildivsi</code> (arith::CeilDivSIOp)&nbsp;<a class=headline-hash href=#arithceildivsi-arithceildivsiop>¶</a></h3><p><em>Signed ceil integer division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.ceildivsi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Signed integer division. Rounds towards positive infinity, i.e. <code>7 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1)
is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the
behavior is undefined if <em>any</em> of its elements are divided by zero or has a
signed division overflow.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar signed integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>ceildivsi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-5>Operands:&nbsp;<a class=headline-hash href=#operands-5>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-5>Results:&nbsp;<a class=headline-hash href=#results-5>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithceildivui-arithceildivuiop><code>arith.ceildivui</code> (arith::CeilDivUIOp)&nbsp;<a class=headline-hash href=#arithceildivui-arithceildivuiop>¶</a></h3><p><em>Unsigned ceil integer division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.ceildivui` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Unsigned integer division. Rounds towards positive infinity. Treats the
leading bit as the most significant, i.e. for <code>i16</code> given two&rsquo;s complement
representation, <code>6 / -2 = 6 / (2^16 - 2) = 1</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and
<code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by
zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar unsigned integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>ceildivui <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-6>Operands:&nbsp;<a class=headline-hash href=#operands-6>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-6>Results:&nbsp;<a class=headline-hash href=#results-6>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithcmpf-arithcmpfop><code>arith.cmpf</code> (arith::CmpFOp)&nbsp;<a class=headline-hash href=#arithcmpf-arithcmpfop>¶</a></h3><p><em>Floating-point comparison operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.cmpf` $predicate `,` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpf</code> operation compares its two operands according to the float
comparison rules and the predicate specified by the respective attribute.
The predicate defines the type of comparison: (un)orderedness, (in)equality
and signed less/greater than (or equal to) as well as predicates that are
always true or false. The operands must have the same type, and this type
must be a float type, or a vector or tensor thereof. The result is an i1,
or a vector/tensor thereof having the same shape as the inputs. Unlike cmpi,
the operands are always treated as signed. The u prefix indicates
<em>unordered</em> comparison, not unsigned comparison, so &ldquo;une&rdquo; means unordered or
not equal. For the sake of readability by humans, custom assembly form for
the operation uses a string-typed attribute for the predicate. The value of
this attribute corresponds to lower-cased name of the predicate constant,
e.g., &ldquo;one&rdquo; means &ldquo;ordered not equal&rdquo;. The string representation of the
attribute is merely a syntactic sugar and is converted to an integer
attribute by the parser.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%r1</span> <span class=p>=</span> arith<span class=p>.</span>cmpf oeq<span class=p>,</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span>
</span></span><span class=line><span class=cl><span class=nv>%r2</span> <span class=p>=</span> arith<span class=p>.</span>cmpf ult<span class=p>,</span> <span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>42x42x</span><span class=k>f64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%r3</span> <span class=p>=</span> <span class=s>&#34;arith.cmpf&#34;</span><span class=p>(</span><span class=nv>%0</span><span class=p>,</span> <span class=nv>%1</span><span class=p>)</span> <span class=p>{</span>predicate<span class=p>:</span> <span class=m>0</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span>f8<span class=p>,</span> f8<span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameTypeOperands</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-2>Attributes:&nbsp;<a class=headline-hash href=#attributes-2>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::arith::CmpFPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</td></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-7>Operands:&nbsp;<a class=headline-hash href=#operands-7>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-7>Results:&nbsp;<a class=headline-hash href=#results-7>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=arithcmpi-arithcmpiop><code>arith.cmpi</code> (arith::CmpIOp)&nbsp;<a class=headline-hash href=#arithcmpi-arithcmpiop>¶</a></h3><p><em>Integer comparison operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.cmpi` $predicate `,` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two
arguments can be integers, vectors or tensors thereof as long as their types
match. The operation produces an i1 for the former case, a vector or a
tensor of i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is
performed. The following comparisons are supported:</p><ul><li>equal (mnemonic: <code>"eq"</code>; integer value: <code>0</code>)</li><li>not equal (mnemonic: <code>"ne"</code>; integer value: <code>1</code>)</li><li>signed less than (mnemonic: <code>"slt"</code>; integer value: <code>2</code>)</li><li>signed less than or equal (mnemonic: <code>"sle"</code>; integer value: <code>3</code>)</li><li>signed greater than (mnemonic: <code>"sgt"</code>; integer value: <code>4</code>)</li><li>signed greater than or equal (mnemonic: <code>"sge"</code>; integer value: <code>5</code>)</li><li>unsigned less than (mnemonic: <code>"ult"</code>; integer value: <code>6</code>)</li><li>unsigned less than or equal (mnemonic: <code>"ule"</code>; integer value: <code>7</code>)</li><li>unsigned greater than (mnemonic: <code>"ugt"</code>; integer value: <code>8</code>)</li><li>unsigned greater than or equal (mnemonic: <code>"uge"</code>; integer value: <code>9</code>)</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or
tensor operands, the comparison is performed elementwise and the element of
the result indicates whether the comparison is true for the operand elements
with the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying
attribute has integer type (or rather enum class in C++ code) as seen from
the generic assembly form. String literals are used to improve readability
of the IR by humans.</p><p>This operation only applies to integer-like operands, but not floats. The
main reason being that comparison operations have diverging sets of
attributes: integers require sign specification while floats require various
floating point-related particularities, e.g., <code>-ffast-math</code> behavior,
IEEE754 compliance, etc
(
<a href=/docs/Rationale/Rationale/>rationale</a>).
The type of comparison is specified as attribute to avoid introducing ten
similar operations, taking into account that they are often implemented
using the same operation downstream
(
<a href=/docs/Rationale/Rationale/>rationale</a>). The
separation between signed and unsigned order comparisons is necessary
because of integers being signless. The comparison operation must know how
to interpret values with the foremost bit being set: negatives in two&rsquo;s
complement or large positives
(
<a href=/docs/Rationale/Rationale/>rationale</a>).</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of scalar &#34;signed less than&#34; comparison.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>cmpi slt<span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;arith.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span> <span class=p>:</span> <span class=p>(</span><span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Custom form of vector equality comparison.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>cmpi eq<span class=p>,</span> <span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;arith.cmpi&#34;</span><span class=p>(</span><span class=nv>%lhs</span><span class=p>,</span> <span class=nv>%rhs</span><span class=p>)</span> <span class=p>{</span><span class=nl>predicate =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i64</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>:</span> <span class=p>(</span><span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i64</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i1</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameTypeOperands</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-3>Attributes:&nbsp;<a class=headline-hash href=#attributes-3>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>predicate</code></td><td>::mlir::arith::CmpIPredicateAttr</td><td>allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</td></tr></table><h4 id=operands-8>Operands:&nbsp;<a class=headline-hash href=#operands-8>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-8>Results:&nbsp;<a class=headline-hash href=#results-8>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>bool-like</td></tr></tbody></table><h3 id=arithconstant-arithconstantop><code>arith.constant</code> (arith::ConstantOp)&nbsp;<a class=headline-hash href=#arithconstant-arithconstantop>¶</a></h3><p><em>Integer or floating point constant</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.constant` attr-dict $value
</code></pre><p>The <code>constant</code> operation produces an SSA value equal to some integer or
floating-point constant specified by an attribute. This is the way MLIR
forms simple integer and floating point constants.</p><p>Example:</p><pre tabindex=0><code>// Integer constant
%1 = arith.constant 42 : i32

// Equivalent generic form
%1 = &#34;arith.constant&#34;() {value = 42 : i32} : () -&gt; i32
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>ConstantLike</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-4>Attributes:&nbsp;<a class=headline-hash href=#attributes-4>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>value</code></td><td>::mlir::TypedAttr</td><td><details><summary>TypedAttr instance</summary><pre><code>This interface is used for attributes that have a type. The type of an
attribute is understood to represent the type of the data contained in the
attribute and is often used as the type of a value with this data.
</code></pre></details></td></tr></table><h4 id=results-9>Results:&nbsp;<a class=headline-hash href=#results-9>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=arithdivf-arithdivfop><code>arith.divf</code> (arith::DivFOp)&nbsp;<a class=headline-hash href=#arithdivf-arithdivfop>¶</a></h3><p><em>Floating point division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.divf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-5>Attributes:&nbsp;<a class=headline-hash href=#attributes-5>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-9>Operands:&nbsp;<a class=headline-hash href=#operands-9>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-10>Results:&nbsp;<a class=headline-hash href=#results-10>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithdivsi-arithdivsiop><code>arith.divsi</code> (arith::DivSIOp)&nbsp;<a class=headline-hash href=#arithdivsi-arithdivsiop>¶</a></h3><p><em>Signed integer division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.divsi` $lhs `,` $rhs (`exact` $isExact^)?
              attr-dict `:` type($result)
</code></pre><p>Signed integer division. Rounds towards zero. Treats the leading bit as
sign, i.e. <code>6 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1)
is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the
behavior is undefined if <em>any</em> of its elements are divided by zero or has a
signed division overflow.</p><p>If the <code>exact</code> attribute is present, the result value is poison if <code>lhs</code> is
not a multiple of <code>rhs</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar signed integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>divsi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Scalar signed integer division where %b is known to be a multiple of %c.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>divsi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> exact <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>divsi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>divsi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-6>Attributes:&nbsp;<a class=headline-hash href=#attributes-6>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-10>Operands:&nbsp;<a class=headline-hash href=#operands-10>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-11>Results:&nbsp;<a class=headline-hash href=#results-11>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithdivui-arithdivuiop><code>arith.divui</code> (arith::DivUIOp)&nbsp;<a class=headline-hash href=#arithdivui-arithdivuiop>¶</a></h3><p><em>Unsigned integer division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.divui` $lhs `,` $rhs (`exact` $isExact^)?
              attr-dict `:` type($result)
</code></pre><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as
the most significant, i.e. for <code>i16</code> given two&rsquo;s complement representation,
<code>6 / -2 = 6 / (2^16 - 2) = 0</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and
<code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by
zero.</p><p>If the <code>exact</code> attribute is present, the result value is poison if <code>lhs</code> is
not a multiple of <code>rhs</code>.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar unsigned integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>divui <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Scalar unsigned integer division where %b is known to be a multiple of %c.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>divui <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> exact <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>divui <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>divui <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-7>Attributes:&nbsp;<a class=headline-hash href=#attributes-7>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-11>Operands:&nbsp;<a class=headline-hash href=#operands-11>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-12>Results:&nbsp;<a class=headline-hash href=#results-12>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithextf-arithextfop><code>arith.extf</code> (arith::ExtFOp)&nbsp;<a class=headline-hash href=#arithextf-arithextfop>¶</a></h3><p><em>Cast from floating-point to wider floating-point</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.extf` $in (`fastmath` `` $fastmath^)?
              attr-dict `:` type($in) `to` type($out)
</code></pre><p>Cast a floating-point value to a larger floating-point-typed value.
The destination type must to be strictly wider than the source type.
When operating on vectors, casts elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-8>Attributes:&nbsp;<a class=headline-hash href=#attributes-8>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-12>Operands:&nbsp;<a class=headline-hash href=#operands-12>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-13>Results:&nbsp;<a class=headline-hash href=#results-13>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithextsi-arithextsiop><code>arith.extsi</code> (arith::ExtSIOp)&nbsp;<a class=headline-hash href=#arithextsi-arithextsiop>¶</a></h3><p><em>Integer sign extension operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.extsi` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>The integer sign extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with copies
of the most-significant bit of the input.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>      <span class=c>// %1 is 0b101
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>  <span class=c>// %2 is 0b111101
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>      <span class=c>// %3 is 0b010
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>  <span class=c>// %4 is 0b000010
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl><span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>extsi <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-13>Operands:&nbsp;<a class=headline-hash href=#operands-13>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h4 id=results-14>Results:&nbsp;<a class=headline-hash href=#results-14>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h3 id=arithextui-arithextuiop><code>arith.extui</code> (arith::ExtUIOp)&nbsp;<a class=headline-hash href=#arithextui-arithextuiop>¶</a></h3><p><em>Integer zero extension operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.extui` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>The integer zero extension operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be larger than the input bit-width (N > M).
The top-most (N - M) bits of the output are filled with zeros.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i3</span>      <span class=c>// %1 is 0b101
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>extui <span class=nv>%1</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>  <span class=c>// %2 is 0b000101
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>2</span> <span class=p>:</span> <span class=k>i3</span>      <span class=c>// %3 is 0b010
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>extui <span class=nv>%3</span> <span class=p>:</span> <span class=k>i3</span> to <span class=k>i6</span>  <span class=c>// %4 is 0b000010
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>extui <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i64</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-14>Operands:&nbsp;<a class=headline-hash href=#operands-14>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h4 id=results-15>Results:&nbsp;<a class=headline-hash href=#results-15>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h3 id=arithfloordivsi-arithfloordivsiop><code>arith.floordivsi</code> (arith::FloorDivSIOp)&nbsp;<a class=headline-hash href=#arithfloordivsi-arithfloordivsiop>¶</a></h3><p><em>Signed floor integer division operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.floordivsi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Signed integer division. Rounds towards negative infinity, i.e. <code>5 / -2 = -3</code>.</p><p>Divison by zero, or signed division overflow (minimum value divided by -1)
is undefined behavior. When applied to <code>vector</code> and <code>tensor</code> values, the
behavior is undefined if <em>any</em> of its elements are divided by zero or has a
signed division overflow.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar signed integer division.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>floordivsi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-15>Operands:&nbsp;<a class=headline-hash href=#operands-15>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-16>Results:&nbsp;<a class=headline-hash href=#results-16>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithfptosi-arithfptosiop><code>arith.fptosi</code> (arith::FPToSIOp)&nbsp;<a class=headline-hash href=#arithfptosi-arithfptosiop>¶</a></h3><p><em>Cast from floating-point type to integer type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.fptosi` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Cast from a value interpreted as floating-point to the nearest (rounding
towards zero) signed integer value. When operating on vectors, casts
elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-16>Operands:&nbsp;<a class=headline-hash href=#operands-16>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-17>Results:&nbsp;<a class=headline-hash href=#results-17>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h3 id=arithfptoui-arithfptouiop><code>arith.fptoui</code> (arith::FPToUIOp)&nbsp;<a class=headline-hash href=#arithfptoui-arithfptouiop>¶</a></h3><p><em>Cast from floating-point type to integer type</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.fptoui` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Cast from a value interpreted as floating-point to the nearest (rounding
towards zero) unsigned integer value. When operating on vectors, casts
elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-17>Operands:&nbsp;<a class=headline-hash href=#operands-17>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-18>Results:&nbsp;<a class=headline-hash href=#results-18>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h3 id=arithindex_cast-arithindexcastop><code>arith.index_cast</code> (arith::IndexCastOp)&nbsp;<a class=headline-hash href=#arithindex_cast-arithindexcastop>¶</a></h3><p><em>Cast between index and integer types</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.index_cast` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Casts between scalar or vector integers and corresponding &lsquo;index&rsquo; scalar or
vectors. Index is an integer of platform-specific bit width. If casting to
a wider integer, the value is sign-extended. If casting to a narrower
integer, the value is truncated.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-18>Operands:&nbsp;<a class=headline-hash href=#operands-18>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-integer-like or memref of signless-integer</td></tr></tbody></table><h4 id=results-19>Results:&nbsp;<a class=headline-hash href=#results-19>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-integer-like or memref of signless-integer</td></tr></tbody></table><h3 id=arithindex_castui-arithindexcastuiop><code>arith.index_castui</code> (arith::IndexCastUIOp)&nbsp;<a class=headline-hash href=#arithindex_castui-arithindexcastuiop>¶</a></h3><p><em>Unsigned cast between index and integer types</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.index_castui` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Casts between scalar or vector integers and corresponding &lsquo;index&rsquo; scalar or
vectors. Index is an integer of platform-specific bit width. If casting to
a wider integer, the value is zero-extended. If casting to a narrower
integer, the value is truncated.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-19>Operands:&nbsp;<a class=headline-hash href=#operands-19>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-integer-like or memref of signless-integer</td></tr></tbody></table><h4 id=results-20>Results:&nbsp;<a class=headline-hash href=#results-20>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-integer-like or memref of signless-integer</td></tr></tbody></table><h3 id=arithmaximumf-arithmaximumfop><code>arith.maximumf</code> (arith::MaximumFOp)&nbsp;<a class=headline-hash href=#arithmaximumf-arithmaximumfop>¶</a></h3><p><em>Floating-point maximum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.maximumf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Returns the maximum of the two arguments, treating -0.0 as less than +0.0.
If one of the arguments is NaN, then the result is also NaN.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar floating-point maximum.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>maximumf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-9>Attributes:&nbsp;<a class=headline-hash href=#attributes-9>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-20>Operands:&nbsp;<a class=headline-hash href=#operands-20>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-21>Results:&nbsp;<a class=headline-hash href=#results-21>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithmaxnumf-arithmaxnumfop><code>arith.maxnumf</code> (arith::MaxNumFOp)&nbsp;<a class=headline-hash href=#arithmaxnumf-arithmaxnumfop>¶</a></h3><p><em>Floating-point maximum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.maxnumf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Returns the maximum of the two arguments.
If the arguments are -0.0 and +0.0, then the result is either of them.
If one of the arguments is NaN, then the result is the other argument.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar floating-point maximum.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>maxnumf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-10>Attributes:&nbsp;<a class=headline-hash href=#attributes-10>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-21>Operands:&nbsp;<a class=headline-hash href=#operands-21>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-22>Results:&nbsp;<a class=headline-hash href=#results-22>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithmaxsi-arithmaxsiop><code>arith.maxsi</code> (arith::MaxSIOp)&nbsp;<a class=headline-hash href=#arithmaxsi-arithmaxsiop>¶</a></h3><p><em>Signed integer maximum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.maxsi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-22>Operands:&nbsp;<a class=headline-hash href=#operands-22>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-23>Results:&nbsp;<a class=headline-hash href=#results-23>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithmaxui-arithmaxuiop><code>arith.maxui</code> (arith::MaxUIOp)&nbsp;<a class=headline-hash href=#arithmaxui-arithmaxuiop>¶</a></h3><p><em>Unsigned integer maximum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.maxui` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-23>Operands:&nbsp;<a class=headline-hash href=#operands-23>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-24>Results:&nbsp;<a class=headline-hash href=#results-24>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithminimumf-arithminimumfop><code>arith.minimumf</code> (arith::MinimumFOp)&nbsp;<a class=headline-hash href=#arithminimumf-arithminimumfop>¶</a></h3><p><em>Floating-point minimum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.minimumf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Returns the minimum of the two arguments, treating -0.0 as less than +0.0.
If one of the arguments is NaN, then the result is also NaN.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar floating-point minimum.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>minimumf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-11>Attributes:&nbsp;<a class=headline-hash href=#attributes-11>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-24>Operands:&nbsp;<a class=headline-hash href=#operands-24>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-25>Results:&nbsp;<a class=headline-hash href=#results-25>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithminnumf-arithminnumfop><code>arith.minnumf</code> (arith::MinNumFOp)&nbsp;<a class=headline-hash href=#arithminnumf-arithminnumfop>¶</a></h3><p><em>Floating-point minimum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.minnumf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Returns the minimum of the two arguments.
If the arguments are -0.0 and +0.0, then the result is either of them.
If one of the arguments is NaN, then the result is the other argument.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar floating-point minimum.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>minnumf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-12>Attributes:&nbsp;<a class=headline-hash href=#attributes-12>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-25>Operands:&nbsp;<a class=headline-hash href=#operands-25>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-26>Results:&nbsp;<a class=headline-hash href=#results-26>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithminsi-arithminsiop><code>arith.minsi</code> (arith::MinSIOp)&nbsp;<a class=headline-hash href=#arithminsi-arithminsiop>¶</a></h3><p><em>Signed integer minimum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.minsi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-26>Operands:&nbsp;<a class=headline-hash href=#operands-26>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-27>Results:&nbsp;<a class=headline-hash href=#results-27>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithminui-arithminuiop><code>arith.minui</code> (arith::MinUIOp)&nbsp;<a class=headline-hash href=#arithminui-arithminuiop>¶</a></h3><p><em>Unsigned integer minimum operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.minui` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-27>Operands:&nbsp;<a class=headline-hash href=#operands-27>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-28>Results:&nbsp;<a class=headline-hash href=#results-28>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithmulf-arithmulfop><code>arith.mulf</code> (arith::MulFOp)&nbsp;<a class=headline-hash href=#arithmulf-arithmulfop>¶</a></h3><p><em>Floating point multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.mulf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>mulf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD pointwise vector multiplication, e.g. for Intel SSE.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor pointwise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-13>Attributes:&nbsp;<a class=headline-hash href=#attributes-13>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-28>Operands:&nbsp;<a class=headline-hash href=#operands-28>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-29>Results:&nbsp;<a class=headline-hash href=#results-29>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithmuli-arithmuliop><code>arith.muli</code> (arith::MulIOp)&nbsp;<a class=headline-hash href=#arithmuli-arithmuliop>¶</a></h3><p><em>Integer multiplication operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.muli` $lhs `,` $rhs (`overflow` `` $overflowFlags^)?
              attr-dict `:` type($result)
</code></pre><p>Performs N-bit multiplication on the operands. The operands are interpreted as
unsigned bitvectors. The result is represented by a bitvector containing the
mathematical value of the multiplication modulo 2^n, where <code>n</code> is the bitwidth.
Because <code>arith</code> integers use a two&rsquo;s complement representation, this operation is
applicable on both signed and unsigned integer operands.</p><p>The <code>muli</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar type,
a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for
&ldquo;No Unsigned Wrap&rdquo; and &ldquo;No Signed Wrap&rdquo;, respectively. If the <code>nuw</code> and/or
<code>nsw</code> flags are present, and an unsigned/signed overflow occurs
(respectively), the result is poison.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>muli <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Scalar multiplication with overflow flags.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>muli <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> overflow<span class=p>&lt;</span>nsw<span class=p>,</span> nuw<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>muli <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>muli <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithIntegerOverflowFlagsInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>OpAsmOpInterface</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-14>Attributes:&nbsp;<a class=headline-hash href=#attributes-14>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>overflowFlags</code></td><td>::mlir::arith::IntegerOverflowFlagsAttr</td><td>Integer overflow arith flags</td></tr></table><h4 id=operands-29>Operands:&nbsp;<a class=headline-hash href=#operands-29>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-30>Results:&nbsp;<a class=headline-hash href=#results-30>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithmulsi_extended-arithmulsiextendedop><code>arith.mulsi_extended</code> (arith::MulSIExtendedOp)&nbsp;<a class=headline-hash href=#arithmulsi_extended-arithmulsiextendedop>¶</a></h3><p><em>Extended signed integer multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.mulsi_extended` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>Performs (2*N)-bit multiplication on sign-extended operands. Returns two
N-bit results: the low and the high halves of the product. The low half has
the same value as the result of regular multiplication <code>arith.muli</code> with
the same operands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%low</span><span class=p>,</span> <span class=nv>%high</span> <span class=p>=</span> arith<span class=p>.</span>mulsi_extended <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Vector element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>mulsi_extended <span class=nv>%d</span><span class=p>,</span> <span class=nv>%e</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>mulsi_extended <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-30>Operands:&nbsp;<a class=headline-hash href=#operands-30>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-31>Results:&nbsp;<a class=headline-hash href=#results-31>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>low</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>high</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithmului_extended-arithmuluiextendedop><code>arith.mului_extended</code> (arith::MulUIExtendedOp)&nbsp;<a class=headline-hash href=#arithmului_extended-arithmuluiextendedop>¶</a></h3><p><em>Extended unsigned integer multiplication operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.mului_extended` $lhs `,` $rhs attr-dict `:` type($lhs)
</code></pre><p>Performs (2*N)-bit multiplication on zero-extended operands. Returns two
N-bit results: the low and the high halves of the product. The low half has
the same value as the result of regular multiplication <code>arith.muli</code> with
the same operands.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%low</span><span class=p>,</span> <span class=nv>%high</span> <span class=p>=</span> arith<span class=p>.</span>mului_extended <span class=nv>%a</span><span class=p>,</span> <span class=nv>%b</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Vector element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%c</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>mului_extended <span class=nv>%d</span><span class=p>,</span> <span class=nv>%e</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise multiplication.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span><span class=p>:</span><span class=nl>2 =</span> arith<span class=p>.</span>mului_extended <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-31>Operands:&nbsp;<a class=headline-hash href=#operands-31>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-32>Results:&nbsp;<a class=headline-hash href=#results-32>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>low</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>high</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithnegf-arithnegfop><code>arith.negf</code> (arith::NegFOp)&nbsp;<a class=headline-hash href=#arithnegf-arithnegfop>¶</a></h3><p><em>Floating point negation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.negf` $operand (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>negf</code> operation computes the negation of a given value. It takes one
operand and returns one result of the same type. This type may be a float
scalar type, a vector whose element type is float, or a tensor of floats.
It has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar negation value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>negf <span class=nv>%b</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise negation value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>negf <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise negation value.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>negf <span class=nv>%y</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span>f8<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-15>Attributes:&nbsp;<a class=headline-hash href=#attributes-15>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-32>Operands:&nbsp;<a class=headline-hash href=#operands-32>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>operand</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-33>Results:&nbsp;<a class=headline-hash href=#results-33>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithori-arithoriop><code>arith.ori</code> (arith::OrIOp)&nbsp;<a class=headline-hash href=#arithori-arithoriop>¶</a></h3><p><em>Integer binary or</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.ori` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>The <code>ori</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar integer bitwise or.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>ori <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise bitwise integer or.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>ori <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise bitwise integer or.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>ori <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>Idempotent</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-33>Operands:&nbsp;<a class=headline-hash href=#operands-33>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-34>Results:&nbsp;<a class=headline-hash href=#results-34>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithremf-arithremfop><code>arith.remf</code> (arith::RemFOp)&nbsp;<a class=headline-hash href=#arithremf-arithremfop>¶</a></h3><p><em>Floating point division remainder operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.remf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>Returns the floating point division remainder.
The remainder has the same sign as the dividend (lhs operand).</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-16>Attributes:&nbsp;<a class=headline-hash href=#attributes-16>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-34>Operands:&nbsp;<a class=headline-hash href=#operands-34>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-35>Results:&nbsp;<a class=headline-hash href=#results-35>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithremsi-arithremsiop><code>arith.remsi</code> (arith::RemSIOp)&nbsp;<a class=headline-hash href=#arithremsi-arithremsiop>¶</a></h3><p><em>Signed integer division remainder operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.remsi` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 % -2 = 0</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and
<code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by
zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar signed integer division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>remsi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>remsi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise integer division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>remsi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-35>Operands:&nbsp;<a class=headline-hash href=#operands-35>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-36>Results:&nbsp;<a class=headline-hash href=#results-36>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithremui-arithremuiop><code>arith.remui</code> (arith::RemUIOp)&nbsp;<a class=headline-hash href=#arithremui-arithremuiop>¶</a></h3><p><em>Unsigned integer division remainder operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.remui` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>Unsigned integer division remainder. Treats the leading bit as the most
significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Division by zero is undefined behavior. When applied to <code>vector</code> and
<code>tensor</code> values, the behavior is undefined if <em>any</em> elements are divided by
zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar unsigned integer division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>remui <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>remui <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise integer division remainder.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>remui <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-36>Operands:&nbsp;<a class=headline-hash href=#operands-36>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-37>Results:&nbsp;<a class=headline-hash href=#results-37>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithscaling_extf-arithscalingextfop><code>arith.scaling_extf</code> (arith::ScalingExtFOp)&nbsp;<a class=headline-hash href=#arithscaling_extf-arithscalingextfop>¶</a></h3><p><em>Upcasts input floats using provided scales values following OCP MXFP Spec</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.scaling_extf` $in `,` $scale (`fastmath` `` $fastmath^)? attr-dict `:`
              type($in) `,` type($scale) `to` type($out)
</code></pre><p>This operation upcasts input floating-point values using provided scale
values. It expects both scales and the input operand to be of the same shape,
making the operation elementwise. Scales are usually calculated per block
following the OCP MXFP spec as described in
<a href=https://arxiv.org/abs/2310.10537>https://arxiv.org/abs/2310.10537</a>.</p><p>If scales are calculated per block where blockSize != 1, then scales may
require broadcasting to make this operation elementwise. For example, let&rsquo;s
say the input is of shape <code>&lt;dim1 x dim2 x ... dimN></code>. Given blockSize != 1 and
assuming quantization happens on the last axis, the input can be reshaped to
<code>&lt;dim1 x dim2 x ... (dimN/blockSize) x blockSize></code>. Scales will be calculated
per block on the last axis. Therefore, scales will be of shape
<code>&lt;dim1 x dim2 x ... (dimN/blockSize) x 1></code>. Scales could also be of some other
shape as long as it is broadcast compatible with the input, e.g.,
<code>&lt;1 x 1 x ... (dimN/blockSize) x 1></code>.</p><p>In this example, before calling into <code>arith.scaling_extf</code>, scales must be
broadcasted to <code>&lt;dim1 x dim2 x dim3 ... (dimN/blockSize) x blockSize></code>. Note
that there could be multiple quantization axes. Internally,
<code>arith.scaling_extf</code> would perform the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Cast scale to result type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>truncf <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span> to f8E8M0FNU
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%0</span> <span class=p>:</span> f8E8M0FNU to <span class=k>f16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Cast input to result type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%3</span> <span class=p>:</span> f4E2M1FN to <span class=k>f16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Perform scaling
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>mulf <span class=nv>%2</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f16</span>
</span></span></code></pre></div><p>It propagates NaN values. Therefore, if either scale or the input element
contains NaN, then the output element value will also be a NaN.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Upcast from f4E2M1FN to f32.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>scaling_extf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> f4E2M1FN<span class=p>,</span> f8E8M0FNU to <span class=k>f32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Element-wise upcast with broadcast (blockSize = 32).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>broadcast <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>1x</span>f8E8M0FNU<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f8E8M0FNU<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%h</span> <span class=p>=</span> arith<span class=p>.</span>scaling_extf <span class=nv>%i</span><span class=p>,</span> <span class=nv>%f</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f4E2M1FN<span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f8E8M0FNU<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>bf16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-17>Attributes:&nbsp;<a class=headline-hash href=#attributes-17>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-37>Operands:&nbsp;<a class=headline-hash href=#operands-37>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>scale</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-38>Results:&nbsp;<a class=headline-hash href=#results-38>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithscaling_truncf-arithscalingtruncfop><code>arith.scaling_truncf</code> (arith::ScalingTruncFOp)&nbsp;<a class=headline-hash href=#arithscaling_truncf-arithscalingtruncfop>¶</a></h3><p><em>Downcasts input floating point values using provided scales values following OCP MXFP Spec</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.scaling_truncf` $in `,` $scale ($roundingmode^)? (`fastmath` `` $fastmath^)? attr-dict `:`
              type($in) `,` type($scale) `to` type($out)
</code></pre><p>This operation downcasts input using the provided scale values. It expects
both scales and the input operand to be of the same shape and, therefore,
makes the operation elementwise. Scales are usually calculated per block
following the OCP MXFP spec as described in
<a href=https://arxiv.org/abs/2310.10537>https://arxiv.org/abs/2310.10537</a>.
Users are required to normalize and clamp the scales as necessary before calling
passing them to this operation. OCP MXFP spec also does the flushing of denorms
on the input operand, which should be handled during lowering by passing appropriate
fastMath flag to this operation.</p><p>If scales are calculated per block where blockSize != 1, scales may require
broadcasting to make this operation elementwise. For example, let&rsquo;s say the
input is of shape <code>&lt;dim1 x dim2 x ... dimN></code>. Given blockSize != 1 and
assuming quantization happens on the last axis, the input can be reshaped to
<code>&lt;dim1 x dim2 x ... (dimN/blockSize) x blockSize></code>. Scales will be calculated
per block on the last axis. Therefore, scales will be of shape
<code>&lt;dim1 x dim2 x ... (dimN/blockSize) x 1></code>. Scales could also be of some other
shape as long as it is broadcast compatible with the input, e.g.,
<code>&lt;1 x 1 x ... (dimN/blockSize) x 1></code>.</p><p>In this example, before calling into <code>arith.scaling_truncf</code>, scales must be
broadcasted to <code>&lt;dim1 x dim2 x dim3 ... (dimN/blockSize) x blockSize></code>. Note
that there could be multiple quantization axes. Internally,
<code>arith.scaling_truncf</code> would perform the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Cast scale to input type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%0</span> <span class=p>=</span> arith<span class=p>.</span>truncf <span class=nv>%1</span> <span class=p>:</span> <span class=k>f32</span> to f8E8M0FNU
</span></span><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span>extf <span class=nv>%0</span> <span class=p>:</span> f8E8M0FNU to <span class=k>f16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Perform scaling.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>divf <span class=nv>%2</span><span class=p>,</span> <span class=nv>%1</span> <span class=p>:</span> <span class=k>f16</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Cast to result type.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>truncf <span class=nv>%3</span> <span class=p>:</span> <span class=k>f16</span> to f4E2M1FN
</span></span></code></pre></div><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Downcast from f32 to f4E2M1FN.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>scaling_truncf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f32</span><span class=p>,</span> f8E8M0FNU to f4E2M1FN
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Element-wise downcast with broadcast (blockSize = 32).
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> <span class=kt>vector</span><span class=p>.</span>broadcast <span class=nv>%g</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>1x</span>f8E8M0FNU<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f8E8M0FNU<span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=nv>%h</span> <span class=p>=</span> arith<span class=p>.</span>scaling_truncf <span class=nv>%i</span><span class=p>,</span> <span class=nv>%f</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span><span class=k>bf16</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f8E8M0FNU<span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>32x</span>f4E2M1FN<span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ArithRoundingModeInterface</code>, <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-18>Attributes:&nbsp;<a class=headline-hash href=#attributes-18>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>roundingmode</code></td><td>::mlir::arith::RoundingModeAttr</td><td>Floating point rounding mode</td></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-38>Operands:&nbsp;<a class=headline-hash href=#operands-38>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>scale</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-39>Results:&nbsp;<a class=headline-hash href=#results-39>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithselect-arithselectop><code>arith.select</code> (arith::SelectOp)&nbsp;<a class=headline-hash href=#arithselect-arithselectop>¶</a></h3><p><em>Select operation</em></p><p>The <code>arith.select</code> operation chooses one value based on a binary condition
supplied as its first operand.</p><p>If the value of the first operand (the condition) is <code>1</code>, then the second
operand is returned, and the third operand is ignored, even if it was poison.</p><p>If the value of the first operand (the condition) is <code>0</code>, then the third
operand is returned, and the second operand is ignored, even if it was poison.</p><p>If the value of the first operand (the condition) is poison, then the
operation returns poison.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em>
of all operands is identical. The choice is made for each element
individually based on the value at the same position as the element in the
condition operand. If an i1 is provided as the condition, the entire vector
or tensor is chosen.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Custom form of scalar selection.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Generic form of the same operation.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> <span class=s>&#34;arith.select&#34;</span><span class=p>(</span><span class=nv>%cond</span><span class=p>,</span> <span class=nv>%true</span><span class=p>,</span> <span class=nv>%false</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=k>i1</span><span class=p>,</span> <span class=k>i32</span><span class=p>,</span> <span class=k>i32</span><span class=p>)</span> <span class=p>-&gt;</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Element-wise vector selection.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> arith<span class=p>.</span>select <span class=nv>%vcond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>i1</span><span class=p>&gt;,</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Full vector selection.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%vx</span> <span class=p>=</span> arith<span class=p>.</span>select <span class=nv>%cond</span><span class=p>,</span> <span class=nv>%vtrue</span><span class=p>,</span> <span class=nv>%vfalse</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>42x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>SelectLikeOpInterface</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-39>Operands:&nbsp;<a class=headline-hash href=#operands-39>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>condition</code></td><td>bool-like</td></tr><tr><td style=text-align:center><code>true_value</code></td><td>any type</td></tr><tr><td style=text-align:center><code>false_value</code></td><td>any type</td></tr></tbody></table><h4 id=results-40>Results:&nbsp;<a class=headline-hash href=#results-40>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>any type</td></tr></tbody></table><h3 id=arithshli-arithshliop><code>arith.shli</code> (arith::ShLIOp)&nbsp;<a class=headline-hash href=#arithshli-arithshliop>¶</a></h3><p><em>Integer left-shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.shli` $lhs `,` $rhs (`overflow` `` $overflowFlags^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>shli</code> operation shifts the integer value of the first operand to the left
by the integer value of the second operand. The second operand is interpreted as
unsigned. The low order bits are filled with zeros. If the value of the second
operand is greater or equal than the bitwidth of the first operand, then the
operation returns poison.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for
&ldquo;No Unsigned Wrap&rdquo; and &ldquo;No Signed Wrap&rdquo;, respectively. If the <code>nuw</code> and/or
<code>nsw</code> flags are present, and an unsigned/signed overflow occurs
(respectively), the result is poison.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>5</span> <span class=p>:</span> <span class=k>i8</span>  <span class=c>// %1 is 0b00000101
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>shli <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i8</span> <span class=c>// %3 is 0b00101000
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>shli <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> overflow<span class=p>&lt;</span>nsw<span class=p>,</span> nuw<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i8</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithIntegerOverflowFlagsInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-19>Attributes:&nbsp;<a class=headline-hash href=#attributes-19>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>overflowFlags</code></td><td>::mlir::arith::IntegerOverflowFlagsAttr</td><td>Integer overflow arith flags</td></tr></table><h4 id=operands-40>Operands:&nbsp;<a class=headline-hash href=#operands-40>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-41>Results:&nbsp;<a class=headline-hash href=#results-41>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithshrsi-arithshrsiop><code>arith.shrsi</code> (arith::ShRSIOp)&nbsp;<a class=headline-hash href=#arithshrsi-arithshrsiop>¶</a></h3><p><em>Signed integer right-shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.shrsi` $lhs `,` $rhs (`exact` $isExact^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>shrsi</code> operation shifts an integer value of the first operand to the right
by the value of the second operand. The first operand is interpreted as signed,
and the second operand is interpreter as unsigned. The high order bits in the
output are filled with copies of the most-significant bit of the shifted value
(which means that the sign of the value is preserved). If the value of the second
operand is greater or equal than bitwidth of the first operand, then the operation
returns poison.</p><p>If the <code>exact</code> attribute is present, the result value of shrsi is a poison
value if any of the bits shifted out are non-zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>         <span class=c>// %1 is 0b10100000
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>shrsi <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> exact <span class=p>:</span> <span class=k>i8</span>   <span class=c>// %3 is 0b11110100
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>98</span> <span class=p>:</span> <span class=k>i8</span>          <span class=c>// %4 is 0b01100010
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>shrsi <span class=nv>%4</span><span class=p>,</span> <span class=nv>%2</span> <span class=p>:</span> <span class=k>i8</span>         <span class=c>// %5 is 0b00001100
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-20>Attributes:&nbsp;<a class=headline-hash href=#attributes-20>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-41>Operands:&nbsp;<a class=headline-hash href=#operands-41>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-42>Results:&nbsp;<a class=headline-hash href=#results-42>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithshrui-arithshruiop><code>arith.shrui</code> (arith::ShRUIOp)&nbsp;<a class=headline-hash href=#arithshrui-arithshruiop>¶</a></h3><p><em>Unsigned integer right-shift</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.shrui` $lhs `,` $rhs (`exact` $isExact^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>shrui</code> operation shifts an integer value of the first operand to the right
by the value of the second operand. The first operand is interpreted as unsigned,
and the second operand is interpreted as unsigned. The high order bits are always
filled with zeros. If the value of the second operand is greater or equal than the
bitwidth of the first operand, then the operation returns poison.</p><p>If the <code>exact</code> attribute is present, the result value of shrui is a poison
value if any of the bits shifted out are non-zero.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>160</span> <span class=p>:</span> <span class=k>i8</span>        <span class=c>// %1 is 0b10100000
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>3</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>6</span> <span class=p>:</span> <span class=k>i8</span>
</span></span><span class=line><span class=cl><span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>shrui <span class=nv>%1</span><span class=p>,</span> <span class=nv>%2</span> exact <span class=p>:</span> <span class=k>i8</span>  <span class=c>// %4 is 0b00010100
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>shrui <span class=nv>%1</span><span class=p>,</span> <span class=nv>%3</span> <span class=p>:</span> <span class=k>i8</span>        <span class=c>// %3 is 0b00000010
</span></span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-21>Attributes:&nbsp;<a class=headline-hash href=#attributes-21>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>isExact</code></td><td>::mlir::UnitAttr</td><td>unit attribute</td></tr></table><h4 id=operands-42>Operands:&nbsp;<a class=headline-hash href=#operands-42>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-43>Results:&nbsp;<a class=headline-hash href=#results-43>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithsitofp-arithsitofpop><code>arith.sitofp</code> (arith::SIToFPOp)&nbsp;<a class=headline-hash href=#arithsitofp-arithsitofpop>¶</a></h3><p><em>Cast from integer type to floating-point</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.sitofp` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Cast from a value interpreted as a signed integer to the corresponding
floating-point value. If the value cannot be exactly represented, it is
rounded using the default rounding mode. When operating on vectors, casts
elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-43>Operands:&nbsp;<a class=headline-hash href=#operands-43>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h4 id=results-44>Results:&nbsp;<a class=headline-hash href=#results-44>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithsubf-arithsubfop><code>arith.subf</code> (arith::SubFOp)&nbsp;<a class=headline-hash href=#arithsubf-arithsubfop>¶</a></h3><p><em>Floating point subtraction operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.subf` $lhs `,` $rhs (`fastmath` `` $fastmath^)?
              attr-dict `:` type($result)
</code></pre><p>The <code>subf</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be a floating point
scalar type, a vector whose element type is a floating point type, or a
floating point tensor.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar subtraction.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>subf <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>f64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector subtraction, e.g. for Intel SSE.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>subf <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>f32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor subtraction.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>subf <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>bf16</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>TODO: In the distant future, this will accept optional attributes for fast
math, contraction, rounding mode, and other controls.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-22>Attributes:&nbsp;<a class=headline-hash href=#attributes-22>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-44>Operands:&nbsp;<a class=headline-hash href=#operands-44>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>floating-point-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-45>Results:&nbsp;<a class=headline-hash href=#results-45>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithsubi-arithsubiop><code>arith.subi</code> (arith::SubIOp)&nbsp;<a class=headline-hash href=#arithsubi-arithsubiop>¶</a></h3><p><em>Integer subtraction operation.</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.subi` $lhs `,` $rhs (`overflow` `` $overflowFlags^)?
              attr-dict `:` type($result)
</code></pre><p>Performs N-bit subtraction on the operands. The operands are interpreted as unsigned
bitvectors. The result is represented by a bitvector containing the mathematical
value of the subtraction modulo 2^n, where <code>n</code> is the bitwidth. Because <code>arith</code>
integers use a two&rsquo;s complement representation, this operation is applicable on
both signed and unsigned integer operands.</p><p>The <code>subi</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar type,
a vector whose element type is integer, or a tensor of integers.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for
&ldquo;No Unsigned Wrap&rdquo; and &ldquo;No Signed Wrap&rdquo;, respectively. If the <code>nuw</code> and/or
<code>nsw</code> flags are present, and an unsigned/signed overflow occurs
(respectively), the result is poison.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar subtraction.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>subi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Scalar subtraction with overflow flags.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>subi <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> overflow<span class=p>&lt;</span>nsw<span class=p>,</span> nuw<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise subtraction.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>subi <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise subtraction.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>subi <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithIntegerOverflowFlagsInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-23>Attributes:&nbsp;<a class=headline-hash href=#attributes-23>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>overflowFlags</code></td><td>::mlir::arith::IntegerOverflowFlagsAttr</td><td>Integer overflow arith flags</td></tr></table><h4 id=operands-45>Operands:&nbsp;<a class=headline-hash href=#operands-45>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-46>Results:&nbsp;<a class=headline-hash href=#results-46>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h3 id=arithtruncf-arithtruncfop><code>arith.truncf</code> (arith::TruncFOp)&nbsp;<a class=headline-hash href=#arithtruncf-arithtruncfop>¶</a></h3><p><em>Cast from floating-point to narrower floating-point</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.truncf` $in ($roundingmode^)?
              (`fastmath` `` $fastmath^)?
              attr-dict `:` type($in) `to` type($out)
</code></pre><p>Truncate a floating-point value to a smaller floating-point-typed value.
The destination type must be strictly narrower than the source type.
If the value cannot be exactly represented, it is rounded using the
provided rounding mode or the default one if no rounding mode is provided.
When operating on vectors, casts elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithFastMathInterface</code>, <code>ArithRoundingModeInterface</code>, <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-24>Attributes:&nbsp;<a class=headline-hash href=#attributes-24>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>roundingmode</code></td><td>::mlir::arith::RoundingModeAttr</td><td>Floating point rounding mode</td></tr><tr><td><code>fastmath</code></td><td>::mlir::arith::FastMathFlagsAttr</td><td>Floating point fast math flags</td></tr></table><h4 id=operands-46>Operands:&nbsp;<a class=headline-hash href=#operands-46>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>floating-point-like</td></tr></tbody></table><h4 id=results-47>Results:&nbsp;<a class=headline-hash href=#results-47>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithtrunci-arithtrunciop><code>arith.trunci</code> (arith::TruncIOp)&nbsp;<a class=headline-hash href=#arithtrunci-arithtrunciop>¶</a></h3><p><em>Integer truncation operation</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.trunci` $in (`overflow` `` $overflowFlags^)? attr-dict
              `:` type($in) `to` type($out)
</code></pre><p>The integer truncation operation takes an integer input of
width M and an integer destination type of width N. The destination
bit-width must be smaller than the input bit-width (N &lt; M).
The top-most (N - M) bits of the input are discarded.</p><p>This op supports <code>nuw</code>/<code>nsw</code> overflow flags which stands for &ldquo;No Unsigned
Wrap&rdquo; and &ldquo;No Signed Wrap&rdquo;, respectively. If the nuw keyword is present,
and any of the truncated bits are non-zero, the result is a poison value.
If the nsw keyword is present, and any of the truncated bits are not the
same as the top bit of the truncation result, the result is a poison value.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>  <span class=c>// Scalar truncation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>21</span> <span class=p>:</span> <span class=k>i5</span>     <span class=c>// %1 is 0b10101
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%2</span> <span class=p>=</span> arith<span class=p>.</span>trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i4</span> <span class=c>// %2 is 0b0101
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%3</span> <span class=p>=</span> arith<span class=p>.</span>trunci <span class=nv>%1</span> <span class=p>:</span> <span class=k>i5</span> to <span class=k>i3</span> <span class=c>// %3 is 0b101
</span></span></span><span class=line><span class=cl><span class=c></span>
</span></span><span class=line><span class=cl>  <span class=c>// Vector truncation.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%4</span> <span class=p>=</span> arith<span class=p>.</span>trunci <span class=nv>%0</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i32</span><span class=p>&gt;</span> to <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2 x</span> <span class=k>i16</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c>// Scalar truncation with overflow flags.
</span></span></span><span class=line><span class=cl><span class=c></span>  <span class=nv>%5</span> <span class=p>=</span> arith<span class=p>.</span>trunci <span class=nv>%a</span> overflow<span class=p>&lt;</span>nsw<span class=p>,</span> nuw<span class=p>&gt;</span> <span class=p>:</span> <span class=k>i32</span> to <span class=k>i16</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ArithIntegerOverflowFlagsInterface</code>, <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=attributes-25>Attributes:&nbsp;<a class=headline-hash href=#attributes-25>¶</a></h4><table><tr><th>Attribute</th><th>MLIR Type</th><th>Description</th></tr><tr><td><code>overflowFlags</code></td><td>::mlir::arith::IntegerOverflowFlagsAttr</td><td>Integer overflow arith flags</td></tr></table><h4 id=operands-47>Operands:&nbsp;<a class=headline-hash href=#operands-47>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h4 id=results-48>Results:&nbsp;<a class=headline-hash href=#results-48>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h3 id=arithuitofp-arithuitofpop><code>arith.uitofp</code> (arith::UIToFPOp)&nbsp;<a class=headline-hash href=#arithuitofp-arithuitofpop>¶</a></h3><p><em>Cast from unsigned integer type to floating-point</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.uitofp` $in attr-dict `:` type($in) `to` type($out)
</code></pre><p>Cast from a value interpreted as unsigned integer to the corresponding
floating-point value. If the value cannot be exactly represented, it is
rounded using the default rounding mode. When operating on vectors, casts
elementwise.</p><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Elementwise</code>, <code>SameOperandsAndResultShape</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>CastOpInterface</code>, <code>ConditionallySpeculatable</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-48>Operands:&nbsp;<a class=headline-hash href=#operands-48>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>in</code></td><td>signless-fixed-width-integer-like</td></tr></tbody></table><h4 id=results-49>Results:&nbsp;<a class=headline-hash href=#results-49>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>out</code></td><td>floating-point-like</td></tr></tbody></table><h3 id=arithxori-arithxoriop><code>arith.xori</code> (arith::XOrIOp)&nbsp;<a class=headline-hash href=#arithxori-arithxoriop>¶</a></h3><p><em>Integer binary xor</em></p><p>Syntax:</p><pre tabindex=0><code>operation ::= `arith.xori` $lhs `,` $rhs attr-dict `:` type($result)
</code></pre><p>The <code>xori</code> operation takes two operands and returns one result, each of
these is required to be the same type. This type may be an integer scalar
type, a vector whose element type is integer, or a tensor of integers. It
has no standard attributes.</p><p>Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Scalar integer bitwise xor.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%a</span> <span class=p>=</span> arith<span class=p>.</span>xori <span class=nv>%b</span><span class=p>,</span> <span class=nv>%c</span> <span class=p>:</span> <span class=k>i64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// SIMD vector element-wise bitwise integer xor.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%f</span> <span class=p>=</span> arith<span class=p>.</span>xori <span class=nv>%g</span><span class=p>,</span> <span class=nv>%h</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>4x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Tensor element-wise bitwise integer xor.
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%x</span> <span class=p>=</span> arith<span class=p>.</span>xori <span class=nv>%y</span><span class=p>,</span> <span class=nv>%z</span> <span class=p>:</span> <span class=kt>tensor</span><span class=p>&lt;</span><span class=m>4x?x</span><span class=k>i8</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Traits: <code>AlwaysSpeculatableImplTrait</code>, <code>Commutative</code>, <code>Elementwise</code>, <code>SameOperandsAndResultType</code>, <code>Scalarizable</code>, <code>Tensorizable</code>, <code>Vectorizable</code></p><p>Interfaces: <code>ConditionallySpeculatable</code>, <code>InferIntRangeInterface</code>, <code>InferTypeOpInterface</code>, <code>NoMemoryEffect (MemoryEffectOpInterface)</code>, <code>VectorUnrollOpInterface</code></p><p>Effects: <code>MemoryEffects::Effect{}</code></p><h4 id=operands-49>Operands:&nbsp;<a class=headline-hash href=#operands-49>¶</a></h4><table><thead><tr><th style=text-align:center>Operand</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>lhs</code></td><td>signless-integer-like</td></tr><tr><td style=text-align:center><code>rhs</code></td><td>signless-integer-like</td></tr></tbody></table><h4 id=results-50>Results:&nbsp;<a class=headline-hash href=#results-50>¶</a></h4><table><thead><tr><th style=text-align:center>Result</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center><code>result</code></td><td>signless-integer-like</td></tr></tbody></table><h2 id=attributes-26>Attributes&nbsp;<a class=headline-hash href=#attributes-26>¶</a></h2><h3 id=fastmathflagsattr>FastMathFlagsAttr&nbsp;<a class=headline-hash href=#fastmathflagsattr>¶</a></h3><p><em>Floating point fast math flags</em></p><p>Syntax:</p><pre tabindex=0><code>#arith.fastmath&lt;
  ::mlir::arith::FastMathFlags   # value
&gt;
</code></pre><h4 id=parameters>Parameters:&nbsp;<a class=headline-hash href=#parameters>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::arith::FastMathFlags</code></td><td>an enum of type FastMathFlags</td></tr></tbody></table><h3 id=integeroverflowflagsattr>IntegerOverflowFlagsAttr&nbsp;<a class=headline-hash href=#integeroverflowflagsattr>¶</a></h3><p><em>Integer overflow arith flags</em></p><p>Syntax:</p><pre tabindex=0><code>#arith.overflow&lt;
  ::mlir::arith::IntegerOverflowFlags   # value
&gt;
</code></pre><h4 id=parameters-1>Parameters:&nbsp;<a class=headline-hash href=#parameters-1>¶</a></h4><table><thead><tr><th style=text-align:center>Parameter</th><th style=text-align:center>C++ type</th><th>Description</th></tr></thead><tbody><tr><td style=text-align:center>value</td><td style=text-align:center><code>::mlir::arith::IntegerOverflowFlags</code></td><td>an enum of type IntegerOverflowFlags</td></tr></tbody></table><h2 id=enums>Enums&nbsp;<a class=headline-hash href=#enums>¶</a></h2><h3 id=cmpfpredicate>CmpFPredicate&nbsp;<a class=headline-hash href=#cmpfpredicate>¶</a></h3><p><em>Allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</em></p><h4 id=cases>Cases:&nbsp;<a class=headline-hash href=#cases>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>AlwaysFalse</td><td style=text-align:center><code>0</code></td><td>false</td></tr><tr><td style=text-align:center>OEQ</td><td style=text-align:center><code>1</code></td><td>oeq</td></tr><tr><td style=text-align:center>OGT</td><td style=text-align:center><code>2</code></td><td>ogt</td></tr><tr><td style=text-align:center>OGE</td><td style=text-align:center><code>3</code></td><td>oge</td></tr><tr><td style=text-align:center>OLT</td><td style=text-align:center><code>4</code></td><td>olt</td></tr><tr><td style=text-align:center>OLE</td><td style=text-align:center><code>5</code></td><td>ole</td></tr><tr><td style=text-align:center>ONE</td><td style=text-align:center><code>6</code></td><td>one</td></tr><tr><td style=text-align:center>ORD</td><td style=text-align:center><code>7</code></td><td>ord</td></tr><tr><td style=text-align:center>UEQ</td><td style=text-align:center><code>8</code></td><td>ueq</td></tr><tr><td style=text-align:center>UGT</td><td style=text-align:center><code>9</code></td><td>ugt</td></tr><tr><td style=text-align:center>UGE</td><td style=text-align:center><code>10</code></td><td>uge</td></tr><tr><td style=text-align:center>ULT</td><td style=text-align:center><code>11</code></td><td>ult</td></tr><tr><td style=text-align:center>ULE</td><td style=text-align:center><code>12</code></td><td>ule</td></tr><tr><td style=text-align:center>UNE</td><td style=text-align:center><code>13</code></td><td>une</td></tr><tr><td style=text-align:center>UNO</td><td style=text-align:center><code>14</code></td><td>uno</td></tr><tr><td style=text-align:center>AlwaysTrue</td><td style=text-align:center><code>15</code></td><td>true</td></tr></tbody></table><h3 id=cmpipredicate>CmpIPredicate&nbsp;<a class=headline-hash href=#cmpipredicate>¶</a></h3><p><em>Allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9</em></p><h4 id=cases-1>Cases:&nbsp;<a class=headline-hash href=#cases-1>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>eq</td><td style=text-align:center><code>0</code></td><td>eq</td></tr><tr><td style=text-align:center>ne</td><td style=text-align:center><code>1</code></td><td>ne</td></tr><tr><td style=text-align:center>slt</td><td style=text-align:center><code>2</code></td><td>slt</td></tr><tr><td style=text-align:center>sle</td><td style=text-align:center><code>3</code></td><td>sle</td></tr><tr><td style=text-align:center>sgt</td><td style=text-align:center><code>4</code></td><td>sgt</td></tr><tr><td style=text-align:center>sge</td><td style=text-align:center><code>5</code></td><td>sge</td></tr><tr><td style=text-align:center>ult</td><td style=text-align:center><code>6</code></td><td>ult</td></tr><tr><td style=text-align:center>ule</td><td style=text-align:center><code>7</code></td><td>ule</td></tr><tr><td style=text-align:center>ugt</td><td style=text-align:center><code>8</code></td><td>ugt</td></tr><tr><td style=text-align:center>uge</td><td style=text-align:center><code>9</code></td><td>uge</td></tr></tbody></table><h3 id=integeroverflowflags>IntegerOverflowFlags&nbsp;<a class=headline-hash href=#integeroverflowflags>¶</a></h3><p><em>Integer overflow arith flags</em></p><h4 id=cases-2>Cases:&nbsp;<a class=headline-hash href=#cases-2>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>none</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>nsw</td><td style=text-align:center><code>1</code></td><td>nsw</td></tr><tr><td style=text-align:center>nuw</td><td style=text-align:center><code>2</code></td><td>nuw</td></tr></tbody></table><h3 id=roundingmode>RoundingMode&nbsp;<a class=headline-hash href=#roundingmode>¶</a></h3><p><em>Floating point rounding mode</em></p><h4 id=cases-3>Cases:&nbsp;<a class=headline-hash href=#cases-3>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>to_nearest_even</td><td style=text-align:center><code>0</code></td><td>to_nearest_even</td></tr><tr><td style=text-align:center>downward</td><td style=text-align:center><code>1</code></td><td>downward</td></tr><tr><td style=text-align:center>upward</td><td style=text-align:center><code>2</code></td><td>upward</td></tr><tr><td style=text-align:center>toward_zero</td><td style=text-align:center><code>3</code></td><td>toward_zero</td></tr><tr><td style=text-align:center>to_nearest_away</td><td style=text-align:center><code>4</code></td><td>to_nearest_away</td></tr></tbody></table><h3 id=atomicrmwkind>AtomicRMWKind&nbsp;<a class=headline-hash href=#atomicrmwkind>¶</a></h3><p><em>Allowed 64-bit signless integer cases: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15</em></p><h4 id=cases-4>Cases:&nbsp;<a class=headline-hash href=#cases-4>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>addf</td><td style=text-align:center><code>0</code></td><td>addf</td></tr><tr><td style=text-align:center>addi</td><td style=text-align:center><code>1</code></td><td>addi</td></tr><tr><td style=text-align:center>andi</td><td style=text-align:center><code>2</code></td><td>andi</td></tr><tr><td style=text-align:center>assign</td><td style=text-align:center><code>3</code></td><td>assign</td></tr><tr><td style=text-align:center>maximumf</td><td style=text-align:center><code>4</code></td><td>maximumf</td></tr><tr><td style=text-align:center>maxnumf</td><td style=text-align:center><code>5</code></td><td>maxnumf</td></tr><tr><td style=text-align:center>maxs</td><td style=text-align:center><code>6</code></td><td>maxs</td></tr><tr><td style=text-align:center>maxu</td><td style=text-align:center><code>7</code></td><td>maxu</td></tr><tr><td style=text-align:center>minimumf</td><td style=text-align:center><code>8</code></td><td>minimumf</td></tr><tr><td style=text-align:center>minnumf</td><td style=text-align:center><code>9</code></td><td>minnumf</td></tr><tr><td style=text-align:center>mins</td><td style=text-align:center><code>10</code></td><td>mins</td></tr><tr><td style=text-align:center>minu</td><td style=text-align:center><code>11</code></td><td>minu</td></tr><tr><td style=text-align:center>mulf</td><td style=text-align:center><code>12</code></td><td>mulf</td></tr><tr><td style=text-align:center>muli</td><td style=text-align:center><code>13</code></td><td>muli</td></tr><tr><td style=text-align:center>ori</td><td style=text-align:center><code>14</code></td><td>ori</td></tr><tr><td style=text-align:center>xori</td><td style=text-align:center><code>15</code></td><td>xori</td></tr></tbody></table><h3 id=fastmathflags>FastMathFlags&nbsp;<a class=headline-hash href=#fastmathflags>¶</a></h3><p><em>Floating point fast math flags</em></p><h4 id=cases-5>Cases:&nbsp;<a class=headline-hash href=#cases-5>¶</a></h4><table><thead><tr><th style=text-align:center>Symbol</th><th style=text-align:center>Value</th><th>String</th></tr></thead><tbody><tr><td style=text-align:center>none</td><td style=text-align:center><code>0</code></td><td>none</td></tr><tr><td style=text-align:center>reassoc</td><td style=text-align:center><code>1</code></td><td>reassoc</td></tr><tr><td style=text-align:center>nnan</td><td style=text-align:center><code>2</code></td><td>nnan</td></tr><tr><td style=text-align:center>ninf</td><td style=text-align:center><code>4</code></td><td>ninf</td></tr><tr><td style=text-align:center>nsz</td><td style=text-align:center><code>8</code></td><td>nsz</td></tr><tr><td style=text-align:center>arcp</td><td style=text-align:center><code>16</code></td><td>arcp</td></tr><tr><td style=text-align:center>contract</td><td style=text-align:center><code>32</code></td><td>contract</td></tr><tr><td style=text-align:center>afn</td><td style=text-align:center><code>64</code></td><td>afn</td></tr><tr><td style=text-align:center>fast</td><td style=text-align:center><code>127</code></td><td>fast</td></tr></tbody></table><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/docs/Dialects/AMX/ title="'amx' Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - 'amx' Dialect</a>
<a class="nav nav-next" href=https://mlir.llvm.org/docs/Dialects/ArmNeon/ title="'arm_neon' Dialect">Next - 'arm_neon' Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/OpenMPPasses/></a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPUTransformOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li class=active><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>