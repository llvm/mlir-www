<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Developer Guide - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/getting_started/DeveloperGuide/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>Developer Guide</h1><p>This document attempts to describe a few developer policies used in MLIR (such
as coding standards used) as well as development approach (such as, testing
methods).</p><h2 id=style-guide>Style guide&nbsp;<a class=headline-hash href=#style-guide>¶</a></h2><p>MLIR follows the
<a href=https://llvm.org/docs/CodingStandards.html>LLVM style</a> guide.
We also adhere to the following (which deviate from or are not specified in the
LLVM style guide):</p><ul><li>Adopts
<a href=https://llvm.org/docs/Proposals/VariableNames.html>camelBack</a>;</li><li>Uses Doxygen-style (<code>///</code>) comments for top-level and class member
definitions, regardless of them being visible as public APIs.</li><li>Except for IR units (Region, Block, and Operation), non-nullable output
arguments are passed by non-const reference in general.</li><li>IR constructs are not designed for
<a href=/docs/Rationale/UsageOfConst/>const correctness</a>.</li><li>Do <em>not</em> use recursive algorithms if the recursion can&rsquo;t be bounded
statically: that is avoid recursion if there is a possible IR input that can
trigger a stack overflow (for example traversing use-def chains in a
recursive way). At the moment, we tolerate it for the two following cases:<ul><li>The nesting of the IR: we use recursion when traversing nested regions.</li><li>Type nesting: recursion may be used for the nesting of composite types.</li></ul></li><li>Follows git conventions for
<a href=/getting_started/Contributing/>commit messages</a>.</li></ul><p>Please run clang-format on the files you modified with the <code>.clang-format</code>
configuration file available in the root directory. Check the clang-format
<a href=https://clang.llvm.org/docs/ClangFormat.html>documentation</a> for more details
on integrating it with your development environment. In particular, if clang is
installed system-wide, running <code>git clang-format origin/main</code> will update the
files in the working directory with the relevant formatting changes; don&rsquo;t
forget to include those to the commit.</p><h2 id=ir-should-be-valid-before-and-after-each-pass>IR should be valid before and after each pass&nbsp;<a class=headline-hash href=#ir-should-be-valid-before-and-after-each-pass>¶</a></h2><p>Passes should assume that their input IR passes the verifier. Passes should not
check invariants that are guaranteed by the verifier. If many passes are checking
the same invariant consider adding that invariant to the verifier or factoring
the IR design / dialects to better model the invariant at each phase of compilation.</p><p>Similarly, the IR after a pass runs should be verifier-valid. If a pass produces IR
that fails the verifier then the pass has a bug.</p><p>It is somewhat common for invalid IR to exist transiently while a pass is executing.
This is moderately discouraged but often practically necessary.</p><h2 id=assertions-and-crashes-in-passes>Assertions and crashes in passes&nbsp;<a class=headline-hash href=#assertions-and-crashes-in-passes>¶</a></h2><p>It should not be possible to trigger a crash or assertion by running an MLIR
pass on verifier-valid IR. If it is possible, then the pass has a bug.</p><p>If a pass requires additional invariants not guaranteed by the verifier, then
it should check them itself and if those invariants are not present,
either safely perform no transformation (for pure optimization passes)
or emit a diagnostic explaining why a transformation cannot be performed
(for lowering passes where the transformation is needed for correctness).</p><h2 id=pass-name-and-other-command-line-options>Pass name and other command line options&nbsp;<a class=headline-hash href=#pass-name-and-other-command-line-options>¶</a></h2><p>To avoid collision between options provided by different dialects, the naming
convention is to prepend the dialect name to every dialect-specific passes and
options in general. Options that are specific to a pass should also be prefixed
with the pass name. For example, the affine dialect provides a loop tiling pass
that is registered on the command line as <code>-affine-tile</code>, and with a tile size
option that can be set with <code>-affine-tile-size</code>.</p><p>We also avoid <code>cl::opt</code> to provide pass options in favor of the
<a href=/docs/PassManagement/>pass options</a>
mechanism. This allows for these options to be serialized in a pass pipeline
description, as well as passing different options to multiple instances of a
pass in the same pipeline.</p><h2 id=ir-verifier>IR Verifier&nbsp;<a class=headline-hash href=#ir-verifier>¶</a></h2><p>TLDR: only verify local aspects of an operation, in particular don&rsquo;t follow
def-use chains (don&rsquo;t look at the producer of any operand or the user of any
results).</p><p>MLIR encourages to enforce invariants around operations in verifiers. It is
common for operations defined in
<a href=/docs/DefiningDialects/Operations/>ODS</a>
to define constraint on the type of operands they accept, or the relationship
between operands and results. For example the operations in the <code>arith</code>
dialect are defined with the <code>SameOperandsAndResultType</code> trait, which enforces
a self-describing invariant.</p><p>When an invariant fails, we consider the IR to be &ldquo;invalid&rdquo; and we abort the
compilation flow. By convention the contract of any pass in the compiler is
to assume its input IR is valid and it must produce a valid output as well.
The default setting for the pass manager is to enforce this between every
single pass. Because the process is aborted when a verifier is failing, they
must only fire on things that are definitive broken invariant, and not on
&ldquo;possibly invalid&rdquo; cases.</p><p>While it is encouraged to verify as much invariants as possible in order to
catch bugs during development as soon as possible, there is some important
aspect to keep in mind. In particular a common point of confusion is about how
to handle &ldquo;undefined behavior&rdquo; cases. For example the <code>tensor.dim</code> operation:</p><pre tabindex=0><code>// Returns the dimension of %A indexed by %dim.
%y = tensor.dim %A, %dim : memref&lt;4x?xf32&gt;
</code></pre><p>The <code>%dim</code> indicates what dimension to return. If the dimension index is out
of bounds, the behavior is undefined. What about:</p><pre tabindex=0><code>%ten = arith.constant 10 : index
%y = tensor.dim %A, %ten : memref&lt;4x?xf32&gt;
</code></pre><p>We have unambiguously a violation of the spec here, and we can statically
verify it. However this is not the kind of invariants to enforce in a
verifier because it relies on non-local properties, which makes the design
of the compiler much less flexible. For example:</p><pre tabindex=0><code>  %five = arith.constant 5 : index
  %ten = arith.addi %five, %five : index
  %y = tensor.dim %A, %ten : memref&lt;4x?xf32&gt;
}
</code></pre><p>The IR would be valid, and going through constant folding for <code>arith.addi</code>
would lead to the situation above, if we deemed this invalid IR that would
mean that the folder for <code>arith.addi</code> has a bug: it is turning valid IR
into invalid IR. The same would apply to many other transformations
(inlining for example).</p><p>This is why the guidelines to write verifier is to stick to information local
to an operation (think &ldquo;what I see when I print this operation alone&rdquo;).
Looking through operands or results is extremely unusual and should be
avoided.</p><h2 id=testing-guidelines>Testing guidelines&nbsp;<a class=headline-hash href=#testing-guidelines>¶</a></h2><p>See here for the
<a href=/getting_started/TestingGuide/>testing guide</a>.</p><h2 id=guidelines-on-contributing-a-new-dialect-or-important-components>Guidelines on contributing a new dialect (or important components)&nbsp;<a class=headline-hash href=#guidelines-on-contributing-a-new-dialect-or-important-components>¶</a></h2><p>To contribute a dialect (or a major component in MLIR), it is usual to write an
overview &ldquo;RFC&rdquo; (it can be just a few informal paragraphs) and send it to the
MLIR mailing-list. When accepting a new component to MLIR, the community is
also accepting the burden of maintaining it. The following points should be
considered when evaluating whether a dialect is a good fit for the core MLIR
repository:</p><ul><li>What is the overall goal of the dialect? What is the first implementation
milestone?</li><li>How does it fit into the MLIR dialect ecosystem?<ul><li>Connection: how does it connect to the existing dialects in a compilation
pipeline(s)?</li><li>Consolidation: is there already a dialect with a similar goal or matching
abstractions; if so, can it be improved instead of adding a new one?</li><li>Reuse: how does it generalize to similar but slightly different use-cases?</li></ul></li><li>What is the community of users that it is serving?</li><li>Who are the future contributors/maintainers beyond those who propose the
dialect?</li></ul><p>On a practical aspect, we will expect the code to follow the other sections of
this document, with an emphasis on the documentation alongside the source code.</p><p>It is prefered to upstream your dialects/components in small incremental
patches that can be individually reviewed. That is, after the initial RFC has
been agreed on, we encourage dialects to be built progressively by faster
iterations in-tree ; as long as it is clear they evolve towards their
milestones and goals.</p><p>We have seen the following broad categories of dialects:</p><ul><li>Edge dialects that model a representation external to MLIR. Examples include
LLVM, SPIR-V dialects, TensorFlow, XLA/HLO, … Such dialects may be a better
fit for the project that contains the original representation instead of
being added to the MLIR repository. In particular, because MLIR will not
take an external dependency on another project.</li><li>Structured Abstraction dialects that generalize common features of several
other dialects or introduce a programming model. Generalization is sometimes
demonstrated by having several dialects lower to or originate from a new
dialect. While additional abstractions may be useful, they should be traded
off against the additional complexity of the dialect ecosystem. Examples of
abstraction dialects include the GPU and Loop dialects.</li><li>Transformation dialects that serve as input/output for program
transformations. These dialects are commonly introduced to materialize
transformation pre- and post-conditions in the IR, while conditions can be
obtained through analysis or through operation semantics. Examples include
Affine, Linalg dialects.</li></ul><p>While it can be useful to frame the goals of a proposal, this categorization is
not exhaustive or absolute, and the community is open to discussing any new
dialect beyond this taxonomy.</p><h2 id=breaking-changes>Breaking Changes&nbsp;<a class=headline-hash href=#breaking-changes>¶</a></h2><p>MLIR (like LLVM) does not provide any C++ compatibility guarantee, and favor
refactoring API liberally to enable upstream development. Downstream users are
expected to manage API updates when they pull a new version of MLIR.</p><p>When performing breaking changes, we expect to proceed with the most convenient
way for the change to be reviewed and implemented, while minimizing churn. It
is frequent to break changes in multiple commits to ease the review process.
A breaking can be implemented incrementally within these guidelines, but we
don&rsquo;t go out of our way only to accomodate downstream users. As such we don&rsquo;t
have predefined deprecation period for APIs.
A good practice is to communicate on
<a href=https://llvm.discourse.group/c/mlir/31>Discourse</a> about the timeline and plan
for conducting such changes.</p><p>See also the
<a href=https://llvm.org/docs/DeveloperPolicy.html#making-a-major-change>general LLVM guideline for any large change in general</a>.</p><div class=edit-meta><br><a href=https://github.com/llvm/mlir-www//edit/main/website/content/getting_started/DeveloperGuide.md class=edit-page><i class="fas fa-pen-square"></i> Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/getting_started/Contributing/ title="How to Contribute"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - How to Contribute</a>
<a class="nav nav-next" href=https://mlir.llvm.org/getting_started/openprojects/ title="Open Projects">Next - Open Projects <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li class=active><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIRTransforms/></a></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/SMTExtensionOps/></a></li><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/WasmSSAOps/>'wasmssa' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PatternSearch/>Pattern Search</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Remarks/>Remark Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>