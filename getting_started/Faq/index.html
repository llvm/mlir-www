<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>FAQ - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.119.0"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/getting_started/Faq/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script>
<link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script>
<script src=https://mlir.llvm.org/js/bundle.js></script>
<script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type=text/x-mathjax-config>
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [['$', '$'] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ]
    }
  });
</script><link rel=apple-touch-icon sizes=180x180 href="/apple-touch-icon.png?v=1"><link rel=icon type=image/png sizes=32x32 href="/favicon-32x32.png?v=1"><link rel=icon type=image/png sizes=16x16 href="/favicon-16x16.png?v=1"><link rel=manifest href="/site.webmanifest?v=1"><link rel=mask-icon href="/safari-pinned-tab.svg?v=1" color=#3775e0><link rel="shortcut icon" href="/favicon.ico?v=1"><meta name=msapplication-TileColor content="#2d89ef"><meta name=theme-color content="#ffffff"><link rel=icon href=/favicon.svg type=image/svg+xml sizes=any><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/mlir/31>Forums</a></li><li class=child><a href=https://discord.gg/xS7Z362>Chat</a></li></ul></li><li><a href=/getting_started/Debugging/>Debugging Tips</a></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/main/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=/doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/main/mlir>GitHub</a></li></ul></li><li><a href="https://github.com/llvm/llvm-project/issues?q=is%3Aissue%20state%3Aopen%20label%3Amlir">Bugs</a></li><li><a href=https://github.com/llvm/mlir-www/tree/main/website/static/LogoAssets>Logo Assets</a></li><li><a href=https://www.youtube.com/MLIRCompiler>Youtube Channel</a></li></ul></nav></div><div class=content-container><main><h1>FAQ</h1><h2 id=how-to-refer-to-mlir-in-publications-is-there-an-accompanying-paper>How to refer to MLIR in publications? Is there an accompanying paper?&nbsp;<a class=headline-hash href=#how-to-refer-to-mlir-in-publications-is-there-an-accompanying-paper>¶</a></h2><p>MLIR has been presented in the 2021 IEEE/ACM International Symposium on Code
Generation and Optimization, the full text of the paper is
<a href=https://ieeexplore.ieee.org/abstract/document/9370308>available from
IEEE</a>. A pre-publication
draft is available on
<a href=https://arxiv.org/pdf/2002.11054>arXiv</a> but may be
missing improvements and corrections. Please also note that MLIR keeps evolving
and IR snippets presented in the paper may no longer use modern syntax, refer to
the MLIR documentation for the new syntax.</p><p>To cite MLIR in academic or other publications, please use: <em>Chris Lattner,
Mehdi Amini, Uday Bondhugula, Albert Cohen, Andy Davis, Jacques Pienaar, River
Riddle, Tatiana Shpeisman, Nicolas Vasilache, and Oleksandr Zinenko. &ldquo;MLIR:
Scaling compiler infrastructure for domain specific computation.&rdquo; In 2021
IEEE/ACM International Symposium on Code Generation and Optimization (CGO), pp.
2-14. IEEE, 2021.</em></p><p>The BibTeX entry is as follows.</p><pre tabindex=0><code>@inproceedings{mlir,
  author={Lattner, Chris and Amini, Mehdi and Bondhugula, Uday and Cohen, Albert and Davis, Andy and Pienaar, Jacques and Riddle, River and Shpeisman, Tatiana and Vasilache, Nicolas and Zinenko, Oleksandr},
  booktitle={2021 {{IEEE/ACM}} International Symposium on Code Generation and Optimization (CGO)},
  title={{{MLIR}}: Scaling Compiler Infrastructure for Domain Specific Computation},
  year={2021},
  volume={},
  number={},
  pages={2-14},
  doi={10.1109/CGO51591.2021.9370308}
}
</code></pre><p>Please do <strong>not</strong> cite the arXiv preprint as it is not a formal peer-reviewed
publication.</p><h2 id=why-is-small-feature-not-available-in-mlir>Why is &lt;small feature> not available in MLIR?&nbsp;<a class=headline-hash href=#why-is-small-feature-not-available-in-mlir>¶</a></h2><p>On general basis, there is never a reason why a small feature is not available in MLIR other than nobody needed it enough to implement it. Consider submitting a patch. For larger features and dialects, follow the
<a href=https://mlir.llvm.org/getting_started/DeveloperGuide/#guidelines-on-contributing-a-new-dialect-or-important-components>request-for-comments</a> process.</p><h2 id=mlir-is-too-heavy-framework-should-i-just-reimplement-my-own-compiler-from-scratch>MLIR is too heavy framework, should I just reimplement my own compiler from scratch?&nbsp;<a class=headline-hash href=#mlir-is-too-heavy-framework-should-i-just-reimplement-my-own-compiler-from-scratch>¶</a></h2><p>Maybe: it is hard to tell as it depends on your requirements, even C++ may already be too
large for some micro-controllers. In our experience most projects ends up growing beyond
what their original author intended, and reimplementing the features you would get from
MLIR would also have a footprint. MLIR footprint is representative of the features it
provides. More importantly we have a &ldquo;you don&rsquo;t pay for what you don&rsquo;t use&rdquo; approach:
MLIR is very modular and you can link a binary with a very minimal set of libraries.
If you use just the core IR, some pieces of the infrastructure, and a few dialects
you should expect a few MBs. We have
<a href=https://github.com/llvm/llvm-project/tree/main/mlir/examples/minimal-opt>three examples</a>
in the repo showing some small possible configurations of MLIR, showing that the
core of MLIR can take around 1MB.</p><h2 id=what-is-the-difference-between-the-tensor-and-vector-types>What is the difference between the Tensor and Vector types?&nbsp;<a class=headline-hash href=#what-is-the-difference-between-the-tensor-and-vector-types>¶</a></h2><ol><li>Conceptual: vectors are meant to and occur in lower level dialects - often where you expect hardware to have registers of that size. Tensors model higher-level &ldquo;closer to the source&rdquo; abstract representation. This is reflected in the abstraction modeled by the operations from the
<a href=https://mlir.llvm.org/docs/Dialects/Vector/><code>vector</code> dialect</a>, while Tensors would be more naturally present in the operations of the
<a href=https://mlir.llvm.org/docs/Dialects/Linalg/><code>linalg</code> dialect</a>.</li><li>Tensors can be dynamically shaped, unranked, or have 0 dimensions ; but Vectors can&rsquo;t be.</li><li>You can have a memref (a buffer in memory) containing Vectors but you can&rsquo;t have a memref of a tensor type.</li><li>The set of allowed element types is different: the Tensor type isn&rsquo;t limited while Vector is limited to float and integer types.</li><li>Tensors accept an optional &ldquo;encoding&rdquo; attribute, vector don&rsquo;t at the moment.</li></ol><h2 id=registered-loaded-dependent-whats-up-with-dialects-management>Registered, loaded, dependent: what&rsquo;s up with Dialects management?&nbsp;<a class=headline-hash href=#registered-loaded-dependent-whats-up-with-dialects-management>¶</a></h2><p>Before creating an Operation, a Type, or an Attribute, the associated Dialect
must be already <em>loaded</em> in the <code>MLIRContext</code>. For example the Toy tutorial
explicitly loads the Toy Dialect before emitting the Toy IR from the AST.</p><p>The process of loading a Dialect in the context is not thread-safe, which forces
all involved Dialects to be loaded before the multi-threaded pass manager starts
the execution. To keep the system modular and layered, invoking a pass pipeline
should never require pre-loading dialects explicitly. This is achieved by
requiring every pass to declare a list of <em>dependent</em> Dialects: these are
Dialects for which an entity (Operation, Type, or Attribute) can be created by
the pass, other than for Dialects that would already be in the input.
For example, a <code>convertLinalgToLoops</code> pass would declare the <code>SCF</code> Dialect as
dependent, but does not need to declare <code>Linalg</code>. See also
<a href=https://mlir.llvm.org/docs/PassManagement/#dependent-dialects>dependent dialects</a>
in the pass infrastructure documentation.</p><p>Finally, dialects can be <em>registered</em> with the context. The sole purpose of the
registration is to make these dialects available for the textual parser used by
tools like <code>mlir-opt</code> or <code>mlir-translate</code>. A compiler frontend emitting the IR
programmatically and invoking a pass pipeline would never need to register any
dialects.</p><h2 id=in-dialect-conversion-i-want-an-operation-to-be-removed-after-its-users-get-converted-how-do-i-do-that>In dialect conversion, I want an operation to be removed after its users get converted, how do I do that?&nbsp;<a class=headline-hash href=#in-dialect-conversion-i-want-an-operation-to-be-removed-after-its-users-get-converted-how-do-i-do-that>¶</a></h2><p>This operation can be marked &ldquo;illegal&rdquo; and you can just do speculatively
<code>rewriter.eraseOp(op);</code>. The operation won&rsquo;t be actually removed right now,
instead when mark something as erased you are basically saying to the driver
&ldquo;I expect all uses of this to go away by the time everything is over&rdquo;. The
conversion will fail if the operation you marked as erased doesn&rsquo;t actually get
erased at the end.</p><h2 id=why-is-dialect-x-missing-feature-y>Why is dialect X missing feature Y?&nbsp;<a class=headline-hash href=#why-is-dialect-x-missing-feature-y>¶</a></h2><p>Most likely, nobody has had a need for it yet. Many MLIR components, dialects
even more than others, grew out of specific needs and are extended by volunteers
sending patches to add the missing bits. Everybody is welcome to contribute!</p><p>In some specfic cases, the dialect design might have explicitly decided against
implementing a feature or chose an alternative modeling that provides a similar
functionality. Such design decisions are usually noted in the dialect or
rationale documents.</p><h2 id=many-dialects-define-a-constant-operation-how-do-i-get-a-constant-value-generically>Many dialects define a <code>constant</code> operation, how do I get a constant value generically?&nbsp;<a class=headline-hash href=#many-dialects-define-a-constant-operation-how-do-i-get-a-constant-value-generically>¶</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/IR/Matchers.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Return the constant attribute, or null if the Operation isn&#39;t a constant.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Attribute</span> <span class=nf>getConstantAttr</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>constantOp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Attribute</span> <span class=n>constant</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>matchPattern</span><span class=p>(</span><span class=n>value</span><span class=p>.</span><span class=n>getDefiningOp</span><span class=p>(),</span> <span class=n>m_Constant</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>constant</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h2 id=what-is-the-difference-between-traits-and-interfaces>What is the difference between traits and interfaces?&nbsp;<a class=headline-hash href=#what-is-the-difference-between-traits-and-interfaces>¶</a></h2><p>Both
<a href=https://mlir.llvm.org/docs/Traits/>traits</a> and
<a href=https://mlir.llvm.org/docs/Interfaces>interfaces</a> can be used to inject common
behavior into operations, types and attributes without introducing duplication.
However, conceptually these are quite different.</p><p>Traits inject static behavior into operations/types/attributes whereas
interfaces dynamically dispatch behavior based on their runtime type. For
instance, since
<a href=https://github.com/llvm/llvm-project/blob/f3e1f44340dc26e3810d601edf0e052813b7a11c/mlir/include/mlir/IR/BuiltinOps.td#L167><code>ModuleOp</code></a>
implements the
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/SymbolTable.h#L338><code>SymbolTable</code></a>
trait, <code>mlir::ModuleOp</code> exposes <code>lookupSymbol</code> as a member function. However,
there is no type-erased way to access this functionality &ndash; it is available only
via <code>mlir::ModuleOp</code>. On the other hand, if an operation implements
<a href=https://github.com/llvm/llvm-project/blob/902184e6cc263e4c66440c95a21665b6fdffe57c/mlir/include/mlir/Interfaces/CallInterfaces.td#L25><code>CallOpInterface</code></a>,
its implementation of <code>getCallableForCallee</code> can be invoked in a type-erased
manner by <code>dyn_cast</code>ing the operation to a <code>CallOpInterface</code>. The caller does
not need to know the concrete type of the operation to do this.</p><p>There is one similarity between interfaces and traits: both their presence can
be checked dynamically (i.e. without access to the concrete type).
Specifically, presence of traits can be checked using
<a href=https://github.com/llvm/llvm-project/blob/902184e6cc263e4c66440c95a21665b6fdffe57c/mlir/include/mlir/IR/Operation.h#L470><code>Operation::hasTrait</code></a>
and presence of interfaces can be checked using <code>isa&lt;></code>. However, this
similarity does not run deep, and was only added for practical ergonomic
reasons.</p><h2 id=how-to-convert-a-memref-to-a-pointer>How to convert a <code>memref</code> to a pointer?&nbsp;<a class=headline-hash href=#how-to-convert-a-memref-to-a-pointer>¶</a></h2><p>It is impossible in the general case. Structured memory reference (<code>memref</code>) type <strong>is not (only) a pointer</strong>. This type supports multi-dimensional indexing and customizable data layouts to support advanced yet analyzable addressing modes. Implementing address computation requires understanding the layout and storing additional information such as sizes and layout parameters that would be impossible with a plain, single-typed pointer to a contiguous block of data. Even the single-dimensional <code>memref&lt;?xi8></code> with the default layout is <em>not a pointer</em> as it must store at the very least the size of the data (think C++ <code>std::string</code> vs. C <code>NULL</code>-terminated <code>const char *</code>).</p><p>It is, however, possible to define operations that create pointer-like types out of a <code>memref</code> as well as operations that, conversely, create <code>memref</code> out of pointers combined with additional information. Before implementing such operations, dialect authors are advised to carefully consider the implication of such operations on aliasing properties of the resulting IR.</p><p>Interoperability with C is often cited to motivate an opaque cast from <code>memref</code>s to pointers. The
<a href=https://mlir.llvm.org/docs/TargetLLVMIR/#ranked-memref-types>LLVM IR target</a> provides an interface compatible with C for a well-defined subset of <code>memrefs</code> with
<a href=https://mlir.llvm.org/docs/Dialects/Builtin/#strided-memref>strided layout</a>. At the function boundary, it even provides a minimalist support for passing memrefs as
<a href=https://mlir.llvm.org/docs/TargetLLVMIR/#bare-pointer-calling-convention-for-ranked-memref>bare pointers</a> provided their sizes are known statically and their layout is trivially identity.</p><h2 id=whats-with-op-symbol-declaration-cannot-have-public-visibility>What&rsquo;s with &ldquo;op symbol declaration cannot have public visibility&rdquo;?&nbsp;<a class=headline-hash href=#whats-with-op-symbol-declaration-cannot-have-public-visibility>¶</a></h2><p>A common mistake is to try to provide a function declaration (that is a function
without a body) but leaving it &ldquo;public&rdquo;. Declaration must be private, only
definitions can be public in the MLIR symbol system. See the
<a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/#symbol-visibility>symbol visibility</a>
documentation.</p><h2 id=im-confused-about-iterating-on-getusers-vs-getuses-whats-the-difference>I&rsquo;m confused about iterating on <code>getUsers()</code> vs <code>getUses()</code>: what&rsquo;s the difference?&nbsp;<a class=headline-hash href=#im-confused-about-iterating-on-getusers-vs-getuses-whats-the-difference>¶</a></h2><p>The &ldquo;users&rdquo; of an SSA value are instances of <code>Operation</code>, while the &ldquo;uses&rdquo; refer to
the operands of these operations. For example considering <code>test.op(%0, %0) : ...</code>, when
iterating on the &ldquo;uses&rdquo; of <code>%0</code> you would see two instances of <code>OpOperand</code> (one for each
use in <code>test.op</code>), whereas iterating on the &ldquo;users&rdquo; of <code>%0</code> would yield directly two
<code>Operation *</code> corresponding to <code>test.op</code>. Note that you see <code>test.op</code> twice as it is
twice a user of <code>%0</code>, it&rsquo;s up to the call site to use a set to unique these if needed.
<a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/#traversing-the-def-use-chains>The tutorial on use-def chains</a> may help understand the details as well.</p><h2 id=how-to-programmatically-obtain-the-name-of-the-ssa-value-foo>How to programmatically obtain the &ldquo;name&rdquo; of the SSA value (<code>%foo</code>)?&nbsp;<a class=headline-hash href=#how-to-programmatically-obtain-the-name-of-the-ssa-value-foo>¶</a></h2><p>The values names are <em>not part of the IR</em> and are only there to make textual
representation of the IR easier for humans to read. They are generated by the
IR printer on-the-fly and may differ depending on the printer configuration.
While it is technically possible to configure the printer to produce predictable
names, in particular names with specific prefixes via the
<a href=https://github.com/llvm/llvm-project/blob/main/mlir/include/mlir/IR/OpAsmInterface.td><code>OpAsmOpInterface</code></a>,
one is strongly discouraged from relying on the textual names. Therefore there
is intentionally no support for obtaining these names easily.</p><div class=edit-meta><br><a href=https://github.com/llvm/mlir-www//edit/main/website/content/getting_started/Faq.md class=edit-page><i class="fas fa-pen-square"></i> Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=https://mlir.llvm.org/getting_started/Debugging/ title="Debugging Tips"><i class="fas fa-arrow-left" aria-hidden=true></i> Prev - Debugging Tips</a>
<a class="nav nav-next" href=https://mlir.llvm.org/getting_started/Contributing/ title="How to Contribute">Next - How to Contribute <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=https://mlir.llvm.org/governance/>Governance</a></li><li><a href=https://mlir.llvm.org/users/>Users of MLIR</a></li><li><a href=https://mlir.llvm.org/pubs/>MLIR Related Publications</a></li><li><a href=https://mlir.llvm.org/talks/>Talks</a></li><li><a href=https://mlir.llvm.org/deprecation/>Deprecations & Current Refactoring</a></li><li class="parent has-sub-menu"><a href=https://mlir.llvm.org/getting_started/>Getting Started<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/getting_started/ReportingIssues/>Reporting Issues</a></li><li><a href=https://mlir.llvm.org/getting_started/Debugging/>Debugging Tips</a></li><li class=active><a href=https://mlir.llvm.org/getting_started/Faq/>FAQ</a></li><li><a href=https://mlir.llvm.org/getting_started/Contributing/>How to Contribute</a></li><li><a href=https://mlir.llvm.org/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=https://mlir.llvm.org/getting_started/openprojects/>Open Projects</a></li><li><a href=https://mlir.llvm.org/getting_started/Glossary/>Glossary</a></li><li><a href=https://mlir.llvm.org/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/>Code Documentation<span class="mark closed">+</span></a><ul class=sub-menu><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Bindings/>Bindings<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Bindings/Python/>MLIR Python Bindings</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tools/>Tools<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tools/MLIRLSP/>MLIR : Language Server Protocol</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-reduce/>MLIR Reduce</a></li><li><a href=https://mlir.llvm.org/docs/Tools/mlir-rewrite/>mlir-rewrite</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ActionTracing/>Action: Tracing and Debugging MLIR-based Compilers</a></li><li><a href=https://mlir.llvm.org/docs/Bufferization/>Bufferization</a></li><li><a href=https://mlir.llvm.org/docs/DataLayout/>Data Layout Modeling</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/DefiningDialects/>Defining Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Constraints/>Constraints</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Assembly/>Customizing Assembly Behavior</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/AttributesAndTypes/>Defining Dialect Attributes and Types</a></li><li><a href=https://mlir.llvm.org/docs/DefiningDialects/Operations/>Operation Definition Specification (ODS)</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Diagnostics/>Diagnostic Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/DialectConversion/>Dialect Conversion</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/>Dialects<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenACCDialect/>'acc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Affine/>'affine' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMDGPU/>'amdgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AMX/>'amx' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArithOps/>'arith' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmNeon/>'arm_neon' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSVE/>'arm_sve' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ArmSME/>'ArmSME' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/AsyncDialect/>'async' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/BufferizationOps/>'bufferization' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ControlFlowDialect/>'cf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ComplexOps/>'complex' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/DLTIDialect/>'dlti' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/EmitC/>'emitc' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Func/>'func' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/GPU/>'gpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/>'index' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/IRDL/>'irdl' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/Linalg/>'linalg' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/Linalg/OpDSL/>Linalg OpDSL</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/LLVM/>'llvm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MathOps/>'math' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MemRef/>'memref' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MLProgramOps/>'ml_program' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MPI/>'mpi' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVGPU/>'nvgpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/NVVMDialect/>'nvvm' Dialect</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/>'omp' Dialect<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Dialects/OpenMPDialect/ODS/>ODS Documentation</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLInterpOps/>'pdl_interp' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PDLOps/>'pdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/PtrOps/>'ptr' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/QuantDialect/>'quant' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ROCDLDialect/>'rocdl' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SCFDialect/>'scf' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/ShapeDialect/>'shape' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Shard/>'shard' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SMT/>'smt' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SparseTensorOps/>'sparse_tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TensorOps/>'tensor' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/UBOps/>'ub' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/VCIXDialect/>'vcix' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Vector/>'vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/X86Vector/>'x86vector' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeGPU/>'xegpu' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/XeVMDialect/>'xevm' Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Builtin/>Builtin Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/MatchOpInterfaces/>OpInterface definitions</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/TOSA/>Tensor Operator Set Architecture (TOSA) Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Dialects/Transform/>Transform Dialect</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Interfaces/>Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/TargetLLVMIR/>LLVM IR Target</a></li><li><a href=https://mlir.llvm.org/docs/BytecodeFormat/>MLIR Bytecode Format</a></li><li><a href=https://mlir.llvm.org/docs/CAPI/>MLIR C API</a></li><li><a href=https://mlir.llvm.org/docs/LangRef/>MLIR Language Reference</a></li><li><a href=https://mlir.llvm.org/docs/ReleaseNotes/>MLIR Release Notes</a></li><li><a href=https://mlir.llvm.org/docs/Canonicalization/>Operation Canonicalization</a></li><li><a href=https://mlir.llvm.org/docs/OwnershipBasedBufferDeallocation/>Ownership-based Buffer Deallocation</a></li><li><a href=https://mlir.llvm.org/docs/PassManagement/>Pass Infrastructure</a></li><li><a href=https://mlir.llvm.org/docs/Passes/>Passes</a></li><li><a href=https://mlir.llvm.org/docs/PatternRewriter/>Pattern Rewriting : Generic DAG-to-DAG Rewriting</a></li><li><a href=https://mlir.llvm.org/docs/PDLL/>PDLL - PDL Language</a></li><li><a href=https://mlir.llvm.org/docs/Quantization/>Quantization</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Rationale/>Rationale<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleGenericDAGRewriter/>Generic DAG Rewriter Infrastructure Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleLinalgDialect/>Linalg Dialect Rationale: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/Rationale/>MLIR Rationale</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/SideEffectsAndSpeculation/>Side Effects & Speculation</a></li><li><a href=https://mlir.llvm.org/docs/Rationale/UsageOfConst/>Usage of 'const' in MLIR, for core IR types</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/ShapeInference/>Shape Inference</a></li><li><a href=https://mlir.llvm.org/docs/SPIRVToLLVMDialectConversion/>SPIR-V Dialect to LLVM Dialect conversion manual</a></li><li><a href=https://mlir.llvm.org/docs/SymbolsAndSymbolTables/>Symbols and Symbol Tables</a></li><li><a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Traits/>Traits<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Traits/Broadcastable/>The `Broadcastable` Trait</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/>Tutorials<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/CreatingADialect/>Creating a Dialect</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/Toy/>Toy Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Language and AST</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=has-sub-menu><a href=https://mlir.llvm.org/docs/Tutorials/transform/>Transform Dialect Tutorial<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch0/>Chapter 0: A Primer on “Structured” Linalg Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch1/>Chapter 1: Combining Existing Transformations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch2/>Chapter 2: Adding a Simple New Transformation Operation</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch3/>Chapter 3: More than Simple Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/Ch4/>Chapter 4: Matching Payload with Transform Operations</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/transform/ChH/>Chapter H: Reproducing Halide Schedule</a></li></ul></li><li><a href=https://mlir.llvm.org/docs/Tutorials/UnderstandingTheIRStructure/>Understanding the IR Structure</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/MlirOpt/>Using `mlir-opt`</a></li><li><a href=https://mlir.llvm.org/docs/Tutorials/DataFlowAnalysis/>Writing DataFlow Analyses in MLIR</a></li></ul></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>