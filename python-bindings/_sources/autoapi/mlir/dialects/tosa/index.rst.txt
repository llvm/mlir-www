mlir.dialects.tosa
==================

.. py:module:: mlir.dialects.tosa


Classes
-------

.. autoapisummary::

   mlir.dialects.tosa.AbsOp
   mlir.dialects.tosa.AddOp
   mlir.dialects.tosa.ApplyScaleOp
   mlir.dialects.tosa.ArgMaxOp
   mlir.dialects.tosa.ArithmeticRightShiftOp
   mlir.dialects.tosa.AvgPool2dOp
   mlir.dialects.tosa.BitwiseAndOp
   mlir.dialects.tosa.BitwiseNotOp
   mlir.dialects.tosa.BitwiseOrOp
   mlir.dialects.tosa.BitwiseXorOp
   mlir.dialects.tosa.CastFromBlockScaledOp
   mlir.dialects.tosa.CastOp
   mlir.dialects.tosa.CastToBlockScaledOp
   mlir.dialects.tosa.CeilOp
   mlir.dialects.tosa.ClampOp
   mlir.dialects.tosa.ClzOp
   mlir.dialects.tosa.ConcatOp
   mlir.dialects.tosa.ConstOp
   mlir.dialects.tosa.ConstShapeOp
   mlir.dialects.tosa.Conv2DOp
   mlir.dialects.tosa.Conv3DOp
   mlir.dialects.tosa.CosOp
   mlir.dialects.tosa.CustomOp
   mlir.dialects.tosa.DepthwiseConv2DOp
   mlir.dialects.tosa.EqualOp
   mlir.dialects.tosa.ErfOp
   mlir.dialects.tosa.ExpOp
   mlir.dialects.tosa.FFT2dOp
   mlir.dialects.tosa.FloorOp
   mlir.dialects.tosa.GatherOp
   mlir.dialects.tosa.GreaterEqualOp
   mlir.dialects.tosa.GreaterOp
   mlir.dialects.tosa.IdentityOp
   mlir.dialects.tosa.IfOp
   mlir.dialects.tosa.IntDivOp
   mlir.dialects.tosa.LogOp
   mlir.dialects.tosa.LogicalAndOp
   mlir.dialects.tosa.LogicalLeftShiftOp
   mlir.dialects.tosa.LogicalNotOp
   mlir.dialects.tosa.LogicalOrOp
   mlir.dialects.tosa.LogicalRightShiftOp
   mlir.dialects.tosa.LogicalXorOp
   mlir.dialects.tosa.MatMulOp
   mlir.dialects.tosa.MatmulTBlockScaledOp
   mlir.dialects.tosa.MaxPool2dOp
   mlir.dialects.tosa.MaximumOp
   mlir.dialects.tosa.MinimumOp
   mlir.dialects.tosa.MulOp
   mlir.dialects.tosa.NegateOp
   mlir.dialects.tosa.PadOp
   mlir.dialects.tosa.PowOp
   mlir.dialects.tosa.RFFT2dOp
   mlir.dialects.tosa.ReciprocalOp
   mlir.dialects.tosa.ReduceAllOp
   mlir.dialects.tosa.ReduceAnyOp
   mlir.dialects.tosa.ReduceMaxOp
   mlir.dialects.tosa.ReduceMinOp
   mlir.dialects.tosa.ReduceProductOp
   mlir.dialects.tosa.ReduceSumOp
   mlir.dialects.tosa.RescaleOp
   mlir.dialects.tosa.ReshapeOp
   mlir.dialects.tosa.ResizeOp
   mlir.dialects.tosa.ReverseOp
   mlir.dialects.tosa.RsqrtOp
   mlir.dialects.tosa.ScatterOp
   mlir.dialects.tosa.SelectOp
   mlir.dialects.tosa.SigmoidOp
   mlir.dialects.tosa.SinOp
   mlir.dialects.tosa.SliceOp
   mlir.dialects.tosa.SubOp
   mlir.dialects.tosa.TableOp
   mlir.dialects.tosa.TanhOp
   mlir.dialects.tosa.TileOp
   mlir.dialects.tosa.TransposeConv2DOp
   mlir.dialects.tosa.TransposeOp
   mlir.dialects.tosa.VariableOp
   mlir.dialects.tosa.VariableReadOp
   mlir.dialects.tosa.VariableWriteOp
   mlir.dialects.tosa.WhileOp
   mlir.dialects.tosa.YieldOp


Functions
---------

.. autoapisummary::

   mlir.dialects.tosa.abs
   mlir.dialects.tosa.add
   mlir.dialects.tosa.apply_scale
   mlir.dialects.tosa.argmax
   mlir.dialects.tosa.arithmetic_right_shift
   mlir.dialects.tosa.avg_pool2d
   mlir.dialects.tosa.bitwise_and
   mlir.dialects.tosa.bitwise_not
   mlir.dialects.tosa.bitwise_or
   mlir.dialects.tosa.bitwise_xor
   mlir.dialects.tosa.cast_from_block_scaled
   mlir.dialects.tosa.cast
   mlir.dialects.tosa.cast_to_block_scaled
   mlir.dialects.tosa.ceil
   mlir.dialects.tosa.clamp
   mlir.dialects.tosa.clz
   mlir.dialects.tosa.concat
   mlir.dialects.tosa.const
   mlir.dialects.tosa.const_shape
   mlir.dialects.tosa.conv2d
   mlir.dialects.tosa.conv3d
   mlir.dialects.tosa.cos
   mlir.dialects.tosa.custom
   mlir.dialects.tosa.depthwise_conv2d
   mlir.dialects.tosa.equal
   mlir.dialects.tosa.erf
   mlir.dialects.tosa.exp
   mlir.dialects.tosa.fft2d
   mlir.dialects.tosa.floor
   mlir.dialects.tosa.gather
   mlir.dialects.tosa.greater_equal
   mlir.dialects.tosa.greater
   mlir.dialects.tosa.identity
   mlir.dialects.tosa.cond_if
   mlir.dialects.tosa.intdiv
   mlir.dialects.tosa.log
   mlir.dialects.tosa.logical_and
   mlir.dialects.tosa.logical_left_shift
   mlir.dialects.tosa.logical_not
   mlir.dialects.tosa.logical_or
   mlir.dialects.tosa.logical_right_shift
   mlir.dialects.tosa.logical_xor
   mlir.dialects.tosa.matmul
   mlir.dialects.tosa.matmul_t_block_scaled
   mlir.dialects.tosa.max_pool2d
   mlir.dialects.tosa.maximum
   mlir.dialects.tosa.minimum
   mlir.dialects.tosa.mul
   mlir.dialects.tosa.negate
   mlir.dialects.tosa.pad
   mlir.dialects.tosa.pow
   mlir.dialects.tosa.rfft2d
   mlir.dialects.tosa.reciprocal
   mlir.dialects.tosa.reduce_all
   mlir.dialects.tosa.reduce_any
   mlir.dialects.tosa.reduce_max
   mlir.dialects.tosa.reduce_min
   mlir.dialects.tosa.reduce_product
   mlir.dialects.tosa.reduce_sum
   mlir.dialects.tosa.rescale
   mlir.dialects.tosa.reshape
   mlir.dialects.tosa.resize
   mlir.dialects.tosa.reverse
   mlir.dialects.tosa.rsqrt
   mlir.dialects.tosa.scatter
   mlir.dialects.tosa.select
   mlir.dialects.tosa.sigmoid
   mlir.dialects.tosa.sin
   mlir.dialects.tosa.slice
   mlir.dialects.tosa.sub
   mlir.dialects.tosa.table
   mlir.dialects.tosa.tanh
   mlir.dialects.tosa.tile
   mlir.dialects.tosa.transpose_conv2d
   mlir.dialects.tosa.transpose
   mlir.dialects.tosa.variable
   mlir.dialects.tosa.variable_read
   mlir.dialects.tosa.variable_write
   mlir.dialects.tosa.while_loop
   mlir.dialects.tosa.yield_


Module Contents
---------------

.. py:class:: AbsOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise absolute value operation.

   Example:

   .. code:: mlir

       %output = tosa.abs(%input1) : (tensor<21x3xf32>) -> tensor<21x3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.abs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: abs(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AddOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise addition of input1 and input2. Axis of size 1 will be broadcast,
   as necessary. Rank of input tensors must match.

   Example:

   .. code:: mlir

       // Elementwise addition.
       %out = tosa.add %input1, %input2 : tensor<12x6xf32>, tensor<12x6xf32> -> tensor<12x6xf32>
       
       // Elementwise addition with broadcasting.
       %out = tosa.add %input1, %input2 : tensor<12x6xsi32>, tensor<1x1xsi32> -> tensor<12x6xsi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.add'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: add(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ApplyScaleOp(output, value, multiplier, shift, rounding_mode, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Applies rescaling for fixed point values. This behavior is replicated in
   multiple quantized operations (mul, convolution, rescale, matmul, pooling).

   The commonplace implementation is to use i64 operations to avoid integer
   overflow with target specific implementations can use native operations to
   avoid wider than necessary types.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.apply_scale'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: multiplier() -> _ods_ir


   .. py:method:: shift() -> _ods_ir


   .. py:method:: rounding_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: apply_scale(output, value, multiplier, shift, rounding_mode, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ArgMaxOp(output, input, axis, *, nan_mode=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This returns the index with the largest value across the given axis of the
   input tensor. If multiple locations have equal values, returns the first
   match along the search axis.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.argmax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: argmax(output, input, axis, *, nan_mode=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ArithmeticRightShiftOp(output, input1, input2, round, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise arithmetic right shift of input1 by the amount specified in
   input2. Axis of size 1 will be broadcast, as necessary. Rank of input tensors
   must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.arithmetic_right_shift'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: round() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: arithmetic_right_shift(output, input1, input2, round, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AvgPool2dOp(output, input, input_zp, output_zp, kernel, stride, pad, acc_type, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This performs an average pooling over the given input tensor. A sliding
   window of size given by  is passed over the input tensor, with
   the mean value being placed in the output tensor. When calculating the
   average, only the number of valid input tensor values, but not padding, are
   used to calculate the divisor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.avg_pool2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: output_zp() -> _ods_ir


   .. py:method:: kernel() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: pad() -> _ods_ir


   .. py:method:: acc_type() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: avg_pool2d(output, input, input_zp, output_zp, kernel, stride, pad, acc_type, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseAndOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise bitwise AND of input1 and input2. Axis of size 1
   will be broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.bitwise_and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: bitwise_and(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseNotOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise bitwise NOT of input tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.bitwise_not'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: bitwise_not(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseOrOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise bitwise OR of input1 and input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.bitwise_or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: bitwise_or(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseXorOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise bitwise XOR of input1 and input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.bitwise_xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: bitwise_xor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CastFromBlockScaledOp(output_data, input_data, input_scale, block_size, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Apply the scales from a scale tensor to the values in a value tensor, casting
   the result to the output type. The block dimension must be the last dimension
   of the tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.cast_from_block_scaled'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input_data() -> _ods_ir


   .. py:method:: input_scale() -> _ods_ir


   .. py:method:: block_size() -> _ods_ir


   .. py:method:: output_data() -> _ods_ir


.. py:function:: cast_from_block_scaled(output_data, input_data, input_scale, block_size, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CastOp(output, input, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Casts a tensor from one data type to another.

   * This table is showing the supported conversions from the TOSA Specification.
   * The MLIR dialect here can be used to represent other conversions.

   | Mode                     | Input   | Output  |
   |--------------------------|---------|---------|
   | fp16 to fp32             | float16 | float32 |
   | fp16 to int 16           | float16 | int16   |
   | fp16 to int 32           | float16 | int32   |
   | fp16 to int 8            | float16 | int8    |
   | fp32 to fp16             | float32 | float16 |
   | fp32 to int 16           | float32 | int16   |
   | fp32 to int 32           | float32 | int32   |
   | fp32 to int 8            | float32 | int8    |
   | int 16 to fp16           | int16   | float16 |
   | int 16 to fp32           | int16   | float32 |
   | int 32 to fp16           | int32   | float16 |
   | int 32 to fp32           | int32   | float32 |
   | int 8 to fp16            | int8    | float16 |
   | int 8 to fp32            | int8    | float32 |
   | bool to int 16           | Boolean | int16   |
   | bool to int 32           | Boolean | int32   |
   | bool to int 8            | Boolean | int8    |
   | int 16 to bool           | int16   | Boolean |
   | int 16 to int 32         | int16   | int32   |
   | int 16 to int 8          | int16   | int8    |
   | int 32 to bool           | int32   | Boolean |
   | int 32 to int 16         | int32   | int16   |
   | int 32 to int 8          | int32   | int8    |
   | int 8 to bool            | int8    | Boolean |
   | int 8 to int 16          | int8    | int16   |
   | int 8 to int 32          | int8    | int32   |
   | bf16 to fp32             | bf16    | float32 |
   | bf16 to int 16           | bf16    | int16   |
   | bf16 to int 32           | bf16    | int32   |
   | bf16 to int 8            | bf16    | int8    |
   | fp32 to bf16             | float32 | bf16    |
   | int 16 to bf16           | int16   | bf16    |
   | int 32 to bf16           | int32   | bf16    |
   | int 8 to bf16            | int8    | bf16    |
   | bf16 to fp8e4m3          | bf16    | fp8e4m3 |
   | fp8e4m3 to bf16          | fp8e4m3 | bf16    |
   | bf16 to fp8e5m2          | bf16    | fp8e5m2 |
   | fp8e5m2 to bf16          | fp8e5m2 | bf16    |
   | fp16 to fp8e4m3          | float16 | fp8e4m3 |
   | fp32 to fp8e4m3          | float32 | fp8e4m3 |
   | fp8e4m3 to fp16          | fp8e4m3 | float16 |
   | fp8e4m3 to fp32          | fp8e4m3 | float32 |
   | fp16 to fp8e5m2          | float16 | fp8e5m2 |
   | fp32 to fp8e5m2          | float32 | fp8e5m2 |
   | fp8e5m2 to fp16          | fp8e5m2 | float16 |
   | fp8e5m2 to fp32          | fp8e5m2 | float32 |


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.cast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: cast(output, input, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CastToBlockScaledOp(output_data, output_scale, input_data, block_size, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Calculate a scale value per block of input values and use that to calculate
   scaled data values from an input tensor. The output tensors are cast to the
   specified scale and value types. The block dimension will be the last dimension
   of the tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.cast_to_block_scaled'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input_data() -> _ods_ir


   .. py:method:: block_size() -> _ods_ir


   .. py:method:: output_data() -> _ods_ir


   .. py:method:: output_scale() -> _ods_ir


.. py:function:: cast_to_block_scaled(output_data, output_scale, input_data, block_size, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CeilOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise ceiling operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.ceil'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: ceil(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ClampOp(output, input, min_val, max_val, *, nan_mode=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Clamp to an arbitrary minimum and maximum value.
   Maximum and minimum values are specified as values in the range of the
   input type.
   No zero point subtraction is done to the values, thus to clamp to the zero
   point value, the zero point itself should be supplied as the minimum value.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.clamp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: min_val() -> _ods_ir


   .. py:method:: max_val() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: clamp(output, input, min_val, max_val, *, nan_mode=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ClzOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise count leading zeros operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.clz'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: clz(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConcatOp(input1, axis, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Concatenate a list of tensors along a given axis.
   No data conversion happens during a concat operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.concat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: concat(input1, axis, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstOp(values, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   A node containing constant data for use as the input to an operation. May
   hold data in any of the supported data formats.

   Example:

   .. code:: mlir

       // Generic form
       %out = "tosa.const"() {values = dense<0> : tensor<2x3xi32>} : () -> tensor<2x3xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.const'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: values() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: const(values, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstShapeOp(output, values, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   A node containing a constant shape.

   Example:

   .. code:: mlir

       // Generic form
       %out = "tosa.const_shape"() {values = dense<0> : tensor<4xindex>} : () -> !tosa.shape<4>


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.const_shape'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: values() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: const_shape(output, values, *, loc=None, ip=None) -> _ods_ir

.. py:class:: Conv2DOp(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs a 2D convolution over the given tensor input, using the weight
   tensor. Implementations may choose to skip calculation of multiplies in
   the padding area.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.conv2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: weight() -> _ods_ir


   .. py:method:: bias() -> _ods_ir


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: weight_zp() -> _ods_ir


   .. py:method:: pad() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: dilation() -> _ods_ir


   .. py:method:: acc_type() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output() -> _ods_ir


.. py:function:: conv2d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Conv3DOp(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs a 3D convolution over the given input tensor. Implementations
   may choose to skip calculation of multiplies in the padding area.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.conv3d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: weight() -> _ods_ir


   .. py:method:: bias() -> _ods_ir


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: weight_zp() -> _ods_ir


   .. py:method:: pad() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: dilation() -> _ods_ir


   .. py:method:: acc_type() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output() -> _ods_ir


.. py:function:: conv3d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CosOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise cosine operation for values given in radians.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.cos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: cos(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CustomOp(output_list, operator_name, domain_name, implementation_attrs, input_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Hardware implementing TOSA may choose to add additional custom operators
   that are not expressed in the existing TOSA operations. These operators are
   not expected to be portable across TOSA implementations. The input and
   output signatures must be expressed in the corresponding TOSA node.

   ``operator_name`` is a string that tells the backend which custom operator is
   being called.

   ``domain_name`` is a string identifier which can help avoid name collisions on
   the identifier field.

   ``implementation_attrs`` is a string which is a backend and identifier specific
   set of attributes to the custom operator.

   ``input_list`` is the set of tensor inputs to the custom operator.

   ``output_list`` is the list of tensors returned by the operator. The number of operators
   is backend specific.

   Example:

   .. code:: mlir

       %out = tosa.custom %in {domain_name = "tosa_mlir_test", operator_name =
              "custom_test", implementation_attrs = ""}: (tensor<10xi32>) ->
              (tensor<10xi32>)


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.custom'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input_list() -> _ods_ir


   .. py:method:: operator_name() -> _ods_ir


   .. py:method:: domain_name() -> _ods_ir


   .. py:method:: implementation_attrs() -> _ods_ir


   .. py:method:: output_list() -> _ods_ir


.. py:function:: custom(output_list, operator_name, domain_name, implementation_attrs, input_list, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, CustomOp]

.. py:class:: DepthwiseConv2DOp(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs 2D convolutions separately over each channel of the given tensor
   input, using the weight tensor. Implementations may choose to skip
   calculation of multiplies in the padding area.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.depthwise_conv2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: weight() -> _ods_ir


   .. py:method:: bias() -> _ods_ir


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: weight_zp() -> _ods_ir


   .. py:method:: pad() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: dilation() -> _ods_ir


   .. py:method:: acc_type() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output() -> _ods_ir


.. py:function:: depthwise_conv2d(output, input, weight, bias, input_zp, weight_zp, pad, stride, dilation, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: EqualOp(input1, input2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise comparison operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.equal'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: equal(input1, input2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ErfOp(output, input, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Gauss error function: $ erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt $
   For quantized integer data types, the TABLE operator should be used instead
   with the following definition. The ERF table has 513 entries each of
   16-bit precision and covering the input range -4.0 to +4.0 in steps of 1/64.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.erf'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: erf(output, input, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ExpOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise e to the x operation


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.exp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: exp(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FFT2dOp(output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs a batched complex 2D Fast Fourier Transform over the input. The
   complex input values are constructed from the corresponding values in the
   input_real and input_imag tensors. The resulting values in the output are
   split into the output_real and output_imag tensors. No normalization is
   applied on either the forward or inverse versions of the operation.

   Example:

   .. code:: mlir

        %output_real, %output_imag = tosa.fft2d %input_real, %input_imag : (tensor<8x9xf32>, tensor<8x9xf32>) -> (tensor<8x9xf32>, tensor<8x9xf32>)


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.fft2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input_real() -> _ods_ir


   .. py:method:: input_imag() -> _ods_ir


   .. py:method:: inverse() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output_real() -> _ods_ir


   .. py:method:: output_imag() -> _ods_ir


.. py:function:: fft2d(output_real, output_imag, input_real, input_imag, inverse, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FloorOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise floor operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.floor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: floor(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GatherOp(output, values, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Generate a tensor for which each element in the output is a subtensor of the
   values tensor based on the indices. N is the number of batches, W the number
   of indices in each batch, K the range of each index and C the number data
   channels for each index.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.gather'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: values() -> _ods_ir


   .. py:method:: indices() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: gather(output, values, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GreaterEqualOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise comparison operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.greater_equal'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: greater_equal(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GreaterOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise greater than comparison operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.greater'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: greater(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: IdentityOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns a tensor with the same shape, type, and contents as the input.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.identity'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: identity(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: IfOp(output_list, condition, input_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Evaluates a Boolean condition and then takes one of two distinct execution
   paths. This implements the semantic If-then-else structure.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.cond_if'



   .. py:attribute:: _ODS_REGIONS
      :value: (2, True)



   .. py:method:: condition() -> _ods_ir


   .. py:method:: input_list() -> _ods_ir


   .. py:method:: output_list() -> _ods_ir


   .. py:method:: then_graph() -> _ods_ir


   .. py:method:: else_graph() -> _ods_ir


.. py:function:: cond_if(output_list, condition, input_list, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, IfOp]

.. py:class:: IntDivOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise integer divide of input1 by input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match. The result of the
   divide is truncated towards zero. Expected use is for operations on
   non-scaled integers. Floating point divide should use RECIPROCAL and MUL.
   Quantized integer divide should use TABLE (for 1/x) and MUL.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.intdiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: intdiv(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise natural logarithm operation


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.log'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: log(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalAndOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical AND of input1 and input2. Axis of size 1 will be
   broadcast, as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_and(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalLeftShiftOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical left-shift of input1 by the amount specified in input2.
   Axis of size 1 will be broadcast, as necessary.
   Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_left_shift'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_left_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalNotOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical NOT of input.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_not'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_not(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalOrOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical OR of input1 and input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_or(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalRightShiftOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical right shift of input1 by the amount specified in input2.
   Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
   match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_right_shift'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_right_shift(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalXorOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise logical XOR of input1 and input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.logical_xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: logical_xor(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MatMulOp(output, a, b, a_zp, b_zp, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs two dimensional matrix multiplications.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.matmul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: a_zp() -> _ods_ir


   .. py:method:: b_zp() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: matmul(output, a, b, a_zp, b_zp, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MatmulTBlockScaledOp(output_data, a_data, a_scale, b_data, b_scale, block_size, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs two dimensional matrix multiplications using block scaled tensors. The block
   dimension is always the the last dimension of the tensor, so the result is effectively
   a matrix multiply of A by the transposed B matrix. If the N dimension of input B is of
   size 1, the B matrix will be broadcast.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.matmul_t_block_scaled'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a_data() -> _ods_ir


   .. py:method:: a_scale() -> _ods_ir


   .. py:method:: b_data() -> _ods_ir


   .. py:method:: b_scale() -> _ods_ir


   .. py:method:: block_size() -> _ods_ir


   .. py:method:: output_data() -> _ods_ir


.. py:function:: matmul_t_block_scaled(output_data, a_data, a_scale, b_data, b_scale, block_size, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MaxPool2dOp(output, input, kernel, stride, pad, *, nan_mode=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This performs a max pooling over the given input tensor. A sliding window of
   size given by  is passed over the input tensor, with the
   maximum value being placed in the
   output tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.max_pool2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: kernel() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: pad() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: max_pool2d(output, input, kernel, stride, pad, *, nan_mode=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MaximumOp(output, input1, input2, *, nan_mode=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise max of input1 and input2. Axis of size 1 will be broadcast, as
   necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.maximum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: maximum(output, input1, input2, *, nan_mode=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MinimumOp(output, input1, input2, *, nan_mode=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise minimum of input1 and input2. Axis of size 1
   will be broadcast, as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.minimum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: minimum(output, input1, input2, *, nan_mode=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MulOp(output, input1, input2, shift, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise multiplication (Hadamard product) of input1 and input2.
   Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
   match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.mul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: shift() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: mul(output, input1, input2, shift, *, loc=None, ip=None) -> _ods_ir

.. py:class:: NegateOp(output, input1, input1_zp, output_zp, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise negation operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.negate'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input1_zp() -> _ods_ir


   .. py:method:: output_zp() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: negate(output, input1, input1_zp, output_zp, *, loc=None, ip=None) -> _ods_ir

.. py:class:: PadOp(output, input1, padding, pad_const, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Pads a tensor along the borders of each dimension with a supplied value.
   Returns a new tensor with the padding included. The pad_const value includes
   the zero point if the tensor uses a zero point.

   Example:

   .. code:: mlir

       %pad_const = "tosa.const"() {values = dense<3.14> : tensor<1xf32>} : () -> tensor<1xf32>
       %padding = tosa.const_shape {values = dense<[1, 2, 3, 4]> : tensor<4xindex>} : () -> !tosa.shape<4>
       tosa.pad %arg0, %padding, %pad_const: (tensor<1x2xf32>, !tosa.shape<4>, tensor<1xf32>)  -> (tensor<4x9xf32>)

   Example 2:

   .. code:: mlir

       %pad_const = "tosa.const"() {values = dense<3.14> : tensor<1xf32>} : () -> tensor<1xf32>
       %padding = tosa.const_shape {values = dense<[-1, 2, 3, 4]> : tensor<4xindex>} : () -> !tosa.shape<4>
       tosa.pad %arg0, %padding, %pad_const : (tensor<1x2xf32>, !tosa.shape<4>, tensor<1xf32>)  -> (tensor<?x9xf32>)


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.pad'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: padding() -> _ods_ir


   .. py:method:: pad_const() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: pad(output, input1, padding, pad_const, *, loc=None, ip=None) -> _ods_ir

.. py:class:: PowOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise input1 value raised to the power of input2.
   Axis of size 1 will be broadcast, as necessary. Rank of input tensors must
   match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.pow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: pow(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: RFFT2dOp(output_real, output_imag, input_real, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs a batched 2D real-valued Fast Fourier Transform over the input where
   the input tensor consists of real values producing complex valued output. The
   complex output values will be split into the output_real and output_imag
   tensor arguments. RFFT2D takes advantage of Hermitian symmetry to only
   calculate the first half of the final output axis. Implementations may choose
   to skip calculation of the imaginary values at (0,0), (0,W/2), (H/2,0), and
   (H/2, W/2). If the calculation is skipped, the result at that location must be
   zero.

   Example:

   .. code:: mlir

        %ouput_real, %output_imag = tosa.rfft2d %input_real : (tensor<8x16xf32>) -> (tensor<8x9xf32>, tensor<8x9xf32>)


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.rfft2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input_real() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output_real() -> _ods_ir


   .. py:method:: output_imag() -> _ods_ir


.. py:function:: rfft2d(output_real, output_imag, input_real, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReciprocalOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise reciprocal operation. For integer operation, a TABLE should be
   used with the appropriate ranges.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reciprocal'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reciprocal(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceAllOp(input, axis, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis with a logical AND operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_all'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_all(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceAnyOp(input, axis, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis with a logical OR operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_any'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_any(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceMaxOp(input, axis, *, nan_mode=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis with a maximum operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_max'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_max(input, axis, *, nan_mode=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceMinOp(input, axis, *, nan_mode=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis with a minimum operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_min'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: nan_mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_min(input, axis, *, nan_mode=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceProductOp(input, axis, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis by computing the product of the axis.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_product'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_product(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ReduceSumOp(input, axis, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reduce a tensor along the given axis by computing the sum of the axis.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reduce_sum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reduce_sum(input, axis, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: RescaleOp(output, input, multiplier, shift, input_zp, output_zp, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   RESCALE is defined using an integer multiply, add, and shift.

   Rescale supports two precisions of multiplier: 16-bit and 32-bit. The 32-bit multiplier
   version supports two rounding modes to enable simpler lowering of existing frameworks
   that use two stage rounding. All arithmetic is designed so that it does not overflow a
   64-bit accumulator and that the result fits in 32 bits. In particular, a 48-bit value
   cannot be scaled with the 32-bit multiplier because the accumulator would need to have
   80 bits.

   The shift and value range are limited to allow a variety of implementations. The limit
   of 62 on shift allows the shift to be decomposed as two right shifts of 31.

   Supported rescalings:

   * This table is showing the supported conversions from the TOSA Specification.
   * The MLIR dialect here can be used to represent other conversions.

   | Mode                   | Input | Output | Unsigned input | Unsigned output |
   |------------------------|-------|--------|----------------|-----------------|
   | signed 16 to 16        | int16 | int16  |  false         |  false          |
   | signed 16 to 32        | int16 | int32  |  false         |  false          |
   | signed 16 to 8         | int16 | int8   |  false         |  false          |
   | signed 32 to 16        | int32 | int16  |  false         |  false          |
   | signed 32 to 32        | int32 | int32  |  false         |  false          |
   | signed 32 to 8         | int32 | int8   |  false         |  false          |
   | signed 8 to 16         | int8  | int16  |  false         |  false          |
   | signed 8 to 32         | int8  | int32  |  false         |  false          |
   | signed 8 to 8          | int8  | int8   |  false         |  false          |
   | signed 48 to 16        | int48 | int16  |  false         |  false          |
   | signed 48 to 32        | int48 | int32  |  false         |  false          |
   | signed 48 to 8         | int48 | int8   |  false         |  false          |
   | unsigned 8 to signed 8 | uint8 | int8   |  true          |  false          |
   | signed 8 to unsigned 8 | int8  | uint8  |  false         |  true           |


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.rescale'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: multiplier() -> _ods_ir[_ods_ir]


   .. py:method:: shift() -> _ods_ir[_ods_ir]


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: output_zp() -> _ods_ir


   .. py:method:: scale32() -> _ods_ir


   .. py:method:: rounding_mode() -> _ods_ir


   .. py:method:: per_channel() -> _ods_ir


   .. py:method:: input_unsigned() -> _ods_ir


   .. py:method:: output_unsigned() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: rescale(output, input, multiplier, shift, input_zp, output_zp, scale32, rounding_mode, per_channel, input_unsigned, output_unsigned, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReshapeOp(input1, shape, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns a tensor with the same type/values as the input, with a new shape
   specified by the shape argument. Reshape may operate on tensors of any rank.
   No data conversion happens during a reshape operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reshape'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: shape() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reshape(input1, shape, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ResizeOp(output, input, scale, offset, border, mode, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Resizes a tensor. Resize is only allowed in the H and W dimensions.

   The height dimension is scaled by factor (scale_y_n/scale_y_d). The width
   dimension is scaled by factor (scale_x_n/scale_x_d).

   The NEAREST_NEIGHBOR mode returns the value of the input tensor closest to
   the calculated sample position for both floating-point and integer data
   formats.

   Floating-point BILINEAR mode returns a bilinearly interpolated output value
   based on the four closest input sample positions.

   For integer BILINEAR interpolation mode, the output value must be scaled by
   1/(scale_y_n * scale_x_n) in a following operation to complete the
   interpolation (for example with a RESCALE operator).

   The output dimensions can be derived from the input dimensions by inverting
   the scale as described in the pseudocode. The [border_y, border_x] values
   adjust the output size to allow fractional sampling beyond integer input
   position (IH - 1,IW - 1).

   The limit MAX_SCALE is applied to each scale ratio after reduction of the
   ratio. Individual scale numerator and denominator values are allowed to be
   larger than MAX_SCALE.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.resize'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: scale() -> _ods_ir


   .. py:method:: offset() -> _ods_ir


   .. py:method:: border() -> _ods_ir


   .. py:method:: mode() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: resize(output, input, scale, offset, border, mode, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReverseOp(output, input1, axis, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns a tensor with the same type/values as the input, with the data
   reversed along the given axis. No data conversion happens during a reverse
   operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.reverse'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: axis() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: reverse(output, input1, axis, *, loc=None, ip=None) -> _ods_ir

.. py:class:: RsqrtOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise reciprocal square root operation. For integer operation, a TABLE
   should be used with the appropriate ranges.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.rsqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: rsqrt(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ScatterOp(values_out, values_in, indices, input, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The values_out tensor is set to the values_in tensor with data modified as
   follows: data from the input tensor is inserted at the positions specified
   by the indices tensor. N is the number of batches, W the number of indices
   in each batch, K the range of each index and C the number data channels for
   each index. It is not permitted to repeat the same output index within a
   single SCATTER operation and so each output index occurs at most once. It
   follows that K >= W. In use cases that require multiple updates to the same
   output position, these must be decomposed into multiple SCATTER operations.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.scatter'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: values_in() -> _ods_ir


   .. py:method:: indices() -> _ods_ir


   .. py:method:: input() -> _ods_ir


   .. py:method:: values_out() -> _ods_ir


.. py:function:: scatter(values_out, values_in, indices, input, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SelectOp(output, input1, input2, input3, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise select of the output based on a condition.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.select'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: input3() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: select(output, input1, input2, input3, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SigmoidOp(output, input, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Applies the sigmoid logistic function to each element of the input tensor:
   $ sigmoid(x) = \frac{1}{1 + e^{-x}} $.

   For quantized integer data types, the TABLE operator should be used instead.
   Each implementation may choose an appropriate TABLE given the scale and zero
   point of the input data. Eight or sixteen bit precision tables may be used
   based on the input tensor to the sigmoid function.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.sigmoid'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: sigmoid(output, input, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SinOp(output, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise sine operation for values given in radians.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.sin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: sin(output, input1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SliceOp(output, input1, start, size, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Extracts a slice of input1, beginning at the start coordinates,
   and extending for size elements in each direction.
   No data conversion happens during a slice operation.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.slice'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: start() -> _ods_ir


   .. py:method:: size() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: slice(output, input1, start, size, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SubOp(output, input1, input2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Elementwise subtraction of input1 and input2. Axis of size 1 will be
   broadcast as necessary. Rank of input tensors must match.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.sub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: input2() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: sub(output, input1, input2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: TableOp(output, input1, table, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Table lookup operation. For int8_t TABLE operation, perform a 256 entry
   table lookup returning an int8_t value. For int16_t tables, the int16_t
   input is treated as a fixed-point 9.7 value. The most significant 9 bits
   are used to index into the table. The fractional 7 bits are used to
   interpolate based on table[index] and table[index+1]. For int16_t inputs,
   the TABLE operator returns a 16.7 interpolated value in an int32_t. This
   value can then be input to the RESCALE operator to scale to the required
   output data type. Note that int16_t table has 513 values to handle
   table[index+1] when index=511.

   An int16_t to int16_t table lookup can be constructed in TOSA as follows:

   * Use the TABLE operator to produce a fixed point 16.7 interpolated result
   * Use RESCALE (in_t=int32_t, out_t=int16_t, scale=1<<14, shift=21) to
   scale the output to int16_t range (or alternate scale as required)


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.table'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: table() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: table(output, input1, table, *, loc=None, ip=None) -> _ods_ir

.. py:class:: TanhOp(output, input, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Parameterized hyperbolic tangent: $ tanh(x) = \frac{1 - e^{-2x}}{1 + e^{-2x}} $.

   For quantized integer data types, the TABLE operator should be used instead.
   Each implementation may choose an appropriate TABLE given the scale and zero
   point of the input data. Eight or sixteen bit precision tables may be used
   based on the input tensor to the tanh function.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.tanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: tanh(output, input, *, loc=None, ip=None) -> _ods_ir

.. py:class:: TileOp(output, input1, multiples, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Replicates input1 multiples times along each dimension.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.tile'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: multiples() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: tile(output, input1, multiples, *, loc=None, ip=None) -> _ods_ir

.. py:class:: TransposeConv2DOp(output, input, weight, bias, input_zp, weight_zp, out_pad, stride, acc_type, *, local_bound=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Performs a 2D transposed convolution over the given tensor input, using the
   weights tensor. Implementations may choose to skip calculation of multiplies
   by zero at fractional input positions.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.transpose_conv2d'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input() -> _ods_ir


   .. py:method:: weight() -> _ods_ir


   .. py:method:: bias() -> _ods_ir


   .. py:method:: input_zp() -> _ods_ir


   .. py:method:: weight_zp() -> _ods_ir


   .. py:method:: out_pad() -> _ods_ir


   .. py:method:: stride() -> _ods_ir


   .. py:method:: acc_type() -> _ods_ir


   .. py:method:: local_bound() -> Optional[_ods_ir]


   .. py:method:: output() -> _ods_ir


.. py:function:: transpose_conv2d(output, input, weight, bias, input_zp, weight_zp, out_pad, stride, acc_type, *, local_bound=None, loc=None, ip=None) -> _ods_ir

.. py:class:: TransposeOp(output, input1, perms, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Permutes the dimensions of the input tensor input1 based on the perms
   argument. Each value in the perms list must be a valid dimension of the
   input tensor and may not be repeated.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.transpose'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: perms() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: transpose(output, input1, perms, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VariableOp(sym_name, var_shape, type_, *, initial_value=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Defines a new TOSA variable. This is a persistent mutable value across multiple
   TOSA graph invocations. Modifications are expressed using read/write semantics.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.variable'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: var_shape() -> _ods_ir


   .. py:method:: type_() -> _ods_ir


   .. py:method:: initial_value() -> Optional[_ods_ir]


.. py:function:: variable(sym_name, var_shape, type_, *, initial_value=None, loc=None, ip=None) -> VariableOp

.. py:class:: VariableReadOp(output1, name, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reads the value from a pseudo-buffer resource holding a persistent mutable tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.variable_read'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: name() -> _ods_ir

      
      Returns the fully qualified name of the operation.



   .. py:method:: output1() -> _ods_ir


.. py:function:: variable_read(output1, name, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VariableWriteOp(name, input1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Assigns a value to the pseudo-buffer resource holding a persistent mutable tensor.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.variable_write'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: input1() -> _ods_ir


   .. py:method:: name() -> _ods_ir

      
      Returns the fully qualified name of the operation.



.. py:function:: variable_write(name, input1, *, loc=None, ip=None) -> VariableWriteOp

.. py:class:: WhileOp(output_list, input_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Generates and evaluates a Boolean condition and either executes a loop body
   or exits the loop. This action is performed repeatedly after
   updating and re-evaluating the Boolean condition every iteration. This
   implements the semantic foreach or while iterative loop structure.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.while_loop'



   .. py:attribute:: _ODS_REGIONS
      :value: (2, True)



   .. py:method:: input_list() -> _ods_ir


   .. py:method:: output_list() -> _ods_ir


   .. py:method:: cond_graph() -> _ods_ir


   .. py:method:: body_graph() -> _ods_ir


.. py:function:: while_loop(output_list, input_list, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, WhileOp]

.. py:class:: YieldOp(inputs, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   return operation within the conditional and body of
   structured control flow. Operation takes variadic operands
   but produces no results of its own.


   .. py:attribute:: OPERATION_NAME
      :value: 'tosa.yield'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: inputs() -> _ods_ir


.. py:function:: yield_(inputs, *, loc=None, ip=None) -> YieldOp

