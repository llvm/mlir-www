mlir.dialects._func_ops_gen
===========================

.. py:module:: mlir.dialects._func_ops_gen


Attributes
----------

.. autoapisummary::

   mlir.dialects._func_ops_gen._ods_ir


Classes
-------

.. autoapisummary::

   mlir.dialects._func_ops_gen._Dialect
   mlir.dialects._func_ops_gen.CallIndirectOp
   mlir.dialects._func_ops_gen.CallOp
   mlir.dialects._func_ops_gen.ConstantOp
   mlir.dialects._func_ops_gen.FuncOp
   mlir.dialects._func_ops_gen.ReturnOp


Functions
---------

.. autoapisummary::

   mlir.dialects._func_ops_gen.call_indirect
   mlir.dialects._func_ops_gen.call
   mlir.dialects._func_ops_gen.constant
   mlir.dialects._func_ops_gen.func
   mlir.dialects._func_ops_gen.return_


Module Contents
---------------

.. py:data:: _ods_ir

.. py:class:: _Dialect(descriptor: object)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: DIALECT_NAMESPACE
      :value: 'func'



.. py:class:: CallIndirectOp(results_, callee, callee_operands, *, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``func.call_indirect`` operation represents an indirect call to a value
   of function type. The operands and result types of the call must match the
   specified function type.

   Function values can be created with the
   ```func.constant`` operation <#funcconstant-constantop>`_.

   Example:

   .. code:: mlir

       %func = func.constant @my_func : (tensor<16xf32>, tensor<16xf32>) -> tensor<16xf32>
       %result = func.call_indirect %func(%0, %1) : (tensor<16xf32>, tensor<16xf32>) -> tensor<16xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'func.call_indirect'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: callee() -> _ods_ir


   .. py:method:: callee_operands() -> _ods_ir


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: results_() -> _ods_ir


.. py:function:: call_indirect(results_, callee, callee_operands, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, CallIndirectOp]

.. py:class:: CallOp(result, callee, operands_, *, arg_attrs=None, res_attrs=None, no_inline=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``func.call`` operation represents a direct call to a function that is
   within the same symbol scope as the call. The operands and result types of
   the call must match the specified function type. The callee is encoded as a
   symbol reference attribute named "callee".

   Example:

   .. code:: mlir

       %2 = func.call @my_add(%0, %1) : (f32, f32) -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'func.call'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


   .. py:method:: callee() -> _ods_ir


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: no_inline() -> bool


.. py:function:: call(result, callee, operands_, *, arg_attrs=None, res_attrs=None, no_inline=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, CallOp]

.. py:class:: ConstantOp(result, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``func.constant`` operation produces an SSA value from a symbol reference
   to a ``func.func`` operation

   Example:

   .. code:: mlir

       // Reference to function @myfn.
       %2 = func.constant @myfn : (tensor<16xf32>, f32) -> tensor<16xf32>
       
       // Equivalent generic forms
       %2 = "func.constant"() { value = @myfn } : () -> ((tensor<16xf32>, f32) -> tensor<16xf32>)

   MLIR does not allow direct references to functions in SSA operands because
   the compiler is multithreaded, and disallowing SSA values to directly
   reference a function simplifies this
   (`rationale <../Rationale/Rationale.md#multithreading-the-compiler>`_).


   .. py:attribute:: OPERATION_NAME
      :value: 'func.constant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


.. py:function:: constant(result, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FuncOp(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, no_inline=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Operations within the function cannot implicitly capture values defined
   outside of the function, i.e. Functions are ``IsolatedFromAbove``. All
   external references must use function arguments or attributes that establish
   a symbolic connection (e.g. symbols referenced by name via a string
   attribute like SymbolRefAttr). An external function declaration (used when
   referring to a function declared in some other module) has no body. While
   the MLIR textual form provides a nice inline syntax for function arguments,
   they are internally represented as “block arguments” to the first block in
   the region.

   Only dialect attribute names may be specified in the attribute dictionaries
   for function arguments, results, or the function itself.

   Example:

   .. code:: mlir

       // External function definitions.
       func.func private @abort()
       func.func private @scribble(i32, i64, memref<? x 128 x f32, #layout_map0>) -> f64
       
       // A function that returns its argument twice:
       func.func @count(%x: i64) -> (i64, i64)
         attributes {fruit = "banana"} {
         return %x, %x: i64, i64
       }
       
       // A function with an argument attribute
       func.func private @example_fn_arg(%x: i32 {swift.self = unit})
       
       // A function with a result attribute
       func.func private @example_fn_result() -> (f64 {dialectName.attrName = 0 : i64})
       
       // A function with an attribute
       func.func private @example_fn_attr() attributes {dialectName.attrName = false}


   .. py:attribute:: OPERATION_NAME
      :value: 'func.func'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: function_type() -> _ods_ir


   .. py:method:: sym_visibility() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: no_inline() -> bool


   .. py:method:: body() -> _ods_ir


.. py:function:: func(sym_name, function_type, *, sym_visibility=None, arg_attrs=None, res_attrs=None, no_inline=None, loc=None, ip=None) -> FuncOp

.. py:class:: ReturnOp(operands_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``func.return`` operation represents a return operation within a function.
   The operation takes variable number of operands and produces no results.
   The operand number and types must match the signature of the function
   that contains the operation.

   Example:

   .. code:: mlir

       func.func @foo() -> (i32, f8) {
         ...
         return %0, %1 : i32, f8
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'func.return'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


.. py:function:: return_(operands_, *, loc=None, ip=None) -> ReturnOp

