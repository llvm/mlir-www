mlir.dialects._pdl_ops_gen
==========================

.. py:module:: mlir.dialects._pdl_ops_gen


Attributes
----------

.. autoapisummary::

   mlir.dialects._pdl_ops_gen._ods_ir


Classes
-------

.. autoapisummary::

   mlir.dialects._pdl_ops_gen._Dialect
   mlir.dialects._pdl_ops_gen.ApplyNativeConstraintOp
   mlir.dialects._pdl_ops_gen.ApplyNativeRewriteOp
   mlir.dialects._pdl_ops_gen.AttributeOp
   mlir.dialects._pdl_ops_gen.EraseOp
   mlir.dialects._pdl_ops_gen.OperandOp
   mlir.dialects._pdl_ops_gen.OperandsOp
   mlir.dialects._pdl_ops_gen.OperationOp
   mlir.dialects._pdl_ops_gen.PatternOp
   mlir.dialects._pdl_ops_gen.RangeOp
   mlir.dialects._pdl_ops_gen.ReplaceOp
   mlir.dialects._pdl_ops_gen.ResultOp
   mlir.dialects._pdl_ops_gen.ResultsOp
   mlir.dialects._pdl_ops_gen.RewriteOp
   mlir.dialects._pdl_ops_gen.TypeOp
   mlir.dialects._pdl_ops_gen.TypesOp


Functions
---------

.. autoapisummary::

   mlir.dialects._pdl_ops_gen.apply_native_constraint
   mlir.dialects._pdl_ops_gen.apply_native_rewrite
   mlir.dialects._pdl_ops_gen.attribute
   mlir.dialects._pdl_ops_gen.erase
   mlir.dialects._pdl_ops_gen.operand
   mlir.dialects._pdl_ops_gen.operands_
   mlir.dialects._pdl_ops_gen.operation_
   mlir.dialects._pdl_ops_gen.pattern
   mlir.dialects._pdl_ops_gen.range
   mlir.dialects._pdl_ops_gen.replace
   mlir.dialects._pdl_ops_gen.result
   mlir.dialects._pdl_ops_gen.results_
   mlir.dialects._pdl_ops_gen.rewrite
   mlir.dialects._pdl_ops_gen.type_
   mlir.dialects._pdl_ops_gen.types


Module Contents
---------------

.. py:data:: _ods_ir

.. py:class:: _Dialect(descriptor: object)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: DIALECT_NAMESPACE
      :value: 'pdl'



.. py:class:: ApplyNativeConstraintOp(results_, name, args, *, isNegated=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.apply_native_constraint`` operations apply a native C++ constraint, that
   has been registered externally with the consumer of PDL, to a given set of
   entities and optionally return a number of values.

   Example:

   .. code:: mlir

       // Apply `myConstraint` to the entities defined by `input`, `attr`, and `op`.
       pdl.apply_native_constraint "myConstraint"(%input, %attr, %op : !pdl.value, !pdl.attribute, !pdl.operation)
       // Apply constraint `with_result` to `root`. This constraint returns an attribute.
       %attr = pdl.apply_native_constraint "with_result"(%root : !pdl.operation) : !pdl.attribute


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.apply_native_constraint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: args() -> _ods_ir


   .. py:method:: name() -> _ods_ir

      
      Returns the fully qualified name of the operation.



   .. py:method:: isNegated() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


.. py:function:: apply_native_constraint(results_, name, args, *, is_negated=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, ApplyNativeConstraintOp]

.. py:class:: ApplyNativeRewriteOp(results_, name, args, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.apply_native_rewrite`` operations apply a native C++ function, that has
   been registered externally with the consumer of PDL, to perform a rewrite
   and optionally return a number of values. The native function may accept any
   number of arguments. This operation is used within a pdl.rewrite region to enable
   the interleaving of native rewrite methods with other pdl constructs.

   Example:

   .. code:: mlir

       // Apply a native rewrite method that returns an attribute.
       %ret = pdl.apply_native_rewrite "myNativeFunc"(%arg0, %attr1) : !pdl.attribute

   .. code:: c++

       // The native rewrite as defined in C++:
       static Attribute myNativeFunc(PatternRewriter &rewriter, Value arg0, Attribute arg1) {
         // Just return the second arg.
         return arg1;
       }
       
       void registerNativeRewrite(PDLPatternModule &pdlModule) {
         pdlModule.registerRewriteFunction("myNativeFunc", myNativeFunc);
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.apply_native_rewrite'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: args() -> _ods_ir


   .. py:method:: name() -> _ods_ir

      
      Returns the fully qualified name of the operation.



   .. py:method:: results_() -> _ods_ir


.. py:function:: apply_native_rewrite(results_, name, args, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, ApplyNativeRewriteOp]

.. py:class:: AttributeOp(attr, *, valueType=None, value=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.attribute`` operations capture named attribute edges into an operation.
   Instances of this operation define, and partially constrain, attributes of a
   given operation. A ``pdl.attribute`` may partially constrain the input by
   specifying an expected attribute value type (via a ``pdl.type`` operation), or
   a constant value for the attribute (via ``val``). Only one of these may be set
   for a given input, as the type of the constant value provides the type. When
   defined within a ``pdl.rewrite`` region, the constant value must be specified.

   Example:

   .. code:: mlir

       // Define an attribute:
       %attr = pdl.attribute
       
       // Define an attribute with an expected type:
       %type = pdl.type : i32
       %attr = pdl.attribute : %type
       
       // Define an attribute with a constant value:
       %attr = pdl.attribute = "hello"


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.attribute'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: valueType() -> Optional[_ods_ir]


   .. py:method:: value() -> Optional[_ods_ir]


   .. py:method:: attr() -> _ods_ir


.. py:function:: attribute(attr, *, value_type=None, value=None, loc=None, ip=None) -> _ods_ir

.. py:class:: EraseOp(opValue, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.erase`` operations are used within ``pdl.rewrite`` regions to specify that
   an input operation should be marked as erased. The semantics of this
   operation correspond with the ``eraseOp`` method on a ``PatternRewriter``.

   Example:

   .. code:: mlir

       pdl.erase %root


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.erase'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: opValue() -> _ods_ir


.. py:function:: erase(op_value, *, loc=None, ip=None) -> EraseOp

.. py:class:: OperandOp(value, *, valueType=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.operand`` operations capture external operand edges into an operation
   node that originate from operations or block arguments not otherwise
   specified within the pattern (i.e. via ``pdl.result`` or ``pdl.results``). These
   operations define individual operands of a given operation. A ``pdl.operand``
   may partially constrain an operand by specifying an expected value type
   (via a ``pdl.type`` operation).

   Example:

   .. code:: mlir

       // Define an external operand:
       %operand = pdl.operand
       
       // Define an external operand with an expected type:
       %type = pdl.type : i32
       %operand = pdl.operand : %type


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.operand'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: valueType() -> Optional[_ods_ir]


   .. py:method:: value() -> _ods_ir


.. py:function:: operand(value, *, value_type=None, loc=None, ip=None) -> _ods_ir

.. py:class:: OperandsOp(value, *, valueType=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.operands`` operations capture external operand range edges into an
   operation node that originate from operations or block arguments not
   otherwise specified within the pattern (i.e. via ``pdl.result`` or
   ``pdl.results``). These operations define groups of input operands into a
   given operation. A ``pdl.operands`` may partially constrain a set of input
   operands by specifying expected value types (via ``pdl.types`` operations).

   Example:

   .. code:: mlir

       // Define a range of input operands:
       %operands = pdl.operands
       
       // Define a range of input operands with expected types:
       %types = pdl.types : [i32, i64, i32]
       %typed_operands = pdl.operands : %types


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.operands'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: valueType() -> Optional[_ods_ir]


   .. py:method:: value() -> _ods_ir


.. py:function:: operands_(value, *, value_type=None, loc=None, ip=None) -> _ods_ir

.. py:class:: OperationOp(op, operandValues, attributeValues, attributeValueNames, typeValues, *, opName=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.operation`` operations define operation nodes within a pattern. Within
   a match sequence, i.e. when directly nested within a ``pdl.pattern``, these
   operations correspond to input operations, or those that already existing
   within the MLIR module. Inside of a ``pdl.rewrite``, these operations
   correspond to operations that should be created as part of the replacement
   sequence.

   ``pdl.operation``s are composed of a name, and a set of attribute, operand,
   and result type values, that map to what those that would be on a
   constructed instance of that operation. The results of a ``pdl.operation`` are
   a handle to the operation itself. Handles to the results of the operation
   can be extracted via ``pdl.result``.

   Example:

   .. code:: mlir

       // Define an instance of a `foo.op` operation.
       %op = pdl.operation "foo.op"(%arg0, %arg1 : !pdl.value, !pdl.value)
         {"attrA" = %attr0} -> (%type, %type : !pdl.type, !pdl.type)

   When used within a matching context, the name of the operation may be
   omitted.

   When used within a rewriting context, i.e. when defined within a
   ``pdl.rewrite``, all of the result types must be "inferable". This means that
   the type must be attributable to either a constant type value or the result
   type of another entity, such as an attribute, the result of a
   ``apply_native_rewrite``, or the result type of another operation. If the
   result type value does not meet any of these criteria, the operation must
   override the ``InferTypeOpInterface`` to ensure that the result types can be
   inferred.

   The operands of the operation are interpreted in the following ways:

   #. A single !pdl.range:

   In this case, the single range is treated as all of the operands of the
   operation.

   .. code:: mlir

       // Define an instance with single range of operands.
       %op = pdl.operation "func.return"(%allArgs : !pdl.range<value>)

   #. A variadic number of either !pdl.value or !pdl.range:

   In this case, the inputs are expected to correspond with the operand groups
   defined on the operation in ODS.

   .. code:: tablgen

       // Given the following operation definition in ODS:
       def MyIndirectCallOp {
         let results = (outs FunctionType:$call, Variadic<AnyType>:$args);
       }

   .. code:: mlir

       // We can match the operands as so:
       %op = pdl.operation "my.indirect_call"(%call, %args : !pdl.value, !pdl.range<value>)

   The results of the operation are interpreted in the following ways:

   #. A single !pdl.range:

   In this case, the single range is treated as all of the result types of the
   operation.

   .. code:: mlir

       // Define an instance with single range of types.
       %allResultTypes = pdl.types
       %op = pdl.operation "builtin.unrealized_conversion_cast" -> (%allResultTypes : !pdl.types)

   #. A variadic number of either !pdl.type or !pdl.range:

   In this case, the inputs are expected to correspond with the result groups
   defined on the operation in ODS.

   .. code:: tablgen

       // Given the following operation definition in ODS:
       def MyOp {
         let results = (outs SomeType:$result, Variadic<SomeType>:$otherResults);
       }

   .. code:: mlir

       // We can match the results as so:
       %result = pdl.type
       %otherResults = pdl.types
       %op = pdl.operation "foo.op" -> (%result, %otherResults : !pdl.type, !pdl.range<type>)


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.operation'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operandValues() -> _ods_ir


   .. py:method:: attributeValues() -> _ods_ir


   .. py:method:: typeValues() -> _ods_ir


   .. py:method:: opName() -> Optional[_ods_ir]


   .. py:method:: attributeValueNames() -> _ods_ir


   .. py:method:: op() -> _ods_ir


.. py:function:: operation_(op, operand_values, attribute_values, attribute_value_names, type_values, *, op_name=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PatternOp(benefit, *, sym_name=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.pattern`` operations provide a transformable representation for a
   ``RewritePattern``. The attributes on this operation correspond to the various
   metadata on a ``RewritePattern``, such as the benefit. The match section of
   the pattern is specified within the region body, with the rewrite provided
   by a terminating ``pdl.rewrite``.

   Example:

   .. code:: mlir

       // Provide a pattern matching "foo.op" that replaces the root with its
       // operand.
       pdl.pattern : benefit(1) {
         %resultType = pdl.type
         %inputOperand = pdl.operand
         %root = pdl.operation "foo.op"(%inputOperand) -> (%resultType)
         pdl.rewrite %root {
           pdl.replace %root with (%inputOperand)
         }
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.pattern'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: benefit() -> _ods_ir


   .. py:method:: sym_name() -> Optional[_ods_ir]


   .. py:method:: bodyRegion() -> _ods_ir


.. py:function:: pattern(benefit, *, sym_name=None, loc=None, ip=None) -> PatternOp

.. py:class:: RangeOp(result, arguments, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.range`` operations construct a range from a given set of PDL entities,
   which all share the same underlying element type. For example, a
   ``!pdl.range<value>`` may be constructed from a list of ``!pdl.value``
   or ``!pdl.range<value>`` entities.

   Example:

   .. code:: mlir

       // Construct a range of values.
       %valueRange = pdl.range %inputValue, %inputRange : !pdl.value, !pdl.range<value>
       
       // Construct a range of types.
       %typeRange = pdl.range %inputType, %inputRange : !pdl.type, !pdl.range<type>
       
       // Construct an empty range of types.
       %valueRange = pdl.range : !pdl.range<type>

   TODO: Range construction is currently limited to rewrites, but it could
   be extended to constraints under certain circustances; i.e., if we can
   determine how to extract the underlying elements. If we can't, e.g. if
   there are multiple sub ranges used for construction, we won't be able
   to determine their sizes during constraint time.


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.range'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arguments() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: range(result, arguments, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReplaceOp(opValue, replValues, *, replOperation=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.replace`` operations are used within ``pdl.rewrite`` regions to specify
   that an input operation should be marked as replaced. The semantics of this
   operation correspond with the ``replaceOp`` method on a ``PatternRewriter``. The
   set of replacement values can be either:

   * a single ``Operation`` (``replOperation`` should be populated)
   * The operation will be replaced with the results of this operation.

   * a set of ``Value``s (``replValues`` should be populated)
   * The operation will be replaced with these values.


   Example:

   .. code:: mlir

       // Replace root node with 2 values:
       pdl.replace %root with (%val0, %val1 : !pdl.value, !pdl.value)
       
       // Replace root node with a range of values:
       pdl.replace %root with (%vals : !pdl.range<value>)
       
       // Replace root with another operation:
       pdl.replace %root with %otherOp


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.replace'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: opValue() -> _ods_ir


   .. py:method:: replOperation() -> Optional[_ods_ir]


   .. py:method:: replValues() -> _ods_ir


.. py:function:: replace(op_value, repl_values, *, repl_operation=None, loc=None, ip=None) -> ReplaceOp

.. py:class:: ResultOp(val, parent, index, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.result`` operations extract result edges from an operation node within
   a pattern or rewrite region. The provided index is zero-based, and
   represents the concrete result to extract, i.e. this is not the result index
   as defined by the ODS definition of the operation.

   Example:

   .. code:: mlir

       // Extract a result:
       %operation = pdl.operation ...
       %pdl_result = pdl.result 1 of %operation
       
       // Imagine the following IR being matched:
       %result_0, %result_1 = foo.op ...
       
       // If the example pattern snippet above were matching against `foo.op` in
       // the IR snippet, `%pdl_result` would correspond to `%result_1`.


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.result'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: parent() -> _ods_ir

      
      Returns the parent operation, or ``None`` if at top level.



   .. py:method:: index() -> _ods_ir


   .. py:method:: val() -> _ods_ir


.. py:function:: result(val, parent, index, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ResultsOp(val, parent, *, index=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.results`` operations extract a result group from an operation within a
   pattern or rewrite region. If an index is provided, this operation extracts
   a result group as defined by the ODS definition of the operation. In this
   case the result of this operation may be either a single ``pdl.value`` or
   a ``pdl.range<value>``, depending on the constraint of the result in ODS. If
   no index is provided, this operation extracts the full result range of the
   operation.

   Example:

   .. code:: mlir

       // Extract all of the results of an operation:
       %operation = pdl.operation ...
       %results = pdl.results of %operation
       
       // Extract the results in the first result group of an operation, which is
       // variadic:
       %operation = pdl.operation ...
       %results = pdl.results 0 of %operation -> !pdl.range<value>
       
       // Extract the results in the second result group of an operation, which is
       // not variadic:
       %operation = pdl.operation ...
       %results = pdl.results 1 of %operation -> !pdl.value


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.results'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: parent() -> _ods_ir

      
      Returns the parent operation, or ``None`` if at top level.



   .. py:method:: index() -> Optional[_ods_ir]


   .. py:method:: val() -> _ods_ir


.. py:function:: results_(val, parent, *, index=None, loc=None, ip=None) -> _ods_ir

.. py:class:: RewriteOp(externalArgs, *, root=None, name=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.rewrite`` operations terminate the region of a ``pdl.pattern`` and specify
   the main rewrite of a ``pdl.pattern``, on the optional root operation. The
   rewrite is specified either via a string name (``name``) to a native
   rewrite function, or via the region body. The rewrite region, if specified,
   must contain a single block. If the rewrite is external it functions
   similarly to ``pdl.apply_native_rewrite``, and takes a set of additional
   positional values defined within the matcher as arguments. If the rewrite is
   external, the root operation is passed to the native function as the leading
   arguments. The root operation, if provided, specifies the starting point in
   the pattern for the subgraph isomorphism search. Pattern matching will proceed
   from this node downward (towards the defining operation) or upward
   (towards the users) until all the operations in the pattern have been matched.
   If the root is omitted, the pdl_interp lowering will automatically select
   the best root of the pdl.rewrite among all the operations in the pattern.

   Example:

   .. code:: mlir

       // Specify an external rewrite function:
       pdl.rewrite %root with "myExternalRewriter"(%value : !pdl.value)
       
       // Specify a rewrite inline using PDL with the given root:
       pdl.rewrite %root {
         %op = pdl.operation "foo.op"(%arg0, %arg1)
         pdl.replace %root with %op
       }
       
       // Specify a rewrite inline using PDL, automatically selecting root:
       pdl.rewrite {
         %op1 = pdl.operation "foo.op"(%arg0, %arg1)
         %op2 = pdl.operation "bar.op"(%arg0, %arg1)
         pdl.replace %root1 with %op1
         pdl.replace %root2 with %op2
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.rewrite'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: root() -> Optional[_ods_ir]


   .. py:method:: externalArgs() -> _ods_ir


   .. py:method:: name() -> Optional[_ods_ir]

      
      Returns the fully qualified name of the operation.



   .. py:method:: bodyRegion() -> _ods_ir


.. py:function:: rewrite(external_args, *, root=None, name=None, loc=None, ip=None) -> RewriteOp

.. py:class:: TypeOp(result, *, constantType=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.type`` operations capture result type constraints of ``Attributes``,
   ``Values``, and ``Operations``. Instances of this operation define, and
   partially constrain, results types of a given entity. A ``pdl.type`` may
   partially constrain the result by specifying a constant ``Type``.

   Example:

   .. code:: mlir

       // Define a type:
       %type = pdl.type
       
       // Define a type with a constant value:
       %type = pdl.type : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.type'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: constantType() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: type_(result, *, constant_type=None, loc=None, ip=None) -> _ods_ir

.. py:class:: TypesOp(result, *, constantTypes=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``pdl.types`` operations capture result type constraints of ``Value``s, and
   ``Operation``s. Instances of this operation define results types of a given
   entity. A ``pdl.types`` may partially constrain the results by specifying
   an array of ``Type``s.

   Example:

   .. code:: mlir

       // Define a range of types:
       %types = pdl.types
       
       // Define a range of types with a range of constant values:
       %types = pdl.types : [i32, i64, i32]


   .. py:attribute:: OPERATION_NAME
      :value: 'pdl.types'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: constantTypes() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: types(result, *, constant_types=None, loc=None, ip=None) -> _ods_ir

