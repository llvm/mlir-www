mlir.dialects.spirv
===================

.. py:module:: mlir.dialects.spirv


Classes
-------

.. autoapisummary::

   mlir.dialects.spirv.AccessChainOp
   mlir.dialects.spirv.AddressOfOp
   mlir.dialects.spirv.AtomicAndOp
   mlir.dialects.spirv.AtomicCompareExchangeOp
   mlir.dialects.spirv.AtomicCompareExchangeWeakOp
   mlir.dialects.spirv.AtomicExchangeOp
   mlir.dialects.spirv.AtomicIAddOp
   mlir.dialects.spirv.AtomicIDecrementOp
   mlir.dialects.spirv.AtomicIIncrementOp
   mlir.dialects.spirv.AtomicISubOp
   mlir.dialects.spirv.AtomicOrOp
   mlir.dialects.spirv.AtomicSMaxOp
   mlir.dialects.spirv.AtomicSMinOp
   mlir.dialects.spirv.AtomicUMaxOp
   mlir.dialects.spirv.AtomicUMinOp
   mlir.dialects.spirv.AtomicXorOp
   mlir.dialects.spirv.BitCountOp
   mlir.dialects.spirv.BitFieldInsertOp
   mlir.dialects.spirv.BitFieldSExtractOp
   mlir.dialects.spirv.BitFieldUExtractOp
   mlir.dialects.spirv.BitReverseOp
   mlir.dialects.spirv.BitcastOp
   mlir.dialects.spirv.BitwiseAndOp
   mlir.dialects.spirv.BitwiseOrOp
   mlir.dialects.spirv.BitwiseXorOp
   mlir.dialects.spirv.BranchConditionalOp
   mlir.dialects.spirv.BranchOp
   mlir.dialects.spirv.CLAcosOp
   mlir.dialects.spirv.CLAcoshOp
   mlir.dialects.spirv.CLAsinOp
   mlir.dialects.spirv.CLAsinhOp
   mlir.dialects.spirv.CLAtan2Op
   mlir.dialects.spirv.CLAtanOp
   mlir.dialects.spirv.CLAtanhOp
   mlir.dialects.spirv.CLCeilOp
   mlir.dialects.spirv.CLCosOp
   mlir.dialects.spirv.CLCoshOp
   mlir.dialects.spirv.CLErfOp
   mlir.dialects.spirv.CLExpOp
   mlir.dialects.spirv.CLFAbsOp
   mlir.dialects.spirv.CLFMaxOp
   mlir.dialects.spirv.CLFMinOp
   mlir.dialects.spirv.CLFloorOp
   mlir.dialects.spirv.CLFmaOp
   mlir.dialects.spirv.CLLogOp
   mlir.dialects.spirv.CLMixOp
   mlir.dialects.spirv.CLPowOp
   mlir.dialects.spirv.CLPrintfOp
   mlir.dialects.spirv.CLRintOp
   mlir.dialects.spirv.CLRoundOp
   mlir.dialects.spirv.CLRsqrtOp
   mlir.dialects.spirv.CLSAbsOp
   mlir.dialects.spirv.CLSMaxOp
   mlir.dialects.spirv.CLSMinOp
   mlir.dialects.spirv.CLSinOp
   mlir.dialects.spirv.CLSinhOp
   mlir.dialects.spirv.CLSqrtOp
   mlir.dialects.spirv.CLTanOp
   mlir.dialects.spirv.CLTanhOp
   mlir.dialects.spirv.CLUMaxOp
   mlir.dialects.spirv.CLUMinOp
   mlir.dialects.spirv.CompositeConstructOp
   mlir.dialects.spirv.CompositeExtractOp
   mlir.dialects.spirv.CompositeInsertOp
   mlir.dialects.spirv.ConstantOp
   mlir.dialects.spirv.ControlBarrierOp
   mlir.dialects.spirv.ConvertFToSOp
   mlir.dialects.spirv.ConvertFToUOp
   mlir.dialects.spirv.ConvertPtrToUOp
   mlir.dialects.spirv.ConvertSToFOp
   mlir.dialects.spirv.ConvertUToFOp
   mlir.dialects.spirv.ConvertUToPtrOp
   mlir.dialects.spirv.CopyMemoryOp
   mlir.dialects.spirv.DotOp
   mlir.dialects.spirv.EXTAtomicFAddOp
   mlir.dialects.spirv.EXTConstantCompositeReplicateOp
   mlir.dialects.spirv.EXTEmitMeshTasksOp
   mlir.dialects.spirv.EXTSetMeshOutputsOp
   mlir.dialects.spirv.EXTSpecConstantCompositeReplicateOp
   mlir.dialects.spirv.EmitVertexOp
   mlir.dialects.spirv.EndPrimitiveOp
   mlir.dialects.spirv.EntryPointOp
   mlir.dialects.spirv.ExecutionModeOp
   mlir.dialects.spirv.FAddOp
   mlir.dialects.spirv.FConvertOp
   mlir.dialects.spirv.FDivOp
   mlir.dialects.spirv.FModOp
   mlir.dialects.spirv.FMulOp
   mlir.dialects.spirv.FNegateOp
   mlir.dialects.spirv.FOrdEqualOp
   mlir.dialects.spirv.FOrdGreaterThanEqualOp
   mlir.dialects.spirv.FOrdGreaterThanOp
   mlir.dialects.spirv.FOrdLessThanEqualOp
   mlir.dialects.spirv.FOrdLessThanOp
   mlir.dialects.spirv.FOrdNotEqualOp
   mlir.dialects.spirv.FRemOp
   mlir.dialects.spirv.FSubOp
   mlir.dialects.spirv.FUnordEqualOp
   mlir.dialects.spirv.FUnordGreaterThanEqualOp
   mlir.dialects.spirv.FUnordGreaterThanOp
   mlir.dialects.spirv.FUnordLessThanEqualOp
   mlir.dialects.spirv.FUnordLessThanOp
   mlir.dialects.spirv.FUnordNotEqualOp
   mlir.dialects.spirv.FuncOp
   mlir.dialects.spirv.FunctionCallOp
   mlir.dialects.spirv.GLAcosOp
   mlir.dialects.spirv.GLAcoshOp
   mlir.dialects.spirv.GLAsinOp
   mlir.dialects.spirv.GLAsinhOp
   mlir.dialects.spirv.GLAtanOp
   mlir.dialects.spirv.GLAtanhOp
   mlir.dialects.spirv.GLCeilOp
   mlir.dialects.spirv.GLCosOp
   mlir.dialects.spirv.GLCoshOp
   mlir.dialects.spirv.GLCrossOp
   mlir.dialects.spirv.GLDistanceOp
   mlir.dialects.spirv.GLExp2Op
   mlir.dialects.spirv.GLExpOp
   mlir.dialects.spirv.GLFAbsOp
   mlir.dialects.spirv.GLFClampOp
   mlir.dialects.spirv.GLFMaxOp
   mlir.dialects.spirv.GLFMinOp
   mlir.dialects.spirv.GLFMixOp
   mlir.dialects.spirv.GLFSignOp
   mlir.dialects.spirv.GLFindILsbOp
   mlir.dialects.spirv.GLFindSMsbOp
   mlir.dialects.spirv.GLFindUMsbOp
   mlir.dialects.spirv.GLFloorOp
   mlir.dialects.spirv.GLFmaOp
   mlir.dialects.spirv.GLFractOp
   mlir.dialects.spirv.GLFrexpStructOp
   mlir.dialects.spirv.GLInverseSqrtOp
   mlir.dialects.spirv.GLLdexpOp
   mlir.dialects.spirv.GLLengthOp
   mlir.dialects.spirv.GLLog2Op
   mlir.dialects.spirv.GLLogOp
   mlir.dialects.spirv.GLNormalizeOp
   mlir.dialects.spirv.GLPackHalf2x16Op
   mlir.dialects.spirv.GLPowOp
   mlir.dialects.spirv.GLReflectOp
   mlir.dialects.spirv.GLRoundEvenOp
   mlir.dialects.spirv.GLRoundOp
   mlir.dialects.spirv.GLSAbsOp
   mlir.dialects.spirv.GLSClampOp
   mlir.dialects.spirv.GLSMaxOp
   mlir.dialects.spirv.GLSMinOp
   mlir.dialects.spirv.GLSSignOp
   mlir.dialects.spirv.GLSinOp
   mlir.dialects.spirv.GLSinhOp
   mlir.dialects.spirv.GLSqrtOp
   mlir.dialects.spirv.GLTanOp
   mlir.dialects.spirv.GLTanhOp
   mlir.dialects.spirv.GLUClampOp
   mlir.dialects.spirv.GLUMaxOp
   mlir.dialects.spirv.GLUMinOp
   mlir.dialects.spirv.GLUnpackHalf2x16Op
   mlir.dialects.spirv.GenericCastToPtrExplicitOp
   mlir.dialects.spirv.GenericCastToPtrOp
   mlir.dialects.spirv.GlobalVariableOp
   mlir.dialects.spirv.GraphARMOp
   mlir.dialects.spirv.GraphConstantARMOp
   mlir.dialects.spirv.GraphEntryPointARMOp
   mlir.dialects.spirv.GraphOutputsARMOp
   mlir.dialects.spirv.GroupBroadcastOp
   mlir.dialects.spirv.GroupFAddOp
   mlir.dialects.spirv.GroupFMaxOp
   mlir.dialects.spirv.GroupFMinOp
   mlir.dialects.spirv.GroupFMulKHROp
   mlir.dialects.spirv.GroupIAddOp
   mlir.dialects.spirv.GroupIMulKHROp
   mlir.dialects.spirv.GroupNonUniformAllEqualOp
   mlir.dialects.spirv.GroupNonUniformAllOp
   mlir.dialects.spirv.GroupNonUniformAnyOp
   mlir.dialects.spirv.GroupNonUniformBallotBitCountOp
   mlir.dialects.spirv.GroupNonUniformBallotFindLSBOp
   mlir.dialects.spirv.GroupNonUniformBallotFindMSBOp
   mlir.dialects.spirv.GroupNonUniformBallotOp
   mlir.dialects.spirv.GroupNonUniformBitwiseAndOp
   mlir.dialects.spirv.GroupNonUniformBitwiseOrOp
   mlir.dialects.spirv.GroupNonUniformBitwiseXorOp
   mlir.dialects.spirv.GroupNonUniformBroadcastOp
   mlir.dialects.spirv.GroupNonUniformElectOp
   mlir.dialects.spirv.GroupNonUniformFAddOp
   mlir.dialects.spirv.GroupNonUniformFMaxOp
   mlir.dialects.spirv.GroupNonUniformFMinOp
   mlir.dialects.spirv.GroupNonUniformFMulOp
   mlir.dialects.spirv.GroupNonUniformIAddOp
   mlir.dialects.spirv.GroupNonUniformIMulOp
   mlir.dialects.spirv.GroupNonUniformLogicalAndOp
   mlir.dialects.spirv.GroupNonUniformLogicalOrOp
   mlir.dialects.spirv.GroupNonUniformLogicalXorOp
   mlir.dialects.spirv.GroupNonUniformRotateKHROp
   mlir.dialects.spirv.GroupNonUniformSMaxOp
   mlir.dialects.spirv.GroupNonUniformSMinOp
   mlir.dialects.spirv.GroupNonUniformShuffleDownOp
   mlir.dialects.spirv.GroupNonUniformShuffleOp
   mlir.dialects.spirv.GroupNonUniformShuffleUpOp
   mlir.dialects.spirv.GroupNonUniformShuffleXorOp
   mlir.dialects.spirv.GroupNonUniformUMaxOp
   mlir.dialects.spirv.GroupNonUniformUMinOp
   mlir.dialects.spirv.GroupSMaxOp
   mlir.dialects.spirv.GroupSMinOp
   mlir.dialects.spirv.GroupUMaxOp
   mlir.dialects.spirv.GroupUMinOp
   mlir.dialects.spirv.IAddCarryOp
   mlir.dialects.spirv.IAddOp
   mlir.dialects.spirv.IEqualOp
   mlir.dialects.spirv.IMulOp
   mlir.dialects.spirv.INTELControlBarrierArriveOp
   mlir.dialects.spirv.INTELControlBarrierWaitOp
   mlir.dialects.spirv.INTELConvertBF16ToFOp
   mlir.dialects.spirv.INTELConvertFToBF16Op
   mlir.dialects.spirv.INTELRoundFToTF32Op
   mlir.dialects.spirv.INTELSubgroupBlockReadOp
   mlir.dialects.spirv.INTELSubgroupBlockWriteOp
   mlir.dialects.spirv.INotEqualOp
   mlir.dialects.spirv.ISubBorrowOp
   mlir.dialects.spirv.ISubOp
   mlir.dialects.spirv.ImageDrefGatherOp
   mlir.dialects.spirv.ImageFetchOp
   mlir.dialects.spirv.ImageOp
   mlir.dialects.spirv.ImageQuerySizeOp
   mlir.dialects.spirv.ImageReadOp
   mlir.dialects.spirv.ImageSampleExplicitLodOp
   mlir.dialects.spirv.ImageSampleImplicitLodOp
   mlir.dialects.spirv.ImageSampleProjDrefImplicitLodOp
   mlir.dialects.spirv.ImageWriteOp
   mlir.dialects.spirv.InBoundsPtrAccessChainOp
   mlir.dialects.spirv.IsFiniteOp
   mlir.dialects.spirv.IsInfOp
   mlir.dialects.spirv.IsNanOp
   mlir.dialects.spirv.KHRAssumeTrueOp
   mlir.dialects.spirv.KHRCooperativeMatrixLengthOp
   mlir.dialects.spirv.KHRCooperativeMatrixLoadOp
   mlir.dialects.spirv.KHRCooperativeMatrixMulAddOp
   mlir.dialects.spirv.KHRCooperativeMatrixStoreOp
   mlir.dialects.spirv.KHRSubgroupBallotOp
   mlir.dialects.spirv.KillOp
   mlir.dialects.spirv.LoadOp
   mlir.dialects.spirv.LogicalAndOp
   mlir.dialects.spirv.LogicalEqualOp
   mlir.dialects.spirv.LogicalNotEqualOp
   mlir.dialects.spirv.LogicalNotOp
   mlir.dialects.spirv.LogicalOrOp
   mlir.dialects.spirv.LoopOp
   mlir.dialects.spirv.MatrixTimesMatrixOp
   mlir.dialects.spirv.MatrixTimesScalarOp
   mlir.dialects.spirv.MatrixTimesVectorOp
   mlir.dialects.spirv.MemoryBarrierOp
   mlir.dialects.spirv.MergeOp
   mlir.dialects.spirv.ModuleOp
   mlir.dialects.spirv.NotOp
   mlir.dialects.spirv.OrderedOp
   mlir.dialects.spirv.PtrAccessChainOp
   mlir.dialects.spirv.PtrCastToGenericOp
   mlir.dialects.spirv.ReferenceOfOp
   mlir.dialects.spirv.ReturnOp
   mlir.dialects.spirv.ReturnValueOp
   mlir.dialects.spirv.SConvertOp
   mlir.dialects.spirv.SDivOp
   mlir.dialects.spirv.SDotAccSatOp
   mlir.dialects.spirv.SDotOp
   mlir.dialects.spirv.SGreaterThanEqualOp
   mlir.dialects.spirv.SGreaterThanOp
   mlir.dialects.spirv.SLessThanEqualOp
   mlir.dialects.spirv.SLessThanOp
   mlir.dialects.spirv.SModOp
   mlir.dialects.spirv.SMulExtendedOp
   mlir.dialects.spirv.SNegateOp
   mlir.dialects.spirv.SRemOp
   mlir.dialects.spirv.SUDotAccSatOp
   mlir.dialects.spirv.SUDotOp
   mlir.dialects.spirv.SelectOp
   mlir.dialects.spirv.SelectionOp
   mlir.dialects.spirv.ShiftLeftLogicalOp
   mlir.dialects.spirv.ShiftRightArithmeticOp
   mlir.dialects.spirv.ShiftRightLogicalOp
   mlir.dialects.spirv.SpecConstantCompositeOp
   mlir.dialects.spirv.SpecConstantOp
   mlir.dialects.spirv.SpecConstantOperationOp
   mlir.dialects.spirv.StoreOp
   mlir.dialects.spirv.SwitchOp
   mlir.dialects.spirv.TransposeOp
   mlir.dialects.spirv.UConvertOp
   mlir.dialects.spirv.UDivOp
   mlir.dialects.spirv.UDotAccSatOp
   mlir.dialects.spirv.UDotOp
   mlir.dialects.spirv.UGreaterThanEqualOp
   mlir.dialects.spirv.UGreaterThanOp
   mlir.dialects.spirv.ULessThanEqualOp
   mlir.dialects.spirv.ULessThanOp
   mlir.dialects.spirv.UModOp
   mlir.dialects.spirv.UMulExtendedOp
   mlir.dialects.spirv.UndefOp
   mlir.dialects.spirv.UnorderedOp
   mlir.dialects.spirv.UnreachableOp
   mlir.dialects.spirv.VariableOp
   mlir.dialects.spirv.VectorExtractDynamicOp
   mlir.dialects.spirv.VectorInsertDynamicOp
   mlir.dialects.spirv.VectorShuffleOp
   mlir.dialects.spirv.VectorTimesMatrixOp
   mlir.dialects.spirv.VectorTimesScalarOp
   mlir.dialects.spirv.YieldOp


Functions
---------

.. autoapisummary::

   mlir.dialects.spirv.AccessChain
   mlir.dialects.spirv.mlir_addressof
   mlir.dialects.spirv.AtomicAnd
   mlir.dialects.spirv.AtomicCompareExchange
   mlir.dialects.spirv.AtomicCompareExchangeWeak
   mlir.dialects.spirv.AtomicExchange
   mlir.dialects.spirv.AtomicIAdd
   mlir.dialects.spirv.AtomicIDecrement
   mlir.dialects.spirv.AtomicIIncrement
   mlir.dialects.spirv.AtomicISub
   mlir.dialects.spirv.AtomicOr
   mlir.dialects.spirv.AtomicSMax
   mlir.dialects.spirv.AtomicSMin
   mlir.dialects.spirv.AtomicUMax
   mlir.dialects.spirv.AtomicUMin
   mlir.dialects.spirv.AtomicXor
   mlir.dialects.spirv.BitCount
   mlir.dialects.spirv.BitFieldInsert
   mlir.dialects.spirv.BitFieldSExtract
   mlir.dialects.spirv.BitFieldUExtract
   mlir.dialects.spirv.BitReverse
   mlir.dialects.spirv.Bitcast
   mlir.dialects.spirv.BitwiseAnd
   mlir.dialects.spirv.BitwiseOr
   mlir.dialects.spirv.BitwiseXor
   mlir.dialects.spirv.BranchConditional
   mlir.dialects.spirv.Branch
   mlir.dialects.spirv.CL_acos
   mlir.dialects.spirv.CL_acosh
   mlir.dialects.spirv.CL_asin
   mlir.dialects.spirv.CL_asinh
   mlir.dialects.spirv.CL_atan2
   mlir.dialects.spirv.CL_atan
   mlir.dialects.spirv.CL_atanh
   mlir.dialects.spirv.CL_ceil
   mlir.dialects.spirv.CL_cos
   mlir.dialects.spirv.CL_cosh
   mlir.dialects.spirv.CL_erf
   mlir.dialects.spirv.CL_exp
   mlir.dialects.spirv.CL_fabs
   mlir.dialects.spirv.CL_fmax
   mlir.dialects.spirv.CL_fmin
   mlir.dialects.spirv.CL_floor
   mlir.dialects.spirv.CL_fma
   mlir.dialects.spirv.CL_log
   mlir.dialects.spirv.CL_mix
   mlir.dialects.spirv.CL_pow
   mlir.dialects.spirv.CL_printf
   mlir.dialects.spirv.CL_rint
   mlir.dialects.spirv.CL_round
   mlir.dialects.spirv.CL_rsqrt
   mlir.dialects.spirv.CL_s_abs
   mlir.dialects.spirv.CL_s_max
   mlir.dialects.spirv.CL_s_min
   mlir.dialects.spirv.CL_sin
   mlir.dialects.spirv.CL_sinh
   mlir.dialects.spirv.CL_sqrt
   mlir.dialects.spirv.CL_tan
   mlir.dialects.spirv.CL_tanh
   mlir.dialects.spirv.CL_u_max
   mlir.dialects.spirv.CL_u_min
   mlir.dialects.spirv.CompositeConstruct
   mlir.dialects.spirv.CompositeExtract
   mlir.dialects.spirv.CompositeInsert
   mlir.dialects.spirv.Constant
   mlir.dialects.spirv.ControlBarrier
   mlir.dialects.spirv.ConvertFToS
   mlir.dialects.spirv.ConvertFToU
   mlir.dialects.spirv.ConvertPtrToU
   mlir.dialects.spirv.ConvertSToF
   mlir.dialects.spirv.ConvertUToF
   mlir.dialects.spirv.ConvertUToPtr
   mlir.dialects.spirv.CopyMemory
   mlir.dialects.spirv.Dot
   mlir.dialects.spirv.EXT_AtomicFAdd
   mlir.dialects.spirv.EXT_ConstantCompositeReplicate
   mlir.dialects.spirv.EXT_EmitMeshTasks
   mlir.dialects.spirv.EXT_SetMeshOutputs
   mlir.dialects.spirv.EXT_SpecConstantCompositeReplicate
   mlir.dialects.spirv.EmitVertex
   mlir.dialects.spirv.EndPrimitive
   mlir.dialects.spirv.EntryPoint
   mlir.dialects.spirv.ExecutionMode
   mlir.dialects.spirv.FAdd
   mlir.dialects.spirv.FConvert
   mlir.dialects.spirv.FDiv
   mlir.dialects.spirv.FMod
   mlir.dialects.spirv.FMul
   mlir.dialects.spirv.FNegate
   mlir.dialects.spirv.FOrdEqual
   mlir.dialects.spirv.FOrdGreaterThanEqual
   mlir.dialects.spirv.FOrdGreaterThan
   mlir.dialects.spirv.FOrdLessThanEqual
   mlir.dialects.spirv.FOrdLessThan
   mlir.dialects.spirv.FOrdNotEqual
   mlir.dialects.spirv.FRem
   mlir.dialects.spirv.FSub
   mlir.dialects.spirv.FUnordEqual
   mlir.dialects.spirv.FUnordGreaterThanEqual
   mlir.dialects.spirv.FUnordGreaterThan
   mlir.dialects.spirv.FUnordLessThanEqual
   mlir.dialects.spirv.FUnordLessThan
   mlir.dialects.spirv.FUnordNotEqual
   mlir.dialects.spirv.func
   mlir.dialects.spirv.FunctionCall
   mlir.dialects.spirv.GL_Acos
   mlir.dialects.spirv.GL_Acosh
   mlir.dialects.spirv.GL_Asin
   mlir.dialects.spirv.GL_Asinh
   mlir.dialects.spirv.GL_Atan
   mlir.dialects.spirv.GL_Atanh
   mlir.dialects.spirv.GL_Ceil
   mlir.dialects.spirv.GL_Cos
   mlir.dialects.spirv.GL_Cosh
   mlir.dialects.spirv.GL_Cross
   mlir.dialects.spirv.GL_Distance
   mlir.dialects.spirv.GL_Exp2
   mlir.dialects.spirv.GL_Exp
   mlir.dialects.spirv.GL_FAbs
   mlir.dialects.spirv.GL_FClamp
   mlir.dialects.spirv.GL_FMax
   mlir.dialects.spirv.GL_FMin
   mlir.dialects.spirv.GL_FMix
   mlir.dialects.spirv.GL_FSign
   mlir.dialects.spirv.GL_FindILsb
   mlir.dialects.spirv.GL_FindSMsb
   mlir.dialects.spirv.GL_FindUMsb
   mlir.dialects.spirv.GL_Floor
   mlir.dialects.spirv.GL_Fma
   mlir.dialects.spirv.GL_Fract
   mlir.dialects.spirv.GL_FrexpStruct
   mlir.dialects.spirv.GL_InverseSqrt
   mlir.dialects.spirv.GL_Ldexp
   mlir.dialects.spirv.GL_Length
   mlir.dialects.spirv.GL_Log2
   mlir.dialects.spirv.GL_Log
   mlir.dialects.spirv.GL_Normalize
   mlir.dialects.spirv.GL_PackHalf2x16
   mlir.dialects.spirv.GL_Pow
   mlir.dialects.spirv.GL_Reflect
   mlir.dialects.spirv.GL_RoundEven
   mlir.dialects.spirv.GL_Round
   mlir.dialects.spirv.GL_SAbs
   mlir.dialects.spirv.GL_SClamp
   mlir.dialects.spirv.GL_SMax
   mlir.dialects.spirv.GL_SMin
   mlir.dialects.spirv.GL_SSign
   mlir.dialects.spirv.GL_Sin
   mlir.dialects.spirv.GL_Sinh
   mlir.dialects.spirv.GL_Sqrt
   mlir.dialects.spirv.GL_Tan
   mlir.dialects.spirv.GL_Tanh
   mlir.dialects.spirv.GL_UClamp
   mlir.dialects.spirv.GL_UMax
   mlir.dialects.spirv.GL_UMin
   mlir.dialects.spirv.GL_UnpackHalf2x16
   mlir.dialects.spirv.GenericCastToPtrExplicit
   mlir.dialects.spirv.GenericCastToPtr
   mlir.dialects.spirv.GlobalVariable
   mlir.dialects.spirv.ARM_Graph
   mlir.dialects.spirv.ARM_GraphConstant
   mlir.dialects.spirv.ARM_GraphEntryPoint
   mlir.dialects.spirv.ARM_GraphOutputs
   mlir.dialects.spirv.GroupBroadcast
   mlir.dialects.spirv.GroupFAdd
   mlir.dialects.spirv.GroupFMax
   mlir.dialects.spirv.GroupFMin
   mlir.dialects.spirv.KHR_GroupFMul
   mlir.dialects.spirv.GroupIAdd
   mlir.dialects.spirv.KHR_GroupIMul
   mlir.dialects.spirv.GroupNonUniformAllEqual
   mlir.dialects.spirv.GroupNonUniformAll
   mlir.dialects.spirv.GroupNonUniformAny
   mlir.dialects.spirv.GroupNonUniformBallotBitCount
   mlir.dialects.spirv.GroupNonUniformBallotFindLSB
   mlir.dialects.spirv.GroupNonUniformBallotFindMSB
   mlir.dialects.spirv.GroupNonUniformBallot
   mlir.dialects.spirv.GroupNonUniformBitwiseAnd
   mlir.dialects.spirv.GroupNonUniformBitwiseOr
   mlir.dialects.spirv.GroupNonUniformBitwiseXor
   mlir.dialects.spirv.GroupNonUniformBroadcast
   mlir.dialects.spirv.GroupNonUniformElect
   mlir.dialects.spirv.GroupNonUniformFAdd
   mlir.dialects.spirv.GroupNonUniformFMax
   mlir.dialects.spirv.GroupNonUniformFMin
   mlir.dialects.spirv.GroupNonUniformFMul
   mlir.dialects.spirv.GroupNonUniformIAdd
   mlir.dialects.spirv.GroupNonUniformIMul
   mlir.dialects.spirv.GroupNonUniformLogicalAnd
   mlir.dialects.spirv.GroupNonUniformLogicalOr
   mlir.dialects.spirv.GroupNonUniformLogicalXor
   mlir.dialects.spirv.GroupNonUniformRotateKHR
   mlir.dialects.spirv.GroupNonUniformSMax
   mlir.dialects.spirv.GroupNonUniformSMin
   mlir.dialects.spirv.GroupNonUniformShuffleDown
   mlir.dialects.spirv.GroupNonUniformShuffle
   mlir.dialects.spirv.GroupNonUniformShuffleUp
   mlir.dialects.spirv.GroupNonUniformShuffleXor
   mlir.dialects.spirv.GroupNonUniformUMax
   mlir.dialects.spirv.GroupNonUniformUMin
   mlir.dialects.spirv.GroupSMax
   mlir.dialects.spirv.GroupSMin
   mlir.dialects.spirv.GroupUMax
   mlir.dialects.spirv.GroupUMin
   mlir.dialects.spirv.IAddCarry
   mlir.dialects.spirv.IAdd
   mlir.dialects.spirv.IEqual
   mlir.dialects.spirv.IMul
   mlir.dialects.spirv.INTEL_ControlBarrierArrive
   mlir.dialects.spirv.INTEL_ControlBarrierWait
   mlir.dialects.spirv.INTEL_ConvertBF16ToF
   mlir.dialects.spirv.INTEL_ConvertFToBF16
   mlir.dialects.spirv.INTEL_RoundFToTF32
   mlir.dialects.spirv.INTEL_SubgroupBlockRead
   mlir.dialects.spirv.INTEL_SubgroupBlockWrite
   mlir.dialects.spirv.INotEqual
   mlir.dialects.spirv.ISubBorrow
   mlir.dialects.spirv.ISub
   mlir.dialects.spirv.ImageDrefGather
   mlir.dialects.spirv.ImageFetch
   mlir.dialects.spirv.Image
   mlir.dialects.spirv.ImageQuerySize
   mlir.dialects.spirv.ImageRead
   mlir.dialects.spirv.ImageSampleExplicitLod
   mlir.dialects.spirv.ImageSampleImplicitLod
   mlir.dialects.spirv.ImageSampleProjDrefImplicitLod
   mlir.dialects.spirv.ImageWrite
   mlir.dialects.spirv.InBoundsPtrAccessChain
   mlir.dialects.spirv.IsFinite
   mlir.dialects.spirv.IsInf
   mlir.dialects.spirv.IsNan
   mlir.dialects.spirv.KHR_AssumeTrue
   mlir.dialects.spirv.KHR_CooperativeMatrixLength
   mlir.dialects.spirv.KHR_CooperativeMatrixLoad
   mlir.dialects.spirv.KHR_CooperativeMatrixMulAdd
   mlir.dialects.spirv.KHR_CooperativeMatrixStore
   mlir.dialects.spirv.KHR_SubgroupBallot
   mlir.dialects.spirv.Kill
   mlir.dialects.spirv.Load
   mlir.dialects.spirv.LogicalAnd
   mlir.dialects.spirv.LogicalEqual
   mlir.dialects.spirv.LogicalNotEqual
   mlir.dialects.spirv.LogicalNot
   mlir.dialects.spirv.LogicalOr
   mlir.dialects.spirv.mlir_loop
   mlir.dialects.spirv.MatrixTimesMatrix
   mlir.dialects.spirv.MatrixTimesScalar
   mlir.dialects.spirv.MatrixTimesVector
   mlir.dialects.spirv.MemoryBarrier
   mlir.dialects.spirv.mlir_merge
   mlir.dialects.spirv.module
   mlir.dialects.spirv.Not
   mlir.dialects.spirv.Ordered
   mlir.dialects.spirv.PtrAccessChain
   mlir.dialects.spirv.PtrCastToGeneric
   mlir.dialects.spirv.mlir_referenceof
   mlir.dialects.spirv.Return
   mlir.dialects.spirv.ReturnValue
   mlir.dialects.spirv.SConvert
   mlir.dialects.spirv.SDiv
   mlir.dialects.spirv.SDotAccSat
   mlir.dialects.spirv.SDot
   mlir.dialects.spirv.SGreaterThanEqual
   mlir.dialects.spirv.SGreaterThan
   mlir.dialects.spirv.SLessThanEqual
   mlir.dialects.spirv.SLessThan
   mlir.dialects.spirv.SMod
   mlir.dialects.spirv.SMulExtended
   mlir.dialects.spirv.SNegate
   mlir.dialects.spirv.SRem
   mlir.dialects.spirv.SUDotAccSat
   mlir.dialects.spirv.SUDot
   mlir.dialects.spirv.Select
   mlir.dialects.spirv.mlir_selection
   mlir.dialects.spirv.ShiftLeftLogical
   mlir.dialects.spirv.ShiftRightArithmetic
   mlir.dialects.spirv.ShiftRightLogical
   mlir.dialects.spirv.SpecConstantComposite
   mlir.dialects.spirv.SpecConstant
   mlir.dialects.spirv.SpecConstantOperation
   mlir.dialects.spirv.Store
   mlir.dialects.spirv.Switch
   mlir.dialects.spirv.Transpose
   mlir.dialects.spirv.UConvert
   mlir.dialects.spirv.UDiv
   mlir.dialects.spirv.UDotAccSat
   mlir.dialects.spirv.UDot
   mlir.dialects.spirv.UGreaterThanEqual
   mlir.dialects.spirv.UGreaterThan
   mlir.dialects.spirv.ULessThanEqual
   mlir.dialects.spirv.ULessThan
   mlir.dialects.spirv.UMod
   mlir.dialects.spirv.UMulExtended
   mlir.dialects.spirv.Undef
   mlir.dialects.spirv.Unordered
   mlir.dialects.spirv.Unreachable
   mlir.dialects.spirv.Variable
   mlir.dialects.spirv.VectorExtractDynamic
   mlir.dialects.spirv.VectorInsertDynamic
   mlir.dialects.spirv.VectorShuffle
   mlir.dialects.spirv.VectorTimesMatrix
   mlir.dialects.spirv.VectorTimesScalar
   mlir.dialects.spirv.mlir_yield


Module Contents
---------------

.. py:class:: AccessChainOp(component_ptr, base_ptr, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer. Its Type operand must be the type
   reached by walking the Base’s type hierarchy down to the last provided
   index in Indexes, and its Storage Class operand must be the same as the
   Storage Class of Base.

   Base must be a pointer, pointing to the base of a composite object.

   Indexes walk the type hierarchy to the desired depth, potentially down
   to scalar granularity. The first index in Indexes will select the top-
   level member/element/component/element of the base composite. All
   composite constituents use zero-based numbering, as described by their
   OpType… instruction. The second index will apply similarly to that
   result, and so on. Once any non-composite type is reached, there must be
   no remaining (unused) indexes.

   Each index in Indexes

   * must be a scalar integer type,
   * is treated as a signed count, and
   * must be an OpConstant when indexing into a structure.

   Example:
   --------

   .. code:: mlir

       %0 = "spirv.Constant"() { value = 1: i32} : () -> i32
       %1 = spirv.Variable : !spirv.ptr<!spirv.struct<f32, !spirv.array<4xf32>>, Function>
       %2 = spirv.AccessChain %1[%0] : !spirv.ptr<!spirv.struct<f32, !spirv.array<4xf32>>, Function> -> !spirv.ptr<!spirv.array<4xf32>, Function>
       %3 = spirv.Load "Function" %2 ["Volatile"] : !spirv.array<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AccessChain'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base_ptr() -> _ods_ir


   .. py:method:: indices() -> _ods_ir


   .. py:method:: component_ptr() -> _ods_ir


.. py:function:: AccessChain(component_ptr, base_ptr, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AddressOfOp(pointer, variable, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Variables in module scope are defined using symbol names. This op generates
   an SSA value that can be used to refer to the symbol within function scope
   for use in ops that expect an SSA value. This operation has no corresponding
   SPIR-V instruction; it's merely used for modelling purpose in the SPIR-V
   dialect. Since variables in module scope in SPIR-V dialect are of pointer
   type, this op returns a pointer type as well, and the type is the same as
   the variable referenced.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.mlir.addressof @global_var : !spirv.ptr<f32, Input>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.addressof'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: variable() -> _ods_ir


   .. py:method:: pointer() -> _ods_ir


.. py:function:: mlir_addressof(pointer, variable, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicAndOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by the bitwise AND of Original Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicAnd <Device> <None> %pointer, %value :
                          !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicAnd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicAnd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicCompareExchangeOp(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value from Value only if Original Value equals Comparator,
   and
   #. store the New Value back through Pointer'only if 'Original Value
   equaled Comparator.

   The instruction's result is the Original Value.

   Result Type must be an integer type scalar.

   Use Equal for the memory semantics of this instruction when Value and
   Original Value compare equal.

   Use Unequal for the memory semantics of this instruction when Value and
   Original Value compare unequal. Unequal must not be set to Release or
   Acquire and Release. In addition, Unequal cannot be set to a stronger
   memory-order then Equal.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.  This type
   must also match the type of Comparator.

   Memory is a memory Scope.

   Example:
   --------

   .. code::

       %0 = spirv.AtomicCompareExchange <Workgroup> <Acquire> <None>
                                       %pointer, %value, %comparator
                                       : !spirv.ptr<i32, WorkGroup>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicCompareExchange'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: comparator() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: equal_semantics() -> _ods_ir


   .. py:method:: unequal_semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicCompareExchange(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicCompareExchangeWeakOp(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Has the same semantics as OpAtomicCompareExchange.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicCompareExchangeWeak <Workgroup> <Acquire> <None>
                                          %pointer, %value, %comparator
                                          : !spirv.ptr<i32, WorkGroup>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicCompareExchangeWeak'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: comparator() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: equal_semantics() -> _ods_ir


   .. py:method:: unequal_semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicCompareExchangeWeak(pointer, memory_scope, equal_semantics, unequal_semantics, value, comparator, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicExchangeOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value from copying Value, and
   #. store the New Value back through Pointer.

   The instruction's result is the Original Value.

   Result Type must be a scalar of integer type or floating-point type.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory is a memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicExchange <Workgroup> <Acquire> %pointer, %value,
                               : !spirv.ptr<i32, WorkGroup>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicExchange'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicExchange(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicIAddOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by integer addition of Original Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicIAdd <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicIAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicIAdd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicIDecrementOp(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value through integer subtraction of 1 from Original Value,
   and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.  The type of the value
   pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicIDecrement <Device> <None> %pointer :
                                 !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicIDecrement'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicIDecrement(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicIIncrementOp(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value through integer addition of 1 to Original Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.  The type of the value
   pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicIncrement <Device> <None> %pointer :
                                !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicIIncrement'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicIIncrement(pointer, memory_scope, semantics, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicISubOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by integer subtraction of Value from Original Value,
   and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicISub <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicISub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicISub(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicOrOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by the bitwise OR of Original Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicOr <Device> <None> %pointer, %value :
                         !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicOr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicOr(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicSMaxOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by finding the largest signed integer of Original
   Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicSMax <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicSMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicSMax(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicSMinOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by finding the smallest signed integer of Original
   Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicSMin <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicSMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicSMin(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicUMaxOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by finding the largest unsigned integer of Original
   Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicUMax <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicUMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicUMax(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicUMinOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by finding the smallest unsigned integer of Original
   Value and Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicUMin <Device> <None> %pointer, %value :
                           !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicUMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicUMin(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicXorOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   #. load through Pointer to get an Original Value,
   #. get a New Value by the bitwise exclusive OR of Original Value and
   Value, and
   #. store the New Value back through Pointer.

   The instruction’s result is the Original Value.

   Result Type must be an integer type scalar.

   The type of Value must be the same as Result Type.  The type of the
   value pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.AtomicXor <Device> <None> %pointer, %value :
                          !spirv.ptr<i32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.AtomicXor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: AtomicXor(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitCountOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component.

   Result Type must be a scalar or vector of integer type.  The components
   must be wide enough to hold the unsigned Width of Base as an unsigned
   value. That is, no sign bit is needed or counted when checking for a
   wide enough result width.

   Base must be a scalar or vector of integer type.  It must have the same
   number of components as Result Type.

   The result is the unsigned value that is the number of bits in Base that
   are 1.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.BitCount %0: i32
       %3 = spirv.BitCount %1: vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitCount'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitCount(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitFieldInsertOp(base, insert, offset, count, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component.

   Result Type must be a scalar or vector of integer type.

   The type of Base and Insert must be the same as Result Type.

   Any result bits numbered outside [Offset, Offset + Count -  1]
   (inclusive) will come from the corresponding bits in Base.

   Any result bits numbered in [Offset, Offset + Count -  1] come, in
   order, from the bits numbered [0, Count - 1] of Insert.

   Count  must be an integer type scalar. Count is the number of bits taken
   from Insert. It will be consumed as an unsigned value. Count can be 0,
   in which case the result will be Base.

   Offset  must be an integer type scalar. Offset is the lowest-order bit
   of the bit field.  It will be consumed as an unsigned value.

   The resulting value is undefined if Count or Offset or their sum is
   greater than the number of bits in the result.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.BitFieldInsert %base, %insert, %offset, %count : vector<3xi32>, i8, i8


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitFieldInsert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base() -> _ods_ir


   .. py:method:: insert() -> _ods_ir


   .. py:method:: offset() -> _ods_ir[_ods_ir]


   .. py:method:: count() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitFieldInsert(base, insert, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitFieldSExtractOp(base, offset, count, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component.

   Result Type must be a scalar or vector of integer type.

   The type of Base must be the same as Result Type.

   If Count is greater than 0: The bits of Base numbered in [Offset, Offset

   * Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the
   result. The remaining bits of the result will all be the same as bit
   Offset + Count -  1 of Base.

   Count  must be an integer type scalar. Count is the number of bits
   extracted from Base. It will be consumed as an unsigned value. Count can
   be 0, in which case the result will be 0.

   Offset  must be an integer type scalar. Offset is the lowest-order bit
   of the bit field to extract from Base.  It will be consumed as an
   unsigned value.

   The resulting value is undefined if Count or Offset or their sum is
   greater than the number of bits in the result.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.BitFieldSExtract %base, %offset, %count : vector<3xi32>, i8, i8


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitFieldSExtract'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base() -> _ods_ir


   .. py:method:: offset() -> _ods_ir[_ods_ir]


   .. py:method:: count() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitFieldSExtract(base, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitFieldUExtractOp(base, offset, count, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The semantics are the same as with OpBitFieldSExtract with the exception
   that there is no sign extension. The remaining bits of the result will
   all be 0.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.BitFieldUExtract %base, %offset, %count : vector<3xi32>, i8, i8


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitFieldUExtract'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base() -> _ods_ir


   .. py:method:: offset() -> _ods_ir[_ods_ir]


   .. py:method:: count() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitFieldUExtract(base, offset, count, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitReverseOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component.

   Result Type must be a scalar or vector of integer type.

   The type of Base must be the same as Result Type.

   The bit-number n of the result will be taken from bit-number Width - 1 -
   n of Base, where Width is the OpTypeInt operand of the Result Type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.BitReverse %0 : i32
       %3 = spirv.BitReverse %1 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitReverse'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitReverse(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitcastOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer, or a scalar or vector of
   numerical-type.

   Operand must have a type of OpTypePointer, or a scalar or vector of
   numerical-type. It must be a different type than Result Type.

   If either Result Type or Operand is a pointer, the other must be a
   pointer (diverges from the SPIR-V spec).

   If Result Type has a different number of components than Operand, the
   total number of bits in Result Type must equal the total number of bits
   in Operand. Let L be the type, either Result Type or Operand's type,
   that has the larger number of components. Let S be the other type, with
   the smaller number of components. The number of components in L must be
   an integer multiple of the number of components in S. The first
   component (that is, the only or lowest-numbered component) of S maps to
   the first components of L, and so on,  up to the last component of S
   mapping to the last components of L. Within this mapping, any single
   component of S (mapping to multiple components of L) maps its lower-
   ordered bits to the lower-numbered components of L.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.Bitcast %0 : f32 to i32
       %1 = spirv.Bitcast %0 : vector<2xf32> to i64
       %1 = spirv.Bitcast %0 : !spirv.ptr<f32, Function> to !spirv.ptr<i32, Function>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Bitcast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Bitcast(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseAndOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component, and within each component, per bit.

   Result Type must be a scalar or vector of integer type.  The type of
   Operand 1 and Operand 2  must be a scalar or vector of integer type.
   They must have the same number of components as Result Type. They must
   have the same component width as Result Type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.BitwiseAnd %0, %1 : i32
       %2 = spirv.BitwiseAnd %0, %1 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitwiseAnd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitwiseAnd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseOrOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component, and within each component, per bit.

   Result Type must be a scalar or vector of integer type.  The type of
   Operand 1 and Operand 2  must be a scalar or vector of integer type.
   They must have the same number of components as Result Type. They must
   have the same component width as Result Type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.BitwiseOr %0, %1 : i32
       %2 = spirv.BitwiseOr %0, %1 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitwiseOr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitwiseOr(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitwiseXorOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component, and within each component, per bit.

   Result Type must be a scalar or vector of integer type.  The type of
   Operand 1 and Operand 2  must be a scalar or vector of integer type.
   They must have the same number of components as Result Type. They must
   have the same component width as Result Type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.BitwiseXor %0, %1 : i32
       %2 = spirv.BitwiseXor %0, %1 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BitwiseXor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: BitwiseXor(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BranchConditionalOp(condition, trueTargetOperands, falseTargetOperands, trueTarget, falseTarget, *, branch_weights=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Condition must be a Boolean type scalar.

   Branch weights are unsigned 32-bit integer literals. There must be
   either no Branch Weights or exactly two branch weights. If present, the
   first is the weight for branching to True Label, and the second is the
   weight for branching to False Label. The implied probability that a
   branch is taken is its weight divided by the sum of the two Branch
   weights. At least one weight must be non-zero. A weight of zero does not
   imply a branch is dead or permit its removal; branch weights are only
   hints. The two weights must not overflow a 32-bit unsigned integer when
   added together.

   This instruction must be the last instruction in a block.

   .. code::

       branch-conditional-op ::= `spirv.BranchConditional` ssa-use
                                 (`[` integer-literal, integer-literal `]`)?
                                 `,` successor `,` successor
       successor ::= bb-id branch-use-list?
       branch-use-list ::= `(` ssa-use-list `:` type-list-no-parens `)`

   Example:
   --------

   .. code:: mlir

       spirv.BranchConditional %condition, ^true_branch, ^false_branch
       spirv.BranchConditional %condition, ^true_branch(%0: i32), ^false_branch(%1: i32)


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.BranchConditional'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: condition() -> _ods_ir[_ods_ir]


   .. py:method:: trueTargetOperands() -> _ods_ir


   .. py:method:: falseTargetOperands() -> _ods_ir


   .. py:method:: branch_weights() -> Optional[_ods_ir]


.. py:function:: BranchConditional(condition, true_target_operands, false_target_operands, true_target, false_target, *, branch_weights=None, loc=None, ip=None) -> BranchConditionalOp

.. py:class:: BranchOp(targetOperands, target, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This instruction must be the last instruction in a block.

   Example:
   --------

   .. code:: mlir

       spirv.Branch ^target
       spirv.Branch ^target(%0, %1: i32, f32)


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Branch'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: targetOperands() -> _ods_ir


.. py:function:: Branch(target_operands, target, *, loc=None, ip=None) -> BranchOp

.. py:class:: CLAcosOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.acos %0 : f32
       %3 = spirv.CL.acos %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.acos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_acos(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAcoshOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.acosh %0 : f32
       %3 = spirv.CL.acosh %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.acosh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_acosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAsinOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.asin %0 : f32
       %3 = spirv.CL.asin %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.asin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_asin(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAsinhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.asinh %0 : f32
       %3 = spirv.CL.asinh %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.asinh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_asinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAtan2Op(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type, y and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.atan2 %0, %1 : f32
       %3 = spirv.CL.atan2 %0, %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.atan2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_atan2(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAtanOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.atan %0 : f32
       %3 = spirv.CL.atan %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.atan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_atan(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLAtanhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is an angle in radians.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.atanh %0 : f32
       %3 = spirv.CL.atanh %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.atanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_atanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLCeilOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.ceil %0 : f32
       %3 = spirv.CL.ceil %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.ceil'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_ceil(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLCosOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.cos %0 : f32
       %3 = spirv.CL.cos %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.cos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_cos(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLCoshOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.cosh %0 : f32
       %3 = spirv.CL.cosh %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.cosh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_cosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLErfOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.erf %0 : f32
       %3 = spirv.CL.erf %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.erf'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_erf(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLExpOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Compute the base-e exponential of x. (i.e. ex)

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand,
   must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.exp %0 : f32
       %3 = spirv.CL.exp %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.exp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_exp(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLFAbsOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Compute the absolute value of x.

   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand,
   must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.fabs %0 : f32
       %3 = spirv.CL.fabs %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.fabs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_fabs(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLFMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if x < y, otherwise it returns x. If one argument is a NaN,
   Fmax returns the other argument. If both arguments are NaNs, Fmax returns a NaN.

   Result Type, x and y must be floating-point or vector(2,3,4,8,16)
   of floating-point values.

   All of the operands, including the Result Type operand,
   must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.fmax %0, %1 : f32
       %3 = spirv.CL.fmax %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.fmax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_fmax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLFMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if y < x, otherwise it returns x. If one argument is a NaN, Fmin returns the other argument.
   If both arguments are NaNs, Fmin returns a NaN.

   Result Type,x and y must be floating-point or vector(2,3,4,8,16) of floating-point values.

   All of the operands, including the Result Type operand, must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.fmin %0, %1 : f32
       %3 = spirv.CL.fmin %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.fmin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_fmin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLFloorOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.floor %0 : f32
       %3 = spirv.CL.floor %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.floor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_floor(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLFmaOp(x, y, z, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type, a, b and c must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.CL.fma %a, %b, %c : f32
       %1 = spirv.CL.fma %a, %b, %c : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.fma'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_fma(x, y, z, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLLogOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.log %0 : f32
       %3 = spirv.CL.log %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.log'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_log(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLMixOp(x, y, z, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type, x, y and a must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Note: This instruction can be implemented using contractions such as mad
   or fma.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.CL.mix %a, %b, %c : f32
       %1 = spirv.CL.mix %a, %b, %c : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.mix'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_mix(x, y, z, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLPowOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type, x and y must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.pow %0, %1 : f32
       %3 = spirv.CL.pow %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.pow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_pow(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLPrintfOp(result, format, arguments, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   printf returns 0 if it was executed successfully and -1 otherwise.

   Result Type must be i32.

   Format must be a pointer(constant) to i8. If there are insufficient
   arguments for the format, the behavior is undefined. If the format
   is exhausted while arguments remain, the excess arguments are evaluated
   (as always) but are otherwise ignored. The printf instruction returns
   when the end of the format string is encountered.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.CL.printf %fmt %1, %2  : !spirv.ptr<i8, UniformConstant>, i32, i32 -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.printf'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: format() -> _ods_ir


   .. py:method:: arguments() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_printf(result, format, arguments, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CLRintOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.CL.rint %0 : f32
       %1 = spirv.CL.rint %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.rint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_rint(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLRoundOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.round %0 : f32
       %3 = spirv.CL.round %0 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.round'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_round(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLRsqrtOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.rsqrt %0 : f32
       %3 = spirv.CL.rsqrt %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.rsqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_rsqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSAbsOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns |x|, where x is treated as signed integer.

   Result Type and x must be integer or vector(2,3,4,8,16) of
   integer values.

   All of the operands, including the Result Type operand,
   must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.s_abs %0 : i32
       %3 = spirv.CL.s_abs %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.s_abs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_s_abs(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if x < y, otherwise it returns x, where x and y are treated as signed integers.

   Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.

   All of the operands, including the Result Type operand, must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.s_max %0, %1 : i32
       %3 = spirv.CL.s_max %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.s_max'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_s_max(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if x < y, otherwise it returns x, where x and y are treated as signed integers.

   Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.

   All of the operands, including the Result Type operand, must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.s_min %0, %1 : i32
       %3 = spirv.CL.s_min %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.s_min'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_s_min(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSinOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.sin %0 : f32
       %3 = spirv.CL.sin %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.sin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_sin(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSinhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.sinh %0 : f32
       %3 = spirv.CL.sinh %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.sinh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_sinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLSqrtOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.sqrt %0 : f32
       %3 = spirv.CL.sqrt %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.sqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_sqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLTanOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.tan %0 : f32
       %3 = spirv.CL.tan %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.tan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_tan(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLTanhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type and x must be floating-point or vector(2,3,4,8,16) of
   floating-point values.

   All of the operands, including the Result Type operand, must be of the
   same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.tanh %0 : f32
       %3 = spirv.CL.tanh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.tanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_tanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLUMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if x < y, otherwise it returns x, where x and y are treated as unsigned integers.

   Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.

   All of the operands, including the Result Type operand, must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.u_max %0, %1 : i32
       %3 = spirv.CL.u_max %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.u_max'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_u_max(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CLUMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Returns y if x < y, otherwise it returns x, where x and y are treated as unsigned integers.

   Result Type,x and y must be integer or vector(2,3,4,8,16) of integer values.

   All of the operands, including the Result Type operand, must be of the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.CL.u_min %0, %1 : i32
       %3 = spirv.CL.u_min %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CL.u_min'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CL_u_min(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CompositeConstructOp(result, constituents, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a composite type, whose top-level
   members/elements/components/columns have the same type as the types of
   the operands, with one exception. The exception is that for constructing
   a vector, the operands may also be vectors with the same component type
   as the Result Type component type. When constructing a vector, the total
   number of components in all the operands must equal the number of
   components in Result Type.

   Constituents will become members of a structure, or elements of an
   array, or components of a vector, or columns of a matrix. There must be
   exactly one Constituent for each top-level
   member/element/component/column of the result, with one exception. The
   exception is that for constructing a vector, a contiguous subset of the
   scalars consumed can be represented by a vector operand instead. The
   Constituents must appear in the order needed by the definition of the
   type of the result. When constructing a vector, there must be at least
   two Constituent operands.

   Example:
   --------

   .. code:: mlir

       %a = spirv.CompositeConstruct %1, %2, %3 : vector<3xf32>
       %b = spirv.CompositeConstruct %a, %1 : (vector<3xf32>, f32) -> vector<4xf32>
       
       %c = spirv.CompositeConstruct %1 :
         (f32) -> !spirv.coopmatrix<4x4xf32, Subgroup, MatrixA>
       
       %d = spirv.CompositeConstruct %a, %4, %5 :
         (vector<3xf32>, !spirv.array<4xf32>, !spirv.struct<(f32)>) ->
           !spirv.struct<(vector<3xf32>, !spirv.array<4xf32>, !spirv.struct<(f32)>)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CompositeConstruct'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: constituents() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CompositeConstruct(result, constituents, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CompositeExtractOp(component, composite, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be the type of object selected by the last provided
   index.  The instruction result is the extracted object.

   Composite is the composite to extract from.

   Indexes walk the type hierarchy, potentially down to component
   granularity, to select the part to extract. All indexes must be in
   bounds.  All composite constituents use zero-based numbering, as
   described by their OpType… instruction.

   .. code::

       composite-extract-op ::= ssa-id `=` `spirv.CompositeExtract` ssa-use
                                `[` integer-literal (',' integer-literal)* `]`
                                `:` composite-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Variable : !spirv.ptr<!spirv.array<4x!spirv.array<4xf32>>, Function>
       %1 = spirv.Load "Function" %0 ["Volatile"] : !spirv.array<4x!spirv.array<4xf32>>
       %2 = spirv.CompositeExtract %1[1 : i32] : !spirv.array<4x!spirv.array<4xf32>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CompositeExtract'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: composite() -> _ods_ir


   .. py:method:: indices() -> _ods_ir


   .. py:method:: component() -> _ods_ir


.. py:function:: CompositeExtract(component, composite, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CompositeInsertOp(result, object, composite, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be the same type as Composite.

   Object is the object to use as the modified part.

   Composite is the composite to copy all but the modified part from.

   Indexes walk the type hierarchy of Composite to the desired depth,
   potentially down to component granularity, to select the part to modify.
   All indexes must be in bounds. All composite constituents use zero-based
   numbering, as described by their OpType… instruction. The type of the
   part selected to modify must match the type of Object.

   .. code::

       composite-insert-op ::= ssa-id `=` `spirv.CompositeInsert` ssa-use, ssa-use
                               `[` integer-literal (',' integer-literal)* `]`
                               `:` object-type `into` composite-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.CompositeInsert %object, %composite[1 : i32] : f32 into !spirv.array<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CompositeInsert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: object() -> _ods_ir


   .. py:method:: composite() -> _ods_ir


   .. py:method:: indices() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: CompositeInsert(result, object, composite, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstantOp(constant, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares a SPIR-V normal constant. SPIR-V has multiple constant
   instructions covering different constant types:

   * ``OpConstantTrue`` and ``OpConstantFalse`` for boolean constants
   * ``OpConstant`` for scalar constants
   * ``OpConstantComposite`` for composite constants
   * ``OpConstantNull`` for null constants
   * ...

   Having such a plethora of constant instructions renders IR transformations
   more tedious. Therefore, we use a single ``spirv.Constant`` op to represent
   them all. Note that conversion between those SPIR-V constant instructions
   and this op is purely mechanical; so it can be scoped to the binary
   (de)serialization process.

   .. code::

       spirv.Constant-op ::= ssa-id `=` `spirv.Constant` attribute-value
                           (`:` spirv-type)?

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Constant true
       %1 = spirv.Constant dense<[2.0, 3.0]> : vector<2xf32>
       %2 = spirv.Constant [dense<3.0> : vector<2xf32>] : !spirv.array<1xvector<2xf32>>

   TODO: support constant structs


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Constant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: constant() -> _ods_ir


.. py:function:: Constant(constant, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ControlBarrierOp(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   All invocations of this module within Execution scope must reach this
   point of execution before any invocation will proceed beyond it.

   When Execution is Workgroup or larger, behavior is undefined if this
   instruction is used in control flow that is non-uniform within
   Execution. When Execution is Subgroup or Invocation, the behavior of
   this instruction in non-uniform control flow is defined by the client
   API.

   If Semantics is not None, this instruction also serves as an
   OpMemoryBarrier instruction, and must also perform and adhere to the
   description and semantics of an OpMemoryBarrier instruction with the
   same Memory and Semantics operands.  This allows atomically specifying
   both a control barrier and a memory barrier (that is, without needing
   two instructions). If Semantics is None, Memory is ignored.

   Before version 1.3, it is only valid to use this instruction with
   TessellationControl, GLCompute, or Kernel execution models. There is no
   such restriction starting with version 1.3.

   When used with the TessellationControl execution model, it also
   implicitly synchronizes the Output Storage Class:  Writes to Output
   variables performed by any invocation executed prior to a
   OpControlBarrier will be visible to any other invocation after return
   from that OpControlBarrier.

   Example:
   --------

   .. code:: mlir

       spirv.ControlBarrier <Workgroup>, <Device>, <Acquire|UniformMemory>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ControlBarrier'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: memory_semantics() -> _ods_ir


.. py:function:: ControlBarrier(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> ControlBarrierOp

.. py:class:: ConvertFToSOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Float Value must be a scalar or vector of floating-point type.  It must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertFToS %0 : f32 to i32
       %3 = spirv.ConvertFToS %2 : vector<3xf32> to vector<3xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertFToS'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertFToS(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConvertFToUOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type, whose Signedness
   operand is 0.

   Float Value must be a scalar or vector of floating-point type.  It must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertFToU %0 : f32 to i32
       %3 = spirv.ConvertFToU %2 : vector<3xf32> to vector<3xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertFToU'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertFToU(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConvertPtrToUOp(result, pointer, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar of integer type, whose Signedness operand is 0.

   Pointer must be a physical pointer type. If the bit width of Pointer is
   smaller than that of Result Type, the conversion zero extends Pointer.
   If the bit width of Pointer is larger than that of Result Type,
   the conversion truncates Pointer.

   For same bit width Pointer and Result Type, this is the same as OpBitcast.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertPtrToU %0 : !spirv.ptr<i32, Generic> to i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertPtrToU'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertPtrToU(result, pointer, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConvertSToFOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   Signed Value must be a scalar or vector of integer type.  It must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertSToF %0 : i32 to f32
       %3 = spirv.ConvertSToF %2 : vector<3xi32> to vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertSToF'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertSToF(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConvertUToFOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   Unsigned Value must be a scalar or vector of integer type.  It must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertUToF %0 : i32 to f32
       %3 = spirv.ConvertUToF %2 : vector<3xi32> to vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertUToF'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertUToF(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConvertUToPtrOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a physical pointer type.

   Integer Value must be a scalar of integer type, whose Signedness
   operand is 0. If the bit width of Integer Value is smaller
   than that of Result Type, the conversion zero extends Integer Value.
   If the bit width of Integer Value is larger than that of Result Type,
   the conversion truncates Integer Value.

   For same-width Integer Value and Result Type, this is the same as OpBitcast.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertUToPtr %0 :  i32 to !spirv.ptr<i32, Generic>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ConvertUToPtr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ConvertUToPtr(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CopyMemoryOp(target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   If present, any Memory Operands must begin with a memory operand
   literal. If not present, it is the same as specifying the memory operand
   None. Before version 1.4, at most one memory operands mask can be
   provided. Starting with version 1.4 two masks can be provided, as
   described in Memory Operands. If no masks or only one mask is present,
   it applies to both Source and Target. If two masks are present, the
   first applies to Target and cannot include MakePointerVisible, and the
   second applies to Source and cannot include MakePointerAvailable.

   .. code::

       copy-memory-op ::= `spirv.CopyMemory ` storage-class ssa-use
                          storage-class ssa-use
                          (`[` memory-access `]` (`, [` memory-access `]`)?)?
                          ` : ` spirv-element-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Variable : !spirv.ptr<f32, Function>
       %1 = spirv.Variable : !spirv.ptr<f32, Function>
       spirv.CopyMemory "Function" %0, "Function" %1 : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.CopyMemory'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: target() -> _ods_ir


   .. py:method:: source() -> _ods_ir


   .. py:method:: memory_access() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: source_memory_access() -> Optional[_ods_ir]


   .. py:method:: source_alignment() -> Optional[_ods_ir]


.. py:function:: CopyMemory(target, source, *, memory_access=None, alignment=None, source_memory_access=None, source_alignment=None, loc=None, ip=None) -> CopyMemoryOp

.. py:class:: DotOp(result, vector1, vector2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a floating point scalar.

   Vector 1 and Vector 2 must be vectors of the same type, and their component
   type must be Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Dot %v1, %v2 : vector<4xf32> -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Dot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir[_ods_ir]


   .. py:method:: vector2() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Dot(result, vector1, vector2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: EXTAtomicFAddOp(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Perform the following steps atomically with respect to any other atomic
   accesses within Scope to the same location:

   #. load through Pointer to get an Original Value,
   #. get a New Value by float addition of Original Value and Value, and
   #. store the New Value back through Pointer.

   The instruction's result is the Original Value.

   Result Type must be a floating-point type scalar.

   The type of Value must be the same as Result Type. The type of the value
   pointed to by Pointer must be the same as Result Type.

   Memory must be a valid memory Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.EXT.AtomicFAdd <Device> <None> %pointer, %value :
                              !spirv.ptr<f32, StorageBuffer>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EXT.AtomicFAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: value() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: semantics() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: EXT_AtomicFAdd(pointer, memory_scope, semantics, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: EXTConstantCompositeReplicateOp(replicated_constant, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Represents a splat composite constant i.e., all elements of composite constant
   have the same value.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.EXT.ConstantCompositeReplicate [1 : i32] : vector<2xi32>
       %1 = spirv.EXT.ConstantCompositeReplicate [1 : i32] : !spirv.array<2 x vector<2xi32>>
       %2 = spirv.EXT.ConstantCompositeReplicate [dense<[1, 2]> : vector<2xi32>] : !spirv.array<2 x vector<2xi32>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EXT.ConstantCompositeReplicate'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: replicated_constant() -> _ods_ir


.. py:function:: EXT_ConstantCompositeReplicate(replicated_constant, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: EXTEmitMeshTasksOp(group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Defines the grid size of subsequent mesh shader workgroups to generate upon
   completion of the task shader workgroup.

   Group Count X Y Z must each be a 32-bit unsigned integer value. They
   configure the number of local workgroups in each respective dimensions for the
   launch of child mesh tasks. See Vulkan API specification for more detail.

   Payload is an optional pointer to the payload structure to pass to the
   generated mesh shader invocations. Payload must be the result of an OpVariable
   with a storage class of TaskPayloadWorkgroupEXT.

   The arguments are taken from the first invocation in each workgroup.
   Behaviour is undefined if any invocation terminates without executing this
   instruction, or if any invocation executes this instruction in non-uniform
   control flow.

   This instruction also serves as an OpControlBarrier instruction, and also
   performs and adheres to the description and semantics of an OpControlBarrier
   instruction with the Execution and Memory operands set to Workgroup and the
   Semantics operand set to a combination of WorkgroupMemory and AcquireRelease.

   Ceases all further processing: Only instructions executed before
   OpEmitMeshTasksEXT have observable side effects.

   This instruction must be the last instruction in a block.

   This instruction is only valid in the TaskEXT Execution Model.

   Example:
   --------

   .. code:: mlir

       spirv.EmitMeshTasksEXT %x, %y, %z : i32, i32, i32
       spirv.EmitMeshTasksEXT %x, %x, %z, %payload : i32, i32, i32, !spirv.ptr<i32, TaskPayloadWorkgroupEXT>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EXT.EmitMeshTasks'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: group_count_x() -> _ods_ir


   .. py:method:: group_count_y() -> _ods_ir


   .. py:method:: group_count_z() -> _ods_ir


   .. py:method:: payload() -> Optional[_ods_ir]


.. py:function:: EXT_EmitMeshTasks(group_count_x, group_count_y, group_count_z, *, payload=None, loc=None, ip=None) -> EXTEmitMeshTasksOp

.. py:class:: EXTSetMeshOutputsOp(vertex_count, primitive_count, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Vertex Count must be a 32-bit unsigned integer value. It defines the array size
   of per-vertex outputs.

   Primitive Count must a 32-bit unsigned integer value. It defines the array size
   of per-primitive outputs.

   The arguments are taken from the first invocation in each workgroup. Behavior
   is undefined if any invocation executes this instruction more than once or
   under non-uniform control flow. Behavior is undefined if there is any control
   flow path to an output write that is not preceded by this instruction.

   This instruction is only valid in the MeshEXT Execution Model.

   Example:
   --------

   .. code:: mlir

       spirv.SetMeshOutputsEXT %vcount, %pcount : i32, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EXT.SetMeshOutputs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vertex_count() -> _ods_ir


   .. py:method:: primitive_count() -> _ods_ir


.. py:function:: EXT_SetMeshOutputs(vertex_count, primitive_count, *, loc=None, ip=None) -> EXTSetMeshOutputsOp

.. py:class:: EXTSpecConstantCompositeReplicateOp(type_, sym_name, constituent, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Represents a splat spec composite constant i.e., all elements of spec composite
   constant have the same value. The splat value must come from a symbol reference
   of spec constant instruction.

   Example:
   --------

   .. code:: mlir

       spirv.SpecConstant @sc_i32_1 = 1 : i32
       spirv.EXT.SpecConstantCompositeReplicate @scc_splat_array_of_i32 (@sc_i32_1) : !spirv.array<3 x i32>
       spirv.EXT.SpecConstantCompositeReplicate @scc_splat_struct_of_i32 (@sc_i32_1) : !spirv.struct<(i32, i32, i32)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EXT.SpecConstantCompositeReplicate'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: type_() -> _ods_ir


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: constituent() -> _ods_ir


.. py:function:: EXT_SpecConstantCompositeReplicate(type_, sym_name, constituent, *, loc=None, ip=None) -> EXTSpecConstantCompositeReplicateOp

.. py:class:: EmitVertexOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This instruction must only be used when only one stream is present.

   Example:
   --------

   .. code:: mlir

       spirv.EmitVertex


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EmitVertex'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: EmitVertex(*, loc=None, ip=None) -> EmitVertexOp

.. py:class:: EndPrimitiveOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This instruction must only be used when only one stream is present.

   Example:
   --------

   .. code:: mlir

       spirv.EndPrimitive


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EndPrimitive'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: EndPrimitive(*, loc=None, ip=None) -> EndPrimitiveOp

.. py:class:: EntryPointOp(execution_model, fn, interface, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Execution Model is the execution model for the entry point and its
   static call tree. See Execution Model.

   Entry Point must be the Result  of an OpFunction instruction.

   Name is a name string for the entry point. A module cannot have two
   OpEntryPoint instructions with the same Execution Model and the same
   Name string.

   Interface is a list of symbol references to ``spirv.GlobalVariable``
   operations. These declare the set of global variables from a
   module that form the interface of this entry point. The set of
   Interface symbols must be equal to or a superset of the
   ``spirv.GlobalVariable``s referenced by the entry point’s static call
   tree, within the interface’s storage classes.  Before version 1.4,
   the interface’s storage classes are limited to the Input and
   Output storage classes. Starting with version 1.4, the interface’s
   storage classes are all storage classes used in declaring all
   global variables referenced by the entry point’s call tree.

   .. code::

       execution-model ::= "Vertex" | "TesellationControl" |
                           <and other SPIR-V execution models...>
       
       entry-point-op ::= ssa-id `=` `spirv.EntryPoint` execution-model
                          symbol-reference (`, ` symbol-reference)*

   Example:
   --------

   .. code:: mlir

       spirv.EntryPoint "GLCompute" @foo
       spirv.EntryPoint "Kernel" @foo, @var1, @var2
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.EntryPoint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: execution_model() -> _ods_ir


   .. py:method:: fn() -> _ods_ir


   .. py:method:: interface() -> _ods_ir


.. py:function:: EntryPoint(execution_model, fn, interface, *, loc=None, ip=None) -> EntryPointOp

.. py:class:: ExecutionModeOp(fn, execution_mode, values, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Entry Point must be the Entry Point  operand of an OpEntryPoint
   instruction.

   Mode is the execution mode. See Execution Mode.

   This instruction is only valid when the Mode operand is an execution
   mode that takes no Extra Operands, or takes Extra Operands that are not
    operands.

   .. code::

       execution-mode ::= "Invocations" | "SpacingEqual" |
                          <and other SPIR-V execution modes...>
       
       execution-mode-op ::= `spirv.ExecutionMode ` ssa-use execution-mode
                             (integer-literal (`, ` integer-literal)* )?

   Example:
   --------

   .. code:: mlir

       spirv.ExecutionMode @foo "ContractionOff"
       spirv.ExecutionMode @bar "LocalSizeHint", 3, 4, 5


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ExecutionMode'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: fn() -> _ods_ir


   .. py:method:: execution_mode() -> _ods_ir


   .. py:method:: values() -> _ods_ir


.. py:function:: ExecutionMode(fn, execution_mode, values, *, loc=None, ip=None) -> ExecutionModeOp

.. py:class:: FAddOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FAdd %0, %1 : f32
       %5 = spirv.FAdd %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FAdd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FConvertOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   Float Value must be a scalar or vector of floating-point type.  It must
   have the same number of components as Result Type.  The component width
   cannot equal the component width in Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.FConvertOp %0 : f32 to f64
       %3 = spirv.FConvertOp %2 : vector<3xf32> to vector<3xf64>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FConvert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FConvert(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FDivOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FDiv %0, %1 : f32
       %5 = spirv.FDiv %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FDiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FModOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
   1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
   sign of Operand 2.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FMod %0, %1 : f32
       %5 = spirv.FMod %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FMod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FMulOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FMul %0, %1 : f32
       %5 = spirv.FMul %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FMul(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FNegateOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The type of Operand must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.FNegate %0 : f32
       %3 = spirv.FNegate %2 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FNegate'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FNegate(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdEqual %0, %1 : f32
       %5 = spirv.FOrdEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdGreaterThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdGreaterThanEqual %0, %1 : f32
       %5 = spirv.FOrdGreaterThanEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdGreaterThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdGreaterThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdGreaterThan %0, %1 : f32
       %5 = spirv.FOrdGreaterThan %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdGreaterThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdLessThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdLessThanEqual %0, %1 : f32
       %5 = spirv.FOrdLessThanEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdLessThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdLessThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdLessThan %0, %1 : f32
       %5 = spirv.FOrdLessThan %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdLessThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FOrdNotEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FOrdNotEqual %0, %1 : f32
       %5 = spirv.FOrdNotEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FOrdNotEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FOrdNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FRemOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
   1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
   sign of Operand 1.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FRemOp %0, %1 : f32
       %5 = spirv.FRemOp %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FRem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FRem(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FSubOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FRemOp %0, %1 : f32
       %5 = spirv.FRemOp %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FSub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FSub(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordEqual %0, %1 : f32
       %5 = spirv.FUnordEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordGreaterThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordGreaterThanEqual %0, %1 : f32
       %5 = spirv.FUnordGreaterThanEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordGreaterThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordGreaterThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordGreaterThan %0, %1 : f32
       %5 = spirv.FUnordGreaterThan %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordGreaterThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordLessThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordLessThanEqual %0, %1 : f32
       %5 = spirv.FUnordLessThanEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordLessThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordLessThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordLessThan %0, %1 : f32
       %5 = spirv.FUnordLessThan %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordLessThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FUnordNotEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   floating-point type.  They must have the same type, and they must have
   the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.FUnordNotEqual %0, %1 : f32
       %5 = spirv.FUnordNotEqual %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FUnordNotEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: FUnordNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FuncOp(function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares or defines a SPIR-V function using one region, which
   contains one or more blocks.

   Different from the SPIR-V binary format, this op is not allowed to
   implicitly capture global values, and all external references must use
   function arguments or symbol references. This op itself defines a symbol
   that is unique in the enclosing module op.

   This op itself takes no operands and generates no results. Its region
   can take zero or more arguments and return zero or one values.

   From ``SPV_KHR_physical_storage_buffer``:
   If a parameter of function is

   * a pointer (or contains a pointer) in the PhysicalStorageBuffer storage
   class, the function parameter must be decorated with exactly one of
   ``Aliased`` or ``Restrict``.
   * a pointer (or contains a pointer) and the type it points to is a pointer
   in the PhysicalStorageBuffer storage class, the function parameter must
   be decorated with exactly one of ``AliasedPointer`` or ``RestrictPointer``.

   .. code::

       spv-function-control ::= "None" | "Inline" | "DontInline" | ...
       spv-function-op ::= `spirv.func` function-signature
                            spv-function-control region

   Example:
   --------

   .. code:: mlir

       spirv.func @foo() -> () "None" { ... }
       spirv.func @bar() -> () "Inline|Pure" { ... }
       
       spirv.func @aliased_pointer(%arg0: !spirv.ptr<i32, PhysicalStorageBuffer>,
           { spirv.decoration = #spirv.decoration<Aliased> }) -> () "None" { ... }
       
       spirv.func @restrict_pointer(%arg0: !spirv.ptr<i32, PhysicalStorageBuffer>,
           { spirv.decoration = #spirv.decoration<Restrict> }) -> () "None" { ... }
       
       spirv.func @aliased_pointee(%arg0: !spirv.ptr<!spirv.ptr<i32,
           PhysicalStorageBuffer>, Generic> { spirv.decoration =
           #spirv.decoration<AliasedPointer> }) -> () "None" { ... }
       
       spirv.func @restrict_pointee(%arg0: !spirv.ptr<!spirv.ptr<i32,
           PhysicalStorageBuffer>, Generic> { spirv.decoration =
           #spirv.decoration<RestrictPointer> }) -> () "None" { ... }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.func'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: function_type() -> _ods_ir


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: function_control() -> _ods_ir


   .. py:method:: linkage_attributes() -> Optional[_ods_ir]


   .. py:method:: body() -> _ods_ir


.. py:function:: func(function_type, sym_name, function_control, *, arg_attrs=None, res_attrs=None, linkage_attributes=None, loc=None, ip=None) -> FuncOp

.. py:class:: FunctionCallOp(return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type is the type of the return value of the function. It must be
   the same as the Return Type operand of the Function Type operand of the
   Function operand.

   Function is an OpFunction instruction.  This could be a forward
   reference.

   Argument N is the object to copy to parameter N of Function.

   Note: A forward call is possible because there is no missing type
   information: Result Type must match the Return Type of the function, and
   the calling argument types must match the formal parameter types.

   Example:
   --------

   .. code:: mlir

       spirv.FunctionCall @f_void(%arg0) : (i32) ->  ()
       %0 = spirv.FunctionCall @f_iadd(%arg0, %arg1) : (i32, i32) -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.FunctionCall'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arguments() -> _ods_ir


   .. py:method:: callee() -> _ods_ir


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: return_value() -> Optional[_ods_ir]


.. py:function:: FunctionCall(return_value, callee, arguments, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, FunctionCallOp]

.. py:class:: GLAcosOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric arc cosine of x radians.

   Result is an angle, in radians, whose cosine is x. The range of result
   values is [0, π]. Result is undefined if abs x > 1.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Acos %0 : f32
       %3 = spirv.GL.Acos %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Acos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Acos(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLAcoshOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Arc hyperbolic cosine; result is the non-negative inverse of cosh. The resulting
   value is NaN if x < 1.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Acosh %0 : f32
       %3 = spirv.GL.Acosh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Acosh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Acosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLAsinOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric arc sine of x radians.

   Result is an angle, in radians, whose sine is x. The range of result values
   is [-π / 2, π / 2]. Result is undefined if abs x > 1.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Asin %0 : f32
       %3 = spirv.GL.Asin %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Asin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Asin(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLAsinhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Arc hyperbolic sine; result is the inverse of sinh.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Asinh %0 : f32
       %3 = spirv.GL.Asinh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Asinh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Asinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLAtanOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric arc tangent of x radians.

   Result is an angle, in radians, whose tangent is y_over_x. The range of
   result values is [-π / 2, π / 2].

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Atan %0 : f32
       %3 = spirv.GL.Atan %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Atan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Atan(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLAtanhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Arc hyperbolic tangent; result is the inverse of tanh. The resulting value
   is NaN if abs x ≥ 1.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Atanh %0 : f32
       %3 = spirv.GL.Atanh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Atanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Atanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLCeilOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the value equal to the nearest whole number that is greater than
   or equal to x.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Ceil %0 : f32
       %3 = spirv.GL.Ceil %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Ceil'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Ceil(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLCosOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric cosine of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Cos %0 : f32
       %3 = spirv.GL.Cos %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Cos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Cos(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLCoshOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Hyperbolic cosine of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Cosh %0 : f32
       %3 = spirv.GL.Cosh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Cosh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Cosh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLCrossOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the cross product of x and y, i.e., the resulting components are, in order:

   x[1] * y[2] - y[1] * x[2]

   x[2] * y[0] - y[2] * x[0]

   x[0] * y[1] - y[0] * x[1]

   All the operands must be vectors of 3 components of a floating-point type.

   Result Type and the type of all operands must be the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Cross %0, %1 : vector<3xf32>
       %3 = spirv.GL.Cross %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Cross'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Cross(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLDistanceOp(p0, p1, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the distance between p0 and p1, i.e., length(p0 - p1).

   The operands must all be a scalar or vector whose component type is floating-point.

   Result Type must be a scalar of the same type as the component type of the operands.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Distance %0, %1 : vector<3xf32>, vector<3xf32> -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Distance'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: p0() -> _ods_ir


   .. py:method:: p1() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Distance(p0, p1, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLExp2Op(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is 2 raised to the x power; 2**x.

   .. code::

       exp2(Inf) = Inf.
       exp2(-Inf) = +0.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Exp2 %0 : f32
       %3 = spirv.GL.Exp2 %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Exp2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Exp2(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLExpOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the natural exponentiation of x; e^x.

   The operand x must be a scalar or vector whose component type is
   16-bit or 32-bit floating-point.

   Result Type and the type of x must be the same type. Results are
   computed per component.";

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Exp %0 : f32
       %3 = spirv.GL.Exp %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Exp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Exp(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFAbsOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is x if x >= 0; otherwise result is -x.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FAbs %0 : f32
       %3 = spirv.GL.FAbs %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FAbs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FAbs(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFClampOp(result, x, y, z, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is min(max(x, minVal), maxVal). The resulting value is undefined if
   minVal > maxVal. The semantics used by min() and max() are those of FMin and
   FMax.

   The operands must all be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of all operands must be the same type. Results are
   computed per component.

   .. code::

       fclamp-op ::= ssa-id `=` `spirv.GL.FClamp` ssa-use, ssa-use, ssa-use `:`
                  float-scalar-vector-type

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FClamp %x, %min, %max : f32
       %3 = spirv.GL.FClamp %x, %min, %max : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FClamp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if x < y; otherwise result is x. Which operand is the
   result is undefined if one of the operands is a NaN.

   The operands must all be a scalar or vector whose component type
   is floating-point.

   Result Type and the type of all operands must be the same
   type. Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FMax %0, %1 : f32
       %3 = spirv.GL.FMax %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if y < x; otherwise result is x. Which operand is the result is
   undefined if one of the operands is a NaN.

   The operands must all be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of all operands must be the same type. Results are
   computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FMin %0, %1 : f32
       %3 = spirv.GL.FMin %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFMixOp(x, y, a, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the linear blend of x and y, i.e., x * (1 - a) + y * a.

   The operands must all be a scalar or vector whose component type is floating-point.

   Result Type and the type of all operands must be the same type. Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GL.FMix %x : f32, %y : f32, %a : f32 -> f32
       %0 = spirv.GL.FMix %x : vector<4xf32>, %y : vector<4xf32>, %a : vector<4xf32> -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FMix'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: a() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FMix(x, y, a, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFSignOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is 1.0 if x > 0, 0.0 if x = 0, or -1.0 if x < 0.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FSign %0 : f32
       %3 = spirv.GL.FSign %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FSign'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FSign(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFindILsbOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results in the bit number of the least-significant 1-bit in the binary
   representation of Value. If Value is 0, the result is -1.

   Result Type and the type of Value must both be integer scalar or
   integer vector types. Result Type and operand types must have the
   same number of components with the same component width. Results are
   computed per component.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FindILsb'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FindILsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFindSMsbOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   For positive numbers, the result will be the bit number of the most significant
   1-bit. For negative numbers, the result will be the bit number of the most
   significant 0-bit. For a Value of 0 or -1, the result is -1.

   Result Type and the type of Value must both be integer scalar or
   integer vector types. Result Type and operand types must have the
   same number of components with the same component width. Results are
   computed per component.

   This instruction is currently limited to 32-bit width components.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FindSMsb'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FindSMsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFindUMsbOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results in the bit number of the most-significant 1-bit in the binary
   representation of Value. If Value is 0, the result is -1.

   Result Type and the type of Value must both be integer scalar or
   integer vector types. Result Type and operand types must have the
   same number of components with the same component width. Results are
   computed per component.

   This instruction is currently limited to 32-bit width components.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FindUMsb'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FindUMsb(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFloorOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the value equal to the nearest whole number that is less than or
   equal to x.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Floor %0 : f32
       %3 = spirv.GL.Floor %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Floor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Floor(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFmaOp(result, x, y, z, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   In uses where this operation is decorated with NoContraction:

   * fma is considered a single operation, whereas the expression a * b + c
   is considered two operations.
   * The precision of fma can differ from the precision of the expression
   a * b + c.
   * fma will be computed with the same precision as any other fma decorated
   with NoContraction, giving invariant results for the same input values
   of a, b, and c.

   Otherwise, in the absence of a NoContraction decoration, there are no
   special constraints on the number of operations or difference in precision
   between fma and the expression a * b +c.

   The operands must all be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of all operands must be the same type. Results
   are computed per component.

   .. code::

       fma-op ::= ssa-id `=` `spirv.GL.Fma` ssa-use, ssa-use, ssa-use `:`
                  float-scalar-vector-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GL.Fma %a, %b, %c : f32
       %1 = spirv.GL.Fma %a, %b, %c : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Fma'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Fma(result, x, y, z, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFractOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is:

   .. code::

       fract(x) = x - floor(x)
       fract(±0) = +0
       fract(±Inf) = NaN

   The operand x must be a scalar or vector whose component type is floating-point.

   Result Type and the type of x must be the same type. Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %result = spirv.GL.Sqrt %x : f32
       %result = spirv.GL.Sqrt %x : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Fract'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Fract(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLFrexpStructOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is a structure containing x split into a floating-point significand
   in the range (-1.0, 0.5] or [0.5, 1.0) and an integral exponent of 2, such that:

   x = significand * 2^exponent

   If x is a zero, the exponent is 0.0. If x is an infinity or a NaN, the
   exponent is undefined. If x is 0.0, the significand is 0.0. If x is -0.0,
   the significand is -0.0

   Result Type must be an OpTypeStruct with two members. Member 0 must have
   the same type as the type of x. Member 0 holds the significand. Member 1
   must be a scalar or vector with integer component type, with 32-bit
   component width. Member 1 holds the exponent. These two members and x must
   have the same number of components.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.FrexpStruct %0 : f32 -> !spirv.struct<f32, i32>
       %3 = spirv.GL.FrexpStruct %0 : vector<3xf32> -> !spirv.struct<vector<3xf32>, vector<3xi32>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.FrexpStruct'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_FrexpStruct(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GLInverseSqrtOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the reciprocal of sqrt x. Result is undefined if x <= 0.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.InverseSqrt %0 : f32
       %3 = spirv.GL.InverseSqrt %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.InverseSqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_InverseSqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLLdexpOp(x, exp, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Builds a floating-point number from x and the corresponding
   integral exponent of two in exp:

   significand * 2^exponent

   If this product is too large to be represented in the floating-point
   type, the resulting value is undefined. If exp is greater than +128
   (single precision) or +1024 (double precision), the resulting value is
   undefined. If exp is less than -126 (single precision) or -1022 (double precision),
   the result may be flushed to zero. Additionally, splitting the value
   into a significand and exponent using frexp and then reconstructing a
   floating-point value using ldexp should yield the original input for
   zero and all finite non-denormalized values.

   The operand x must be a scalar or vector whose component type is floating-point.

   The exp operand must be a scalar or vector with integer component type.
   The number of components in x and exp must be the same.

   Result Type must be the same type as the type of x. Results are computed per
   component.

   Example:
   --------

   .. code:: mlir

       %y = spirv.GL.Ldexp %x : f32, %exp : i32 -> f32
       %y = spirv.GL.Ldexp %x : vector<3xf32>, %exp : vector<3xi32> -> vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Ldexp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: exp() -> _ods_ir


   .. py:method:: y() -> _ods_ir


.. py:function:: GL_Ldexp(x, exp, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLLengthOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the length of vector x, i.e., sqrt(x[0]**2 + x[1]**2 + ...).

   The operand x must be a scalar or vector whose component type is floating-point.

   Result Type must be a scalar of the same type as the component type of x.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Length %0 : vector<3xf32> -> f32
       %3 = spirv.GL.Length %1 : f32 -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Length'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Length(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLLog2Op(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the base-2 logarithm of x, i.e., the value y which satisfies the
   equation x = 2**y. The resulting value is NaN if x < 0. Moreover:

   .. code::

       log(Inf) = Inf
       log(1.0) = +0
       log(±0) = -Inf

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Log2 %0 : f32
       %3 = spirv.GL.Log2 %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Log2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Log2(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLLogOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the natural logarithm of x, i.e., the value y which satisfies the
   equation x = ey. Result is undefined if x <= 0.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Log %0 : f32
       %3 = spirv.GL.Log %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Log'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Log(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLNormalizeOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the vector in the same direction as x but with a length of 1.

   The operand x must be a scalar or vector whose component type is floating-point.

   Result Type and the type of x must be the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Normalize %0 : vector<3xf32>
       %3 = spirv.GL.Normalize %1 : vector<4xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Normalize'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Normalize(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLPackHalf2x16Op(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the unsigned integer obtained by converting the components of a
   two-component floating-point vector to the 16-bit OpTypeFloat, and then packing
   these two 16-bit integers into a 32-bit unsigned integer. The first vector
   component specifies the 16 least-significant bits of the result; the second
   component specifies the 16 most-significant bits.

   The RelaxedPrecision Decoration only affects the conversion step of the instruction.

   The v operand must be a vector of 2 components whose type is a 32-bit floating-point.

   Result Type must be a 32-bit integer type.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.GL.PackHalf2x16 %0 : vector<2xf32> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.PackHalf2x16'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_PackHalf2x16(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLPowOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is x raised to the y power; x^y.

   Result is undefined if x = 0 and y ≤ 0.

   The operand x and y must be a scalar or vector whose component type is
   16-bit or 32-bit floating-point.

   Result Type and the type of all operands must be the same type. Results are
   computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Pow %0, %1 : f32
       %3 = spirv.GL.Pow %0, %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Pow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Pow(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLReflectOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   For the incident vector I and surface orientation N, the result is the reflection direction:

   I - 2 * dot(N, I) * N

   N must already be normalized in order to achieve the desired result.

   The operands must all be a scalar or vector whose component type is floating-point.

   Result Type and the type of all operands must be the same type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Reflect %0, %1 : f32
       %3 = spirv.GL.Reflect %0, %1 : vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Reflect'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Reflect(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLRoundEvenOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the value equal to the nearest whole number to x. A fractional
   part of 0.5 will round toward the nearest even whole number. (Both 3.5 and
   4.5 for x will be 4.0.)

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.RoundEven %0 : f32
       %3 = spirv.GL.RoundEven %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.RoundEven'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_RoundEven(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLRoundOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the value equal to the nearest whole number to x. The fraction
   0.5 will round in a direction chosen by the implementation, presumably
   the direction that is fastest. This includes the possibility that
   Round x is the same value as RoundEven x for all values of x.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Round %0 : f32
       %3 = spirv.GL.Round %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Round'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Round(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSAbsOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is x if x ≥ 0; otherwise result is -x, where x is interpreted as a
   signed integer.

   Result Type and the type of x must both be integer scalar or integer vector
   types. Result Type and operand types must have the same number of components
   with the same component width. Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.SAbs %0 : i32
       %3 = spirv.GL.SAbs %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.SAbs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_SAbs(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSClampOp(result, x, y, z, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
   interpreted as signed integers. The resulting value is undefined if
   minVal > maxVal.

   Result Type and the type of the operands must both be integer scalar or
   integer vector types. Result Type and operand types must have the same number
   of components with the same component width. Results are computed per
   component.

   .. code::

       uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
                  sgined-scalar-vector-type

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.SClamp %x, %min, %max : si32
       %3 = spirv.GL.SClamp %x, %min, %max : vector<3xsi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.SClamp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_SClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if x < y; otherwise result is x, where x and y are interpreted
   as signed integers.

   Result Type and the type of x and y must both be integer scalar or integer
   vector types. Result Type and operand types must have the same number of
   components with the same component width. Results are computed per
   component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.SMax %0, %1 : i32
       %3 = spirv.GL.SMax %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.SMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_SMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if y < x; otherwise result is x, where x and y are interpreted
   as signed integers.

   Result Type and the type of x and y must both be integer scalar or integer
   vector types. Result Type and operand types must have the same number of
   components with the same component width. Results are computed per
   component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.SMin %0, %1 : i32
       %3 = spirv.GL.SMin %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.SMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_SMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSSignOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is 1 if x > 0, 0 if x = 0, or -1 if x < 0, where x is interpreted as
   a signed integer.

   Result Type and the type of x must both be integer scalar or integer vector
   types. Result Type and operand types must have the same number of components
   with the same component width. Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.SSign %0 : i32
       %3 = spirv.GL.SSign %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.SSign'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_SSign(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSinOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric sine of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Sin %0 : f32
       %3 = spirv.GL.Sin %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Sin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Sin(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSinhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Hyperbolic sine of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Sinh %0 : f32
       %3 = spirv.GL.Sinh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Sinh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Sinh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLSqrtOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the square root of x. Result is undefined if x < 0.

   The operand x must be a scalar or vector whose component type is
   floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Sqrt %0 : f32
       %3 = spirv.GL.Sqrt %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Sqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Sqrt(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLTanOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The standard trigonometric tangent of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Tan %0 : f32
       %3 = spirv.GL.Tan %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Tan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Tan(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLTanhOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Hyperbolic tangent of x radians.

   The operand x must be a scalar or vector whose component type is 16-bit or
   32-bit floating-point.

   Result Type and the type of x must be the same type. Results are computed
   per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.Tanh %0 : f32
       %3 = spirv.GL.Tanh %1 : vector<3xf16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.Tanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_Tanh(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLUClampOp(result, x, y, z, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is min(max(x, minVal), maxVal), where x, minVal and maxVal are
   interpreted as unsigned integers. The resulting value is undefined if
   minVal > maxVal.

   Result Type and the type of the operands must both be integer scalar or
   integer vector types. Result Type and operand types must have the same number
   of components with the same component width. Results are computed per
   component.

   .. code::

       uclamp-op ::= ssa-id `=` `spirv.GL.UClamp` ssa-use, ssa-use, ssa-use `:`
                  unsigned-signless-scalar-vector-type

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.UClamp %x, %min, %max : i32
       %3 = spirv.GL.UClamp %x, %min, %max : vector<3xui16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.UClamp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: y() -> _ods_ir


   .. py:method:: z() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_UClamp(result, x, y, z, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GLUMaxOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if x < y; otherwise result is x, where x and y are interpreted
   as unsigned integers.

   Result Type and the type of x and y must both be integer scalar or integer
   vector types. Result Type and operand types must have the same number of
   components with the same component width. Results are computed per
   component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.UMax %0, %1 : i32
       %3 = spirv.GL.UMax %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.UMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_UMax(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLUMinOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is y if y < x; otherwise result is x, where x and y are interpreted
   as unsigned integers.

   Result Type and the type of x and y must both be integer scalar or integer
   vector types. Result Type and operand types must have the same number of
   components with the same component width. Results are computed per
   component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.GL.UMin %0, %1 : i32
       %3 = spirv.GL.UMin %0, %1 : vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.UMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_UMin(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GLUnpackHalf2x16Op(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result is the two-component floating-point vector with components obtained by
   unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting
   those values as 16-bit floating-point numbers according to the OpenGL
   Specification, and converting them to 32-bit floating-point values. Subnormal
   numbers are either preserved or flushed to zero, consistently within an
   implementation.

   The first component of the vector is obtained from the 16 least-significant bits
   of v; the second component is obtained from the 16 most-significant bits of v.

   The RelaxedPrecision Decoration only affects the conversion step of the instruction.

   The v operand must be a scalar with 32-bit integer type.

   Result Type must be a vector of 2 components whose type is 32-bit floating point.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.GL.UnpackHalf2x16 %0 : i32 -> vector<2xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GL.UnpackHalf2x16'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GL_UnpackHalf2x16(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GenericCastToPtrExplicitOp(result, pointer, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer. Its Storage Class must be Storage.

   Pointer must have a type of OpTypePointer whose Type is the same as the
   Type of Result Type.Pointer must point to the Generic Storage Class. If
   the cast fails, the instruction result is an OpConstantNull pointer in
   the Storage Storage Class.

   Storage must be one of the following literal values from Storage Class:
   Workgroup, CrossWorkgroup, or Function.

   Example:
   --------

   .. code:: mlir

          %1 = spirv.GenericCastToPtrExplicitOp %0 : !spirv.ptr<f32, Generic> to
          !spirv.ptr<f32, CrossWorkGroup>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GenericCastToPtrExplicit'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GenericCastToPtrExplicit(result, pointer, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GenericCastToPtrOp(result, pointer, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer. Its Storage Class must be
   Workgroup, CrossWorkgroup, or Function.

   Pointer must point to the Generic Storage Class.

   Result Type and Pointer must point to the same type.

   Example:
   --------

   .. code:: mlir

          %1 = spirv.GenericCastToPtrOp %0 : !spirv.ptr<f32, Generic> to
          !spirv.ptr<f32, CrossWorkGroup>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GenericCastToPtr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GenericCastToPtr(result, pointer, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GlobalVariableOp(type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, built_in=None, linkage_attributes=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The variable type must be an OpTypePointer. Its type operand is the type of
   object in memory.

   Storage Class is the Storage Class of the memory holding the object. It
   cannot be Generic. It must be the same as the Storage Class operand of
   the variable types. Only those storage classes that are valid at module
   scope (like Input, Output, StorageBuffer, etc.) are valid.

   Initializer is optional.  If Initializer is present, it will be
   the initial value of the variable’s memory content. Initializer
   must be an symbol defined from a constant instruction or other
   ``spirv.GlobalVariable`` operation in module scope. Initializer must
   have the same type as the type of the defined symbol.

   .. code::

       variable-op ::= `spirv.GlobalVariable` spirv-type symbol-ref-id
                       (`initializer(` symbol-ref-id `)`)?
                       (`bind(` integer-literal, integer-literal `)`)?
                       (`built_in(` string-literal `)`)?
                       attribute-dict?

   where ``initializer`` specifies initializer and ``bind`` specifies the
   descriptor set and binding number. ``built_in`` specifies SPIR-V
   BuiltIn decoration associated with the op.

   Example:
   --------

   .. code:: mlir

       spirv.GlobalVariable @var0 : !spirv.ptr<f32, Input> @var0
       spirv.GlobalVariable @var1 initializer(@var0) : !spirv.ptr<f32, Output>
       spirv.GlobalVariable @var2 bind(1, 2) : !spirv.ptr<f32, Uniform>
       spirv.GlobalVariable @var3 built_in("GlobalInvocationId") : !spirv.ptr<vector<3xi32>, Input>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GlobalVariable'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: type_() -> _ods_ir


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: initializer() -> Optional[_ods_ir]


   .. py:method:: location() -> Optional[_ods_ir]

      
      Returns the source location the operation was defined or derived from.



   .. py:method:: binding() -> Optional[_ods_ir]


   .. py:method:: descriptor_set() -> Optional[_ods_ir]


   .. py:method:: built_in() -> Optional[_ods_ir]


   .. py:method:: linkage_attributes() -> Optional[_ods_ir]


.. py:function:: GlobalVariable(type_, sym_name, *, initializer=None, location=None, binding=None, descriptor_set=None, built_in=None, linkage_attributes=None, loc=None, ip=None) -> GlobalVariableOp

.. py:class:: GraphARMOp(function_type, sym_name, *, arg_attrs=None, res_attrs=None, entry_point=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares or defines a SPIR-V graph using one region, which
   contains one or more blocks.

   This op is not allowed to implicitly capture global values, and all external
   references must use function arguments or symbol references. This op itself
   defines a symbol that is unique in the enclosing module op.

   Note that this op does not have a 1:1 mapping to the SPIR-V ops representing
   a graph. Indeed during serialization a single GraphARMOp is serialized into
   several different SPIR-V ops: OpGraphARM, OpGraphInputARM and OpGraphEndARM.
   There are as many occurences of OpGraphInputARM ops as many inputs in the
   graph. Deserialization maps that set of operations into a single GraphARMOp.

   This op itself takes no operands and generates no results. Its region
   can take zero or more arguments and return one or more values.

   .. code::

       spv-graph-arm-op ::= `spirv.ARM.Graph` function-signature
                           region

   Example:
   --------

   .. code:: mlir

       spirv.ARM.Graph @graph(%arg0: !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
           spirv.ARM.GraphOutputs %arg0 : !spirv.arm.tensor<14x19xi16>
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ARM.Graph'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: function_type() -> _ods_ir


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: entry_point() -> Optional[_ods_ir]


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: body() -> _ods_ir


.. py:function:: ARM_Graph(function_type, sym_name, *, arg_attrs=None, res_attrs=None, entry_point=None, loc=None, ip=None) -> GraphARMOp

.. py:class:: GraphConstantARMOp(output, graph_constant_id, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Declare a graph constant.
   Result Type must be an OpTypeTensorARM.
   GraphConstantID must be a 32-bit integer literal.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.ARM.GraphConstant { graph_constant_id = 42 : i32 } : !spirv.arm.tensor<2x3xi16>

   GraphConstantID is a unique identifier which is use to map the contants
   defined by GraphConstantARM in the SPIRV module with the one provided at
   shader creation time via the VkDataGraphPipelineShaderModuleCreateInfoARM.
   That Vulkan structure provides a list of VkDataGraphPipelineConstantARM
   which contains the bindings from id to data. (For more details see
   https://registry.khronos.org/vulkan/specs/latest/html/vkspec.html#graphs)


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ARM.GraphConstant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: graph_constant_id() -> _ods_ir


   .. py:method:: output() -> _ods_ir


.. py:function:: ARM_GraphConstant(output, graph_constant_id, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GraphEntryPointARMOp(fn, interface, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Graph Entry Point must be the Result  of an OpGraphARM instruction.

   Name is a name string for the graphentry point. A module cannot have two
   OpGraphEntryPointARM instructions with the same Name string.

   Interface is a list of symbol references to ``spirv.GlobalVariable``
   operations. These declare the set of global variables from a
   module that form the interface of this entry point. The set of
   Interface symbols must be equal to or a superset of the
   ``spirv.GlobalVariable``s referenced by the entry point’s static call
   tree, within the interface’s storage classes.

   Example:
   --------

   .. code:: mlir

       spirv.GlobalVariable @arg_0 bind(0, 0) : !spirv.ptr<!spirv.arm.tensor<14x19xi16>, UniformConstant>
       spirv.GlobalVariable @res_0 bind(0, 1) : !spirv.ptr<!spirv.arm.tensor<14x19xi16>, UniformConstant>
       spirv.ARM.GraphEntryPoint @graph, @arg_0, @res_0
       spirv.ARM.Graph @graph(%arg0 : !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
           ...
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ARM.GraphEntryPoint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: fn() -> _ods_ir


   .. py:method:: interface() -> _ods_ir


.. py:function:: ARM_GraphEntryPoint(fn, interface, *, loc=None, ip=None) -> GraphEntryPointARMOp

.. py:class:: GraphOutputsARMOp(value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Values are the graph outputs values and must match the GraphOutputs Type
   operand of the OpTypeGraphARM type of the OpGraphARM body this
   instruction is in.

   This instruction must be the last instruction in a block.

   Example:
   --------

   .. code:: mlir

       spirv.ARM.Graph @graph(%arg0 : !spirv.arm.tensor<14x19xi16>) -> !spirv.arm.tensor<14x19xi16> {
           spirv.ARM.GraphOutputs %arg0 : !spirv.arm.tensor<14x19xi16>
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ARM.GraphOutputs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


.. py:function:: ARM_GraphOutputs(value, *, loc=None, ip=None) -> GraphOutputsARMOp

.. py:class:: GroupBroadcastOp(execution_scope, value, localid, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   All invocations of this module within Execution must reach this point of
   execution.

   Behavior is undefined if this instruction is used in control flow that
   is non-uniform within Execution.

   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution must be Workgroup or Subgroup Scope.

   The type of Value must be the same as Result Type.

   LocalId must be an integer datatype. It can be a scalar, or a vector
   with 2 components or a vector with 3 components. LocalId must be the
   same for all invocations in the group.

   Example:
   --------

   .. code:: mlir

       %scalar_value = ... : f32
       %vector_value = ... : vector<4xf32>
       %scalar_localid = ... : i32
       %vector_localid = ... : vector<3xi32>
       %0 = spirv.GroupBroadcast "Subgroup" %scalar_value, %scalar_localid : f32, i32
       %1 = spirv.GroupBroadcast "Workgroup" %vector_value, %vector_localid :
         vector<4xf32>, vector<3xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupBroadcast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: localid() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupBroadcast(execution_scope, value, localid, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupFAddOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of floating-point type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupFAdd <Workgroup> <Reduce> %value : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupFAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupFAdd(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupFMaxOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of floating-point type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is -INF.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupFMax <Workgroup> <Reduce> %value : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupFMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupFMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupFMinOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of floating-point type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is +INF.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupFMin <Workgroup> <Reduce> %value : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupFMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupFMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupFMulKHROp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   'Execution' reach this point of execution.

   Behavior is undefined unless all invocations within 'Execution' execute the
   same dynamic instance of this instruction.

   'Result Type' must be a scalar or vector of floating-point type.

   'Execution' is a Scope. It must be either Workgroup or Subgroup.

   The identity I for 'Operation' is 1.

   The type of 'X' must be the same as 'Result Type'.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.KHR.GroupFMul <Workgroup> <Reduce> %value : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.GroupFMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_GroupFMul(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupIAddOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupIAdd <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupIAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupIAdd(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupIMulKHROp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   'Execution' reach this point of execution.

   Behavior is undefined unless all invocations within 'Execution' execute the
   same dynamic instance of this instruction.

   'Result Type' must be a scalar or vector of integer type.

   'Execution' is a Scope. It must be either Workgroup or Subgroup.

   The identity I for 'Operation' is 1.

   The type of 'X' must be the same as 'Result Type'.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.KHR.GroupIMul <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.GroupIMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_GroupIMul(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformAllEqualOp(execution_scope, value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a Boolean type.

   Execution is the scope defining the scope restricted tangle affected by
   this command. It must be Subgroup.

   Value must be a scalar or vector of floating-point type, integer type,
   or Boolean type. The compare operation is based on this type, and if it
   is a floating-point type, an ordered-and-equal compare is used.

   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its scope restricted tangle have executed
   all dynamic instances that are program-ordered before X'.

   Example:
   --------

   .. code:: mlir

       %scalar_value = ... : f32
       %vector_value = ... : vector<4xf32>
       %0 = spirv.GroupNonUniformAllEqual <Subgroup> %scalar_value : f32, i1
       %1 = spirv.GroupNonUniformAllEqual <Subgroup> %vector_value : vector<4xf32>, i1


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformAllEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformAllEqual(execution_scope, value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformAllOp(execution_scope, predicate, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a Boolean type.

   Execution is the scope defining the scope restricted tangle affected by
   this command. It must be Subgroup.

   Predicate must be a Boolean type.

   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its scope restricted tangle have executed
   all dynamic instances that are program-ordered before X'.

   Example:
   --------

   .. code:: mlir

       %predicate = ... : i1
       %0 = spirv.GroupNonUniformAll "Subgroup" %predicate : i1


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformAll'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: predicate() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformAll(execution_scope, predicate, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformAnyOp(execution_scope, predicate, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a Boolean type.

   Execution is the scope defining the scope restricted tangle affected by
   this command. It must be Subgroup.

   Predicate must be a Boolean type.

   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its scope restricted tangle have executed
   all dynamic instances that are program-ordered before X'.

   Example:
   --------

   .. code:: mlir

       %predicate = ... : i1
       %0 = spirv.GroupNonUniformAny "Subgroup" %predicate : i1


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformAny'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: predicate() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformAny(execution_scope, predicate, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBallotBitCountOp(result, execution_scope, group_operation, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar of integer type, whose Signedness operand
   is 0.

   Execution is the scope defining the scope restricted tangle affected by
   this command. It must be Subgroup.

   The identity I for Operation is 0.

   Value must be a vector of four components of integer type scalar, whose
   Width operand is 32 and whose Signedness operand is 0.

   Value is a set of bitfields where the first invocation is represented in
   the lowest bit of the first vector component and the last (up to the
   size of the scope) is the higher bit number of the last bitmask needed
   to represent all bits of the invocations in the scope restricted tangle.

   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its scope restricted tangle have executed
   all dynamic instances that are program-ordered before X'.

   Example:
   --------

   .. code:: mlir

       %count = spirv.GroupNonUniformBallotBitCount <Subgroup> <Reduce> %val : vector<4xi32> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBallotBitCount'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBallotBitCount(result, execution_scope, group_operation, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBallotFindLSBOp(result, execution_scope, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar of integer type, whose Signedness operand
   is 0.

   Execution is a Scope that identifies the group of invocations affected
   by this command. It must be Subgroup.

   Value must be a vector of four components of integer type scalar, whose
   Width operand is 32 and whose Signedness operand is 0.

   Value is a set of bitfields where the first invocation is represented in
   the lowest bit of the first vector component and the last (up to the
   size of the group) is the higher bit number of the last bitmask needed
   to represent all bits of the group invocations.

   Example:
   --------

   .. code:: mlir

       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformBallotFindLSB <Subgroup> %vector : vector<4xi32>, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBallotFindLSB'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBallotFindLSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBallotFindMSBOp(result, execution_scope, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar of integer type, whose Signedness operand
   is 0.

   Execution is a Scope that identifies the group of invocations affected
   by this command. It must be Subgroup.

   Value must be a vector of four components of integer type scalar, whose
   Width operand is 32 and whose Signedness operand is 0.

   Value is a set of bitfields where the first invocation is represented in
   the lowest bit of the first vector component and the last (up to the
   size of the group) is the higher bit number of the last bitmask needed
   to represent all bits of the group invocations.

   Example:
   --------

   .. code:: mlir

       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformBallotFindMSB <Subgroup> %vector : vector<4xi32>, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBallotFindMSB'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBallotFindMSB(result, execution_scope, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBallotOp(result, execution_scope, predicate, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a vector of four components of integer type scalar,
   whose Signedness operand is 0.

   Result is a set of bitfields where the first invocation is represented
   in the lowest bit of the first vector component and the last (up to the
   size of the group) is the higher bit number of the last bitmask needed
   to represent all bits of the group invocations.

   Execution must be Workgroup or Subgroup Scope.

   Predicate must be a Boolean type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformBallot <Subgroup> %predicate : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBallot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: predicate() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBallot(result, execution_scope, predicate, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBitwiseAndOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is ~0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformBitwiseAnd <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformBitwiseAnd <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBitwiseAnd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBitwiseAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBitwiseOrOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformBitwiseOr <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformBitwiseOr <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBitwiseOr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBitwiseOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBitwiseXorOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformBitwiseXor <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformBitwiseXor <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBitwiseXor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBitwiseXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformBroadcastOp(execution_scope, value, id, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution must be Workgroup or Subgroup Scope.

   The type of Value must be the same as Result Type.

   Id  must be a scalar of integer type, whose Signedness operand is 0.

   Before version 1.5, Id must come from a constant instruction. Starting
   with version 1.5, Id must be dynamically uniform.

   The resulting value is undefined if Id is an inactive invocation, or is
   greater than or equal to the size of the group.

   Example:
   --------

   .. code:: mlir

       %scalar_value = ... : f32
       %vector_value = ... : vector<4xf32>
       %id = ... : i32
       %0 = spirv.GroupNonUniformBroadcast "Subgroup" %scalar_value, %id : f32, i32
       %1 = spirv.GroupNonUniformBroadcast "Workgroup" %vector_value, %id :
         vector<4xf32>, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformBroadcast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: id() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformBroadcast(execution_scope, value, id, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformElectOp(execution_scope, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a Boolean type.

   Execution must be Workgroup or Subgroup Scope.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformElect : i1


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformElect'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformElect(execution_scope, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformFAddOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.  The method used to
   perform the group operation on the contributed Value(s) from active
   invocations is implementation defined.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : f32
       %vector = ... : vector<4xf32>
       %0 = spirv.GroupNonUniformFAdd <Workgroup> <Reduce> %scalar : f32 -> f32
       %1 = spirv.GroupNonUniformFAdd <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformFAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformFAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformFMaxOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is -INF. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.  The method used to
   perform the group operation on the contributed Value(s) from active
   invocations is implementation defined. From the set of Value(s) provided
   by active invocations within a subgroup, if for any two Values one of
   them is a NaN, the other is chosen. If all Value(s) that are used by the
   current invocation are NaN, then the result is an undefined value.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : f32
       %vector = ... : vector<4xf32>
       %0 = spirv.GroupNonUniformFMax <Workgroup> <Reduce> %scalar : f32 -> f32
       %1 = spirv.GroupNonUniformFMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformFMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformFMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformFMinOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is +INF. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.  The method used to
   perform the group operation on the contributed Value(s) from active
   invocations is implementation defined. From the set of Value(s) provided
   by active invocations within a subgroup, if for any two Values one of
   them is a NaN, the other is chosen. If all Value(s) that are used by the
   current invocation are NaN, then the result is an undefined value.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : f32
       %vector = ... : vector<4xf32>
       %0 = spirv.GroupNonUniformFMin <Workgroup> <Reduce> %scalar : f32 -> i32
       %1 = spirv.GroupNonUniformFMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformFMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformFMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformFMulOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is 1. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.  The method used to
   perform the group operation on the contributed Value(s) from active
   invocations is implementation defined.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : f32
       %vector = ... : vector<4xf32>
       %0 = spirv.GroupNonUniformFMul <Workgroup> <Reduce> %scalar : f32 -> f32
       %1 = spirv.GroupNonUniformFMul <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xf32>, i32 -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformFMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformFMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformIAddOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformIAdd <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformIAdd <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformIAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformIAdd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformIMulOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is 1. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformIMul <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformIMul <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformIMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformIMul(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformLogicalAndOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is ~0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i1
       %vector = ... : vector<4xi1>
       %0 = spirv.GroupNonUniformLogicalAnd <Workgroup> <Reduce> %scalar : i1 -> i1
       %1 = spirv.GroupNonUniformLogicalAnd <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformLogicalAnd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformLogicalAnd(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformLogicalOrOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i1
       %vector = ... : vector<4xi1>
       %0 = spirv.GroupNonUniformLogicalOr <Workgroup> <Reduce> %scalar : i1 -> i1
       %1 = spirv.GroupNonUniformLogicalOr <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformLogicalOr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformLogicalOr(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformLogicalXorOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be present.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i1
       %vector = ... : vector<4xi1>
       %0 = spirv.GroupNonUniformLogicalXor <Workgroup> <Reduce> %scalar : i1 -> i1
       %1 = spirv.GroupNonUniformLogicalXor <Subgroup> <ClusteredReduce>
              %vector cluster_size(%four) : vector<4xi1>, i32 -> vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformLogicalXor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformLogicalXor(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformRotateKHROp(execution_scope, value, delta, *, cluster_size=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Return the Value of the invocation whose id within the group is calculated
   as follows:

   LocalId = SubgroupLocalInvocationId if Execution is Subgroup or
   LocalInvocationId if Execution is Workgroup
   RotationGroupSize = ClusterSize when ClusterSize is present, otherwise
   RotationGroupSize = SubgroupMaxSize if the Kernel capability is declared
   and SubgroupSize if not.
   Invocation ID = ( (LocalId + Delta) & (RotationGroupSize - 1) ) +
   (LocalId & ~(RotationGroupSize - 1))

   Result Type must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The type of Value must be the same as Result Type.

   Delta must be a scalar of integer type, whose Signedness operand is 0.
   Delta must be dynamically uniform within Execution.

   Delta is treated as unsigned and the resulting value is undefined if the
   selected lane is inactive.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar of
   integer type, whose Signedness operand is 0. ClusterSize must come from a
   constant instruction. Behavior is undefined unless ClusterSize is at least
   1 and a power of 2. If ClusterSize is greater than the declared
   SubGroupSize, executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %0 = spirv.GroupNonUniformRotateKHR <Subgroup> %value, %delta : f32, i32 -> f32
       %1 = spirv.GroupNonUniformRotateKHR <Workgroup> %value, %delta,
            clustersize(%four) : f32, i32, i32 -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformRotateKHR'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: delta() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformRotateKHR(execution_scope, value, delta, *, cluster_size=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformSMaxOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is INT_MIN. If Operation is
   ClusteredReduce, ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformSMax <Workgroup> <Reduce> %scalar : i32
       %1 = spirv.GroupNonUniformSMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformSMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformSMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformSMinOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is INT_MAX. If Operation is
   ClusteredReduce, ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformSMin <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformSMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformSMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformSMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformShuffleDownOp(execution_scope, value, delta, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The type of Value must be the same as Result Type.

   Delta  must be a scalar of integer type, whose Signedness operand is 0.

   Delta is treated as unsigned and the resulting value is undefined if
   Delta is greater than or equal to the size of the group, or if the
   current invocation’s id within the group + Delta is either an inactive
   invocation or greater than or equal to the size of the group.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformShuffleDown <Subgroup> %val, %delta : f32, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformShuffleDown'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: delta() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformShuffleDown(execution_scope, value, delta, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformShuffleOp(execution_scope, value, id, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The type of Value must be the same as Result Type.

   Id  must be a scalar of integer type, whose Signedness operand is 0.

   The resulting value is undefined if Id is an inactive invocation, or is
   greater than or equal to the size of the group.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformShuffle <Subgroup> %val, %id : f32, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformShuffle'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: id() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformShuffle(execution_scope, value, id, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformShuffleUpOp(execution_scope, value, delta, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The type of Value must be the same as Result Type.

   Delta  must be a scalar of integer type, whose Signedness operand is 0.

   Delta is treated as unsigned and the resulting value is undefined if
   Delta is greater than the current invocation’s id within the group or if
   the selected lane is inactive.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformShuffleUp <Subgroup> %val, %delta : f32, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformShuffleUp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: delta() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformShuffleUp(execution_scope, value, delta, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformShuffleXorOp(execution_scope, value, mask, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of floating-point type, integer
   type, or Boolean type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The type of Value must be the same as Result Type.

   Mask  must be a scalar of integer type, whose Signedness operand is 0.

   The resulting value is undefined if current invocation’s id within the
   group xor’ed with Mask is an inactive invocation, or is greater than or
   equal to the size of the group.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupNonUniformShuffleXor <Subgroup> %val, %mask : f32, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformShuffleXor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformShuffleXor(execution_scope, value, mask, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformUMaxOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type, whose
   Signedness operand is 0.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is 0. If Operation is ClusteredReduce,
   ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformUMax <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformUMax <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformUMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformUMax(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupNonUniformUMinOp(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type  must be a scalar or vector of integer type, whose
   Signedness operand is 0.

   Execution must be Workgroup or Subgroup Scope.

   The identity I for Operation is UINT_MAX. If Operation is
   ClusteredReduce, ClusterSize must be specified.

   The type of Value must be the same as Result Type.

   ClusterSize is the size of cluster to use. ClusterSize must be a scalar
   of integer type, whose Signedness operand is 0. ClusterSize must come
   from a constant instruction. ClusterSize must be at least 1, and must be
   a power of 2. If ClusterSize is greater than the declared SubGroupSize,
   executing this instruction results in undefined behavior.

   Example:
   --------

   .. code:: mlir

       %four = spirv.Constant 4 : i32
       %scalar = ... : i32
       %vector = ... : vector<4xi32>
       %0 = spirv.GroupNonUniformUMin <Workgroup> <Reduce> %scalar : i32 -> i32
       %1 = spirv.GroupNonUniformUMin <Subgroup> <ClusteredReduce> %vector cluster_size(%four) : vector<4xi32>, i32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupNonUniformUMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: cluster_size() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupNonUniformUMin(result, execution_scope, group_operation, value, *, cluster_size=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupSMaxOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is INT_MIN when X is 32 bits wide and
   LONG_MIN when X is 64 bits wide.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupSMax <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupSMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupSMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupSMinOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is INT_MAX when X is 32 bits wide and
   LONG_MAX when X is 64 bits wide.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupSMin <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupSMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupSMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupUMaxOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is 0.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupUMax <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupUMax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupUMax(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GroupUMinOp(execution_scope, group_operation, x, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Behavior is undefined if not all invocations of this module within
   Execution reach this point of execution.

   Behavior is undefined unless all invocations within Execution execute
   the same dynamic instance of this instruction.

   Result Type  must be a scalar or vector of integer type.

   Execution is a Scope. It must be either Workgroup or Subgroup.

   The identity I for Operation is UINT_MAX when X is 32 bits wide and
   ULONG_MAX when X is 64 bits wide.

   The type of X must be the same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.GroupUMin <Workgroup> <Reduce> %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.GroupUMin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: x() -> _ods_ir


   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: group_operation() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: GroupUMin(execution_scope, group_operation, x, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IAddCarryOp(result, operand1, operand2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be from OpTypeStruct.  The struct must have two
   members, and the two members must be the same type.  The member type
   must be a scalar or vector of integer type, whose Signedness operand is
   0.

   Operand 1 and Operand 2 must have the same type as the members of Result
   Type. These are consumed as unsigned integers.

   Results are computed per component.

   Member 0 of the result gets the low-order bits (full component width) of
   the addition.

   Member 1 of the result gets the high-order (carry) bit of the result of
   the addition. That is, it gets the value 1 if the addition overflowed
   the component width, and 0 otherwise.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.IAddCarry %0, %1 : !spirv.struct<(i32, i32)>
       %2 = spirv.IAddCarry %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IAddCarry'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IAddCarry(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: IAddOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   The resulting value will equal the low-order N bits of the correct
   result R, where N is the component width and R is computed with enough
   precision to avoid overflow and underflow.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.IAdd %0, %1 : i32
       %5 = spirv.IAdd %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IAdd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.IEqual %0, %1 : i32
       %5 = spirv.IEqual %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IMulOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   The resulting value will equal the low-order N bits of the correct
   result R, where N is the component width and R is computed with enough
   precision to avoid overflow and underflow.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.IMul %0, %1 : i32
       %5 = spirv.IMul %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IMul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IMul(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: INTELControlBarrierArriveOp(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Indicates that an invocation has arrived at a split control barrier. This
   may allow other invocations waiting on the split control barrier to continue
   executing.

   When ``Execution`` is ``Workgroup`` or larger, behavior is undefined unless all
   invocations within ``Execution`` execute the same dynamic instance of this
   instruction. When ``Execution`` is ``Subgroup`` or ``Invocation``, the behavior of
   this instruction in non-uniform control flow is defined by the client API.

   If ``Semantics`` is not ``None``, this instruction also serves as the start of a
   memory barrier similar to an ``OpMemoryBarrier`` instruction with the same
   ``Memory`` and ``Semantics`` operands. This allows atomically specifying both a
   control barrier and a memory barrier (that is, without needing two
   instructions). If ``Semantics`` is ``None``, ``Memory`` is ignored.

   Example:
   --------

   .. code:: mlir

       spirv.ControlBarrierArrive <Workgroup> <Device> <Acquire|UniformMemory>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.ControlBarrierArrive'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: memory_semantics() -> _ods_ir


.. py:function:: INTEL_ControlBarrierArrive(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> INTELControlBarrierArriveOp

.. py:class:: INTELControlBarrierWaitOp(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Waits for other invocations of this module to arrive at a split control
   barrier.

   When ``Execution`` is ``Workgroup`` or larger, behavior is undefined unless all
   invocations within ``Execution`` execute the same dynamic instance of this
   instruction. When ``Execution`` is ``Subgroup`` or ``Invocation``, the behavior of
   this instruction in non-uniform control flow is defined by the client API.

   If ``Semantics`` is not ``None``, this instruction also serves as the end of a
   memory barrier similar to an ``OpMemoryBarrier`` instruction with the same
   ``Memory`` and ``Semantics`` operands. This ensures that memory accesses issued
   before arriving at the split barrier are observed before memory accesses
   issued after this instruction. This control is ensured only for memory
   accesses issued by this invocation and observed by another invocation
   executing within ``Memory`` scope. This allows atomically specifying both a
   control barrier and a memory barrier (that is, without needing two
   instructions). If ``Semantics`` is ``None``, ``Memory`` is ignored.

   Example:
   --------

   .. code:: mlir

       spirv.ControlBarrierWait <Workgroup> <Device> <Acquire|UniformMemory>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.ControlBarrierWait'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: execution_scope() -> _ods_ir


   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: memory_semantics() -> _ods_ir


.. py:function:: INTEL_ControlBarrierWait(execution_scope, memory_scope, memory_semantics, *, loc=None, ip=None) -> INTELControlBarrierWaitOp

.. py:class:: INTELConvertBF16ToFOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Interpret a 16-bit integer as bfloat16 and convert the value numerically to 32-bit floating point type.

   Result Type must be a scalar or vector of floating-point. The component width must be 32 bits.

   Bfloat16 Value must be a scalar or vector of integer type, which is interpreted as a bfloat16 type.
   The type must have the same number of components as the Result Type. The component width must be 16 bits.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertBF16ToF %0 : i16 to f32
       %3 = spirv.ConvertBF16ToF %2 : vector<3xi16> to vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.ConvertBF16ToF'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: INTEL_ConvertBF16ToF(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: INTELConvertFToBF16Op(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Convert value numerically from 32-bit floating point to bfloat16,
   which is represented as a 16-bit unsigned integer.

   Result Type must be a scalar or vector of integer type.
   The component width must be 16 bits. Bit pattern in the Result represents a bfloat16 value.

   Float Value must be a scalar or vector of floating-point type.
   It must have the same number of components as Result Type. The component width must be 32 bits.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.ConvertFToBF16 %0 : f32 to i16
       %3 = spirv.ConvertFToBF16 %2 : vector<3xf32> to vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.ConvertFToBF16'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: INTEL_ConvertFToBF16(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: INTELRoundFToTF32Op(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Convert value numerically from a 32-bit floating point type to tensor float32,
   with rounding to the nearest even.

   Result Type must be a scalar or vector of 32-bit floating-point type.
   The component width must be 32 bits. Bit pattern in the Result represents a tensor float32 value.

   Float Value must be a scalar or vector of floating-point type.
   It must have the same number of components as Result Type. The component width must be 32 bits.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.RoundFToTF32 %0 : f32 to f32
       %3 = spirv.RoundFToTF32 %2 : vector<3xf32> to vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.RoundFToTF32'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: INTEL_RoundFToTF32(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: INTELSubgroupBlockReadOp(value, ptr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Reads one or more components of Result data for each invocation in the
   subgroup from the specified Ptr as a block operation.

   The data is read strided, so the first value read is:
   Ptr[ SubgroupLocalInvocationId ]

   and the second value read is:
   Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
   etc.

   Result Type may be a scalar or vector type, and its component type must be
   equal to the type pointed to by Ptr.

   The type of Ptr must be a pointer type, and must point to a scalar type.

   .. code::

       subgroup-block-read-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockRead`
                                   storage-class ssa_use `:` spirv-element-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.INTEL.SubgroupBlockRead "StorageBuffer" %ptr : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.SubgroupBlockRead'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: value() -> _ods_ir


.. py:function:: INTEL_SubgroupBlockRead(value, ptr, *, loc=None, ip=None) -> _ods_ir

.. py:class:: INTELSubgroupBlockWriteOp(ptr, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Writes one or more components of Data for each invocation in the subgroup
   from the specified Ptr as a block operation.

   The data is written strided, so the first value is written to:
   Ptr[ SubgroupLocalInvocationId ]

   and the second value written is:
   Ptr[ SubgroupLocalInvocationId + SubgroupMaxSize ]
   etc.

   The type of Ptr must be a pointer type, and must point to a scalar type.

   The component type of Data must be equal to the type pointed to by Ptr.

   .. code::

       subgroup-block-write-INTEL-op ::= ssa-id `=` `spirv.INTEL.SubgroupBlockWrite`
                         storage-class ssa_use `,` ssa-use `:` spirv-element-type

   Example:
   --------

   .. code:: mlir

       spirv.INTEL.SubgroupBlockWrite "StorageBuffer" %ptr, %value : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INTEL.SubgroupBlockWrite'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: value() -> _ods_ir


.. py:function:: INTEL_SubgroupBlockWrite(ptr, value, *, loc=None, ip=None) -> INTELSubgroupBlockWriteOp

.. py:class:: INotEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.INotEqual %0, %1 : i32
       %5 = spirv.INotEqual %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.INotEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: INotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ISubBorrowOp(result, operand1, operand2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be from OpTypeStruct.  The struct must have two
   members, and the two members must be the same type.  The member type
   must be a scalar or vector of integer type, whose Signedness operand is
   0.

   Operand 1 and Operand 2 must have the same type as the members of Result
   Type. These are consumed as unsigned integers.

   Results are computed per component.

   Member 0 of the result gets the low-order bits (full component width) of
   the subtraction. That is, if Operand 1 is larger than Operand 2, member
   0 gets the full value of the subtraction;  if Operand 2 is larger than
   Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the
   component width.

   Member 1 of the result gets 0 if Operand 1 ≥ Operand 2, and gets 1
   otherwise.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.ISubBorrow %0, %1 : !spirv.struct<(i32, i32)>
       %2 = spirv.ISubBorrow %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ISubBorrow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ISubBorrow(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ISubOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   The resulting value will equal the low-order N bits of the correct
   result R, where N is the component width and R is computed with enough
   precision to avoid overflow and underflow.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.ISub %0, %1 : i32
       %5 = spirv.ISub %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ISub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ISub(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageDrefGatherOp(result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of four components of floating-point type
   or integer type. Its components must be the same as Sampled Type of the
   underlying OpTypeImage (unless that underlying Sampled Type is
   OpTypeVoid). It has one component per gathered texel.

   Sampled Image must be an object whose type is OpTypeSampledImage. Its
   OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the
   underlying OpTypeImage must be 0.

   Coordinate must be a scalar or vector of floating-point type. It
   contains (u[, v] ... [, array layer]) as needed by the definition of
   Sampled Image.

   Dref is the depth-comparison reference value. It must be a 32-bit
   floating-point type scalar.

   Image Operands encodes what operands follow, as per Image Operands.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.ImageDrefGather %1, %2, %3 : !spirv.sampled_image<!spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>, vector<4xf32>, f32 -> vector<4xi32>
       %0 = spirv.ImageDrefGather %1, %2, %3 ["NonPrivateTexel"] : !spirv.sampled_image<!spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>, vector<4xf32>, f32 -> vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageDrefGather'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sampled_image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: dref() -> _ods_ir[_ods_ir]


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageDrefGather(result, sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageFetchOp(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of four components of floating-point type or
   integer type. Its components must be the same as Sampled Type of the underlying
   OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).

   Image must be an object whose type is OpTypeImage. Its Dim operand must not be
   Cube, and its Sampled operand must be 1.

   Coordinate must be a scalar or vector of integer type. It contains (u[, v] … [,
   array layer]) as needed by the definition of Sampled Image.

   Image Operands encodes what operands follow, as per Image Operands.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.ImageFetch %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NeedSampler, R32f>, vector<2xsi32> -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageFetch'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageFetch(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageOp(sampled_image, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be OpTypeImage.

   Sampled Image must have type OpTypeSampledImage whose Image Type is the
   same as Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Image %1 : !spirv.sampled_image<!spirv.image<f32, Cube, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Image'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sampled_image() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Image(sampled_image, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageQuerySizeOp(result, image, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type scalar or vector. The number of
   components must be:

   1 for the 1D and Buffer dimensionalities,

   2 for the 2D, Cube, and Rect dimensionalities,

   3 for the 3D dimensionality,

   plus 1 more if the image type is arrayed. This vector is filled in with
   (width [, height] [, elements]) where elements is the number of layers
   in an image array or the number of cubes in a cube-map array.

   Image must be an object whose type is OpTypeImage. Its Dim operand must
   be one of those listed under Result Type, above. Additionally, if its
   Dim is 1D, 2D, 3D, or Cube, it must also have either an MS of 1 or a
   Sampled of 0 or 2. There is no implicit level-of-detail consumed by this
   instruction. See OpImageQuerySizeLod for querying images having level of
   detail. This operation is allowed on an image decorated as NonReadable.
   See the client API specification for additional image type restrictions.

   Example:
   --------

   .. code:: mlir

       %3 = spirv.ImageQuerySize %0 : !spirv.image<i32, Dim1D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown> -> i32
       %4 = spirv.ImageQuerySize %1 : !spirv.image<i32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Unknown> -> vector<2xi32>
       %5 = spirv.ImageQuerySize %2 : !spirv.image<i32, Dim2D, NoDepth, Arrayed, SingleSampled, NoSampler, Unknown> -> vector<3xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageQuerySize'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: image() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageQuerySize(result, image, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageReadOp(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of floating-point type or integer
   type. It must be a scalar or vector with component type the same as Sampled
   Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).

   Image must be an object whose type is OpTypeImage with a Sampled operand of
   0 or 2. If the Arrayed operand is 1, then additional capabilities may be
   required; e.g., ImageCubeArray, or ImageMSArray.

   Coordinate must be a scalar or vector of floating-point type or integer
   type. It contains non-normalized texel coordinates (u[, v] ... [, array
   layer]) as needed by the definition of Image. See the client API
   specification for handling of coordinates outside the image.

   If the Image Dim operand is SubpassData, Coordinate is relative to the
   current fragment location. See the client API specification for more detail
   on how these coordinates are applied.

   If the Image Dim operand is not SubpassData, the Image Format must not be
   Unknown, unless the StorageImageReadWithoutFormat Capability was declared.

   Image Operands encodes what operands follow, as per Image Operands.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.ImageRead %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, R32f>, vector<2xsi32> -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageRead'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageRead(result, image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageSampleExplicitLodOp(result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of four components of floating-point type
   or integer type. Its components must be the same as Sampled Type of the
   underlying OpTypeImage (unless that underlying Sampled Type is
   OpTypeVoid).

   Sampled Image must be an object whose type is OpTypeSampledImage. Its
   OpTypeImage must not have a Dim of Buffer. The MS operand of the
   underlying OpTypeImage must be 0.

   Coordinate must be a scalar or vector of floating-point type or integer
   type. It contains (u[, v] ... [, array layer]) as needed by the
   definition of Sampled Image. Unless the Kernel capability is declared,
   it must be floating point. It may be a vector larger than needed, but
   all unused components appear after all used components.

   Image Operands encodes what operands follow, as per Image Operands.
   Either Lod or Grad image operands must be present.

   Example:
   --------

   .. code:: mlir

       %result = spirv.ImageSampleExplicitLod %image, %coord ["Lod"](%lod) :
         !spirv.sampled_image<!spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
         vector<2xf32> (f32) -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageSampleExplicitLod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sampled_image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageSampleExplicitLod(result, sampled_image, coordinate, image_operands, operand_arguments, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageSampleImplicitLodOp(result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its derivative group have executed all
   dynamic instances that are program-ordered before X'.

   Result Type must be a vector of four components of floating-point type
   or integer type. Its components must be the same as Sampled Type of the
   underlying OpTypeImage (unless that underlying Sampled Type is
   OpTypeVoid).

   Sampled Image must be an object whose type is OpTypeSampledImage. Its
   OpTypeImage must not have a Dim of Buffer. The MS operand of the
   underlying OpTypeImage must be 0.

   Coordinate must be a scalar or vector of floating-point type. It
   contains (u[, v] ... [, array layer]) as needed by the definition of
   Sampled Image. It may be a vector larger than needed, but all unused
   components appear after all used components.

   Image Operands encodes what operands follow, as per Image Operands.

   This instruction is only valid in the Fragment Execution Model. In
   addition, it consumes an implicit derivative that can be affected by
   code motion.

   Example:
   --------

   .. code:: mlir

       %result = spirv.ImageSampleImplicitLod %image, %coord :
         !spirv.sampled_image<!spirv.image<f32, Cube, NoDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
         vector<3xf32> -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageSampleImplicitLod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sampled_image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageSampleImplicitLod(result, sampled_image, coordinate, operand_arguments, *, image_operands=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageSampleProjDrefImplicitLodOp(sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   An invocation will not execute a dynamic instance of this instruction
   (X') until all invocations in its derivative group have executed all
   dynamic instances that are program-ordered before X'.

   Result Type must be a scalar of integer type or floating-point type. It
   must be the same as Sampled Type of the underlying OpTypeImage.

   Sampled Image must be an object whose type is OpTypeSampledImage. The
   Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,
   and the Arrayed and MS operands must be 0.

   Coordinate must be a vector of floating-point type. It contains (u[,
   v] [, w], q), as needed by the definition of Sampled Image, with the q
   component consumed for the projective division. That is, the actual
   sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition
   of Sampled Image. It may be a vector larger than needed, but all unused
   components appear after all used components.

   Dref/q is the depth-comparison reference value. Dref must be a 32-bit
   floating-point type scalar.

   Image Operands encodes what operands follow, as per Image Operands.

   This instruction is only valid in the Fragment Execution Model. In
   addition, it consumes an implicit derivative that can be affected by
   code motion.

   Example:
   --------

   .. code:: mlir

       %result = spirv.ImageSampleProjDrefImplicitLod %image, %coord, %dref :
         !spirv.sampled_image<!spirv.image<f32, Dim2D, IsDepth, NonArrayed, SingleSampled, NeedSampler, Unknown>>,
         vector<4xf16>, f32 -> f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageSampleProjDrefImplicitLod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sampled_image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: dref() -> _ods_ir[_ods_ir]


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ImageSampleProjDrefImplicitLod(sampled_image, coordinate, dref, operand_arguments, *, image_operands=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ImageWriteOp(image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Image must be an object whose type is OpTypeImage with a Sampled operand
   of 0 or 2. If the Arrayed operand is 1, then additional capabilities may
   be required; e.g., ImageCubeArray, or ImageMSArray. Its Dim operand
   must not be SubpassData.

   Coordinate must be a scalar or vector of floating-point type or integer
   type. It contains non-normalized texel coordinates (u[, v] ... [, array
   layer]) as needed by the definition of Image. See the client API
   specification for handling of coordinates outside the image.

   Texel is the data to write. It must be a scalar or vector with component
   type the same as Sampled Type of the OpTypeImage (unless that Sampled
   Type is OpTypeVoid).

   The Image Format must not be Unknown, unless the
   StorageImageWriteWithoutFormat Capability was declared.

   Image Operands encodes what operands follow, as per Image Operands.

   Example:
   --------

   .. code:: mlir

       spirv.ImageWrite %0, %1, %2 : !spirv.image<f32, Dim2D, NoDepth, NonArrayed, SingleSampled, NoSampler, Rgba16>, vector<2xsi32>, vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ImageWrite'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: image() -> _ods_ir


   .. py:method:: coordinate() -> _ods_ir


   .. py:method:: texel() -> _ods_ir


   .. py:method:: operand_arguments() -> _ods_ir


   .. py:method:: image_operands() -> Optional[_ods_ir]


.. py:function:: ImageWrite(image, coordinate, texel, operand_arguments, *, image_operands=None, loc=None, ip=None) -> ImageWriteOp

.. py:class:: InBoundsPtrAccessChainOp(result, base_ptr, element, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Example:
   --------

   .. code:: mlir

       func @inbounds_ptr_access_chain(%arg0: !spirv.ptr<f32, CrossWorkgroup>, %arg1 : i64) -> () {
         %0 = spirv.InBoundsPtrAccessChain %arg0[%arg1] : !spirv.ptr<f32, CrossWorkgroup>, i64 -> !spirv.ptr<f32, CrossWorkgroup>
         ...
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.InBoundsPtrAccessChain'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base_ptr() -> _ods_ir


   .. py:method:: element() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: InBoundsPtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: IsFiniteOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   x must be a scalar or vector of floating-point type.  It must have the
   same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.IsFinite %0: f32
       %3 = spirv.IsFinite %1: vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IsFinite'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IsFinite(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IsInfOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   x must be a scalar or vector of floating-point type.  It must have the
   same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.IsInf %0: f32
       %3 = spirv.IsInf %1: vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IsInf'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IsInf(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IsNanOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   x must be a scalar or vector of floating-point type.  It must have the
   same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.IsNan %0: f32
       %3 = spirv.IsNan %1: vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.IsNan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: IsNan(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: KHRAssumeTrueOp(condition, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   .. code::

       assumetruekhr-op ::= `spirv.KHR.AssumeTrue` ssa-use

   Example:
   --------

   .. code:: mlir

       spirv.KHR.AssumeTrue %arg


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.AssumeTrue'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: condition() -> _ods_ir[_ods_ir]


.. py:function:: KHR_AssumeTrue(condition, *, loc=None, ip=None) -> KHRAssumeTrueOp

.. py:class:: KHRCooperativeMatrixLengthOp(cooperative_matrix_type, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Number of components of a cooperative matrix type accessible to each
   invocation when treated as a composite.

   The type attribute must be a cooperative matrix type.

   Example:
   --------

   .. code::

       %0 = spirv.KHR.CooperativeMatrixLength :
              !spirv.coopmatrix<8x16xi32, Subgroup, MatrixA>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.CooperativeMatrixLength'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: cooperative_matrix_type() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_CooperativeMatrixLength(cooperative_matrix_type, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: KHRCooperativeMatrixLoadOp(result, pointer, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Load a cooperative matrix through a pointer.

   Result Type is the type of the loaded object. It must be a cooperative
   matrix type.

   Pointer is a pointer. Its type must be an OpTypePointer whose Type operand is
   a scalar or vector type. If the Shader capability was declared, Pointer must
   point into an array and any ArrayStride decoration on Pointer is ignored.

   MemoryLayout specifies how matrix elements are laid out in memory. It must
   come from a 32-bit integer constant instruction whose value corresponds to a
   Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
   description of the layouts and detailed layout-specific rules.

   Stride further qualifies how matrix elements are laid out in memory. It must
   be a scalar integer type and its exact semantics depend on MemoryLayout.

   Memory Operand must be a Memory Operand literal. If not present, it is the
   same as specifying None.

   NOTE: In earlier versions of the SPIR-V spec, 'Memory Operand' was known
   as 'Memory Access'.

   For a given dynamic instance of this instruction, all operands of this
   instruction must be the same for all invocations in a given scope instance
   (where the scope is the scope the cooperative matrix type was created with).
   All invocations in a given scope instance must be active or all must be
   inactive.

   TODO: In the SPIR-V spec, ``stride`` is an optional argument. We should also
   support this optionality in the SPIR-V dialect.

   Example:
   --------

   .. code::

       %0 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, <RowMajor>
            : !spirv.ptr<i32, StorageBuffer>, i32
                -> !spirv.KHR.coopmatrix<16x8xi32, Workgroup, MatrixA>
       
       %1 = spirv.KHR.CooperativeMatrixLoad %ptr, %stride, <ColumnMajor>, <Volatile>
            : !spirv.ptr<f32, StorageBuffer>, i64
                -> !spirv.KHR.coopmatrix<8x8xf32, Subgroup, MatrixAcc>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.CooperativeMatrixLoad'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: matrix_layout() -> _ods_ir


   .. py:method:: memory_operand() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_CooperativeMatrixLoad(result, pointer, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None) -> _ods_ir

.. py:class:: KHRCooperativeMatrixMulAddOp(a, b, c, *, matrix_operands=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Linear-algebraic matrix multiply of A by B and then component-wise add C.
   The order of the operations is implementation-dependent. The internal
   precision of floating-point operations is defined by the client API. Integer
   operations used in the multiplication of A by B are performed at the
   precision of the Result Type and the resulting value will equal the
   low-order N bits of the correct result R, where N is the result width and R
   is computed with enough precision to avoid overflow and underflow if the
   SaturatingAccumulation Cooperative Matrix Operand is not present. If the
   SaturatingAccumulation Cooperative Matrix Operand is present and overflow or
   underflow occurs as part of calculating that intermediate result, the result
   of the instruction is undefined. Integer additions of the elements of that
   intermediate result with those of C are performed at the precision of Result
   Type, are exact, and are saturating if the SaturatingAccumulation
   Cooperative Matrix Operand is present, with the signedness of the saturation
   being that of the components of Result Type. If the SaturatingAccumulation
   Cooperative Matrix Operand is not present then the resulting value will
   equal the low-order N bits of the correct result R, where N is the result
   width and R is computed with enough precision to avoid overflow and
   underflow.

   Result Type must be a cooperative matrix type with M rows and N columns
   whose Use must be MatrixAccumulatorKHR.

   A is a cooperative matrix with M rows and K columns whose Use must be
   MatrixAKHR.

   B is a cooperative matrix with K rows and N columns whose Use must be
   MatrixBKHR.

   C is a cooperative matrix with M rows and N columns whose Use must be
   MatrixAccumulatorKHR.

   The values of M, N, and K must be consistent across the result and operands.
   This is referred to as an MxNxK matrix multiply.

   A, B, C, and Result Type must have the same scope, and this defines the
   scope of the operation. A, B, C, and Result Type need not necessarily have
   the same component type, this is defined by the client API.

   If the Component Type of any matrix operand is an integer type, then its
   components are treated as signed if the Matrix{A,B,C,Result}SignedComponents
   Cooperative Matrix Operand is present and are treated as unsigned otherwise.

   Cooperative Matrix Operands is an optional Cooperative Matrix Operand
   literal. If not present, it is the same as specifying the Cooperative Matrix
   Operand None.

   For a given dynamic instance of this instruction, all invocations in a given
   scope instance must be active or all must be inactive (where the scope is
   the scope of the operation).

   .. code:: {.ebnf}

       cooperative-matrixmuladd-op ::= ssa-id `=` `spirv.KHR.CooperativeMatrixMulAdd`
                                 ssa-use `,` ssa-use `,` ssa-use
                                 (`<` matrix-operands `>`)? `:`
                                 a-cooperative-matrix-type `,`
                                 b-cooperative-matrix-type `->`
                                   result-cooperative-matrix-type

   Example:
   --------

   .. code::

       %0 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC :
         !spirv.coopmatrix<4x4xf32, Subgroup, MatrixA>,
         !spirv.coopmatrix<4x4xf32, Subgroup, MatrixB> ->
           !spirv.coopmatrix<4x4xf32, Subgroup, MatrixAcc>
       
       %1 = spirv.KHR.CooperativeMatrixMulAdd %matA, %matB, %matC, <ASigned | AccSat> :
         !spirv.coopmatrix<8x16xi32, Subgroup, MatrixA>,
         !spirv.coopmatrix<16x4xi32, Subgroup, MatrixB> ->
           !spirv.coopmatrix<8x4xi32, Subgroup, MatrixAcc>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.CooperativeMatrixMulAdd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: c() -> _ods_ir


   .. py:method:: matrix_operands() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_CooperativeMatrixMulAdd(a, b, c, *, matrix_operands=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: KHRCooperativeMatrixStoreOp(pointer, object, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Store a cooperative matrix through a pointer.
   Pointer is a pointer. Its type must be an OpTypePointer whose Type operand
   is a scalar or vector type. If the Shader capability was declared, Pointer
   must point into an array and any ArrayStride decoration on Pointer is
   ignored.

   Object is the object to store. Its type must be an
   OpTypeCooperativeMatrixKHR.

   MemoryLayout specifies how matrix elements are laid out in memory. It must
   come from a 32-bit integer constant instruction whose value corresponds to a
   Cooperative Matrix Layout. See the Cooperative Matrix Layout table for a
   description of the layouts and detailed layout-specific rules.

   Stride further qualifies how matrix elements are laid out in memory. It must
   be a scalar integer type and its exact semantics depend on MemoryLayout.

   Memory Operand must be a Memory Operand literal. If not present, it is the
   same as specifying None.

   NOTE: In earlier versions of the SPIR-V spec, 'Memory Operand' was known
   as 'Memory Access'.

   For a given dynamic instance of this instruction, all operands of this
   instruction must be the same for all invocations in a given scope instance
   (where the scope is the scope the cooperative matrix type was created with).
   All invocations in a given scope instance must be active or all must be
   inactive.

   TODO: In the SPIR-V spec, ``stride`` is an optional argument. We should also
   support this optionality in the SPIR-V dialect.

   Example:
   --------

   .. code::

         spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, <RowMajor> :
           !spirv.ptr<i32, StorageBuffer>, !spirv.coopmatrix<16x8xi32, Workgroup, MatrixA>, i32
       
         spirv.KHR.CooperativeMatrixStore %ptr, %obj, %stride, <ColumnMajor>, <Volatile> :
           !spirv.ptr<f32, StorageBuffer>, !spirv.coopmatrix<8x8xf32, Subgroup, MatrixAcc>, i64


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.CooperativeMatrixStore'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: object() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: matrix_layout() -> _ods_ir


   .. py:method:: memory_operand() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


.. py:function:: KHR_CooperativeMatrixStore(pointer, object, matrix_layout, stride, *, memory_operand=None, alignment=None, loc=None, ip=None) -> KHRCooperativeMatrixStoreOp

.. py:class:: KHRSubgroupBallotOp(result, predicate, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Computes a bitfield value combining the Predicate value from all invocations
   in the current Subgroup that execute the same dynamic instance of this
   instruction. The bit is set to one if the corresponding invocation is active
   and the predicate is evaluated to true; otherwise, it is set to zero.

   Predicate must be a Boolean type.

   Result Type must be a 4 component vector of 32 bit integer types.

   Result is a set of bitfields where the first invocation is represented in bit
   0 of the first vector component and the last (up to SubgroupSize) is the
   higher bit number of the last bitmask needed to represent all bits of the
   subgroup invocations.

   .. code::

       subgroup-ballot-op ::= ssa-id `=` `spirv.KHR.SubgroupBallot`
                                   ssa-use `:` `vector` `<` 4 `x` `i32` `>`

   Example:
   --------

   .. code:: mlir

       %0 = spirv.KHR.SubgroupBallot %predicate : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.KHR.SubgroupBallot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: predicate() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: KHR_SubgroupBallot(result, predicate, *, loc=None, ip=None) -> _ods_ir

.. py:class:: KillOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Fragment-shader discard.

   Ceases all further processing in any invocation that executes it: Only
   instructions these invocations executed before OpKill have observable
   side effects. If this instruction is executed in non-uniform control
   flow, all subsequent control flow is non-uniform (for invocations that
   continue to execute).

   This instruction must be the last instruction in a block.

   This instruction is only valid in the Fragment Execution Model.

   Example:
   --------

   .. code:: mlir

       spirv.Kill


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Kill'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: Kill(*, loc=None, ip=None) -> KillOp

.. py:class:: LoadOp(value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type is the type of the loaded object. It must be a type with
   fixed size; i.e., it cannot be, nor include, any OpTypeRuntimeArray
   types.

   Pointer is the pointer to load through.  Its type must be an
   OpTypePointer whose Type operand is the same as Result Type.

   If present, any Memory Operands must begin with a memory operand
   literal. If not present, it is the same as specifying the memory operand
   None.

   .. code::

       memory-access ::= `"None"` | `"Volatile"` | `"Aligned", ` integer-literal
                       | `"NonTemporal"`
       
       load-op ::= ssa-id ` = spirv.Load ` storage-class ssa-use
                   (`[` memory-access `]`)? ` : ` spirv-element-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Variable : !spirv.ptr<f32, Function>
       %1 = spirv.Load "Function" %0 : f32
       %2 = spirv.Load "Function" %0 ["Volatile"] : f32
       %3 = spirv.Load "Function" %0 ["Aligned", 4] : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: memory_access() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: value() -> _ods_ir


.. py:function:: Load(value, ptr, *, memory_access=None, alignment=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalAndOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 must be the same as Result Type.

   The type of Operand 2 must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.LogicalAnd %0, %1 : i1
       %2 = spirv.LogicalAnd %0, %1 : vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.LogicalAnd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: LogicalAnd(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 must be the same as Result Type.

   The type of Operand 2 must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.LogicalEqual %0, %1 : i1
       %2 = spirv.LogicalEqual %0, %1 : vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.LogicalEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: LogicalEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalNotEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 must be the same as Result Type.

   The type of Operand 2 must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.LogicalNotEqual %0, %1 : i1
       %2 = spirv.LogicalNotEqual %0, %1 : vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.LogicalNotEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: LogicalNotEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalNotOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.LogicalNot %0 : i1
       %2 = spirv.LogicalNot %0 : vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.LogicalNot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: LogicalNot(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogicalOrOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 must be the same as Result Type.

   The type of Operand 2 must be the same as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.LogicalOr %0, %1 : i1
       %2 = spirv.LogicalOr %0, %1 : vector<4xi1>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.LogicalOr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: LogicalOr(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LoopOp(results_, loop_control, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   SPIR-V can explicitly declare structured control-flow constructs using merge
   instructions. These explicitly declare a header block before the control
   flow diverges and a merge block where control flow subsequently converges.
   These blocks delimit constructs that must nest, and can only be entered
   and exited in structured ways. See "2.11. Structured Control Flow" of the
   SPIR-V spec for more details.

   Instead of having a ``spirv.LoopMerge`` op to directly model loop merge
   instruction for indicating the merge and continue target, we use regions
   to delimit the boundary of the loop: the merge target is the next op
   following the ``spirv.mlir.loop`` op and the continue target is the block that
   has a back-edge pointing to the entry block inside the ``spirv.mlir.loop``'s region.
   This way it's easier to discover all blocks belonging to a construct and
   it plays nicer with the MLIR system.

   The ``spirv.mlir.loop`` region should contain at least four blocks: one entry block,
   one loop header block, one loop continue block, one loop merge block.
   The entry block should be the first block and it should jump to the loop
   header block, which is the second block. The loop merge block should be the
   last block. The merge block should only contain a ``spirv.mlir.merge`` op.
   The continue block should be the second to last block and it should have a
   branch to the loop header block. The loop continue block should be the only
   block, except the entry block, branching to the header block.

   Values defined inside the loop regions cannot be directly used
   outside of them; however, the loop region can yield values. These values are
   yielded using a ``spirv.mlir.merge`` op and returned as a result of the loop op.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.loop'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: loop_control() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


   .. py:method:: body() -> _ods_ir


.. py:function:: mlir_loop(results_, loop_control, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, LoopOp]

.. py:class:: MatrixTimesMatrixOp(result, leftmatrix, rightmatrix, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypeMatrix whose Column Type is a vector of
   floating-point type.

   LeftMatrix must be a matrix whose Column Type is the same as the Column
   Type in Result Type.

   RightMatrix must be a matrix with the same Component Type as the
   Component Type in Result Type. Its number of columns must equal the
   number of columns in Result Type. Its columns must have the same number
   of components as the number of columns in LeftMatrix.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.MatrixTimesMatrix %matrix_1, %matrix_2 :
           !spirv.matrix<4 x vector<3xf32>>, !spirv.matrix<3 x vector<4xf32>> ->
           !spirv.matrix<4 x vector<4xf32>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.MatrixTimesMatrix'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: leftmatrix() -> _ods_ir


   .. py:method:: rightmatrix() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: MatrixTimesMatrix(result, leftmatrix, rightmatrix, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MatrixTimesScalarOp(matrix, scalar, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a matrix type with a float component type.

   The type of Matrix must be the same as Result Type. Each component in
   each column in Matrix is multiplied by Scalar.

   Scalar must have the same type as the Component Type in Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.MatrixTimesScalar %matrix, %scalar :
       !spirv.matrix<3 x vector<3xf32>>, f32 -> !spirv.matrix<3 x vector<3xf32>>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.MatrixTimesScalar'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: matrix() -> _ods_ir


   .. py:method:: scalar() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: MatrixTimesScalar(matrix, scalar, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MatrixTimesVectorOp(result, matrix, vector, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of floating-point type.

   Matrix must be an OpTypeMatrix whose Column Type is Result Type.

   Vector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.MatrixTimesVector %matrix, %vector : 
           !spirv.matrix<3 x vector<2xf32>>, vector<3xf32> -> vector<2xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.MatrixTimesVector'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: matrix() -> _ods_ir


   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: MatrixTimesVector(result, matrix, vector, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MemoryBarrierOp(memory_scope, memory_semantics, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Ensures that memory accesses issued before this instruction will be
   observed before memory accesses issued after this instruction. This
   control is ensured only for memory accesses issued by this invocation
   and observed by another invocation executing within Memory scope. If the
   Vulkan memory model is declared, this ordering only applies to memory
   accesses that use the NonPrivatePointer memory operand or
   NonPrivateTexel image operand.

   Semantics declares what kind of memory is being controlled and what kind
   of control to apply.

   To execute both a memory barrier and a control barrier, see
   OpControlBarrier.

   Example:
   --------

   .. code:: mlir

       spirv.MemoryBarrier "Device", "Acquire|UniformMemory"


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.MemoryBarrier'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: memory_scope() -> _ods_ir


   .. py:method:: memory_semantics() -> _ods_ir


.. py:function:: MemoryBarrier(memory_scope, memory_semantics, *, loc=None, ip=None) -> MemoryBarrierOp

.. py:class:: MergeOp(operands_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   We use ``spirv.mlir.selection``/``spirv.mlir.loop`` for modelling structured selection/loop.
   This op is a terminator used inside their regions to mean jumping to the
   merge point, which is the next op following the ``spirv.mlir.selection`` or
   ``spirv.mlir.loop`` op. This op does not have a corresponding instruction in the
   SPIR-V binary format; it's solely for structural purpose.

   The instruction is also used to yield values from inside the selection/loop region
   to the outside, as values that were sunk into the region cannot otherwise escape it.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.merge'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


.. py:function:: mlir_merge(operands_, *, loc=None, ip=None) -> MergeOp

.. py:class:: ModuleOp(addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op defines a SPIR-V module using a MLIR region. The region contains
   one block. Module-level operations, including functions definitions,
   are all placed in this block.

   Using an op with a region to define a SPIR-V module enables "embedding"
   SPIR-V modules in other dialects in a clean manner: this op guarantees
   the validity and serializability of a SPIR-V module and thus serves as
   a clear-cut boundary.

   This op takes no operands and generates no results. This op should not
   implicitly capture values from the enclosing environment.

   This op has only one region, which only contains one block. The block
   has no terminator.

   .. code::

       addressing-model ::= `Logical` | `Physical32` | `Physical64` | ...
       memory-model ::= `Simple` | `GLSL450` | `OpenCL` | `Vulkan` | ...
       spv-module-op ::= `spirv.module` addressing-model memory-model
                         (requires  spirv-vce-attribute)?
                         (`attributes` attribute-dict)?
                         region

   Example:
   --------

   .. code:: mlir

       spirv.module Logical GLSL450  {}
       
       spirv.module Logical Vulkan
           requires #spirv.vce<v1.0, [Shader], [SPV_KHR_vulkan_memory_model]>
           attributes { some_additional_attr = ... } {
         spirv.func @do_nothing() -> () {
           spirv.Return
         }
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.module'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: addressing_model() -> _ods_ir


   .. py:method:: memory_model() -> _ods_ir


   .. py:method:: vce_triple() -> Optional[_ods_ir]


   .. py:method:: sym_name() -> Optional[_ods_ir]


.. py:function:: module(addressing_model, memory_model, *, vce_triple=None, sym_name=None, loc=None, ip=None) -> ModuleOp

.. py:class:: NotOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Results are computed per component, and within each component, per bit.

   Result Type must be a scalar or vector of integer type.

   Operand's type  must be a scalar or vector of integer type.  It must
   have the same number of components as Result Type.  The component width
   must equal the component width in Result Type.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.Not %0 : i32
       %3 = spirv.Not %1 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Not'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Not(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: OrderedOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   x must be a scalar or vector of floating-point type.  It must have the
   same number of components as Result Type.

   y must have the same type as x.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.Ordered %0, %1 : f32
       %5 = spirv.Ordered %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Ordered'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Ordered(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PtrAccessChainOp(result, base_ptr, element, indices, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Element is used to do an initial dereference of Base: Base is treated as
   the address of an element in an array, and a new element address is
   computed from Base and Element to become the OpAccessChain Base to
   dereference as per OpAccessChain. This computed Base has the same type
   as the originating Base.

   To compute the new element address, Element is treated as a signed count
   of elements E, relative to the original Base element B, and the address
   of element B + E is computed using enough precision to avoid overflow
   and underflow. For objects in the Uniform, StorageBuffer, or
   PushConstant storage classes, the element's address or location is
   calculated using a stride, which will be the Base-type's Array Stride if
   the Base type is decorated with ArrayStride. For all other objects, the
   implementation calculates the element's address or location.

   With one exception, undefined behavior results when B + E is not an
   element in the same array (same innermost array, if array types are
   nested) as B. The exception being when B + E = L, where L is the length
   of the array: the address computation for element L is done with the
   same stride as any other B + E computation that stays within the array.

   Note: If Base is typed to be a pointer to an array and the desired
   operation is to select an element of that array, OpAccessChain should be
   directly used, as its first Index selects the array element.

   Example:
   --------

   .. code:: mlir

       func @ptr_access_chain(%arg0: !spirv.ptr<f32, CrossWorkgroup>, %arg1 : i64) -> () {
         %0 = spirv.PtrAccessChain %arg0[%arg1] : !spirv.ptr<f32, CrossWorkgroup>, i64 -> !spirv.ptr<f32, CrossWorkgroup>
         ...
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.PtrAccessChain'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base_ptr() -> _ods_ir


   .. py:method:: element() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: PtrAccessChain(result, base_ptr, element, indices, *, loc=None, ip=None) -> _ods_ir

.. py:class:: PtrCastToGenericOp(result, pointer, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer. Its Storage Class must be Generic.

   Pointer must point to the Workgroup, CrossWorkgroup, or Function Storage
   Class.

   Result Type and Pointer must point to the same type.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.PtrCastToGenericOp %0 : !spirv.ptr<f32, CrossWorkGroup> to
            !spirv.ptr<f32, Generic>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.PtrCastToGeneric'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: pointer() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: PtrCastToGeneric(result, pointer, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReferenceOfOp(reference, spec_const, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Specialization constants in module scope are defined using symbol names.
   This op generates an SSA value that can be used to refer to the symbol
   within function scope for use in ops that expect an SSA value.
   This operation has no corresponding SPIR-V instruction; it's merely used
   for modelling purpose in the SPIR-V dialect. This op's return type is
   the same as the specialization constant.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.mlir.referenceof @spec_const : f32

   TODO Add support for composite specialization constants.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.referenceof'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: spec_const() -> _ods_ir


   .. py:method:: reference() -> _ods_ir


.. py:function:: mlir_referenceof(reference, spec_const, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ReturnOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This instruction must be the last instruction in a block.

   Example:
   --------

   .. code:: mlir

       spirv.Return


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Return'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: Return(*, loc=None, ip=None) -> ReturnOp

.. py:class:: ReturnValueOp(value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Value is the value returned, by copy, and must match the Return Type
   operand of the OpTypeFunction type of the OpFunction body this return
   instruction is in.

   This instruction must be the last instruction in a block.

   Example:
   --------

   .. code:: mlir

       spirv.ReturnValue %0 : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ReturnValue'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


.. py:function:: ReturnValue(value, *, loc=None, ip=None) -> ReturnValueOp

.. py:class:: SConvertOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Signed Value must be a scalar or vector of integer type.  It must have
   the same number of components as Result Type.  The component width
   cannot equal the component width in Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.SConvertOp %0 : i32 to i64
       %3 = spirv.SConvertOp %2 : vector<3xi32> to vector<3xi64>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SConvert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SConvert(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SDivOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SDiv %0, %1 : i32
       %5 = spirv.SDiv %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SDiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SDotAccSatOp(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type whose Width must be greater than or
   equal to that of the components of Vector 1 and Vector 2.

   Vector 1 and Vector 2 must have the same type.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type
   (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).

   The type of Accumulator must be the same as Result Type.

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of the input vectors are sign-extended to the bit width
   of the result's type. The sign-extended input vectors are then
   multiplied component-wise and all components of the vector resulting
   from the component-wise multiplication are added together. Finally, the
   resulting sum is added to the input accumulator. This final addition is
   saturating.

   If any of the multiplications or additions, with the exception of the
   final accumulation, overflow or underflow, the result of the instruction
   is undefined.

   Example:
   --------

   .. code:: mlir

       %r = spirv.SDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.SDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.SDotAccSat %a, %b, %acc : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SDotAccSat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: accumulator() -> _ods_ir[_ods_ir]


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SDotOp(result, vector1, vector2, *, format=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type whose Width must be greater than or
   equal to that of the components of Vector 1 and Vector 2.

   Vector 1 and Vector 2 must have the same type.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type
   (enabled by the DotProductInput4x8Bit or DotProductInputAll capability).

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of the input vectors are sign-extended to the bit width
   of the result's type. The sign-extended input vectors are then
   multiplied component-wise and all components of the vector resulting
   from the component-wise multiplication are added together. The resulting
   value will equal the low-order N bits of the correct result R, where N
   is the result width and R is computed with enough precision to avoid
   overflow and underflow.

   Example:
   --------

   .. code:: mlir

       %r = spirv.SDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.SDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.SDot %a, %b : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SDot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SGreaterThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SGreaterThanEqual %0, %1 : i32
       %5 = spirv.SGreaterThanEqual %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SGreaterThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SGreaterThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SGreaterThan %0, %1 : i32
       %5 = spirv.SGreaterThan %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SGreaterThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SLessThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SLessThanEqual %0, %1 : i32
       %5 = spirv.SLessThanEqual %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SLessThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SLessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SLessThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SLessThan %0, %1 : i32
       %5 = spirv.SLessThan %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SLessThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SLessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SModOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
   1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
   sign of Operand 2.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SMod %0, %1 : i32
       %5 = spirv.SMod %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SMod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SMulExtendedOp(result, operand1, operand2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be from OpTypeStruct.  The struct must have two
   members, and the two members must be the same type.  The member type
   must be a scalar or vector of integer type.

   Operand 1 and Operand 2 must have the same type as the members of Result
   Type. These are consumed as signed integers.

   Results are computed per component.

   Member 0 of the result gets the low-order bits of the multiplication.

   Member 1 of the result gets the high-order bits of the multiplication.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.SMulExtended %0, %1 : !spirv.struct<(i32, i32)>
       %2 = spirv.SMulExtended %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SMulExtended'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SNegateOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   Operand's type  must be a scalar or vector of integer type.  It must
   have the same number of components as Result Type.  The component width
   must equal the component width in Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.SNegate %0 : i32
       %3 = spirv.SNegate %2 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SNegate'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SNegate(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SRemOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same number of components as Result
   Type. They must have the same component width as Result Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand
   1 divided by Operand 2 where if r ≠ 0, the sign of r is the same as the
   sign of Operand 1.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.SRem %0, %1 : i32
       %5 = spirv.SRem %2, %3 : vector<4xi32>
       


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SRem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SRem(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SUDotAccSatOp(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type whose Width must be greater than or
   equal to that of the components of Vector 1 and Vector 2.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type with
   the same number of components and same component Width (enabled by the
   DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
   and Vector 2 are vectors, the components of Vector 2 must have a
   Signedness of 0.

   The type of Accumulator must be the same as Result Type.

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of Vector 1 are sign-extended to the bit width of the
   result's type. All components of Vector 2 are zero-extended to the bit
   width of the result's type. The sign- or zero-extended input vectors are
   then multiplied component-wise and all components of the vector
   resulting from the component-wise multiplication are added together.
   Finally, the resulting sum is added to the input accumulator. This final
   addition is saturating.

   If any of the multiplications or additions, with the exception of the
   final accumulation, overflow or underflow, the result of the instruction
   is undefined.

   Example:
   --------

   .. code:: mlir

       %r = spirv.SUDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.SUDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.SUDotAccSat %a, %b, %acc : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SUDotAccSat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: accumulator() -> _ods_ir[_ods_ir]


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SUDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SUDotOp(result, vector1, vector2, *, format=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type whose Width must be greater than or
   equal to that of the components of Vector 1 and Vector 2.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type with
   the same number of components and same component Width (enabled by the
   DotProductInput4x8Bit or DotProductInputAll capability). When Vector 1
   and Vector 2 are vectors, the components of Vector 2 must have a
   Signedness of 0.

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of Vector 1 are sign-extended to the bit width of the
   result's type. All components of Vector 2 are zero-extended to the bit
   width of the result's type. The sign- or zero-extended input vectors are
   then multiplied component-wise and all components of the vector
   resulting from the component-wise multiplication are added together. The
   resulting value will equal the low-order N bits of the correct result R,
   where N is the result width and R is computed with enough precision to
   avoid overflow and underflow.

   Example:
   --------

   .. code:: mlir

       %r = spirv.SUDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.SUDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.SUDot %a, %b : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SUDot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: SUDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SelectOp(condition, true_value, false_value, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Before version 1.4, Result Type must be a pointer, scalar, or vector.

   The types of Object 1 and Object 2 must be the same as Result Type.

   Condition must be a scalar or vector of Boolean type.

   If Condition is a scalar and true, the result is Object 1. If Condition
   is a scalar and false, the result is Object 2.

   If Condition is a vector, Result Type must be a vector with the same
   number of components as Condition and the result is a mix of Object 1
   and Object 2: When a component of Condition is true, the corresponding
   component in the result is taken from Object 1, otherwise it is taken
   from Object 2.

   Example:
   --------

   .. code:: mlir

       %3 = spirv.Select %0, %1, %2 : i1, f32
       %3 = spirv.Select %0, %1, %2 : i1, vector<3xi32>
       %3 = spirv.Select %0, %1, %2 : vector<3xi1>, vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Select'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: condition() -> _ods_ir


   .. py:method:: true_value() -> _ods_ir


   .. py:method:: false_value() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Select(condition, true_value, false_value, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SelectionOp(results_, selection_control, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   SPIR-V can explicitly declare structured control-flow constructs using merge
   instructions. These explicitly declare a header block before the control
   flow diverges and a merge block where control flow subsequently converges.
   These blocks delimit constructs that must nest, and can only be entered
   and exited in structured ways. See "2.11. Structured Control Flow" of the
   SPIR-V spec for more details.

   Instead of having a ``spirv.SelectionMerge`` op to directly model selection
   merge instruction for indicating the merge target, we use regions to delimit
   the boundary of the selection: the merge target is the next op following the
   ``spirv.mlir.selection`` op. This way it's easier to discover all blocks belonging to
   the selection and it plays nicer with the MLIR system.

   The ``spirv.mlir.selection`` region should contain at least two blocks: one selection
   header block, and one selection merge. The selection header block should be
   the first block. The selection merge block should be the last block.
   The merge block should only contain a ``spirv.mlir.merge`` op.

   Values defined inside the selection regions cannot be directly used
   outside of them; however, the selection region can yield values. These values are
   yielded using a ``spirv.mlir.merge`` op and returned as a result of the selection op.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.selection'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: selection_control() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


   .. py:method:: body() -> _ods_ir


.. py:function:: mlir_selection(results_, selection_control, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, SelectionOp]

.. py:class:: ShiftLeftLogicalOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of each Base and Shift must be a scalar or vector of integer
   type. Base and Shift must have the same number of components.  The
   number of components and bit width of the type of Base must be the same
   as in Result Type.

   Shift is treated as unsigned. The result is undefined if Shift is
   greater than or equal to the bit width of the components of Base.

   The number of components and bit width of Result Type must match those
   Base type. All types must be integer types.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.ShiftLeftLogical %0, %1 : i32, i16
       %5 = spirv.ShiftLeftLogical %3, %4 : vector<3xi32>, vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ShiftLeftLogical'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ShiftLeftLogical(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ShiftRightArithmeticOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of each Base and Shift must be a scalar or vector of integer
   type. Base and Shift must have the same number of components.  The
   number of components and bit width of the type of Base must be the same
   as in Result Type.

   Shift is treated as unsigned. The result is undefined if Shift is
   greater than or equal to the bit width of the components of Base.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.ShiftRightArithmetic %0, %1 : i32, i16
       %5 = spirv.ShiftRightArithmetic %3, %4 : vector<3xi32>, vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ShiftRightArithmetic'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ShiftRightArithmetic(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ShiftRightLogicalOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type.

   The type of each Base and Shift must be a scalar or vector of integer
   type. Base and Shift must have the same number of components.  The
   number of components and bit width of the type of Base must be the same
   as in Result Type.

   Shift is consumed as an unsigned integer. The result is undefined if
   Shift is greater than or equal to the bit width of the components of
   Base.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.ShiftRightLogical %0, %1 : i32, i16
       %5 = spirv.ShiftRightLogical %3, %4 : vector<3xi32>, vector<3xi16>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ShiftRightLogical'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ShiftRightLogical(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SpecConstantCompositeOp(type_, sym_name, constituents, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares a SPIR-V composite specialization constant. This covers
   the ``OpSpecConstantComposite`` SPIR-V instruction. Scalar constants are
   covered by ``spirv.SpecConstant``.

   A constituent of a spec constant composite can be:

   * A symbol referring of another spec constant.
   * The SSA ID of a non-specialization constant (i.e. defined through
   ``spirv.SpecConstant``).
   * The SSA ID of a ``spirv.Undef``.

   .. code::

       spv-spec-constant-composite-op ::= `spirv.SpecConstantComposite` symbol-ref-id ` (`
                                          symbol-ref-id (`, ` symbol-ref-id)*
                                          `) :` composite-type

   where ``composite-type`` is some non-scalar type that can be represented in the ``spv``
   dialect: ``spirv.struct``, ``spirv.array``, or ``vector``.

   Example:
   --------

   .. code:: mlir

       spirv.SpecConstant @sc1 = 1   : i32
       spirv.SpecConstant @sc2 = 2.5 : f32
       spirv.SpecConstant @sc3 = 3.5 : f32
       spirv.SpecConstantComposite @scc (@sc1, @sc2, @sc3) : !spirv.struct<i32, f32, f32>

   TODO Add support for constituents that are:

   * regular constants.
   * undef.
   * spec constant composite.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SpecConstantComposite'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: type_() -> _ods_ir


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: constituents() -> _ods_ir


.. py:function:: SpecConstantComposite(type_, sym_name, constituents, *, loc=None, ip=None) -> SpecConstantCompositeOp

.. py:class:: SpecConstantOp(sym_name, default_value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares a SPIR-V scalar specialization constant. SPIR-V has
   multiple constant instructions covering different scalar types:

   * ``OpSpecConstantTrue`` and ``OpSpecConstantFalse`` for boolean constants
   * ``OpSpecConstant`` for scalar constants

   Similar as ``spirv.Constant``, this op represents all of the above cases.
   ``OpSpecConstantComposite`` and ``OpSpecConstantOp`` are modelled with
   separate ops.

   .. code::

       spv-spec-constant-op ::= `spirv.SpecConstant` symbol-ref-id
                                `spec_id(` integer `)`
                                `=` attribute-value (`:` spirv-type)?

   where ``spec_id`` specifies the SPIR-V SpecId decoration associated with
   the op.

   Example:
   --------

   .. code:: mlir

       spirv.SpecConstant @spec_const1 = true
       spirv.SpecConstant @spec_const2 spec_id(5) = 42 : i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SpecConstant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: default_value() -> _ods_ir


.. py:function:: SpecConstant(sym_name, default_value, *, loc=None, ip=None) -> SpecConstantOp

.. py:class:: SpecConstantOperationOp(result, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op declares a SPIR-V specialization constant that results from
   doing an operation on other constants (specialization or otherwise).

   In the ``spv`` dialect, this op is modelled as follows:

   .. code::

       spv-spec-constant-operation-op ::= `spirv.SpecConstantOperation` `wraps`
                                            generic-spirv-op `:` function-type

   In particular, an ``spirv.SpecConstantOperation`` contains exactly one
   region. In turn, that region, contains exactly 2 instructions:

   * One of SPIR-V's instructions that are allowed within an
   OpSpecConstantOp.
   * An ``spirv.mlir.yield`` instruction as the terminator.

   The following SPIR-V instructions are valid:

   * OpSConvert,
   * OpUConvert,
   * OpFConvert,
   * OpSNegate,
   * OpNot,
   * OpIAdd,
   * OpISub,
   * OpIMul,
   * OpUDiv,
   * OpSDiv,
   * OpUMod,
   * OpSRem,
   * OpSMod
   * OpShiftRightLogical,
   * OpShiftRightArithmetic,
   * OpShiftLeftLogical
   * OpBitwiseOr,
   * OpBitwiseXor,
   * OpBitwiseAnd
   * OpVectorShuffle,
   * OpCompositeExtract,
   * OpCompositeInsert
   * OpLogicalOr,
   * OpLogicalAnd,
   * OpLogicalNot,
   * OpLogicalEqual,
   * OpLogicalNotEqual
   * OpSelect
   * OpIEqual,
   * OpINotEqual
   * OpULessThan,
   * OpSLessThan
   * OpUGreaterThan,
   * OpSGreaterThan
   * OpULessThanEqual,
   * OpSLessThanEqual
   * OpUGreaterThanEqual,
   * OpSGreaterThanEqual

   TODO Add capability-specific ops when supported.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Constant 1: i32
       %1 = spirv.Constant 1: i32
       
       %2 = spirv.SpecConstantOperation wraps "spirv.IAdd"(%0, %1) : (i32, i32) -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.SpecConstantOperation'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



   .. py:method:: body() -> _ods_ir


.. py:function:: SpecConstantOperation(result, *, loc=None, ip=None) -> _ods_ir

.. py:class:: StoreOp(ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Pointer is the pointer to store through.  Its type must be an
   OpTypePointer whose Type operand is the same as the type of Object.

   Object is the object to store.

   If present, any Memory Operands must begin with a memory operand
   literal. If not present, it is the same as specifying the memory operand
   None.

   .. code::

       store-op ::= `spirv.Store ` storage-class ssa-use `, ` ssa-use `, `
                     (`[` memory-access `]`)? `:` spirv-element-type

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Variable : !spirv.ptr<f32, Function>
       %1 = spirv.FMul ... : f32
       spirv.Store "Function" %0, %1 : f32
       spirv.Store "Function" %0, %1 ["Volatile"] : f32
       spirv.Store "Function" %0, %1 ["Aligned", 4] : f32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: value() -> _ods_ir


   .. py:method:: memory_access() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


.. py:function:: Store(ptr, value, *, memory_access=None, alignment=None, loc=None, ip=None) -> StoreOp

.. py:class:: SwitchOp(selector, defaultOperands, targetOperands, case_operand_segments, defaultTarget, targets, *, literals=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Selector must have a type of OpTypeInt. Selector is compared for equality to
   the Target literals.

   Default must be the  of a label. If Selector does not equal any of the
   Target literals, control flow branches to the Default label .

   Target must be alternating scalar integer literals and the  of a label.
   If Selector equals a literal, control flow branches to the following label
   . It is invalid for any two literal to be equal to each other. If Selector
   does not equal any literal, control flow branches to the Default label .
   Each literal is interpreted with the type of Selector: The bit width of
   Selector’s type is the width of each literal’s type. If this width is not a
   multiple of 32-bits and the OpTypeInt Signedness is set to 1, the literal values
   are interpreted as being sign extended.

   If Selector is an OpUndef, behavior is undefined.

   This instruction must be the last instruction in a block.

   Example:
   --------

   .. code:: mlir

       spirv.Switch %selector : si32, [
         default: ^bb1(%a : i32),
         0: ^bb1(%b : i32),
         1: ^bb3(%c : i32)
       ]


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Switch'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: selector() -> _ods_ir[_ods_ir]


   .. py:method:: defaultOperands() -> _ods_ir


   .. py:method:: targetOperands() -> _ods_ir


   .. py:method:: literals() -> Optional[_ods_ir]


   .. py:method:: case_operand_segments() -> _ods_ir


.. py:function:: Switch(selector, default_operands, target_operands, case_operand_segments, default_target, targets, *, literals=None, loc=None, ip=None) -> SwitchOp

.. py:class:: TransposeOp(result, matrix, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypeMatrix.

   Matrix must be an object of type OpTypeMatrix. The number of columns and
   the column size of Matrix must be the reverse of those in Result Type.
   The types of the scalar components in Matrix and Result Type must be the
   same.

   Matrix must have of type of OpTypeMatrix.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Transpose %matrix: !spirv.matrix<2 x vector<3xf32>> ->
       !spirv.matrix<3 x vector<2xf32>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Transpose'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: matrix() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Transpose(result, matrix, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UConvertOp(result, operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type, whose Signedness
   operand is 0.

   Unsigned Value must be a scalar or vector of integer type.  It must have
   the same number of components as Result Type.  The component width
   cannot equal the component width in Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %1 = spirv.UConvertOp %0 : i32 to i64
       %3 = spirv.UConvertOp %2 : vector<3xi32> to vector<3xi64>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UConvert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UConvert(result, operand, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UDivOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type, whose Signedness
   operand is 0.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.UDiv %0, %1 : i32
       %5 = spirv.UDiv %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UDiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UDiv(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UDotAccSatOp(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type with Signedness of 0 whose Width
   must be greater than or equal to that of the components of Vector 1 and
   Vector 2.

   Vector 1 and Vector 2 must have the same type.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type with
   Signedness of 0 (enabled by the DotProductInput4x8Bit or
   DotProductInputAll capability).

   The type of Accumulator must be the same as Result Type.

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of the input vectors are zero-extended to the bit width
   of the result's type. The zero-extended input vectors are then
   multiplied component-wise and all components of the vector resulting
   from the component-wise multiplication are added together. Finally, the
   resulting sum is added to the input accumulator. This final addition is
   saturating.

   If any of the multiplications or additions, with the exception of the
   final accumulation, overflow or underflow, the result of the instruction
   is undefined.

   Example:
   --------

   .. code:: mlir

       %r = spirv.UDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.UDotAccSat %a, %b, %acc, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.UDotAccSat %a, %b, %acc : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UDotAccSat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: accumulator() -> _ods_ir[_ods_ir]


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UDotAccSat(vector1, vector2, accumulator, *, format=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UDotOp(result, vector1, vector2, *, format=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an integer type with Signedness of 0 whose Width
   must be greater than or equal to that of the components of Vector 1 and
   Vector 2.

   Vector 1 and Vector 2 must have the same type.

   Vector 1 and Vector 2 must be either 32-bit integers (enabled by the
   DotProductInput4x8BitPacked capability) or vectors of integer type with
   Signedness of 0 (enabled by the DotProductInput4x8Bit or
   DotProductInputAll capability).

   When Vector 1 and Vector 2 are scalar integer types, Packed Vector
   Format must be specified to select how the integers are to be
   interpreted as vectors.

   All components of the input vectors are zero-extended to the bit width
   of the result's type. The zero-extended input vectors are then
   multiplied component-wise and all components of the vector resulting
   from the component-wise multiplication are added together. The resulting
   value will equal the low-order N bits of the correct result R, where N
   is the result width and R is computed with enough precision to avoid
   overflow and underflow.

   Example:
   --------

   .. code:: mlir

       %r = spirv.UDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i32
       %r = spirv.UDot %a, %b, <PackedVectorFormat4x8Bit> : i32 -> i64
       %r = spirv.UDot %a, %b : vector<4xi8> -> i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UDot'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir


   .. py:method:: vector2() -> _ods_ir


   .. py:method:: format() -> Optional[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UDot(result, vector1, vector2, *, format=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UGreaterThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.UGreaterThanEqual %0, %1 : i32
       %5 = spirv.UGreaterThanEqual %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UGreaterThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UGreaterThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UGreaterThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.UGreaterThan %0, %1 : i32
       %5 = spirv.UGreaterThan %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UGreaterThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UGreaterThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ULessThanEqualOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.ULessThanEqual %0, %1 : i32
       %5 = spirv.ULessThanEqual %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ULessThanEqual'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ULessThanEqual(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ULessThanOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   The type of Operand 1 and Operand 2  must be a scalar or vector of
   integer type.  They must have the same component width, and they must
   have the same number of components as Result Type.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.ULessThan %0, %1 : i32
       %5 = spirv.ULessThan %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.ULessThan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: ULessThan(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UModOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of integer type, whose Signedness
   operand is 0.

   The types of Operand 1 and Operand 2 both must be the same as Result
   Type.

   Results are computed per component.  The resulting value is undefined
   if Operand 2 is 0.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.UMod %0, %1 : i32
       %5 = spirv.UMod %2, %3 : vector<4xi32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UMod'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UMod(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UMulExtendedOp(result, operand1, operand2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be from OpTypeStruct.  The struct must have two
   members, and the two members must be the same type.  The member type
   must be a scalar or vector of integer type, whose Signedness operand is
   0.

   Operand 1 and Operand 2 must have the same type as the members of Result
   Type. These are consumed as unsigned integers.

   Results are computed per component.

   Member 0 of the result gets the low-order bits of the multiplication.

   Member 1 of the result gets the high-order bits of the multiplication.

   Example:
   --------

   .. code:: mlir

       %2 = spirv.UMulExtended %0, %1 : !spirv.struct<(i32, i32)>
       %2 = spirv.UMulExtended %0, %1 : !spirv.struct<(vector<2xi32>, vector<2xi32>)>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.UMulExtended'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: UMulExtended(result, operand1, operand2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UndefOp(result, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type is the type of object to make.

   Each consumption of Result  yields an arbitrary, possibly different
   bit pattern or abstract value resulting in possibly different concrete,
   abstract, or opaque values.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Undef : f32
       %1 = spirv.Undef : !spirv.struct<!spirv.array<4 x vector<4xi32>>>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Undef'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Undef(result, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UnorderedOp(operand1, operand2, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar or vector of Boolean type.

   x must be a scalar or vector of floating-point type.  It must have the
   same number of components as Result Type.

   y must have the same type as x.

   Results are computed per component.

   Example:
   --------

   .. code:: mlir

       %4 = spirv.Unordered %0, %1 : f32
       %5 = spirv.Unordered %2, %3 : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Unordered'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand1() -> _ods_ir


   .. py:method:: operand2() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: Unordered(operand1, operand2, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UnreachableOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This instruction must be the last instruction in a block.


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Unreachable'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: Unreachable(*, loc=None, ip=None) -> UnreachableOp

.. py:class:: VariableOp(pointer, storage_class, *, initializer=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypePointer. Its Type operand is the type of
   object in memory.

   Storage Class is the Storage Class of the memory holding the object.
   Since the op is used to model function-level variables, the storage class
   must be the ``Function`` Storage Class.

   Initializer is optional. If Initializer is present, it will be the
   initial value of the variable's memory content. Initializer must be an
    from a constant instruction or a global (module scope) OpVariable
   instruction. Initializer must have the same type as the type pointed to
   by Result Type.

   From ``SPV_KHR_physical_storage_buffer``:
   If an OpVariable's pointee type is a pointer (or array of pointers) in
   PhysicalStorageBuffer storage class, then the variable must be decorated
   with exactly one of AliasedPointer or RestrictPointer.

   .. code::

       variable-op ::= ssa-id `=` `spirv.Variable` (`init(` ssa-use `)`)?
                       attribute-dict? `:` spirv-pointer-type

   where ``init`` specifies initializer.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.Constant ...
       
       %1 = spirv.Variable : !spirv.ptr<f32, Function>
       %2 = spirv.Variable init(%0): !spirv.ptr<f32, Function>
       
       %3 = spirv.Variable {aliased_pointer} :
         !spirv.ptr<!spirv.ptr<f32, PhysicalStorageBuffer>, Function>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.Variable'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: initializer() -> Optional[_ods_ir]


   .. py:method:: storage_class() -> _ods_ir


   .. py:method:: pointer() -> _ods_ir


.. py:function:: Variable(pointer, storage_class, *, initializer=None, loc=None, ip=None) -> _ods_ir

.. py:class:: VectorExtractDynamicOp(vector, index, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a scalar type.

   Vector must have a type OpTypeVector whose Component Type is Result
   Type.

   Index must be a scalar integer. It is interpreted as a 0-based index of
   which component of Vector to extract.

   Behavior is undefined if Index's value is less than zero or greater than
   or equal to the number of components in Vector.

   Example:
   --------

   .. code::

       %2 = spirv.VectorExtractDynamic %0[%1] : vector<8xf32>, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.VectorExtractDynamic'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: index() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: VectorExtractDynamic(vector, index, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: VectorInsertDynamicOp(vector, component, index, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypeVector.

   Vector must have the same type as Result Type and is the vector that the
   non-written components are copied from.

   Component is the value supplied for the component selected by Index. It
   must have the same type as the type of components in Result Type.

   Index must be a scalar integer. It is interpreted as a 0-based index of
   which component to modify.

   Behavior is undefined if Index's value is less than zero or greater than
   or equal to the number of components in Vector.

   Example:
   --------

   .. code:: mlir

       %scalar = ... : f32
       %2 = spirv.VectorInsertDynamic %scalar %0[%1] : f32, vector<8xf32>, i32


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.VectorInsertDynamic'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: component() -> _ods_ir


   .. py:method:: index() -> _ods_ir[_ods_ir]


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: VectorInsertDynamic(vector, component, index, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: VectorShuffleOp(result, vector1, vector2, components, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be an OpTypeVector. The number of components in Result
   Type must be the same as the number of Component operands.

   Vector 1 and Vector 2 must both have vector types, with the same
   Component Type as Result Type. They do not have to have the same number
   of components as Result Type or with each other. They are logically
   concatenated, forming a single vector with Vector 1's components
   appearing before Vector 2's. The components of this logical vector are
   logically numbered with a single consecutive set of numbers from 0 to N

   * 1, where N is the total number of components.

   Components are these logical numbers (see above), selecting which of the
   logically numbered components form the result. Each component is an
   unsigned 32-bit integer.  They can select the components in any order
   and can repeat components. The first component of the result is selected
   by the first Component operand,  the second component of the result is
   selected by the second Component operand, etc. A Component literal may
   also be FFFFFFFF, which means the corresponding result component has no
   source and is undefined. All Component literals must either be FFFFFFFF
   or in [0, N - 1] (inclusive).

   Note: A vector “swizzle” can be done by using the vector for both Vector
   operands, or using an OpUndef for one of the Vector operands.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.VectorShuffle [1: i32, 3: i32, 5: i32] %vector1, %vector2 :
         vector<4xf32>, vector<2xf32> -> vector<3xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.VectorShuffle'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector1() -> _ods_ir[_ods_ir]


   .. py:method:: vector2() -> _ods_ir[_ods_ir]


   .. py:method:: components() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: VectorShuffle(result, vector1, vector2, components, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VectorTimesMatrixOp(result, vector, matrix, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of floating-point type.

   Vector must be a vector with the same Component Type as the Component
   Type in Result Type. Its number of components must equal the number of
   components in each column in Matrix.

   Matrix must be a matrix with the same Component Type as the Component
   Type in Result Type. Its number of columns must equal the number of
   components in Result Type.

   Example:
   --------

   .. code:: mlir

       %result = spirv.VectorTimesMatrix %vector, %matrix : vector<4xf32>, !spirv.matrix<4 x vector<4xf32>> -> vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.VectorTimesMatrix'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: matrix() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: VectorTimesMatrix(result, vector, matrix, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VectorTimesScalarOp(result, vector, scalar, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Result Type must be a vector of floating-point type.

   The type of Vector must be the same as Result Type. Each component of
   Vector is multiplied by Scalar.

   Scalar must have the same type as the Component Type in Result Type.

   Example:
   --------

   .. code:: mlir

       %0 = spirv.VectorTimesScalar %vector, %scalar : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.VectorTimesScalar'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: scalar() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: VectorTimesScalar(result, vector, scalar, *, loc=None, ip=None) -> _ods_ir

.. py:class:: YieldOp(operand, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This op is a special terminator whose only purpose is to terminate
   an ``spirv.SpecConstantOperation``'s enclosed region. It accepts a
   single operand produced by the preceeding (and only other) instruction
   in its parent block (see SPIRV_SpecConstantOperation for further
   details). This op has no corresponding SPIR-V instruction.

   Example:
   --------

   .. code:: mlir

       %0 = ... (some op supported by SPIR-V OpSpecConstantOp)
       spirv.mlir.yield %0


   .. py:attribute:: OPERATION_NAME
      :value: 'spirv.mlir.yield'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


.. py:function:: mlir_yield(operand, *, loc=None, ip=None) -> YieldOp

