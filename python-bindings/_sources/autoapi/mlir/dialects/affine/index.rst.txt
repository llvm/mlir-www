mlir.dialects.affine
====================

.. py:module:: mlir.dialects.affine


Classes
-------

.. autoapisummary::

   mlir.dialects.affine.AffineApplyOp
   mlir.dialects.affine.AffineDelinearizeIndexOp
   mlir.dialects.affine.AffineForOp
   mlir.dialects.affine.AffineIfOp
   mlir.dialects.affine.AffineLinearizeIndexOp
   mlir.dialects.affine.AffineLoadOp
   mlir.dialects.affine.AffineMaxOp
   mlir.dialects.affine.AffineMinOp
   mlir.dialects.affine.AffineParallelOp
   mlir.dialects.affine.AffinePrefetchOp
   mlir.dialects.affine.AffineStoreOp
   mlir.dialects.affine.AffineVectorLoadOp
   mlir.dialects.affine.AffineVectorStoreOp
   mlir.dialects.affine.AffineYieldOp
   mlir.dialects.affine.AffineForOp
   mlir.dialects.affine.AffineIfOp


Functions
---------

.. autoapisummary::

   mlir.dialects.affine.apply
   mlir.dialects.affine.delinearize_index
   mlir.dialects.affine.for_
   mlir.dialects.affine.if_
   mlir.dialects.affine.linearize_index
   mlir.dialects.affine.load
   mlir.dialects.affine.max
   mlir.dialects.affine.min
   mlir.dialects.affine.parallel
   mlir.dialects.affine.prefetch
   mlir.dialects.affine.store
   mlir.dialects.affine.vector_load
   mlir.dialects.affine.vector_store
   mlir.dialects.affine.yield_
   mlir.dialects.affine.for_


Module Contents
---------------

.. py:class:: AffineApplyOp(map, mapOperands, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.apply`` operation applies an `affine mapping <#affine-maps>`_
   to a list of SSA values, yielding a single SSA value. The number of
   dimension and symbol operands to ``affine.apply`` must be equal to the
   respective number of dimensional and symbolic inputs to the affine mapping;
   the affine mapping has to be one-dimensional, and so the ``affine.apply``
   operation always returns one value. The input operands and result must all
   have ‘index’ type.

   An operand that is a valid dimension as per the `rules on valid affine
   dimensions and symbols <#restrictions-on-dimensions-and-symbols>`_
   cannot be used as a symbolic operand.

   Example:

   .. code:: mlir

       #map = affine_map<(d0, d1) -> (d0 floordiv 8 + d1 floordiv 128)>
       ...
       %1 = affine.apply #map (%s, %t)
       
       // Inline example.
       %2 = affine.apply affine_map<(i)[s0] -> (i + s0)> (%42)[%n]


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.apply'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: mapOperands() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: apply(map, map_operands, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineDelinearizeIndexOp(multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.delinearize_index`` operation takes a single index value and
   calculates the multi-index according to the given basis.

   Example:

   .. code::

       %indices:3 = affine.delinearize_index %linear_index into (%c16, %c224, %c224) : index, index, index

   In the above example, ``%indices:3`` conceptually holds the following:

   .. code::

       #map0 = affine_map<()[s0] -> (s0 floordiv 50176)>
       #map1 = affine_map<()[s0] -> ((s0 mod 50176) floordiv 224)>
       #map2 = affine_map<()[s0] -> (s0 mod 224)>
       %indices_0 = affine.apply #map0()[%linear_index]
       %indices_1 = affine.apply #map1()[%linear_index]
       %indices_2 = affine.apply #map2()[%linear_index]

   In other words, ``%0:3 = affine.delinearize_index %x into (B, C)`` produces
   ``%0 = {%x / (B * C), (%x mod (B * C)) / C, %x mod C}``.

   The basis may either contain ``N`` or ``N-1`` elements, where ``N`` is the number of results.
   If there are N basis elements, the first one will not be used during computations,
   but may be used during analysis and canonicalization to eliminate terms from
   the ``affine.delinearize_index`` or to enable conclusions about the total size of
   ``%linear_index``.

   If the basis is fully provided, the delinearize_index operation is said to "have
   an outer bound". The builders assume that an ``affine.delinearize_index`` has
   an outer bound by default, as this is how the operation was initially defined.

   That is, the example above could also have been written

   .. code:: mlir

       %0:3 = affine.delinearize_index %linear_index into (244, 244) : index, index

   Note that, for symmetry with ``getPaddedBasis()``, if ``hasOuterBound`` is ``true``
   when one of the ``OpFoldResult`` builders is called but the first element of the
   basis is ``nullptr``, that first element is ignored and the builder proceeds as if
   there was no outer bound.

   Due to the constraints of affine maps, all the basis elements must
   be strictly positive. A dynamic basis element being 0 or negative causes
   undefined behavior.

   As with other affine operations, lowerings of delinearize_index may assume
   that the underlying computations do not overflow the index type in a signed sense

   * that is, the product of all basis elements is positive as an ``index`` as well.


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.delinearize_index'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: linear_index() -> _ods_ir[_ods_ir]


   .. py:method:: dynamic_basis() -> _ods_ir


   .. py:method:: static_basis() -> _ods_ir


   .. py:method:: multi_index() -> _ods_ir


.. py:function:: delinearize_index(multi_index, linear_index, dynamic_basis, static_basis, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, AffineDelinearizeIndexOp]

.. py:class:: AffineForOp(results_, lowerBoundOperands, upperBoundOperands, inits, lowerBoundMap, upperBoundMap, step, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Syntax:

   .. code::

       operation   ::= `affine.for` ssa-id `=` lower-bound `to` upper-bound
                       (`step` integer-literal)? `{` op* `}`
       
       lower-bound ::= `max`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
       upper-bound ::= `min`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
       shorthand-bound ::= ssa-id | `-`? integer-literal

   The ``affine.for`` operation represents an affine loop nest. It has one region
   containing its body. This region must contain one block that terminates with
   ```affine.yield`` <#affineyield-mliraffineyieldop>`_. *Note:* when
   ``affine.for`` is printed in custom format, the terminator is omitted. The
   block has one argument of ```index`` <Builtin.md/#indextype>`_ type that
   represents the induction variable of the loop.

   The ``affine.for`` operation executes its body a number of times iterating
   from a lower bound to an upper bound by a stride. The stride, represented by
   ``step``, is a positive constant integer which defaults to "1" if not present.
   The lower and upper bounds specify a half-open range: the range includes the
   lower bound but does not include the upper bound.

   The lower and upper bounds of a ``affine.for`` operation are represented as an
   application of an affine mapping to a list of SSA values passed to the map.
   The `same restrictions <#restrictions-on-dimensions-and-symbols>`_ hold for
   these SSA values as for all bindings of SSA values to dimensions and
   symbols.

   The affine mappings for the bounds may return multiple results, in which
   case the ``max``/``min`` keywords are required (for the lower/upper bound
   respectively), and the bound is the maximum/minimum of the returned values.
   There is no semantic ambiguity, but MLIR syntax requires the use of these
   keywords to make things more obvious to human readers.

   Many upper and lower bounds are simple, so MLIR accepts two custom form
   syntaxes: the form that accepts a single 'ssa-id' (e.g. ``%N``) is shorthand
   for applying that SSA value to a function that maps a single symbol to
   itself, e.g., ``()[s]->(s)()[%N]``. The integer literal form (e.g. ``-42``) is
   shorthand for a nullary mapping function that returns the constant value
   (e.g. ``()->(-42)()``).

   Example showing reverse iteration of the inner loop:

   .. code:: mlir

       #map57 = affine_map<(d0)[s0] -> (s0 - d0 - 1)>
       
       func.func @simple_example(%A: memref<?x?xf32>, %B: memref<?x?xf32>) {
         %N = dim %A, 0 : memref<?x?xf32>
         affine.for %i = 0 to %N step 1 {
           affine.for %j = 0 to %N {   // implicitly steps by 1
             %0 = affine.apply #map57(%j)[%N]
             %tmp = call @F1(%A, %i, %0) : (memref<?x?xf32>, index, index)->(f32)
             call @F2(%tmp, %B, %i, %0) : (f32, memref<?x?xf32>, index, index)->()
           }
         }
         return
       }

   ``affine.for`` can also operate on loop-carried variables (``iter_args``) and
   return the final values after loop termination. The initial values of the
   variables are passed as additional SSA operands to the ``affine.for``
   following the operands for the loop's lower and upper bounds. The
   operation's region has equivalent arguments for each variable representing
   the value of the variable at the current iteration.

   The region must terminate with an ``affine.yield`` that passes all the current
   iteration variables to the next iteration, or to the ``affine.for``'s results
   if at the last iteration. For ``affine.for``'s that execute zero iterations, the
   initial values of the loop-carried variables (corresponding to the SSA
   operands) will be the op's results.

   For example, to sum-reduce a memref:

   .. code:: mlir

       func.func @reduce(%buffer: memref<1024xf32>) -> (f32) {
        // Initial sum set to 0.
        %sum_0 = arith.constant 0.0 : f32
        // iter_args binds initial values to the loop's region arguments.
        %sum = affine.for %i = 0 to 10 step 2
            iter_args(%sum_iter = %sum_0) -> (f32) {
          %t = affine.load %buffer[%i] : memref<1024xf32>
          %sum_next = arith.addf %sum_iter, %t : f32
          // Yield current iteration sum to next iteration %sum_iter or to %sum
          // if final iteration.
          affine.yield %sum_next : f32
        }
        return %sum : f32
       }

   .. code:: mlir

       %res:2 = affine.for %i = 0 to 128 iter_args(%arg0 = %init0, %arg1 = %init1)
                  -> (index, index) {
         %y0 = arith.addi %arg0, %c1 : index
         %y1 = arith.addi %arg1, %c2 : index
         affine.yield %y0, %y1 : index, index
       }

   If the ``affine.for`` defines any values, a yield terminator must be
   explicitly present. The number and types of the "affine.for" results must
   match the initial values in the ``iter_args`` binding and the yield operands.


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.for'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: lowerBoundOperands() -> _ods_ir


   .. py:method:: upperBoundOperands() -> _ods_ir


   .. py:method:: inits() -> _ods_ir


   .. py:method:: lowerBoundMap() -> _ods_ir


   .. py:method:: upperBoundMap() -> _ods_ir


   .. py:method:: step() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


   .. py:method:: region() -> _ods_ir


.. py:function:: for_(results_, lower_bound_operands, upper_bound_operands, inits, lower_bound_map, upper_bound_map, step, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, AffineForOp]

.. py:class:: AffineIfOp(results_, _gen_arg_0, condition, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Syntax:

   .. code::

       operation  ::= `affine.if` if-op-cond `{` op* `}` (`else` `{` op* `}`)?
       if-op-cond ::= integer-set-attr dim-and-symbol-use-list

   The ``affine.if`` operation restricts execution to a subset of the loop
   iteration space defined by an integer set (a conjunction of affine
   constraints). A single ``affine.if`` may end with an optional ``else`` clause.

   The condition of the ``affine.if`` is represented by an
   `integer set <#integer-sets>`_ (a conjunction of affine constraints),
   and the SSA values bound to the dimensions and symbols in the integer set.
   The `same restrictions <#restrictions-on-dimensions-and-symbols>`_ hold for
   these SSA values as for all bindings of SSA values to dimensions and
   symbols.

   The ``affine.if`` operation contains two regions for the "then" and "else"
   clauses.  ``affine.if`` may return results that are defined in its regions.
   The values defined are determined by which execution path is taken.  Each
   region of the ``affine.if`` must contain a single block with no arguments,
   and be terminated by ``affine.yield``.  If ``affine.if`` defines no values,
   the ``affine.yield`` can be left out, and will be inserted implicitly.
   Otherwise, it must be explicit.  If no values are defined, the else block
   may be empty (i.e. contain no blocks).

   Example:

   .. code:: mlir

       #set = affine_set<(d0, d1)[s0]: (d0 - 10 >= 0, s0 - d0 - 9 >= 0,
                                        d1 - 10 >= 0, s0 - d1 - 9 >= 0)>
       func.func @reduced_domain_example(%A, %X, %N) : (memref<10xi32>, i32, i32) {
         affine.for %i = 0 to %N {
            affine.for %j = 0 to %N {
              %0 = affine.apply #map42(%j)
              %tmp = call @S1(%X, %i, %0)
              affine.if #set(%i, %j)[%N] {
                 %1 = affine.apply #map43(%i, %j)
                 call @S2(%tmp, %A, %i, %1)
              }
           }
         }
         return
       }

   Example with an explicit yield (initialization with edge padding):

   .. code:: mlir

       #interior = affine_set<(i, j) : (i - 1 >= 0, j - 1 >= 0,  10 - i >= 0, 10 - j >= 0)> (%i, %j)
       func.func @pad_edges(%I : memref<10x10xf32>) -> (memref<12x12xf32) {
         %O = alloc memref<12x12xf32>
         affine.parallel (%i, %j) = (0, 0) to (12, 12) {
           %1 = affine.if #interior (%i, %j) {
             %2 = load %I[%i - 1, %j - 1] : memref<10x10xf32>
             affine.yield %2
           } else {
             %2 = arith.constant 0.0 : f32
             affine.yield %2 : f32
           }
           affine.store %1, %O[%i, %j] : memref<12x12xf32>
         }
         return %O
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.if'



   .. py:attribute:: _ODS_REGIONS
      :value: (2, True)



   .. py:method:: condition() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


   .. py:method:: thenRegion() -> _ods_ir


   .. py:method:: elseRegion() -> _ods_ir


.. py:function:: if_(results_, _gen_arg_0, condition, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, AffineIfOp]

.. py:class:: AffineLinearizeIndexOp(multi_index, dynamic_basis, static_basis, disjoint, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.linearize_index`` operation takes a sequence of index values and a
   basis of the same length and linearizes the indices using that basis.

   That is, for indices ``%idx_0`` to ``%idx_{N-1}`` and basis elements ``b_0``
   (or ``b_1``) up to ``b_{N-1}`` it computes

   .. code::

       sum(i = 0 to N-1) %idx_i * product(j = i + 1 to N-1) B_j

   In other words, ``%0 = affine.linearize_index [%z, %y, %x] by (Z, Y, X)``
   gives ``%0 = %x + %y * X + %z * X * Y``, or ``%0 = %x + X * (%y + Y * (%z))``.

   The basis may either have ``N`` or ``N-1`` elements, where ``N`` is the number of
   inputs to linearize_index. If ``N`` inputs are provided, the first one is not used
   in computation, but may be used during analysis or canonicalization as a bound
   on ``%idx_0``.

   If all ``N`` basis elements are provided, the linearize_index operation is said to
   "have an outer bound".

   As a convenience, and for symmetry with ``getPaddedBasis()``, if the first
   element of a set of ``OpFoldResult``s passed to the builders of this operation is
   ``nullptr``, that element is ignored.

   If the ``disjoint`` property is present, this is an optimization hint that,
   for all ``i``, ``0 <= %idx_i < B_i`` - that is, no index affects any other index,
   except that ``%idx_0`` may be negative to make the index as a whole negative.
   In addition, ``disjoint`` is an assertion that all bases elements are non-negative.

   Note that the outputs of ``affine.delinearize_index`` are, by definition, ``disjoint``.

   As with other affine ops, undefined behavior occurs if the linearization
   computation overflows in the signed sense.

   Example:

   .. code:: mlir

       %linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (2, 3, 5) : index
       // Same effect
       %linear_index = affine.linearize_index [%index_0, %index_1, %index_2] by (3, 5) : index

   In the above example, ``%linear_index`` conceptually holds the following:

   .. code:: mlir

       #map = affine_map<()[s0, s1, s2] -> (s0 * 15 + s1 * 5 + s2)>
       %linear_index = affine.apply #map()[%index_0, %index_1, %index_2]


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.linearize_index'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: multi_index() -> _ods_ir


   .. py:method:: dynamic_basis() -> _ods_ir


   .. py:method:: static_basis() -> _ods_ir


   .. py:method:: linear_index() -> _ods_ir[_ods_ir]


.. py:function:: linearize_index(multi_index, dynamic_basis, static_basis, disjoint, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineLoadOp(result, memref, indices, map, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Syntax:

   .. code::

       operation ::= ssa-id `=` `affine.load` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type

   The ``affine.load`` op reads an element from a memref, where the index
   for each memref dimension is an affine expression of loop induction
   variables and symbols. The output of ``affine.load`` is a new value with the
   same type as the elements of the memref. An affine expression of loop IVs
   and symbols must be specified for each dimension of the memref. The keyword
   ``symbol`` can be used to indicate SSA identifiers which are symbolic.

   Example 1:

   .. code:: mlir

       %1 = affine.load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>

   Example 2: Uses ``symbol`` keyword for symbols ``%n`` and ``%m``.

   .. code:: mlir

       %1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: memref() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: map() -> _ods_ir


   .. py:method:: result() -> _ods_ir

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineMaxOp(map, operands_, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.max`` operation computes the maximum value result from a multi-result
   affine map.

   Example:

   .. code:: mlir

       %0 = affine.max (d0) -> (1000, d0 + 512) (%i0) : index


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.max'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: max(map, operands_, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineMinOp(map, operands_, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Syntax:

   .. code::

       operation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list

   The ``affine.min`` operation applies an `affine mapping <#affine-expressions>`_
   to a list of SSA values, and returns the minimum value of all result
   expressions. The number of dimension and symbol arguments to ``affine.min``
   must be equal to the respective number of dimensional and symbolic inputs to
   the affine mapping; the ``affine.min`` operation always returns one value. The
   input operands and result must all have 'index' type.

   Example:

   .. code:: mlir

       %0 = affine.min affine_map<(d0)[s0] -> (1000, d0 + 512, s0)> (%arg0)[%arg1]


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.min'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: min(map, operands_, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineParallelOp(results_, reductions, lowerBoundsMap, lowerBoundsGroups, upperBoundsMap, upperBoundsGroups, steps, mapOperands, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.parallel`` operation represents a hyper-rectangular affine
   parallel band, defining zero or more SSA values for its induction variables.
   It has one region capturing the parallel band body. The induction variables
   are represented as arguments of this region. These SSA values always have
   type index, which is the size of the machine word. The strides, represented
   by steps, are positive constant integers which defaults to "1" if not
   present. The lower and upper bounds specify a half-open range: the range
   includes the lower bound but does not include the upper bound. The body
   region must contain exactly one block that terminates with ``affine.yield``.

   The lower and upper bounds of a parallel operation are represented as an
   application of an affine mapping to a list of SSA values passed to the map.
   The same restrictions hold for these SSA values as for all bindings of SSA
   values to dimensions and symbols. The list of expressions in each map is
   interpreted according to the respective bounds group attribute. If a single
   expression belongs to the group, then the result of this expression is taken
   as a lower(upper) bound of the corresponding loop induction variable. If
   multiple expressions belong to the group, then the lower(upper) bound is the
   max(min) of these values obtained from these expressions. The loop band has
   as many loops as elements in the group bounds attributes.

   Each value yielded by ``affine.yield`` will be accumulated/reduced via one of
   the reduction methods defined in the AtomicRMWKind enum.  The order of
   reduction is unspecified, and lowering may produce any valid ordering.
   Loops with a 0 trip count will produce as a result the identity value
   associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf).  Assign
   reductions for loops with a trip count != 1 produces undefined results.

   Note: Calling ``AffineParallelOp::build`` will create the required region and
   block, and insert the required terminator if it is trivial (i.e. no values
   are yielded).  Parsing will also create the required region, block, and
   terminator, even when they are missing from the textual representation.

   Example (3x3 valid convolution):

   .. code:: mlir

       func.func @conv_2d(%D : memref<100x100xf32>, %K : memref<3x3xf32>) -> (memref<98x98xf32>) {
         %O = memref.alloc() : memref<98x98xf32>
         affine.parallel (%x, %y) = (0, 0) to (98, 98) {
           %0 = affine.parallel (%kx, %ky) = (0, 0) to (2, 2) reduce ("addf") -> f32 {
             %1 = affine.load %D[%x + %kx, %y + %ky] : memref<100x100xf32>
             %2 = affine.load %K[%kx, %ky] : memref<3x3xf32>
             %3 = arith.mulf %1, %2 : f32
             affine.yield %3 : f32
           }
           affine.store %0, %O[%x, %y] : memref<98x98xf32>
         }
         return %O : memref<98x98xf32>
       }

   Example (tiling by potentially imperfectly dividing sizes):

   .. code:: mlir

       affine.parallel (%ii, %jj) = (0, 0) to (%N, %M) step (32, 32) {
         affine.parallel (%i, %j) = (%ii, %jj)
                                 to (min(%ii + 32, %N), min(%jj + 32, %M)) {
           call @f(%i, %j) : (index, index) -> ()
         }
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.parallel'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: mapOperands() -> _ods_ir


   .. py:method:: reductions() -> _ods_ir


   .. py:method:: lowerBoundsMap() -> _ods_ir


   .. py:method:: lowerBoundsGroups() -> _ods_ir


   .. py:method:: upperBoundsMap() -> _ods_ir


   .. py:method:: upperBoundsGroups() -> _ods_ir


   .. py:method:: steps() -> _ods_ir


   .. py:method:: results_() -> _ods_ir


   .. py:method:: region() -> _ods_ir


.. py:function:: parallel(results_, reductions, lower_bounds_map, lower_bounds_groups, upper_bounds_map, upper_bounds_groups, steps, map_operands, *, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, AffineParallelOp]

.. py:class:: AffinePrefetchOp(memref, indices, isWrite, localityHint, isDataCache, map, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.prefetch`` op prefetches data from a memref location described
   with an affine subscript similar to affine.load, and has three attributes:
   a read/write specifier, a locality hint, and a cache type specifier as shown
   below:

   .. code:: mlir

       affine.prefetch %0[%i, %j + 5], read, locality<3>, data : memref<400x400xi32>

   The read/write specifier is either 'read' or 'write', the locality hint
   specifier ranges from locality<0> (no locality) to locality<3> (extremely
   local keep in cache). The cache type specifier is either 'data' or 'instr'
   and specifies whether the prefetch is performed on data cache or on
   instruction cache.


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.prefetch'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: memref() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: isWrite() -> _ods_ir


   .. py:method:: localityHint() -> _ods_ir


   .. py:method:: isDataCache() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: prefetch(memref, indices, is_write, locality_hint, is_data_cache, map, *, loc=None, ip=None) -> AffinePrefetchOp

.. py:class:: AffineStoreOp(value, memref, indices, map, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Syntax:

   .. code::

       operation ::= `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type

   The ``affine.store`` op writes an element to a memref, where the index
   for each memref dimension is an affine expression of loop induction
   variables and symbols. The ``affine.store`` op stores a new value which is the
   same type as the elements of the memref. An affine expression of loop IVs
   and symbols must be specified for each dimension of the memref. The keyword
   ``symbol`` can be used to indicate SSA identifiers which are symbolic.

   Example 1:

   .. code:: mlir

       affine.store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>

   Example 2: Uses ``symbol`` keyword for symbols ``%n`` and ``%m``.

   .. code:: mlir

       affine.store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: memref() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: store(value, memref, indices, map, *, loc=None, ip=None) -> AffineStoreOp

.. py:class:: AffineVectorLoadOp(result, memref, indices, map, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.vector_load`` is the vector counterpart of
   `affine.load <#affineload-mliraffineloadop>`_. It reads a slice from a
   `MemRef <Builtin.md/#memreftype>`_, supplied as its first operand,
   into a `vector <Builtin.md/#vectortype>`_ of the same base elemental type.
   The index for each memref dimension is an affine expression of loop induction
   variables and symbols. These indices determine the start position of the read
   within the memref. The shape of the return vector type determines the shape of
   the slice read from the memref. This slice is contiguous along the respective
   dimensions of the shape. Strided vector loads will be supported in the future.
   An affine expression of loop IVs and symbols must be specified for each
   dimension of the memref. The keyword ``symbol`` can be used to indicate SSA
   identifiers which are symbolic.

   Example 1: 8-wide f32 vector load.

   .. code:: mlir

       %1 = affine.vector_load %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>

   Example 2: 4-wide f32 vector load. Uses ``symbol`` keyword for symbols ``%n`` and ``%m``.

   .. code:: mlir

       %1 = affine.vector_load %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>

   Example 3: 2-dim f32 vector load.

   .. code:: mlir

       %1 = affine.vector_load %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>

   TODOs:

   * Add support for strided vector loads.
   * Consider adding a permutation map to permute the slice that is read from memory
   (see `vector.transfer_read <../Vector/#vectortransfer_read-mlirvectortransferreadop>`_).


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.vector_load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: memref() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: map() -> _ods_ir


   .. py:method:: result() -> _ods_ir[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: vector_load(result, memref, indices, map, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AffineVectorStoreOp(value, memref, indices, map, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.vector_store`` is the vector counterpart of
   `affine.store <#affinestore-mliraffinestoreop>`_. It writes a
   `vector <Builtin.md/#vectortype>`_, supplied as its first operand,
   into a slice within a `MemRef <Builtin.md/#memreftype>`_ of the same base
   elemental type, supplied as its second operand.
   The index for each memref dimension is an affine expression of loop
   induction variables and symbols. These indices determine the start position
   of the write within the memref. The shape of the input vector determines the
   shape of the slice written to the memref. This slice is contiguous along the
   respective dimensions of the shape. Strided vector stores will be supported
   in the future.
   An affine expression of loop IVs and symbols must be specified for each
   dimension of the memref. The keyword ``symbol`` can be used to indicate SSA
   identifiers which are symbolic.

   Example 1: 8-wide f32 vector store.

   .. code:: mlir

       affine.vector_store %v0, %0[%i0 + 3, %i1 + 7] : memref<100x100xf32>, vector<8xf32>

   Example 2: 4-wide f32 vector store. Uses ``symbol`` keyword for symbols ``%n`` and ``%m``.

   .. code:: mlir

       affine.vector_store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)] : memref<100x100xf32>, vector<4xf32>

   Example 3: 2-dim f32 vector store.

   .. code:: mlir

       affine.vector_store %v0, %0[%i0, %i1] : memref<100x100xf32>, vector<2x8xf32>

   TODOs:

   * Add support for strided vector stores.
   * Consider adding a permutation map to permute the slice that is written to memory
   (see `vector.transfer_write <../Vector/#vectortransfer_write-mlirvectortransferwriteop>`_).


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.vector_store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: memref() -> _ods_ir[_ods_ir]


   .. py:method:: indices() -> _ods_ir


   .. py:method:: map() -> _ods_ir


.. py:function:: vector_store(value, memref, indices, map, *, loc=None, ip=None) -> AffineVectorStoreOp

.. py:class:: AffineYieldOp(operands_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``affine.yield`` yields zero or more SSA values from an affine op region and
   terminates the region. The semantics of how the values yielded are used
   is defined by the parent operation.
   If ``affine.yield`` has any operands, the operands must match the parent
   operation's results.
   If the parent operation defines no values, then the ``affine.yield`` may be
   left out in the custom syntax and the builders will insert one implicitly.
   Otherwise, it has to be present in the syntax to indicate which values are
   yielded.


   .. py:attribute:: OPERATION_NAME
      :value: 'affine.yield'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


.. py:function:: yield_(operands_, *, loc=None, ip=None) -> AffineYieldOp

.. py:class:: AffineForOp(lower_bound: Union[int, mlir.dialects._ods_common.ResultValueT, AffineMap], upper_bound: Optional[Union[int, mlir.dialects._ods_common.ResultValueT, AffineMap]], step: Optional[Union[int, Attribute]] = None, iter_args: Optional[mlir.dialects._ods_common.ResultValueT] = None, *, lower_bound_operands: Optional[mlir.dialects._ods_common.VariadicResultValueT] = None, upper_bound_operands: Optional[mlir.dialects._ods_common.VariadicResultValueT] = None, loc=None, ip=None)

   Bases: :py:obj:`AffineForOp`


   
   Specialization for the Affine for op class.


   .. py:property:: body

      
      Returns the body (block) of the loop.



   .. py:property:: induction_variable

      
      Returns the induction variable of the loop.



   .. py:property:: inner_iter_args

      
      Returns the loop-carried arguments usable within the loop.

      To obtain the loop-carried operands, use ``iter_args``.



.. py:function:: for_(start, stop, step=None, iter_args: Optional[Sequence[Value]] = None, *, loc=None, ip=None)

.. py:class:: AffineIfOp(cond: IntegerSet, results_: Optional[Type] = None, *, cond_operands: Optional[mlir.dialects._ods_common.VariadicResultValueT] = None, has_else: bool = False, loc=None, ip=None)

   Bases: :py:obj:`AffineIfOp`


   
   Specialization for the Affine if op class.


   .. py:property:: then_block
      :type: Block


      
      Returns the then block of the if operation.



   .. py:property:: else_block
      :type: Optional[Block]


      
      Returns the else block of the if operation.



