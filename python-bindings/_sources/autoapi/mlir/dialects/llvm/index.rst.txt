mlir.dialects.llvm
==================

.. py:module:: mlir.dialects.llvm


Classes
-------

.. autoapisummary::

   mlir.dialects.llvm.ACosOp
   mlir.dialects.llvm.AShrOp
   mlir.dialects.llvm.ASinOp
   mlir.dialects.llvm.ATan2Op
   mlir.dialects.llvm.ATanOp
   mlir.dialects.llvm.AbsOp
   mlir.dialects.llvm.AddOp
   mlir.dialects.llvm.AddrSpaceCastOp
   mlir.dialects.llvm.AddressOfOp
   mlir.dialects.llvm.AliasOp
   mlir.dialects.llvm.AllocaOp
   mlir.dialects.llvm.AndOp
   mlir.dialects.llvm.Annotation
   mlir.dialects.llvm.AssumeOp
   mlir.dialects.llvm.AtomicCmpXchgOp
   mlir.dialects.llvm.AtomicRMWOp
   mlir.dialects.llvm.BitReverseOp
   mlir.dialects.llvm.BitcastOp
   mlir.dialects.llvm.BlockAddressOp
   mlir.dialects.llvm.BlockTagOp
   mlir.dialects.llvm.BrOp
   mlir.dialects.llvm.ByteSwapOp
   mlir.dialects.llvm.CallIntrinsicOp
   mlir.dialects.llvm.CallOp
   mlir.dialects.llvm.ComdatOp
   mlir.dialects.llvm.ComdatSelectorOp
   mlir.dialects.llvm.CondBrOp
   mlir.dialects.llvm.ConstantOp
   mlir.dialects.llvm.ConstrainedFPExtIntr
   mlir.dialects.llvm.ConstrainedFPTruncIntr
   mlir.dialects.llvm.ConstrainedSIToFP
   mlir.dialects.llvm.ConstrainedUIToFP
   mlir.dialects.llvm.CopySignOp
   mlir.dialects.llvm.CoroAlignOp
   mlir.dialects.llvm.CoroBeginOp
   mlir.dialects.llvm.CoroEndOp
   mlir.dialects.llvm.CoroFreeOp
   mlir.dialects.llvm.CoroIdOp
   mlir.dialects.llvm.CoroPromiseOp
   mlir.dialects.llvm.CoroResumeOp
   mlir.dialects.llvm.CoroSaveOp
   mlir.dialects.llvm.CoroSizeOp
   mlir.dialects.llvm.CoroSuspendOp
   mlir.dialects.llvm.CosOp
   mlir.dialects.llvm.CoshOp
   mlir.dialects.llvm.CountLeadingZerosOp
   mlir.dialects.llvm.CountTrailingZerosOp
   mlir.dialects.llvm.CtPopOp
   mlir.dialects.llvm.DSOLocalEquivalentOp
   mlir.dialects.llvm.DbgDeclareOp
   mlir.dialects.llvm.DbgLabelOp
   mlir.dialects.llvm.DbgValueOp
   mlir.dialects.llvm.DebugTrap
   mlir.dialects.llvm.EhTypeidForOp
   mlir.dialects.llvm.Exp2Op
   mlir.dialects.llvm.Exp10Op
   mlir.dialects.llvm.ExpOp
   mlir.dialects.llvm.ExpectOp
   mlir.dialects.llvm.ExpectWithProbabilityOp
   mlir.dialects.llvm.ExtractElementOp
   mlir.dialects.llvm.ExtractValueOp
   mlir.dialects.llvm.FAbsOp
   mlir.dialects.llvm.FAddOp
   mlir.dialects.llvm.FCeilOp
   mlir.dialects.llvm.FCmpOp
   mlir.dialects.llvm.FDivOp
   mlir.dialects.llvm.FFloorOp
   mlir.dialects.llvm.FMAOp
   mlir.dialects.llvm.FMulAddOp
   mlir.dialects.llvm.FMulOp
   mlir.dialects.llvm.FNegOp
   mlir.dialects.llvm.FPExtOp
   mlir.dialects.llvm.FPToSIOp
   mlir.dialects.llvm.FPToUIOp
   mlir.dialects.llvm.FPTruncOp
   mlir.dialects.llvm.FRemOp
   mlir.dialects.llvm.FSubOp
   mlir.dialects.llvm.FTruncOp
   mlir.dialects.llvm.FenceOp
   mlir.dialects.llvm.FractionExpOp
   mlir.dialects.llvm.FreezeOp
   mlir.dialects.llvm.FshlOp
   mlir.dialects.llvm.FshrOp
   mlir.dialects.llvm.GEPOp
   mlir.dialects.llvm.GetActiveLaneMaskOp
   mlir.dialects.llvm.GlobalCtorsOp
   mlir.dialects.llvm.GlobalDtorsOp
   mlir.dialects.llvm.GlobalOp
   mlir.dialects.llvm.ICmpOp
   mlir.dialects.llvm.IFuncOp
   mlir.dialects.llvm.IndirectBrOp
   mlir.dialects.llvm.InlineAsmOp
   mlir.dialects.llvm.InsertElementOp
   mlir.dialects.llvm.InsertValueOp
   mlir.dialects.llvm.IntToPtrOp
   mlir.dialects.llvm.InvariantEndOp
   mlir.dialects.llvm.InvariantStartOp
   mlir.dialects.llvm.InvokeOp
   mlir.dialects.llvm.IsConstantOp
   mlir.dialects.llvm.IsFPClass
   mlir.dialects.llvm.LLVMFuncOp
   mlir.dialects.llvm.LShrOp
   mlir.dialects.llvm.LandingpadOp
   mlir.dialects.llvm.LaunderInvariantGroupOp
   mlir.dialects.llvm.LifetimeEndOp
   mlir.dialects.llvm.LifetimeStartOp
   mlir.dialects.llvm.LinkerOptionsOp
   mlir.dialects.llvm.LlrintOp
   mlir.dialects.llvm.LlroundOp
   mlir.dialects.llvm.LoadExpOp
   mlir.dialects.llvm.LoadOp
   mlir.dialects.llvm.Log2Op
   mlir.dialects.llvm.Log10Op
   mlir.dialects.llvm.LogOp
   mlir.dialects.llvm.LrintOp
   mlir.dialects.llvm.LroundOp
   mlir.dialects.llvm.MaskedLoadOp
   mlir.dialects.llvm.MaskedStoreOp
   mlir.dialects.llvm.MatrixColumnMajorLoadOp
   mlir.dialects.llvm.MatrixColumnMajorStoreOp
   mlir.dialects.llvm.MatrixMultiplyOp
   mlir.dialects.llvm.MatrixTransposeOp
   mlir.dialects.llvm.MaxNumOp
   mlir.dialects.llvm.MaximumOp
   mlir.dialects.llvm.MemcpyInlineOp
   mlir.dialects.llvm.MemcpyOp
   mlir.dialects.llvm.MemmoveOp
   mlir.dialects.llvm.MemsetInlineOp
   mlir.dialects.llvm.MemsetOp
   mlir.dialects.llvm.MinNumOp
   mlir.dialects.llvm.MinimumOp
   mlir.dialects.llvm.ModuleFlagsOp
   mlir.dialects.llvm.MulOp
   mlir.dialects.llvm.NearbyintOp
   mlir.dialects.llvm.NoAliasScopeDeclOp
   mlir.dialects.llvm.NoneTokenOp
   mlir.dialects.llvm.OrOp
   mlir.dialects.llvm.PoisonOp
   mlir.dialects.llvm.PowIOp
   mlir.dialects.llvm.PowOp
   mlir.dialects.llvm.Prefetch
   mlir.dialects.llvm.PtrAnnotation
   mlir.dialects.llvm.PtrMaskOp
   mlir.dialects.llvm.PtrToIntOp
   mlir.dialects.llvm.ResumeOp
   mlir.dialects.llvm.ReturnOp
   mlir.dialects.llvm.RintOp
   mlir.dialects.llvm.RoundEvenOp
   mlir.dialects.llvm.RoundOp
   mlir.dialects.llvm.SAddSat
   mlir.dialects.llvm.SAddWithOverflowOp
   mlir.dialects.llvm.SCmpOp
   mlir.dialects.llvm.SDivOp
   mlir.dialects.llvm.SExtOp
   mlir.dialects.llvm.SIToFPOp
   mlir.dialects.llvm.SMaxOp
   mlir.dialects.llvm.SMinOp
   mlir.dialects.llvm.SMulWithOverflowOp
   mlir.dialects.llvm.SRemOp
   mlir.dialects.llvm.SSACopyOp
   mlir.dialects.llvm.SSHLSat
   mlir.dialects.llvm.SSubSat
   mlir.dialects.llvm.SSubWithOverflowOp
   mlir.dialects.llvm.SelectOp
   mlir.dialects.llvm.ShlOp
   mlir.dialects.llvm.ShuffleVectorOp
   mlir.dialects.llvm.SinOp
   mlir.dialects.llvm.SincosOp
   mlir.dialects.llvm.SinhOp
   mlir.dialects.llvm.SqrtOp
   mlir.dialects.llvm.StackRestoreOp
   mlir.dialects.llvm.StackSaveOp
   mlir.dialects.llvm.StepVectorOp
   mlir.dialects.llvm.StoreOp
   mlir.dialects.llvm.StripInvariantGroupOp
   mlir.dialects.llvm.SubOp
   mlir.dialects.llvm.SwitchOp
   mlir.dialects.llvm.TanOp
   mlir.dialects.llvm.TanhOp
   mlir.dialects.llvm.ThreadlocalAddressOp
   mlir.dialects.llvm.Trap
   mlir.dialects.llvm.TruncOp
   mlir.dialects.llvm.UAddSat
   mlir.dialects.llvm.UAddWithOverflowOp
   mlir.dialects.llvm.UBSanTrap
   mlir.dialects.llvm.UCmpOp
   mlir.dialects.llvm.UDivOp
   mlir.dialects.llvm.UIToFPOp
   mlir.dialects.llvm.UMaxOp
   mlir.dialects.llvm.UMinOp
   mlir.dialects.llvm.UMulWithOverflowOp
   mlir.dialects.llvm.URemOp
   mlir.dialects.llvm.USHLSat
   mlir.dialects.llvm.USubSat
   mlir.dialects.llvm.USubWithOverflowOp
   mlir.dialects.llvm.UndefOp
   mlir.dialects.llvm.UnreachableOp
   mlir.dialects.llvm.VPAShrOp
   mlir.dialects.llvm.VPAddOp
   mlir.dialects.llvm.VPAndOp
   mlir.dialects.llvm.VPFAddOp
   mlir.dialects.llvm.VPFDivOp
   mlir.dialects.llvm.VPFMulAddOp
   mlir.dialects.llvm.VPFMulOp
   mlir.dialects.llvm.VPFNegOp
   mlir.dialects.llvm.VPFPExtOp
   mlir.dialects.llvm.VPFPToSIOp
   mlir.dialects.llvm.VPFPToUIOp
   mlir.dialects.llvm.VPFPTruncOp
   mlir.dialects.llvm.VPFRemOp
   mlir.dialects.llvm.VPFSubOp
   mlir.dialects.llvm.VPFmaOp
   mlir.dialects.llvm.VPIntToPtrOp
   mlir.dialects.llvm.VPLShrOp
   mlir.dialects.llvm.VPLoadOp
   mlir.dialects.llvm.VPMergeMinOp
   mlir.dialects.llvm.VPMulOp
   mlir.dialects.llvm.VPOrOp
   mlir.dialects.llvm.VPPtrToIntOp
   mlir.dialects.llvm.VPReduceAddOp
   mlir.dialects.llvm.VPReduceAndOp
   mlir.dialects.llvm.VPReduceFAddOp
   mlir.dialects.llvm.VPReduceFMaxOp
   mlir.dialects.llvm.VPReduceFMinOp
   mlir.dialects.llvm.VPReduceFMulOp
   mlir.dialects.llvm.VPReduceMulOp
   mlir.dialects.llvm.VPReduceOrOp
   mlir.dialects.llvm.VPReduceSMaxOp
   mlir.dialects.llvm.VPReduceSMinOp
   mlir.dialects.llvm.VPReduceUMaxOp
   mlir.dialects.llvm.VPReduceUMinOp
   mlir.dialects.llvm.VPReduceXorOp
   mlir.dialects.llvm.VPSDivOp
   mlir.dialects.llvm.VPSExtOp
   mlir.dialects.llvm.VPSIToFPOp
   mlir.dialects.llvm.VPSMaxOp
   mlir.dialects.llvm.VPSMinOp
   mlir.dialects.llvm.VPSRemOp
   mlir.dialects.llvm.VPSelectMinOp
   mlir.dialects.llvm.VPShlOp
   mlir.dialects.llvm.VPStoreOp
   mlir.dialects.llvm.VPStridedLoadOp
   mlir.dialects.llvm.VPStridedStoreOp
   mlir.dialects.llvm.VPSubOp
   mlir.dialects.llvm.VPTruncOp
   mlir.dialects.llvm.VPUDivOp
   mlir.dialects.llvm.VPUIToFPOp
   mlir.dialects.llvm.VPUMaxOp
   mlir.dialects.llvm.VPUMinOp
   mlir.dialects.llvm.VPURemOp
   mlir.dialects.llvm.VPXorOp
   mlir.dialects.llvm.VPZExtOp
   mlir.dialects.llvm.VaArgOp
   mlir.dialects.llvm.VaCopyOp
   mlir.dialects.llvm.VaEndOp
   mlir.dialects.llvm.VaStartOp
   mlir.dialects.llvm.VarAnnotation
   mlir.dialects.llvm.XOrOp
   mlir.dialects.llvm.ZExtOp
   mlir.dialects.llvm.ZeroOp
   mlir.dialects.llvm.masked_compressstore
   mlir.dialects.llvm.masked_expandload
   mlir.dialects.llvm.masked_gather
   mlir.dialects.llvm.masked_scatter
   mlir.dialects.llvm.vector_deinterleave2
   mlir.dialects.llvm.vector_extract
   mlir.dialects.llvm.vector_insert
   mlir.dialects.llvm.vector_interleave2
   mlir.dialects.llvm.vector_reduce_add
   mlir.dialects.llvm.vector_reduce_and
   mlir.dialects.llvm.vector_reduce_fadd
   mlir.dialects.llvm.vector_reduce_fmax
   mlir.dialects.llvm.vector_reduce_fmaximum
   mlir.dialects.llvm.vector_reduce_fmin
   mlir.dialects.llvm.vector_reduce_fminimum
   mlir.dialects.llvm.vector_reduce_fmul
   mlir.dialects.llvm.vector_reduce_mul
   mlir.dialects.llvm.vector_reduce_or
   mlir.dialects.llvm.vector_reduce_smax
   mlir.dialects.llvm.vector_reduce_smin
   mlir.dialects.llvm.vector_reduce_umax
   mlir.dialects.llvm.vector_reduce_umin
   mlir.dialects.llvm.vector_reduce_xor
   mlir.dialects.llvm.vscale
   mlir.dialects.llvm.AsmDialect
   mlir.dialects.llvm.AtomicBinOp
   mlir.dialects.llvm.AtomicOrdering
   mlir.dialects.llvm.CConv
   mlir.dialects.llvm.Comdat
   mlir.dialects.llvm.DIFlags
   mlir.dialects.llvm.DISubprogramFlags
   mlir.dialects.llvm.FCmpPredicate
   mlir.dialects.llvm.FPExceptionBehavior
   mlir.dialects.llvm.FastmathFlags
   mlir.dialects.llvm.FramePointerKind
   mlir.dialects.llvm.GEPNoWrapFlags
   mlir.dialects.llvm.ICmpPredicate
   mlir.dialects.llvm.IntegerOverflowFlags
   mlir.dialects.llvm.DIEmissionKind
   mlir.dialects.llvm.DINameTableKind
   mlir.dialects.llvm.ProfileSummaryFormatKind
   mlir.dialects.llvm.Linkage
   mlir.dialects.llvm.ModFlagBehavior
   mlir.dialects.llvm.ModRefInfo
   mlir.dialects.llvm.RoundingMode
   mlir.dialects.llvm.TailCallKind
   mlir.dialects.llvm.UWTableKind
   mlir.dialects.llvm.UnnamedAddr
   mlir.dialects.llvm.Visibility


Functions
---------

.. autoapisummary::

   mlir.dialects.llvm.intr_acos
   mlir.dialects.llvm.ashr
   mlir.dialects.llvm.intr_asin
   mlir.dialects.llvm.intr_atan2
   mlir.dialects.llvm.intr_atan
   mlir.dialects.llvm.intr_abs
   mlir.dialects.llvm.add
   mlir.dialects.llvm.addrspacecast
   mlir.dialects.llvm.mlir_addressof
   mlir.dialects.llvm.mlir_alias
   mlir.dialects.llvm.alloca
   mlir.dialects.llvm.and_
   mlir.dialects.llvm.intr_annotation
   mlir.dialects.llvm.intr_assume
   mlir.dialects.llvm.cmpxchg
   mlir.dialects.llvm.atomicrmw
   mlir.dialects.llvm.intr_bitreverse
   mlir.dialects.llvm.bitcast
   mlir.dialects.llvm.blockaddress
   mlir.dialects.llvm.blocktag
   mlir.dialects.llvm.br
   mlir.dialects.llvm.intr_bswap
   mlir.dialects.llvm.call_intrinsic
   mlir.dialects.llvm.call
   mlir.dialects.llvm.comdat
   mlir.dialects.llvm.comdat_selector
   mlir.dialects.llvm.cond_br
   mlir.dialects.llvm.mlir_constant
   mlir.dialects.llvm.intr_experimental_constrained_fpext
   mlir.dialects.llvm.intr_experimental_constrained_fptrunc
   mlir.dialects.llvm.intr_experimental_constrained_sitofp
   mlir.dialects.llvm.intr_experimental_constrained_uitofp
   mlir.dialects.llvm.intr_copysign
   mlir.dialects.llvm.intr_coro_align
   mlir.dialects.llvm.intr_coro_begin
   mlir.dialects.llvm.intr_coro_end
   mlir.dialects.llvm.intr_coro_free
   mlir.dialects.llvm.intr_coro_id
   mlir.dialects.llvm.intr_coro_promise
   mlir.dialects.llvm.intr_coro_resume
   mlir.dialects.llvm.intr_coro_save
   mlir.dialects.llvm.intr_coro_size
   mlir.dialects.llvm.intr_coro_suspend
   mlir.dialects.llvm.intr_cos
   mlir.dialects.llvm.intr_cosh
   mlir.dialects.llvm.intr_ctlz
   mlir.dialects.llvm.intr_cttz
   mlir.dialects.llvm.intr_ctpop
   mlir.dialects.llvm.dso_local_equivalent
   mlir.dialects.llvm.intr_dbg_declare
   mlir.dialects.llvm.intr_dbg_label
   mlir.dialects.llvm.intr_dbg_value
   mlir.dialects.llvm.intr_debugtrap
   mlir.dialects.llvm.intr_eh_typeid_for
   mlir.dialects.llvm.intr_exp2
   mlir.dialects.llvm.intr_exp10
   mlir.dialects.llvm.intr_exp
   mlir.dialects.llvm.intr_expect
   mlir.dialects.llvm.intr_expect_with_probability
   mlir.dialects.llvm.extractelement
   mlir.dialects.llvm.extractvalue
   mlir.dialects.llvm.intr_fabs
   mlir.dialects.llvm.fadd
   mlir.dialects.llvm.intr_ceil
   mlir.dialects.llvm.fcmp
   mlir.dialects.llvm.fdiv
   mlir.dialects.llvm.intr_floor
   mlir.dialects.llvm.intr_fma
   mlir.dialects.llvm.intr_fmuladd
   mlir.dialects.llvm.fmul
   mlir.dialects.llvm.fneg
   mlir.dialects.llvm.fpext
   mlir.dialects.llvm.fptosi
   mlir.dialects.llvm.fptoui
   mlir.dialects.llvm.fptrunc
   mlir.dialects.llvm.frem
   mlir.dialects.llvm.fsub
   mlir.dialects.llvm.intr_trunc
   mlir.dialects.llvm.fence
   mlir.dialects.llvm.intr_frexp
   mlir.dialects.llvm.freeze
   mlir.dialects.llvm.intr_fshl
   mlir.dialects.llvm.intr_fshr
   mlir.dialects.llvm.getelementptr
   mlir.dialects.llvm.intr_get_active_lane_mask
   mlir.dialects.llvm.mlir_global_ctors
   mlir.dialects.llvm.mlir_global_dtors
   mlir.dialects.llvm.mlir_global
   mlir.dialects.llvm.icmp
   mlir.dialects.llvm.mlir_ifunc
   mlir.dialects.llvm.indirectbr
   mlir.dialects.llvm.inline_asm
   mlir.dialects.llvm.insertelement
   mlir.dialects.llvm.insertvalue
   mlir.dialects.llvm.inttoptr
   mlir.dialects.llvm.intr_invariant_end
   mlir.dialects.llvm.intr_invariant_start
   mlir.dialects.llvm.invoke
   mlir.dialects.llvm.intr_is_constant
   mlir.dialects.llvm.intr_is_fpclass
   mlir.dialects.llvm.func
   mlir.dialects.llvm.lshr
   mlir.dialects.llvm.landingpad
   mlir.dialects.llvm.intr_launder_invariant_group
   mlir.dialects.llvm.intr_lifetime_end
   mlir.dialects.llvm.intr_lifetime_start
   mlir.dialects.llvm.linker_options
   mlir.dialects.llvm.intr_llrint
   mlir.dialects.llvm.intr_llround
   mlir.dialects.llvm.intr_ldexp
   mlir.dialects.llvm.load
   mlir.dialects.llvm.intr_log2
   mlir.dialects.llvm.intr_log10
   mlir.dialects.llvm.intr_log
   mlir.dialects.llvm.intr_lrint
   mlir.dialects.llvm.intr_lround
   mlir.dialects.llvm.intr_masked_load
   mlir.dialects.llvm.intr_masked_store
   mlir.dialects.llvm.intr_matrix_column_major_load
   mlir.dialects.llvm.intr_matrix_column_major_store
   mlir.dialects.llvm.intr_matrix_multiply
   mlir.dialects.llvm.intr_matrix_transpose
   mlir.dialects.llvm.intr_maxnum
   mlir.dialects.llvm.intr_maximum
   mlir.dialects.llvm.intr_memcpy_inline
   mlir.dialects.llvm.intr_memcpy
   mlir.dialects.llvm.intr_memmove
   mlir.dialects.llvm.intr_memset_inline
   mlir.dialects.llvm.intr_memset
   mlir.dialects.llvm.intr_minnum
   mlir.dialects.llvm.intr_minimum
   mlir.dialects.llvm.module_flags
   mlir.dialects.llvm.mul
   mlir.dialects.llvm.intr_nearbyint
   mlir.dialects.llvm.intr_experimental_noalias_scope_decl
   mlir.dialects.llvm.mlir_none
   mlir.dialects.llvm.or_
   mlir.dialects.llvm.mlir_poison
   mlir.dialects.llvm.intr_powi
   mlir.dialects.llvm.intr_pow
   mlir.dialects.llvm.intr_prefetch
   mlir.dialects.llvm.intr_ptr_annotation
   mlir.dialects.llvm.intr_ptrmask
   mlir.dialects.llvm.ptrtoint
   mlir.dialects.llvm.resume
   mlir.dialects.llvm.return_
   mlir.dialects.llvm.intr_rint
   mlir.dialects.llvm.intr_roundeven
   mlir.dialects.llvm.intr_round
   mlir.dialects.llvm.intr_sadd_sat
   mlir.dialects.llvm.intr_sadd_with_overflow
   mlir.dialects.llvm.intr_scmp
   mlir.dialects.llvm.sdiv
   mlir.dialects.llvm.sext
   mlir.dialects.llvm.sitofp
   mlir.dialects.llvm.intr_smax
   mlir.dialects.llvm.intr_smin
   mlir.dialects.llvm.intr_smul_with_overflow
   mlir.dialects.llvm.srem
   mlir.dialects.llvm.intr_ssa_copy
   mlir.dialects.llvm.intr_sshl_sat
   mlir.dialects.llvm.intr_ssub_sat
   mlir.dialects.llvm.intr_ssub_with_overflow
   mlir.dialects.llvm.select
   mlir.dialects.llvm.shl
   mlir.dialects.llvm.shufflevector
   mlir.dialects.llvm.intr_sin
   mlir.dialects.llvm.intr_sincos
   mlir.dialects.llvm.intr_sinh
   mlir.dialects.llvm.intr_sqrt
   mlir.dialects.llvm.intr_stackrestore
   mlir.dialects.llvm.intr_stacksave
   mlir.dialects.llvm.intr_stepvector
   mlir.dialects.llvm.store
   mlir.dialects.llvm.intr_strip_invariant_group
   mlir.dialects.llvm.sub
   mlir.dialects.llvm.switch
   mlir.dialects.llvm.intr_tan
   mlir.dialects.llvm.intr_tanh
   mlir.dialects.llvm.intr_threadlocal_address
   mlir.dialects.llvm.intr_trap
   mlir.dialects.llvm.trunc
   mlir.dialects.llvm.intr_uadd_sat
   mlir.dialects.llvm.intr_uadd_with_overflow
   mlir.dialects.llvm.intr_ubsantrap
   mlir.dialects.llvm.intr_ucmp
   mlir.dialects.llvm.udiv
   mlir.dialects.llvm.uitofp
   mlir.dialects.llvm.intr_umax
   mlir.dialects.llvm.intr_umin
   mlir.dialects.llvm.intr_umul_with_overflow
   mlir.dialects.llvm.urem
   mlir.dialects.llvm.intr_ushl_sat
   mlir.dialects.llvm.intr_usub_sat
   mlir.dialects.llvm.intr_usub_with_overflow
   mlir.dialects.llvm.mlir_undef
   mlir.dialects.llvm.unreachable
   mlir.dialects.llvm.intr_vp_ashr
   mlir.dialects.llvm.intr_vp_add
   mlir.dialects.llvm.intr_vp_and
   mlir.dialects.llvm.intr_vp_fadd
   mlir.dialects.llvm.intr_vp_fdiv
   mlir.dialects.llvm.intr_vp_fmuladd
   mlir.dialects.llvm.intr_vp_fmul
   mlir.dialects.llvm.intr_vp_fneg
   mlir.dialects.llvm.intr_vp_fpext
   mlir.dialects.llvm.intr_vp_fptosi
   mlir.dialects.llvm.intr_vp_fptoui
   mlir.dialects.llvm.intr_vp_fptrunc
   mlir.dialects.llvm.intr_vp_frem
   mlir.dialects.llvm.intr_vp_fsub
   mlir.dialects.llvm.intr_vp_fma
   mlir.dialects.llvm.intr_vp_inttoptr
   mlir.dialects.llvm.intr_vp_lshr
   mlir.dialects.llvm.intr_vp_load
   mlir.dialects.llvm.intr_vp_merge
   mlir.dialects.llvm.intr_vp_mul
   mlir.dialects.llvm.intr_vp_or
   mlir.dialects.llvm.intr_vp_ptrtoint
   mlir.dialects.llvm.intr_vp_reduce_add
   mlir.dialects.llvm.intr_vp_reduce_and
   mlir.dialects.llvm.intr_vp_reduce_fadd
   mlir.dialects.llvm.intr_vp_reduce_fmax
   mlir.dialects.llvm.intr_vp_reduce_fmin
   mlir.dialects.llvm.intr_vp_reduce_fmul
   mlir.dialects.llvm.intr_vp_reduce_mul
   mlir.dialects.llvm.intr_vp_reduce_or
   mlir.dialects.llvm.intr_vp_reduce_smax
   mlir.dialects.llvm.intr_vp_reduce_smin
   mlir.dialects.llvm.intr_vp_reduce_umax
   mlir.dialects.llvm.intr_vp_reduce_umin
   mlir.dialects.llvm.intr_vp_reduce_xor
   mlir.dialects.llvm.intr_vp_sdiv
   mlir.dialects.llvm.intr_vp_sext
   mlir.dialects.llvm.intr_vp_sitofp
   mlir.dialects.llvm.intr_vp_smax
   mlir.dialects.llvm.intr_vp_smin
   mlir.dialects.llvm.intr_vp_srem
   mlir.dialects.llvm.intr_vp_select
   mlir.dialects.llvm.intr_vp_shl
   mlir.dialects.llvm.intr_vp_store
   mlir.dialects.llvm.intr_experimental_vp_strided_load
   mlir.dialects.llvm.intr_experimental_vp_strided_store
   mlir.dialects.llvm.intr_vp_sub
   mlir.dialects.llvm.intr_vp_trunc
   mlir.dialects.llvm.intr_vp_udiv
   mlir.dialects.llvm.intr_vp_uitofp
   mlir.dialects.llvm.intr_vp_umax
   mlir.dialects.llvm.intr_vp_umin
   mlir.dialects.llvm.intr_vp_urem
   mlir.dialects.llvm.intr_vp_xor
   mlir.dialects.llvm.intr_vp_zext
   mlir.dialects.llvm.va_arg
   mlir.dialects.llvm.intr_vacopy
   mlir.dialects.llvm.intr_vaend
   mlir.dialects.llvm.intr_vastart
   mlir.dialects.llvm.intr_var_annotation
   mlir.dialects.llvm.xor
   mlir.dialects.llvm.zext
   mlir.dialects.llvm.mlir_zero
   mlir.dialects.llvm.intr_masked_compressstore
   mlir.dialects.llvm.intr_masked_expandload
   mlir.dialects.llvm.intr_masked_gather
   mlir.dialects.llvm.intr_masked_scatter
   mlir.dialects.llvm.intr_vector_deinterleave2
   mlir.dialects.llvm.intr_vector_extract
   mlir.dialects.llvm.intr_vector_insert
   mlir.dialects.llvm.intr_vector_interleave2
   mlir.dialects.llvm.intr_vector_reduce_add
   mlir.dialects.llvm.intr_vector_reduce_and
   mlir.dialects.llvm.intr_vector_reduce_fadd
   mlir.dialects.llvm.intr_vector_reduce_fmax
   mlir.dialects.llvm.intr_vector_reduce_fmaximum
   mlir.dialects.llvm.intr_vector_reduce_fmin
   mlir.dialects.llvm.intr_vector_reduce_fminimum
   mlir.dialects.llvm.intr_vector_reduce_fmul
   mlir.dialects.llvm.intr_vector_reduce_mul
   mlir.dialects.llvm.intr_vector_reduce_or
   mlir.dialects.llvm.intr_vector_reduce_smax
   mlir.dialects.llvm.intr_vector_reduce_smin
   mlir.dialects.llvm.intr_vector_reduce_umax
   mlir.dialects.llvm.intr_vector_reduce_umin
   mlir.dialects.llvm.intr_vector_reduce_xor
   mlir.dialects.llvm.intr_vscale
   mlir.dialects.llvm.register_attribute_builder
   mlir.dialects.llvm.mlir_constant


Module Contents
---------------

.. py:class:: ACosOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.acos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_acos(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AShrOp(lhs, rhs, *, isExact=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.ashr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: isExact() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: ashr(lhs, rhs, *, is_exact=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ASinOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.asin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_asin(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ATan2Op(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.atan2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_atan2(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ATanOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.atan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_atan(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AbsOp(res, in_, is_int_min_poison, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.abs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: is_int_min_poison() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_abs(res, in_, is_int_min_poison, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AddOp(lhs, rhs, overflowFlags, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.add'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: add(lhs, rhs, overflow_flags, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AddrSpaceCastOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.addrspacecast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: addrspacecast(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AddressOfOp(res, global_name, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Creates an SSA value containing a pointer to a global value (function,
   variable or alias). The global value can be defined after its first
   referenced. If the global value is a constant, storing into it is not
   allowed.

   Examples:

   .. code:: mlir

       func @foo() {
         // Get the address of a global variable.
         %0 = llvm.mlir.addressof @const : !llvm.ptr
       
         // Use it as a regular pointer.
         %1 = llvm.load %0 : !llvm.ptr -> i32
       
         // Get the address of a function.
         %2 = llvm.mlir.addressof @foo : !llvm.ptr
       
         // The function address can be used for indirect calls.
         llvm.call %2() : !llvm.ptr, () -> ()
       
         // Get the address of an aliased global.
         %3 = llvm.mlir.addressof @const_alias : !llvm.ptr
       }
       
       // Define the global.
       llvm.mlir.global @const(42 : i32) : i32
       
       // Define an alias.
       llvm.mlir.alias @const_alias : i32 {
         %0 = llvm.mlir.addressof @const : !llvm.ptr
         llvm.return %0 : !llvm.ptr
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.addressof'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: global_name() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_addressof(res, global_name, *, loc=None, ip=None) -> _ods_ir

.. py:class:: AliasOp(alias_type, sym_name, linkage, *, dso_local=None, thread_local_=None, unnamed_addr=None, visibility_=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``llvm.mlir.alias`` is a top level operation that defines a global alias for
   global variables and functions. The operation is always initialized by
   using a initializer region which could be a direct map to another global
   value or contain some address computation on top of it.

   It uses a symbol for its value, which will be uniqued by the module
   with respect to other symbols in it.

   Similarly to functions and globals, they can also have a linkage attribute.
   This attribute is placed between ``llvm.mlir.alias`` and the symbol name. If
   the attribute is omitted, ``external`` linkage is assumed by default.

   Examples:

   .. code:: mlir

       // Global alias use @-identifiers.
       llvm.mlir.alias external @foo_alias {addr_space = 0 : i32} : !llvm.ptr {
         %0 = llvm.mlir.addressof @some_function : !llvm.ptr
         llvm.return %0 : !llvm.ptr
       }
       
       // More complex initialization.
       llvm.mlir.alias linkonce_odr hidden @glob
       {addr_space = 0 : i32, dso_local} : !llvm.array<32 x i32> {
         %0 = llvm.mlir.constant(1234 : i64) : i64
         %1 = llvm.mlir.addressof @glob.private : !llvm.ptr
         %2 = llvm.ptrtoint %1 : !llvm.ptr to i64
         %3 = llvm.add %2, %0 : i64
         %4 = llvm.inttoptr %3 : i64 to !llvm.ptr
         llvm.return %4 : !llvm.ptr
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.alias'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: alias_type() -> _ods_ir


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: linkage() -> _ods_ir


   .. py:method:: dso_local() -> bool


   .. py:method:: thread_local_() -> bool


   .. py:method:: unnamed_addr() -> Optional[_ods_ir]


   .. py:method:: visibility_() -> _ods_ir


   .. py:method:: initializer() -> _ods_ir


.. py:function:: mlir_alias(alias_type, sym_name, linkage, *, dso_local=None, thread_local_=None, unnamed_addr=None, visibility_=None, loc=None, ip=None) -> AliasOp

.. py:class:: AllocaOp(res, arraySize, elem_type, *, alignment=None, inalloca=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.alloca'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arraySize() -> _ods_ir[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: elem_type() -> _ods_ir


   .. py:method:: inalloca() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: alloca(res, array_size, elem_type, *, alignment=None, inalloca=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AndOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: and_(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Annotation(integer, annotation, fileName, line, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.annotation'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: integer() -> _ods_ir[_ods_ir]


   .. py:method:: annotation() -> _ods_ir


   .. py:method:: fileName() -> _ods_ir


   .. py:method:: line() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_annotation(integer, annotation, file_name, line, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AssumeOp(cond, op_bundle_operands, op_bundle_sizes, *, op_bundle_tags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.assume'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: cond() -> _ods_ir[_ods_ir]


   .. py:method:: op_bundle_operands() -> _ods_ir


   .. py:method:: op_bundle_sizes() -> _ods_ir


   .. py:method:: op_bundle_tags() -> Optional[_ods_ir]


.. py:function:: intr_assume(cond, op_bundle_operands, op_bundle_sizes, *, op_bundle_tags=None, loc=None, ip=None) -> AssumeOp

.. py:class:: AtomicCmpXchgOp(ptr, cmp, val, success_ordering, failure_ordering, *, syncscope=None, alignment=None, weak=None, volatile_=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.cmpxchg'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: cmp() -> _ods_ir


   .. py:method:: val() -> _ods_ir


   .. py:method:: success_ordering() -> _ods_ir


   .. py:method:: failure_ordering() -> _ods_ir


   .. py:method:: syncscope() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: weak() -> bool


   .. py:method:: volatile_() -> bool


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: cmpxchg(ptr, cmp, val, success_ordering, failure_ordering, *, syncscope=None, alignment=None, weak=None, volatile_=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: AtomicRMWOp(bin_op, ptr, val, ordering, *, syncscope=None, alignment=None, volatile_=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.atomicrmw'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: val() -> _ods_ir


   .. py:method:: bin_op() -> _ods_ir


   .. py:method:: ordering() -> _ods_ir


   .. py:method:: syncscope() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: volatile_() -> bool


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: atomicrmw(bin_op, ptr, val, ordering, *, syncscope=None, alignment=None, volatile_=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitReverseOp(in_, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.bitreverse'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_bitreverse(in_, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: BitcastOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.bitcast'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: bitcast(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BlockAddressOp(res, block_addr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Creates an SSA value containing a pointer to a basic block. The block
   address information (function and block) is given by the ``BlockAddressAttr``
   attribute. This operation assumes an existing ``llvm.blocktag`` operation
   identifying an existing MLIR block within a function. Example:

   .. code:: mlir

       llvm.mlir.global private @g() : !llvm.ptr {
         %0 = llvm.blockaddress <function = @fn, tag = <id = 0>> : !llvm.ptr
         llvm.return %0 : !llvm.ptr
       }
       
       llvm.func @fn() {
         llvm.br ^bb1
       ^bb1:  // pred: ^bb0
         llvm.blocktag <id = 0>
         llvm.return
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.blockaddress'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: block_addr() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: blockaddress(res, block_addr, *, loc=None, ip=None) -> _ods_ir

.. py:class:: BlockTagOp(tag, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This operation uses a ``tag`` to uniquely identify an MLIR block in a
   function. The same tag is used by ``llvm.blockaddress`` in order to compute
   the target address.

   A given function should have at most one ``llvm.blocktag`` operation with a
   given ``tag``. This operation cannot be used as a terminator.

   Example:

   .. code:: mlir

       llvm.func @f() -> !llvm.ptr {
         %addr = llvm.blockaddress <function = @f, tag = <id = 1>> : !llvm.ptr
         llvm.br ^bb1
       ^bb1:
         llvm.blocktag <id = 1>
         llvm.return %addr : !llvm.ptr
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.blocktag'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: tag() -> _ods_ir


.. py:function:: blocktag(tag, *, loc=None, ip=None) -> BlockTagOp

.. py:class:: BrOp(destOperands, dest, *, loop_annotation=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.br'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: destOperands() -> _ods_ir


   .. py:method:: loop_annotation() -> Optional[_ods_ir]


.. py:function:: br(dest_operands, dest, *, loop_annotation=None, loc=None, ip=None) -> BrOp

.. py:class:: ByteSwapOp(in_, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.bswap'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_bswap(in_, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CallIntrinsicOp(results_, intrin, args, op_bundle_operands, op_bundle_sizes, *, fastmathFlags=None, op_bundle_tags=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Call the specified llvm intrinsic. If the intrinsic is overloaded, use
   the MLIR function type of this op to determine which intrinsic to call.


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.call_intrinsic'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: args() -> _ods_ir


   .. py:method:: op_bundle_operands() -> _ods_ir


   .. py:method:: intrin() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: op_bundle_sizes() -> _ods_ir


   .. py:method:: op_bundle_tags() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: results_() -> Optional[_ods_ir]


.. py:function:: call_intrinsic(results_, intrin, args, op_bundle_operands, op_bundle_sizes, *, fastmath_flags=None, op_bundle_tags=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, CallIntrinsicOp]

.. py:class:: CallOp(result, callee_operands, op_bundle_operands, op_bundle_sizes, *, var_callee_type=None, callee=None, fastmathFlags=None, CConv=None, TailCallKind=None, memory_effects=None, convergent=None, no_unwind=None, will_return=None, op_bundle_tags=None, arg_attrs=None, res_attrs=None, no_inline=None, always_inline=None, inline_hint=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect
   implements this behavior by providing a variadic ``call`` operation for 0- and
   1-result functions. Even though MLIR supports multi-result functions, LLVM
   IR dialect disallows them.

   The ``call`` instruction supports both direct and indirect calls. Direct calls
   start with a function name (``@``-prefixed) and indirect calls start with an
   SSA value (``%``-prefixed). The direct callee, if present, is stored as a
   function attribute ``callee``. For indirect calls, the callee is of ``!llvm.ptr`` type
   and is stored as the first value in ``callee_operands``. If and only if the
   callee is a variadic function, the ``var_callee_type`` attribute must carry
   the variadic LLVM function type. The trailing type list contains the
   optional indirect callee type and the MLIR function type, which differs from
   the LLVM function type that uses an explicit void type to model functions
   that do not return a value.

   If this operatin has the ``no_inline`` attribute, then this specific function call
   will never be inlined. The opposite behavior will occur if the call has ``always_inline``
   attribute. The ``inline_hint`` attribute indicates that it is desirable to inline
   this function call.

   Examples:

   .. code:: mlir

       // Direct call without arguments and with one result.
       %0 = llvm.call @foo() : () -> (f32)
       
       // Direct call with arguments and without a result.
       llvm.call @bar(%0) : (f32) -> ()
       
       // Indirect call with an argument and without a result.
       %1 = llvm.mlir.addressof @foo : !llvm.ptr
       llvm.call %1(%0) : !llvm.ptr, (f32) -> ()
       
       // Direct variadic call.
       llvm.call @printf(%0, %1) vararg(!llvm.func<i32 (ptr, ...)>) : (!llvm.ptr, i32) -> i32
       
       // Indirect variadic call
       llvm.call %1(%0) vararg(!llvm.func<void (...)>) : !llvm.ptr, (i32) -> ()


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.call'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: callee_operands() -> _ods_ir


   .. py:method:: op_bundle_operands() -> _ods_ir


   .. py:method:: var_callee_type() -> Optional[_ods_ir]


   .. py:method:: callee() -> Optional[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: CConv() -> _ods_ir


   .. py:method:: TailCallKind() -> _ods_ir


   .. py:method:: memory_effects() -> Optional[_ods_ir]


   .. py:method:: convergent() -> bool


   .. py:method:: no_unwind() -> bool


   .. py:method:: will_return() -> bool


   .. py:method:: op_bundle_sizes() -> _ods_ir


   .. py:method:: op_bundle_tags() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: no_inline() -> bool


   .. py:method:: always_inline() -> bool


   .. py:method:: inline_hint() -> bool


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: result() -> Optional[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: call(result, callee_operands, op_bundle_operands, op_bundle_sizes, *, var_callee_type=None, callee=None, fastmath_flags=None, c_conv=None, tail_call_kind=None, memory_effects=None, convergent=None, no_unwind=None, will_return=None, op_bundle_tags=None, arg_attrs=None, res_attrs=None, no_inline=None, always_inline=None, inline_hint=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, CallOp]

.. py:class:: ComdatOp(sym_name, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Provides access to object file COMDAT section/group functionality.

   Examples:

   .. code:: mlir

       llvm.comdat @__llvm_comdat {
         llvm.comdat_selector @any any
       }
       llvm.mlir.global internal constant @has_any_comdat(1 : i64) comdat(@__llvm_comdat::@any) : i64


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.comdat'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: body() -> _ods_ir


.. py:function:: comdat(sym_name, *, loc=None, ip=None) -> ComdatOp

.. py:class:: ComdatSelectorOp(sym_name, comdat, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Provides access to object file COMDAT section/group functionality.

   Examples:

   .. code:: mlir

       llvm.comdat @__llvm_comdat {
         llvm.comdat_selector @any any
       }
       llvm.mlir.global internal constant @has_any_comdat(1 : i64) comdat(@__llvm_comdat::@any) : i64


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.comdat_selector'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: comdat() -> _ods_ir


.. py:function:: comdat_selector(sym_name, comdat, *, loc=None, ip=None) -> ComdatSelectorOp

.. py:class:: CondBrOp(condition, trueDestOperands, falseDestOperands, trueDest, falseDest, *, branch_weights=None, loop_annotation=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.cond_br'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: condition() -> _ods_ir[_ods_ir]


   .. py:method:: trueDestOperands() -> _ods_ir


   .. py:method:: falseDestOperands() -> _ods_ir


   .. py:method:: branch_weights() -> Optional[_ods_ir]


   .. py:method:: loop_annotation() -> Optional[_ods_ir]


.. py:function:: cond_br(condition, true_dest_operands, false_dest_operands, true_dest, false_dest, *, branch_weights=None, loop_annotation=None, loc=None, ip=None) -> CondBrOp

.. py:class:: ConstantOp(res, value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Unlike LLVM IR, MLIR does not have first-class constant values. Therefore,
   all constants must be created as SSA values before being used in other
   operations. ``llvm.mlir.constant`` creates such values for scalars, vectors,
   strings, structs, and array of structs. It has a mandatory ``value`` attribute
   whose type depends on the type of the constant value. The type of the constant
   value must correspond to the attribute type converted to LLVM IR type.

   When creating constant scalars, the ``value`` attribute must be either an
   integer attribute or a floating point attribute. The type of the attribute
   may be omitted for ``i64`` and ``f64`` types that are implied.

   When creating constant vectors, the ``value`` attribute must be either an
   array attribute, a dense attribute, or a sparse attribute that contains
   integers or floats. The number of elements in the result vector must match
   the number of elements in the attribute.

   When creating constant strings, the ``value`` attribute must be a string
   attribute. The type of the constant must be an LLVM array of ``i8``s, and the
   length of the array must match the length of the attribute.

   When creating constant structs, the ``value`` attribute must be an array
   attribute that contains integers or floats. The type of the constant must be
   an LLVM struct type. The number of fields in the struct must match the
   number of elements in the attribute, and the type of each LLVM struct field
   must correspond to the type of the corresponding attribute element converted
   to LLVM IR.

   When creating an array of structs, the ``value`` attribute must be an array
   attribute, itself containing zero, or undef, or array attributes for each
   potential nested array type, and the elements of the leaf array attributes
   for must match the struct element types or be zero or undef attributes.

   Examples:

   .. code:: mlir

       // Integer constant, internal i32 is mandatory
       %0 = llvm.mlir.constant(42 : i32) : i32
       
       // It's okay to omit i64.
       %1 = llvm.mlir.constant(42) : i64
       
       // Floating point constant.
       %2 = llvm.mlir.constant(42.0 : f32) : f32
       
       // Splat dense vector constant.
       %3 = llvm.mlir.constant(dense<1.0> : vector<4xf32>) : vector<4xf32>


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.constant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_constant(res, value, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstrainedFPExtIntr(res, arg_0, fpExceptionBehavior, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.constrained.fpext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_0() -> _ods_ir


   .. py:method:: fpExceptionBehavior() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_experimental_constrained_fpext(res, arg_0, fp_exception_behavior, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstrainedFPTruncIntr(res, arg_0, roundingmode, fpExceptionBehavior, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.constrained.fptrunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_0() -> _ods_ir


   .. py:method:: roundingmode() -> _ods_ir


   .. py:method:: fpExceptionBehavior() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_experimental_constrained_fptrunc(res, arg_0, roundingmode, fp_exception_behavior, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstrainedSIToFP(res, arg_0, roundingmode, fpExceptionBehavior, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.constrained.sitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_0() -> _ods_ir


   .. py:method:: roundingmode() -> _ods_ir


   .. py:method:: fpExceptionBehavior() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_experimental_constrained_sitofp(res, arg_0, roundingmode, fp_exception_behavior, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ConstrainedUIToFP(res, arg_0, roundingmode, fpExceptionBehavior, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.constrained.uitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_0() -> _ods_ir


   .. py:method:: roundingmode() -> _ods_ir


   .. py:method:: fpExceptionBehavior() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_experimental_constrained_uitofp(res, arg_0, roundingmode, fp_exception_behavior, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CopySignOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.copysign'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_copysign(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroAlignOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.align'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_align(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroBeginOp(res, token, mem, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.begin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: token() -> _ods_ir


   .. py:method:: mem() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_begin(res, token, mem, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroEndOp(res, handle, unwind, retvals, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.end'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: handle() -> _ods_ir


   .. py:method:: unwind() -> _ods_ir[_ods_ir]


   .. py:method:: retvals() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_end(res, handle, unwind, retvals, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroFreeOp(res, id, handle, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.free'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: id() -> _ods_ir


   .. py:method:: handle() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_free(res, id, handle, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroIdOp(res, align, promise, coroaddr, fnaddrs, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.id'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: align() -> _ods_ir[_ods_ir]


   .. py:method:: promise() -> _ods_ir


   .. py:method:: coroaddr() -> _ods_ir


   .. py:method:: fnaddrs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_id(res, align, promise, coroaddr, fnaddrs, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroPromiseOp(res, handle, align, from_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.promise'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: handle() -> _ods_ir


   .. py:method:: align() -> _ods_ir[_ods_ir]


   .. py:method:: from_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_promise(res, handle, align, from_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroResumeOp(handle, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.resume'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: handle() -> _ods_ir


.. py:function:: intr_coro_resume(handle, *, loc=None, ip=None) -> CoroResumeOp

.. py:class:: CoroSaveOp(res, handle, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.save'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: handle() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_save(res, handle, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroSizeOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.size'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_size(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CoroSuspendOp(res, save, final, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.coro.suspend'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: save() -> _ods_ir


   .. py:method:: final() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_coro_suspend(res, save, final, *, loc=None, ip=None) -> _ods_ir

.. py:class:: CosOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.cos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_cos(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CoshOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.cosh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_cosh(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CountLeadingZerosOp(in_, is_zero_poison, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ctlz'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: is_zero_poison() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ctlz(in_, is_zero_poison, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CountTrailingZerosOp(in_, is_zero_poison, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.cttz'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: is_zero_poison() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_cttz(in_, is_zero_poison, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: CtPopOp(in_, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ctpop'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ctpop(in_, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: DSOLocalEquivalentOp(res, function_name, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Creates an SSA value containing a pointer to a global value (function or
   alias to function). It represents a function which is functionally
   equivalent to a given function, but is always defined in the current
   linkage unit. The target function may not have ``extern_weak`` linkage.

   Examples:

   .. code:: mlir

       llvm.mlir.global external constant @const() : i64 {
         %0 = llvm.mlir.addressof @const : !llvm.ptr
         %1 = llvm.ptrtoint %0 : !llvm.ptr to i64
         %2 = llvm.dso_local_equivalent @func : !llvm.ptr
         %4 = llvm.ptrtoint %2 : !llvm.ptr to i64
         llvm.return %4 : i64
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.dso_local_equivalent'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: function_name() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: dso_local_equivalent(res, function_name, *, loc=None, ip=None) -> _ods_ir

.. py:class:: DbgDeclareOp(addr, varInfo, *, locationExpr=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.dbg.declare'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: addr() -> _ods_ir


   .. py:method:: varInfo() -> _ods_ir


   .. py:method:: locationExpr() -> _ods_ir


.. py:function:: intr_dbg_declare(addr, var_info, *, location_expr=None, loc=None, ip=None) -> DbgDeclareOp

.. py:class:: DbgLabelOp(label, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.dbg.label'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: label() -> _ods_ir


.. py:function:: intr_dbg_label(label, *, loc=None, ip=None) -> DbgLabelOp

.. py:class:: DbgValueOp(value, varInfo, *, locationExpr=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.dbg.value'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: varInfo() -> _ods_ir


   .. py:method:: locationExpr() -> _ods_ir


.. py:function:: intr_dbg_value(value, var_info, *, location_expr=None, loc=None, ip=None) -> DbgValueOp

.. py:class:: DebugTrap(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.debugtrap'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: intr_debugtrap(*, loc=None, ip=None) -> DebugTrap

.. py:class:: EhTypeidForOp(res, type_info, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.eh.typeid.for'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: type_info() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_eh_typeid_for(res, type_info, *, loc=None, ip=None) -> _ods_ir

.. py:class:: Exp2Op(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.exp2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_exp2(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Exp10Op(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.exp10'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_exp10(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ExpOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.exp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_exp(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ExpectOp(val, expected, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.expect'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: expected() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_expect(val, expected, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ExpectWithProbabilityOp(val, expected, prob, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.expect.with.probability'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: expected() -> _ods_ir[_ods_ir]


   .. py:method:: prob() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_expect_with_probability(val, expected, prob, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ExtractElementOp(vector, position, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.extractelement'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: position() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: extractelement(vector, position, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ExtractValueOp(res, container, position, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.extractvalue'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: container() -> _ods_ir


   .. py:method:: position() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: extractvalue(res, container, position, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FAbsOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.fabs'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_fabs(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FAddOp(lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fadd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fadd(lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FCeilOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ceil'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ceil(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FCmpOp(predicate, lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fcmp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: predicate() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fcmp(predicate, lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FDivOp(lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fdiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fdiv(lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FFloorOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.floor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_floor(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FMAOp(a, b, c, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.fma'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: c() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_fma(a, b, c, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FMulAddOp(a, b, c, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.fmuladd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: c() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_fmuladd(a, b, c, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FMulOp(lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fmul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fmul(lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FNegOp(operand, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fneg'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fneg(operand, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FPExtOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fpext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fpext(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FPToSIOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fptosi'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fptosi(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FPToUIOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fptoui'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fptoui(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FPTruncOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fptrunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fptrunc(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: FRemOp(lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.frem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: frem(lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FSubOp(lhs, rhs, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fsub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: fsub(lhs, rhs, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FTruncOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.trunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_trunc(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FenceOp(ordering, *, syncscope=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.fence'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ordering() -> _ods_ir


   .. py:method:: syncscope() -> Optional[_ods_ir]


.. py:function:: fence(ordering, *, syncscope=None, loc=None, ip=None) -> FenceOp

.. py:class:: FractionExpOp(res, val, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.frexp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_frexp(res, val, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FreezeOp(val, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.freeze'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: freeze(val, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FshlOp(a, b, c, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.fshl'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: c() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_fshl(a, b, c, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: FshrOp(a, b, c, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.fshr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: c() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_fshr(a, b, c, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: GEPOp(res, base, dynamicIndices, rawConstantIndices, elem_type, noWrapFlags, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   This operation mirrors LLVM IRs 'getelementptr' operation that is used to
   perform pointer arithmetic.

   Like in LLVM IR, it is possible to use both constants as well as SSA values
   as indices. In the case of indexing within a structure, it is required to
   either use constant indices directly, or supply a constant SSA value.

   The no-wrap flags can be used to specify the low-level pointer arithmetic
   overflow behavior that LLVM uses after lowering the operation to LLVM IR.
   Valid options include 'inbounds' (pointer arithmetic must be within object
   bounds), 'nusw' (no unsigned signed wrap), and 'nuw' (no unsigned wrap).
   Note that 'inbounds' implies 'nusw' which is ensured by the enum
   definition. The flags can be set individually or in combination.

   Examples:

   .. code:: mlir

       // GEP with an SSA value offset
       %0 = llvm.getelementptr %1[%2] : (!llvm.ptr, i64) -> !llvm.ptr, f32
       
       // GEP with a constant offset and the inbounds attribute set
       %0 = llvm.getelementptr inbounds %1[3] : (!llvm.ptr) -> !llvm.ptr, f32
       
       // GEP with constant offsets into a structure
       %0 = llvm.getelementptr %1[0, 1]
          : (!llvm.ptr) -> !llvm.ptr, !llvm.struct<(i32, f32)>


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.getelementptr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base() -> _ods_ir


   .. py:method:: dynamicIndices() -> _ods_ir


   .. py:method:: rawConstantIndices() -> _ods_ir


   .. py:method:: elem_type() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: getelementptr(res, base, dynamic_indices, raw_constant_indices, elem_type, no_wrap_flags, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GetActiveLaneMaskOp(res, base, n, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.get.active.lane.mask'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: base() -> _ods_ir[_ods_ir]


   .. py:method:: n() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_get_active_lane_mask(res, base, n, *, loc=None, ip=None) -> _ods_ir

.. py:class:: GlobalCtorsOp(ctors, priorities, data, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Specifies a list of constructor functions, priorities, and associated data.
   The functions referenced by this array will be called in ascending order
   of priority (i.e. lowest first) when the module is loaded. The order of
   functions with the same priority is not defined. This operation is
   translated to LLVM's global_ctors global variable. The initializer
   functions are run at load time. However, if the associated data is not
   ``#llvm.zero``, functions only run if the data is not discarded.

   Examples:

   .. code:: mlir

       llvm.func @ctor() {
         ...
         llvm.return
       }
       llvm.mlir.global_ctors ctors = [@ctor], priorities = [0],
                                      data = [#llvm.zero]


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.global_ctors'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ctors() -> _ods_ir


   .. py:method:: priorities() -> _ods_ir


   .. py:method:: data() -> _ods_ir


.. py:function:: mlir_global_ctors(ctors, priorities, data, *, loc=None, ip=None) -> GlobalCtorsOp

.. py:class:: GlobalDtorsOp(dtors, priorities, data, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Specifies a list of destructor functions and priorities. The functions
   referenced by this array will be called in descending order of priority
   (i.e. highest first) when the module is unloaded. The order of functions
   with the same priority is not defined. This operation is translated to
   LLVM's global_dtors global variable. The destruction functions are run at
   load time. However, if the associated data is not ``#llvm.zero``, functions
   only run if the data is not discarded.

   Examples:

   .. code:: mlir

       llvm.func @dtor() {
         llvm.return
       }
       llvm.mlir.global_dtors dtors = [@dtor], priorities = [0],
                                      data = [#llvm.zero]


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.global_dtors'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dtors() -> _ods_ir


   .. py:method:: priorities() -> _ods_ir


   .. py:method:: data() -> _ods_ir


.. py:function:: mlir_global_dtors(dtors, priorities, data, *, loc=None, ip=None) -> GlobalDtorsOp

.. py:class:: GlobalOp(global_type, sym_name, linkage, *, constant=None, dso_local=None, thread_local_=None, externally_initialized=None, value=None, alignment=None, addr_space=None, unnamed_addr=None, section=None, comdat=None, dbg_exprs=None, visibility_=None, target_specific_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Since MLIR allows for arbitrary operations to be present at the top level,
   global variables are defined using the ``llvm.mlir.global`` operation. Both
   global constants and variables can be defined, and the value may also be
   initialized in both cases.

   There are two forms of initialization syntax. Simple constants that can be
   represented as MLIR attributes can be given in-line:

   .. code:: mlir

       llvm.mlir.global @variable(32.0 : f32) : f32

   This initialization and type syntax is similar to ``llvm.mlir.constant`` and
   may use two types: one for MLIR attribute and another for the LLVM value.
   These types must be compatible.

   More complex constants that cannot be represented as MLIR attributes can be
   given in an initializer region:

   .. code:: mlir

       // This global is initialized with the equivalent of:
       //   i32* getelementptr (i32* @g2, i32 2)
       llvm.mlir.global constant @int_gep() : !llvm.ptr {
         %0 = llvm.mlir.addressof @g2 : !llvm.ptr
         %1 = llvm.mlir.constant(2 : i32) : i32
         %2 = llvm.getelementptr %0[%1]
            : (!llvm.ptr, i32) -> !llvm.ptr, i32
         // The initializer region must end with `llvm.return`.
         llvm.return %2 : !llvm.ptr
       }

   Only one of the initializer attribute or initializer region may be provided.

   ``llvm.mlir.global`` must appear at top-level of the enclosing module. It uses
   an @-identifier for its value, which will be uniqued by the module with
   respect to other @-identifiers in it.

   Examples:

   .. code:: mlir

       // Global values use @-identifiers.
       llvm.mlir.global constant @cst(42 : i32) : i32
       
       // Non-constant values must also be initialized.
       llvm.mlir.global @variable(32.0 : f32) : f32
       
       // Strings are expected to be of wrapped LLVM i8 array type and do not
       // automatically include the trailing zero.
       llvm.mlir.global @string("abc") : !llvm.array<3 x i8>
       
       // For strings globals, the trailing type may be omitted.
       llvm.mlir.global constant @no_trailing_type("foo bar")
       
       // A complex initializer is constructed with an initializer region.
       llvm.mlir.global constant @int_gep() : !llvm.ptr {
         %0 = llvm.mlir.addressof @g2 : !llvm.ptr
         %1 = llvm.mlir.constant(2 : i32) : i32
         %2 = llvm.getelementptr %0[%1]
            : (!llvm.ptr, i32) -> !llvm.ptr, i32
         llvm.return %2 : !llvm.ptr
       }

   Similarly to functions, globals have a linkage attribute. In the custom
   syntax, this attribute is placed between ``llvm.mlir.global`` and the optional
   ``constant`` keyword. If the attribute is omitted, ``external`` linkage is
   assumed by default.

   Examples:

   .. code:: mlir

       // A constant with internal linkage will not participate in linking.
       llvm.mlir.global internal constant @cst(42 : i32) : i32
       
       // By default, "external" linkage is assumed and the global participates in
       // symbol resolution at link-time.
       llvm.mlir.global @glob(0 : f32) : f32
       
       // Alignment is optional
       llvm.mlir.global private constant @y(dense<1.0> : tensor<8xf32>) : !llvm.array<8 x f32>

   Like global variables in LLVM IR, globals can have an (optional)
   alignment attribute using keyword ``alignment``. The integer value of the
   alignment must be a positive integer that is a power of 2.

   Examples:

   .. code:: mlir

       // Alignment is optional
       llvm.mlir.global private constant @y(dense<1.0> : tensor<8xf32>) { alignment = 32 : i64 } : !llvm.array<8 x f32>

   The ``target_specific_attrs`` attribute provides a mechanism to preserve
   target-specific LLVM IR attributes that are not explicitly modeled in the
   LLVM dialect.

   The attribute is an array containing either string attributes or
   two-element array attributes of strings. The value of a standalone string
   attribute is interpreted as the name of an LLVM IR attribute on the global.
   A two-element array is interpreted as a key-value pair.

   Example:

   .. code:: mlir

       llvm.mlir.global external @example() {
         target_specific_attrs = ["value-less-attr", ["int-attr", "4"], ["string-attr", "string"]]} : f64


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.global'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: global_type() -> _ods_ir


   .. py:method:: constant() -> bool


   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: linkage() -> _ods_ir


   .. py:method:: dso_local() -> bool


   .. py:method:: thread_local_() -> bool


   .. py:method:: externally_initialized() -> bool


   .. py:method:: value() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: addr_space() -> _ods_ir


   .. py:method:: unnamed_addr() -> Optional[_ods_ir]


   .. py:method:: section() -> Optional[_ods_ir]


   .. py:method:: comdat() -> Optional[_ods_ir]


   .. py:method:: dbg_exprs() -> Optional[_ods_ir]


   .. py:method:: visibility_() -> _ods_ir


   .. py:method:: target_specific_attrs() -> Optional[_ods_ir]


   .. py:method:: initializer() -> _ods_ir


.. py:function:: mlir_global(global_type, sym_name, linkage, *, constant=None, dso_local=None, thread_local_=None, externally_initialized=None, value=None, alignment=None, addr_space=None, unnamed_addr=None, section=None, comdat=None, dbg_exprs=None, visibility_=None, target_specific_attrs=None, loc=None, ip=None) -> GlobalOp

.. py:class:: ICmpOp(predicate, lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.icmp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: predicate() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: icmp(predicate, lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IFuncOp(sym_name, i_func_type, resolver, resolver_type, linkage, *, dso_local=None, address_space=None, unnamed_addr=None, visibility_=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   ``llvm.mlir.ifunc`` is a top level operation that defines a global ifunc.
   It defines a new symbol and takes a symbol refering to a resolver function.
   IFuncs can be called as regular functions. The function type is the same
   as the IFuncType. The symbol is resolved at runtime by calling a resolver
   function.

   Examples:

   .. code:: mlir

       // IFuncs resolve a symbol at runtime using a resovler function.
       llvm.mlir.ifunc external @foo: !llvm.func<f32 (i64)>, !llvm.ptr @resolver
       
       llvm.func @foo_1(i64) -> f32
       llvm.func @foo_2(i64) -> f32
       
       llvm.func @resolve_foo() -> !llvm.ptr attributes {
         %0 = llvm.mlir.addressof @foo_2 : !llvm.ptr
         %1 = llvm.mlir.addressof @foo_1 : !llvm.ptr
       
         // ... Logic selecting from foo_{1, 2}
       
         // Return function pointer to the selected function
         llvm.return %7 : !llvm.ptr
       }
       
       llvm.func @use_foo() {
         // IFuncs are called as regular functions
         %res = llvm.call @foo(%value) : i64 -> f32
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.ifunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: i_func_type() -> _ods_ir


   .. py:method:: resolver() -> _ods_ir


   .. py:method:: resolver_type() -> _ods_ir


   .. py:method:: linkage() -> _ods_ir


   .. py:method:: dso_local() -> bool


   .. py:method:: address_space() -> _ods_ir


   .. py:method:: unnamed_addr() -> _ods_ir


   .. py:method:: visibility_() -> _ods_ir


.. py:function:: mlir_ifunc(sym_name, i_func_type, resolver, resolver_type, linkage, *, dso_local=None, address_space=None, unnamed_addr=None, visibility_=None, loc=None, ip=None) -> IFuncOp

.. py:class:: IndirectBrOp(addr, succOperands, indbr_operand_segments, successors, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Transfer control flow to address in ``$addr``. A list of possible target
   blocks in ``$successors`` can be provided and maybe used as a hint in LLVM:

   .. code:: mlir

       ...
       llvm.func @g(...
         %dest = llvm.blockaddress <function = @g, tag = <id = 0>> : !llvm.ptr
         llvm.indirectbr %dest : !llvm.ptr, [
           ^head
         ]
       ^head:
         llvm.blocktag <id = 0>
         llvm.return %arg0 : i32
         ...

   It also supports a list of operands that can be passed to a target block:

   .. code:: mlir

         llvm.indirectbr %dest : !llvm.ptr, [
           ^head(%arg0 : i32),
           ^tail(%arg1, %arg0 : i32, i32)
         ]
       ^head(%r0 : i32):
         llvm.return %r0 : i32
       ^tail(%r1 : i32, %r2 : i32):
         ...


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.indirectbr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: addr() -> _ods_ir


   .. py:method:: succOperands() -> _ods_ir


   .. py:method:: indbr_operand_segments() -> _ods_ir


.. py:function:: indirectbr(addr, succ_operands, indbr_operand_segments, successors, *, loc=None, ip=None) -> IndirectBrOp

.. py:class:: InlineAsmOp(res, operands_, asm_string, constraints, *, has_side_effects=None, is_align_stack=None, tail_call_kind=None, asm_dialect=None, operand_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The InlineAsmOp mirrors the underlying LLVM semantics with a notable
   exception: the embedded ``asm_string`` is not allowed to define or reference
   any symbol or any global variable: only the operands of the op may be read,
   written, or referenced.
   Attempting to define or reference any symbol or any global behavior is
   considered undefined behavior at this time.
   If ``tail_call_kind`` is used, the operation behaves like the specified
   tail call kind. The ``musttail`` kind it's not available for this operation,
   since it isn't supported by LLVM's inline asm.


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.inline_asm'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operands_() -> _ods_ir


   .. py:method:: asm_string() -> _ods_ir


   .. py:method:: constraints() -> _ods_ir


   .. py:method:: has_side_effects() -> bool


   .. py:method:: is_align_stack() -> bool


   .. py:method:: tail_call_kind() -> _ods_ir


   .. py:method:: asm_dialect() -> Optional[_ods_ir]


   .. py:method:: operand_attrs() -> Optional[_ods_ir]


   .. py:method:: res() -> Optional[_ods_ir]


.. py:function:: inline_asm(res, operands_, asm_string, constraints, *, has_side_effects=None, is_align_stack=None, tail_call_kind=None, asm_dialect=None, operand_attrs=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, InlineAsmOp]

.. py:class:: InsertElementOp(vector, value, position, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.insertelement'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vector() -> _ods_ir[_ods_ir]


   .. py:method:: value() -> _ods_ir


   .. py:method:: position() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: insertelement(vector, value, position, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: InsertValueOp(container, value, position, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.insertvalue'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: container() -> _ods_ir


   .. py:method:: value() -> _ods_ir


   .. py:method:: position() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: insertvalue(container, value, position, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IntToPtrOp(res, arg, *, dereferenceable=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.inttoptr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: dereferenceable() -> Optional[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: inttoptr(res, arg, *, dereferenceable=None, loc=None, ip=None) -> _ods_ir

.. py:class:: InvariantEndOp(start, size, ptr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.invariant.end'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: start() -> _ods_ir


   .. py:method:: ptr() -> _ods_ir


   .. py:method:: size() -> _ods_ir


.. py:function:: intr_invariant_end(start, size, ptr, *, loc=None, ip=None) -> InvariantEndOp

.. py:class:: InvariantStartOp(size, ptr, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.invariant.start'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: size() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_invariant_start(size, ptr, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: InvokeOp(result, callee_operands, normalDestOperands, unwindDestOperands, op_bundle_operands, op_bundle_sizes, normalDest, unwindDest, *, var_callee_type=None, callee=None, arg_attrs=None, res_attrs=None, branch_weights=None, CConv=None, op_bundle_tags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.invoke'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: callee_operands() -> _ods_ir


   .. py:method:: normalDestOperands() -> _ods_ir


   .. py:method:: unwindDestOperands() -> _ods_ir


   .. py:method:: op_bundle_operands() -> _ods_ir


   .. py:method:: var_callee_type() -> Optional[_ods_ir]


   .. py:method:: callee() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: branch_weights() -> Optional[_ods_ir]


   .. py:method:: CConv() -> _ods_ir


   .. py:method:: op_bundle_sizes() -> _ods_ir


   .. py:method:: op_bundle_tags() -> Optional[_ods_ir]


   .. py:method:: result() -> Optional[_ods_ir]

      
      Shortcut to get an op result if it has only one (throws an error otherwise).



.. py:function:: invoke(result, callee_operands, normal_dest_operands, unwind_dest_operands, op_bundle_operands, op_bundle_sizes, normal_dest, unwind_dest, *, var_callee_type=None, callee=None, arg_attrs=None, res_attrs=None, branch_weights=None, c_conv=None, op_bundle_tags=None, loc=None, ip=None) -> Union[_ods_ir, _ods_ir, InvokeOp]

.. py:class:: IsConstantOp(val, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.is.constant'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_is_constant(val, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: IsFPClass(res, in_, bit, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.is.fpclass'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: bit() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_is_fpclass(res, in_, bit, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LLVMFuncOp(sym_name, function_type, *, sym_visibility=None, linkage=None, dso_local=None, CConv=None, comdat=None, convergent=None, personality=None, garbageCollector=None, passthrough=None, arg_attrs=None, res_attrs=None, function_entry_count=None, memory_effects=None, visibility_=None, arm_streaming=None, arm_locally_streaming=None, arm_streaming_compatible=None, arm_new_za=None, arm_in_za=None, arm_out_za=None, arm_inout_za=None, arm_preserves_za=None, section=None, unnamed_addr=None, alignment=None, vscale_range=None, frame_pointer=None, target_cpu=None, tune_cpu=None, reciprocal_estimates=None, prefer_vector_width=None, target_features=None, no_infs_fp_math=None, no_nans_fp_math=None, no_signed_zeros_fp_math=None, denormal_fp_math=None, denormal_fp_math_f32=None, fp_contract=None, instrument_function_entry=None, instrument_function_exit=None, no_inline=None, always_inline=None, inline_hint=None, no_unwind=None, will_return=None, optimize_none=None, vec_type_hint=None, work_group_size_hint=None, reqd_work_group_size=None, intel_reqd_sub_group_size=None, uwtable_kind=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   MLIR functions are defined by an operation that is not built into the IR
   itself. The LLVM dialect provides an ``llvm.func`` operation to define
   functions compatible with LLVM IR. These functions have LLVM dialect
   function type but use MLIR syntax to express it. They are required to have
   exactly one result type. LLVM function operation is intended to capture
   additional properties of LLVM functions, such as linkage and calling
   convention, that may be modeled differently by the built-in MLIR function.

   .. code:: mlir

       // The type of @bar is !llvm<"i64 (i64)">
       llvm.func @bar(%arg0: i64) -> i64 {
         llvm.return %arg0 : i64
       }
       
       // Type type of @foo is !llvm<"void (i64)">
       // !llvm.void type is omitted
       llvm.func @foo(%arg0: i64) {
         llvm.return
       }
       
       // A function with `internal` linkage.
       llvm.func internal @internal_func() {
         llvm.return
       }


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.func'



   .. py:attribute:: _ODS_REGIONS
      :value: (1, True)



   .. py:method:: sym_name() -> _ods_ir


   .. py:method:: sym_visibility() -> Optional[_ods_ir]


   .. py:method:: function_type() -> _ods_ir


   .. py:method:: linkage() -> _ods_ir


   .. py:method:: dso_local() -> bool


   .. py:method:: CConv() -> _ods_ir


   .. py:method:: comdat() -> Optional[_ods_ir]


   .. py:method:: convergent() -> bool


   .. py:method:: personality() -> Optional[_ods_ir]


   .. py:method:: garbageCollector() -> Optional[_ods_ir]


   .. py:method:: passthrough() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: function_entry_count() -> Optional[_ods_ir]


   .. py:method:: memory_effects() -> Optional[_ods_ir]


   .. py:method:: visibility_() -> _ods_ir


   .. py:method:: arm_streaming() -> bool


   .. py:method:: arm_locally_streaming() -> bool


   .. py:method:: arm_streaming_compatible() -> bool


   .. py:method:: arm_new_za() -> bool


   .. py:method:: arm_in_za() -> bool


   .. py:method:: arm_out_za() -> bool


   .. py:method:: arm_inout_za() -> bool


   .. py:method:: arm_preserves_za() -> bool


   .. py:method:: section() -> Optional[_ods_ir]


   .. py:method:: unnamed_addr() -> Optional[_ods_ir]


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: vscale_range() -> Optional[_ods_ir]


   .. py:method:: frame_pointer() -> Optional[_ods_ir]


   .. py:method:: target_cpu() -> Optional[_ods_ir]


   .. py:method:: tune_cpu() -> Optional[_ods_ir]


   .. py:method:: reciprocal_estimates() -> Optional[_ods_ir]


   .. py:method:: prefer_vector_width() -> Optional[_ods_ir]


   .. py:method:: target_features() -> Optional[_ods_ir]


   .. py:method:: no_infs_fp_math() -> Optional[_ods_ir]


   .. py:method:: no_nans_fp_math() -> Optional[_ods_ir]


   .. py:method:: no_signed_zeros_fp_math() -> Optional[_ods_ir]


   .. py:method:: denormal_fp_math() -> Optional[_ods_ir]


   .. py:method:: denormal_fp_math_f32() -> Optional[_ods_ir]


   .. py:method:: fp_contract() -> Optional[_ods_ir]


   .. py:method:: instrument_function_entry() -> Optional[_ods_ir]


   .. py:method:: instrument_function_exit() -> Optional[_ods_ir]


   .. py:method:: no_inline() -> bool


   .. py:method:: always_inline() -> bool


   .. py:method:: inline_hint() -> bool


   .. py:method:: no_unwind() -> bool


   .. py:method:: will_return() -> bool


   .. py:method:: optimize_none() -> bool


   .. py:method:: vec_type_hint() -> Optional[_ods_ir]


   .. py:method:: work_group_size_hint() -> Optional[_ods_ir]


   .. py:method:: reqd_work_group_size() -> Optional[_ods_ir]


   .. py:method:: intel_reqd_sub_group_size() -> Optional[_ods_ir]


   .. py:method:: uwtable_kind() -> Optional[_ods_ir]


   .. py:method:: body() -> _ods_ir


.. py:function:: func(sym_name, function_type, *, sym_visibility=None, linkage=None, dso_local=None, c_conv=None, comdat=None, convergent=None, personality=None, garbage_collector=None, passthrough=None, arg_attrs=None, res_attrs=None, function_entry_count=None, memory_effects=None, visibility_=None, arm_streaming=None, arm_locally_streaming=None, arm_streaming_compatible=None, arm_new_za=None, arm_in_za=None, arm_out_za=None, arm_inout_za=None, arm_preserves_za=None, section=None, unnamed_addr=None, alignment=None, vscale_range=None, frame_pointer=None, target_cpu=None, tune_cpu=None, reciprocal_estimates=None, prefer_vector_width=None, target_features=None, no_infs_fp_math=None, no_nans_fp_math=None, no_signed_zeros_fp_math=None, denormal_fp_math=None, denormal_fp_math_f32=None, fp_contract=None, instrument_function_entry=None, instrument_function_exit=None, no_inline=None, always_inline=None, inline_hint=None, no_unwind=None, will_return=None, optimize_none=None, vec_type_hint=None, work_group_size_hint=None, reqd_work_group_size=None, intel_reqd_sub_group_size=None, uwtable_kind=None, loc=None, ip=None) -> LLVMFuncOp

.. py:class:: LShrOp(lhs, rhs, *, isExact=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.lshr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: isExact() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: lshr(lhs, rhs, *, is_exact=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LandingpadOp(res, _gen_arg_1, *, cleanup=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.landingpad'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: cleanup() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: landingpad(res, _gen_arg_1, *, cleanup=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LaunderInvariantGroupOp(ptr, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.launder.invariant.group'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_launder_invariant_group(ptr, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LifetimeEndOp(ptr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.lifetime.end'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


.. py:function:: intr_lifetime_end(ptr, *, loc=None, ip=None) -> LifetimeEndOp

.. py:class:: LifetimeStartOp(ptr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.lifetime.start'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


.. py:function:: intr_lifetime_start(ptr, *, loc=None, ip=None) -> LifetimeStartOp

.. py:class:: LinkerOptionsOp(options, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Pass the given options to the linker when the resulting object file is linked.
   This is used extensively on Windows to determine the C runtime that the object
   files should link against.

   Examples:

   .. code:: mlir

       // Link against the MSVC static threaded CRT.
       llvm.linker_options ["/DEFAULTLIB:", "libcmt"]
       
       // Link against aarch64 compiler-rt builtins
       llvm.linker_options ["-l", "clang_rt.builtins-aarch64"]


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.linker_options'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: options() -> _ods_ir


.. py:function:: linker_options(options, *, loc=None, ip=None) -> LinkerOptionsOp

.. py:class:: LlrintOp(res, val, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.llrint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_llrint(res, val, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LlroundOp(res, val, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.llround'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_llround(res, val, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LoadExpOp(res, val, power, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ldexp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: power() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ldexp(res, val, power, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LoadOp(res, addr, *, alignment=None, volatile_=None, nontemporal=None, invariant=None, invariantGroup=None, ordering=None, syncscope=None, dereferenceable=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``load`` operation is used to read from memory. A load may be marked as
   atomic, volatile, and/or nontemporal, and takes a number of optional
   attributes that specify aliasing information.

   An atomic load only supports a limited set of pointer, integer, and
   floating point types, and requires an explicit alignment.

   Examples:

   .. code:: mlir

       // A volatile load of a float variable.
       %0 = llvm.load volatile %ptr : !llvm.ptr -> f32
       
       // A nontemporal load of a float variable.
       %0 = llvm.load %ptr {nontemporal} : !llvm.ptr -> f32
       
       // An atomic load of an integer variable.
       %0 = llvm.load %ptr atomic monotonic {alignment = 8 : i64}
           : !llvm.ptr -> i64

   See the following link for more details:
   https://llvm.org/docs/LangRef.html#load-instruction


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: addr() -> _ods_ir


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: volatile_() -> bool


   .. py:method:: nontemporal() -> bool


   .. py:method:: invariant() -> bool


   .. py:method:: invariantGroup() -> bool


   .. py:method:: ordering() -> _ods_ir


   .. py:method:: syncscope() -> Optional[_ods_ir]


   .. py:method:: dereferenceable() -> Optional[_ods_ir]


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: load(res, addr, *, alignment=None, volatile_=None, nontemporal=None, invariant=None, invariant_group=None, ordering=None, syncscope=None, dereferenceable=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Log2Op(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.log2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_log2(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Log10Op(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.log10'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_log10(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LogOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.log'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_log(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: LrintOp(res, val, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.lrint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_lrint(res, val, *, loc=None, ip=None) -> _ods_ir

.. py:class:: LroundOp(res, val, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.lround'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_lround(res, val, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MaskedLoadOp(res, data, mask, alignment, *, pass_thru=None, nontemporal=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: data() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: pass_thru() -> Optional[_ods_ir[_ods_ir]]


   .. py:method:: alignment() -> _ods_ir


   .. py:method:: nontemporal() -> bool


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_masked_load(res, data, mask, alignment, *, pass_thru=None, nontemporal=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MaskedStoreOp(value, data, mask, alignment, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: data() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: alignment() -> _ods_ir


.. py:function:: intr_masked_store(value, data, mask, alignment, *, loc=None, ip=None) -> MaskedStoreOp

.. py:class:: MatrixColumnMajorLoadOp(res, data, stride, isVolatile, rows, columns, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.matrix.column.major.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: data() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: rows() -> _ods_ir


   .. py:method:: columns() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_matrix_column_major_load(res, data, stride, is_volatile, rows, columns, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MatrixColumnMajorStoreOp(matrix, data, stride, isVolatile, rows, columns, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.matrix.column.major.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: matrix() -> _ods_ir[_ods_ir]


   .. py:method:: data() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: rows() -> _ods_ir


   .. py:method:: columns() -> _ods_ir


.. py:function:: intr_matrix_column_major_store(matrix, data, stride, is_volatile, rows, columns, *, loc=None, ip=None) -> MatrixColumnMajorStoreOp

.. py:class:: MatrixMultiplyOp(res, lhs, rhs, lhs_rows, lhs_columns, rhs_columns, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.matrix.multiply'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: lhs_rows() -> _ods_ir


   .. py:method:: lhs_columns() -> _ods_ir


   .. py:method:: rhs_columns() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_matrix_multiply(res, lhs, rhs, lhs_rows, lhs_columns, rhs_columns, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MatrixTransposeOp(res, matrix, rows, columns, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.matrix.transpose'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: matrix() -> _ods_ir[_ods_ir]


   .. py:method:: rows() -> _ods_ir


   .. py:method:: columns() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_matrix_transpose(res, matrix, rows, columns, *, loc=None, ip=None) -> _ods_ir

.. py:class:: MaxNumOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.maxnum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_maxnum(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MaximumOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.maximum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_maximum(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MemcpyInlineOp(dst, src, len, isVolatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.memcpy.inline'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dst() -> _ods_ir


   .. py:method:: src() -> _ods_ir


   .. py:method:: len() -> _ods_ir


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_memcpy_inline(dst, src, len, is_volatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> MemcpyInlineOp

.. py:class:: MemcpyOp(dst, src, len, isVolatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.memcpy'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dst() -> _ods_ir


   .. py:method:: src() -> _ods_ir


   .. py:method:: len() -> _ods_ir[_ods_ir]


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_memcpy(dst, src, len, is_volatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> MemcpyOp

.. py:class:: MemmoveOp(dst, src, len, isVolatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.memmove'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dst() -> _ods_ir


   .. py:method:: src() -> _ods_ir


   .. py:method:: len() -> _ods_ir[_ods_ir]


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_memmove(dst, src, len, is_volatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> MemmoveOp

.. py:class:: MemsetInlineOp(dst, val, len, isVolatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.memset.inline'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dst() -> _ods_ir


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: len() -> _ods_ir


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_memset_inline(dst, val, len, is_volatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> MemsetInlineOp

.. py:class:: MemsetOp(dst, val, len, isVolatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.memset'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dst() -> _ods_ir


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: len() -> _ods_ir[_ods_ir]


   .. py:method:: isVolatile() -> _ods_ir


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_memset(dst, val, len, is_volatile, *, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> MemsetOp

.. py:class:: MinNumOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.minnum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_minnum(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: MinimumOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.minimum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_minimum(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ModuleFlagsOp(flags, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Represents the equivalent in MLIR for LLVM's ``llvm.module.flags`` metadata,
   which requires a list of metadata triplets. Each triplet entry is described
   by a ``ModuleFlagAttr``.

   Example:

   .. code:: mlir

       llvm.module.flags [
         #llvm.mlir.module_flag<error, "wchar_size", 4>,
         #llvm.mlir.module_flag<max, "PIC Level", 2>
       ]


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.module_flags'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: flags() -> _ods_ir


.. py:function:: module_flags(flags, *, loc=None, ip=None) -> ModuleFlagsOp

.. py:class:: MulOp(lhs, rhs, overflowFlags, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: mul(lhs, rhs, overflow_flags, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: NearbyintOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.nearbyint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_nearbyint(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: NoAliasScopeDeclOp(scope, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.noalias.scope.decl'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: scope() -> _ods_ir


.. py:function:: intr_experimental_noalias_scope_decl(scope, *, loc=None, ip=None) -> NoAliasScopeDeclOp

.. py:class:: NoneTokenOp(*, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Unlike LLVM IR, MLIR does not have first-class token values. They must be
   explicitly created as SSA values using ``llvm.mlir.none``. This operation has
   no operands or attributes, and returns a none token value of a wrapped LLVM IR
   pointer type.

   Examples:

   .. code:: mlir

       %0 = llvm.mlir.none : !llvm.token


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.none'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_none(*, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: OrOp(lhs, rhs, *, isDisjoint=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: isDisjoint() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: or_(lhs, rhs, *, is_disjoint=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PoisonOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Unlike LLVM IR, MLIR does not have first-class poison values. Such values
   must be created as SSA values using ``llvm.mlir.poison``. This operation has
   no operands or attributes. It creates a poison value of the specified LLVM
   IR dialect type.

   Example:

   .. code:: mlir

       // Create a poison value for a structure with a 32-bit integer followed
       // by a float.
       %0 = llvm.mlir.poison : !llvm.struct<(i32, f32)>


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.poison'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_poison(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: PowIOp(res, val, power, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.powi'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: power() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_powi(res, val, power, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PowOp(a, b, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.pow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_pow(a, b, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: Prefetch(addr, rw, hint, cache, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.prefetch'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: addr() -> _ods_ir


   .. py:method:: rw() -> _ods_ir


   .. py:method:: hint() -> _ods_ir


   .. py:method:: cache() -> _ods_ir


.. py:function:: intr_prefetch(addr, rw, hint, cache, *, loc=None, ip=None) -> Prefetch

.. py:class:: PtrAnnotation(ptr, annotation, fileName, line, attr, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ptr.annotation'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: annotation() -> _ods_ir


   .. py:method:: fileName() -> _ods_ir


   .. py:method:: line() -> _ods_ir[_ods_ir]


   .. py:method:: attr() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ptr_annotation(ptr, annotation, file_name, line, attr, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PtrMaskOp(ptr, mask, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ptrmask'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: mask() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ptrmask(ptr, mask, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: PtrToIntOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.ptrtoint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: ptrtoint(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: ResumeOp(value, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.resume'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


.. py:function:: resume(value, *, loc=None, ip=None) -> ResumeOp

.. py:class:: ReturnOp(*, arg=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.return'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> Optional[_ods_ir]


.. py:function:: return_(*, arg=None, loc=None, ip=None) -> ReturnOp

.. py:class:: RintOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.rint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_rint(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: RoundEvenOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.roundeven'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_roundeven(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: RoundOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.round'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_round(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SAddSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sadd.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sadd_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SAddWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sadd.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sadd_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SCmpOp(res, a, b, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.scmp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_scmp(res, a, b, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SDivOp(lhs, rhs, *, isExact=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.sdiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: isExact() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: sdiv(lhs, rhs, *, is_exact=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SExtOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.sext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: sext(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SIToFPOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.sitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: sitofp(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SMaxOp(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.smax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_smax(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SMinOp(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.smin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_smin(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SMulWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.smul.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_smul_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SRemOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.srem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: srem(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SSACopyOp(operand, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ssa.copy'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: operand() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ssa_copy(operand, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SSHLSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sshl.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sshl_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SSubSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ssub.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ssub_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SSubWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ssub.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ssub_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SelectOp(condition, trueValue, falseValue, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.select'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: condition() -> _ods_ir


   .. py:method:: trueValue() -> _ods_ir


   .. py:method:: falseValue() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: select(condition, true_value, false_value, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ShlOp(lhs, rhs, overflowFlags, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.shl'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: shl(lhs, rhs, overflow_flags, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ShuffleVectorOp(res, v1, v2, mask, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.shufflevector'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: v1() -> _ods_ir[_ods_ir]


   .. py:method:: v2() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: shufflevector(res, v1, v2, mask, *, loc=None, ip=None) -> _ods_ir

.. py:class:: SinOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sin(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SincosOp(res, val, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sincos'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sincos(res, val, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SinhOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sinh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sinh(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SqrtOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.sqrt'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_sqrt(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: StackRestoreOp(ptr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.stackrestore'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


.. py:function:: intr_stackrestore(ptr, *, loc=None, ip=None) -> StackRestoreOp

.. py:class:: StackSaveOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.stacksave'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_stacksave(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: StepVectorOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.stepvector'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_stepvector(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: StoreOp(value, addr, *, alignment=None, volatile_=None, nontemporal=None, invariantGroup=None, ordering=None, syncscope=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   The ``store`` operation is used to write to memory. A store may be marked as
   atomic, volatile, and/or nontemporal, and takes a number of optional
   attributes that specify aliasing information.

   An atomic store only supports a limited set of pointer, integer, and
   floating point types, and requires an explicit alignment.

   Examples:

   .. code:: mlir

       // A volatile store of a float variable.
       llvm.store volatile %val, %ptr : f32, !llvm.ptr
       
       // A nontemporal store of a float variable.
       llvm.store %val, %ptr {nontemporal} : f32, !llvm.ptr
       
       // An atomic store of an integer variable.
       llvm.store %val, %ptr atomic monotonic {alignment = 8 : i64}
           : i64, !llvm.ptr

   See the following link for more details:
   https://llvm.org/docs/LangRef.html#store-instruction


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir


   .. py:method:: addr() -> _ods_ir


   .. py:method:: alignment() -> Optional[_ods_ir]


   .. py:method:: volatile_() -> bool


   .. py:method:: nontemporal() -> bool


   .. py:method:: invariantGroup() -> bool


   .. py:method:: ordering() -> _ods_ir


   .. py:method:: syncscope() -> Optional[_ods_ir]


   .. py:method:: access_groups() -> Optional[_ods_ir]


   .. py:method:: alias_scopes() -> Optional[_ods_ir]


   .. py:method:: noalias_scopes() -> Optional[_ods_ir]


   .. py:method:: tbaa() -> Optional[_ods_ir]


.. py:function:: store(value, addr, *, alignment=None, volatile_=None, nontemporal=None, invariant_group=None, ordering=None, syncscope=None, access_groups=None, alias_scopes=None, noalias_scopes=None, tbaa=None, loc=None, ip=None) -> StoreOp

.. py:class:: StripInvariantGroupOp(ptr, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.strip.invariant.group'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_strip_invariant_group(ptr, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SubOp(lhs, rhs, overflowFlags, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.sub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: sub(lhs, rhs, overflow_flags, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: SwitchOp(value, defaultOperands, caseOperands, case_operand_segments, defaultDestination, caseDestinations, *, case_values=None, branch_weights=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.switch'



   .. py:attribute:: _ODS_OPERAND_SEGMENTS


   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: defaultOperands() -> _ods_ir


   .. py:method:: caseOperands() -> _ods_ir


   .. py:method:: case_values() -> Optional[_ods_ir]


   .. py:method:: case_operand_segments() -> _ods_ir


   .. py:method:: branch_weights() -> Optional[_ods_ir]


.. py:function:: switch(value, default_operands, case_operands, case_operand_segments, default_destination, case_destinations, *, case_values=None, branch_weights=None, loc=None, ip=None) -> SwitchOp

.. py:class:: TanOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.tan'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_tan(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: TanhOp(in_, *, fastmathFlags=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.tanh'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_tanh(in_, *, fastmath_flags=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ThreadlocalAddressOp(res, global_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.threadlocal.address'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: global_() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_threadlocal_address(res, global_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: Trap(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.trap'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: intr_trap(*, loc=None, ip=None) -> Trap

.. py:class:: TruncOp(res, arg, overflowFlags, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.trunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: trunc(res, arg, overflow_flags, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UAddSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.uadd.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_uadd_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UAddWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.uadd.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_uadd_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UBSanTrap(failureKind, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ubsantrap'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: failureKind() -> _ods_ir


.. py:function:: intr_ubsantrap(failure_kind, *, loc=None, ip=None) -> UBSanTrap

.. py:class:: UCmpOp(res, a, b, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ucmp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ucmp(res, a, b, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UDivOp(lhs, rhs, *, isExact=None, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.udiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: isExact() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: udiv(lhs, rhs, *, is_exact=None, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UIToFPOp(res, arg, *, nonNeg=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.uitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: nonNeg() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: uitofp(res, arg, *, non_neg=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UMaxOp(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.umax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_umax(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UMinOp(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.umin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_umin(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: UMulWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.umul.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_umul_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: URemOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.urem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: urem(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: USHLSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.ushl.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_ushl_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: USubSat(a, b, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.usub.sat'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: a() -> _ods_ir


   .. py:method:: b() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_usub_sat(a, b, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: USubWithOverflowOp(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.usub.with.overflow'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_usub_with_overflow(res, _gen_arg_0, _gen_arg_1, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UndefOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Unlike LLVM IR, MLIR does not have first-class undefined values. Such values
   must be created as SSA values using ``llvm.mlir.undef``. This operation has no
   operands or attributes. It creates an undefined value of the specified LLVM
   IR dialect type.

   Example:

   .. code:: mlir

       // Create a structure with a 32-bit integer followed by a float.
       %0 = llvm.mlir.undef : !llvm.struct<(i32, f32)>


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.undef'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_undef(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: UnreachableOp(*, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.unreachable'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



.. py:function:: unreachable(*, loc=None, ip=None) -> UnreachableOp

.. py:class:: VPAShrOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.ashr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_ashr(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPAddOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.add'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_add(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPAndOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_and(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFAddOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fadd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fadd(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFDivOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fdiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fdiv(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFMulAddOp(res, op1, op2, op3, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fmuladd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: op1() -> _ods_ir[_ods_ir]


   .. py:method:: op2() -> _ods_ir[_ods_ir]


   .. py:method:: op3() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fmuladd(res, op1, op2, op3, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFMulOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fmul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fmul(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFNegOp(res, op, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fneg'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: op() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fneg(res, op, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFPExtOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fpext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fpext(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFPToSIOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fptosi'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fptosi(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFPToUIOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fptoui'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fptoui(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFPTruncOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fptrunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fptrunc(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFRemOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.frem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_frem(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFSubOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fsub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fsub(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPFmaOp(res, op1, op2, op3, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.fma'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: op1() -> _ods_ir[_ods_ir]


   .. py:method:: op2() -> _ods_ir[_ods_ir]


   .. py:method:: op3() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_fma(res, op1, op2, op3, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPIntToPtrOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.inttoptr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_inttoptr(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPLShrOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.lshr'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_lshr(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPLoadOp(res, ptr, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_load(res, ptr, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPMergeMinOp(res, cond, true_val, false_val, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.merge'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: cond() -> _ods_ir[_ods_ir]


   .. py:method:: true_val() -> _ods_ir[_ods_ir]


   .. py:method:: false_val() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_merge(res, cond, true_val, false_val, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPMulOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.mul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_mul(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPOrOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_or(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPPtrToIntOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.ptrtoint'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_ptrtoint(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceAddOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.add'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_add(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceAndOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_and(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceFAddOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.fadd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_fadd(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceFMaxOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.fmax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_fmax(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceFMinOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.fmin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_fmin(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceFMulOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.fmul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_fmul(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceMulOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.mul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_mul(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceOrOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_or(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceSMaxOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.smax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_smax(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceSMinOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.smin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_smin(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceUMaxOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.umax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_umax(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceUMinOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.umin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_umin(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPReduceXorOp(res, satrt_value, val, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.reduce.xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: satrt_value() -> _ods_ir[_ods_ir]


   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_reduce_xor(res, satrt_value, val, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSDivOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.sdiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_sdiv(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSExtOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.sext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_sext(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSIToFPOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.sitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_sitofp(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSMaxOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.smax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_smax(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSMinOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.smin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_smin(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSRemOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.srem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_srem(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPSelectMinOp(res, cond, true_val, false_val, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.select'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: cond() -> _ods_ir[_ods_ir]


   .. py:method:: true_val() -> _ods_ir[_ods_ir]


   .. py:method:: false_val() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_select(res, cond, true_val, false_val, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPShlOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.shl'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_shl(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPStoreOp(val, ptr, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: ptr() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


.. py:function:: intr_vp_store(val, ptr, mask, evl, *, loc=None, ip=None) -> VPStoreOp

.. py:class:: VPStridedLoadOp(res, ptr, stride, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.vp.strided.load'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_experimental_vp_strided_load(res, ptr, stride, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPStridedStoreOp(val, ptr, stride, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.experimental.vp.strided.store'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir[_ods_ir]


   .. py:method:: ptr() -> _ods_ir


   .. py:method:: stride() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


.. py:function:: intr_experimental_vp_strided_store(val, ptr, stride, mask, evl, *, loc=None, ip=None) -> VPStridedStoreOp

.. py:class:: VPSubOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.sub'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_sub(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPTruncOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.trunc'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_trunc(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPUDivOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.udiv'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_udiv(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPUIToFPOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.uitofp'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_uitofp(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPUMaxOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.umax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_umax(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPUMinOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.umin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_umin(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPURemOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.urem'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_urem(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPXorOp(res, lhs, rhs, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir[_ods_ir]


   .. py:method:: rhs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_xor(res, lhs, rhs, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VPZExtOp(res, src, mask, evl, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vp.zext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: src() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: evl() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vp_zext(res, src, mask, evl, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VaArgOp(res, arg, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.va_arg'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: va_arg(res, arg, *, loc=None, ip=None) -> _ods_ir

.. py:class:: VaCopyOp(dest_list, src_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vacopy'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dest_list() -> _ods_ir


   .. py:method:: src_list() -> _ods_ir


.. py:function:: intr_vacopy(dest_list, src_list, *, loc=None, ip=None) -> VaCopyOp

.. py:class:: VaEndOp(arg_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vaend'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_list() -> _ods_ir


.. py:function:: intr_vaend(arg_list, *, loc=None, ip=None) -> VaEndOp

.. py:class:: VaStartOp(arg_list, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vastart'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg_list() -> _ods_ir


.. py:function:: intr_vastart(arg_list, *, loc=None, ip=None) -> VaStartOp

.. py:class:: VarAnnotation(val, annotation, fileName, line, attr, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.var.annotation'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: val() -> _ods_ir


   .. py:method:: annotation() -> _ods_ir


   .. py:method:: fileName() -> _ods_ir


   .. py:method:: line() -> _ods_ir[_ods_ir]


   .. py:method:: attr() -> _ods_ir


.. py:function:: intr_var_annotation(val, annotation, file_name, line, attr, *, loc=None, ip=None) -> VarAnnotation

.. py:class:: XOrOp(lhs, rhs, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: lhs() -> _ods_ir


   .. py:method:: rhs() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: xor(lhs, rhs, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ZExtOp(res, arg, *, nonNeg=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.zext'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: arg() -> _ods_ir


   .. py:method:: nonNeg() -> bool


   .. py:method:: res() -> _ods_ir


.. py:function:: zext(res, arg, *, non_neg=None, loc=None, ip=None) -> _ods_ir

.. py:class:: ZeroOp(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   
   Unlike LLVM IR, MLIR does not have first-class zero-initialized values.
   Such values must be created as SSA values using ``llvm.mlir.zero``. This
   operation has no operands or attributes. It creates a zero-initialized
   value of the specified LLVM IR dialect type.

   Example:

   .. code:: mlir

       // Create a zero-initialized value for a structure with a 32-bit integer
       // followed by a float.
       %0 = llvm.mlir.zero : !llvm.struct<(i32, f32)>


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.mlir.zero'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: mlir_zero(res, *, loc=None, ip=None) -> _ods_ir

.. py:class:: masked_compressstore(value, ptr, mask, *, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.compressstore'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: ptr() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


.. py:function:: intr_masked_compressstore(value, ptr, mask, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> masked_compressstore

.. py:class:: masked_expandload(res, ptr, mask, passthru, *, arg_attrs=None, res_attrs=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.expandload'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptr() -> _ods_ir


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: passthru() -> _ods_ir[_ods_ir]


   .. py:method:: arg_attrs() -> Optional[_ods_ir]


   .. py:method:: res_attrs() -> Optional[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_masked_expandload(res, ptr, mask, passthru, *, arg_attrs=None, res_attrs=None, loc=None, ip=None) -> _ods_ir

.. py:class:: masked_gather(res, ptrs, mask, pass_thru, alignment, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.gather'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: ptrs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: pass_thru() -> _ods_ir


   .. py:method:: alignment() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_masked_gather(res, ptrs, mask, pass_thru, alignment, *, loc=None, ip=None) -> _ods_ir

.. py:class:: masked_scatter(value, ptrs, mask, alignment, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.masked.scatter'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: value() -> _ods_ir[_ods_ir]


   .. py:method:: ptrs() -> _ods_ir[_ods_ir]


   .. py:method:: mask() -> _ods_ir[_ods_ir]


   .. py:method:: alignment() -> _ods_ir


.. py:function:: intr_masked_scatter(value, ptrs, mask, alignment, *, loc=None, ip=None) -> masked_scatter

.. py:class:: vector_deinterleave2(res, vec, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.deinterleave2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vec() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_deinterleave2(res, vec, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_extract(res, srcvec, pos, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.extract'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: srcvec() -> _ods_ir[_ods_ir]


   .. py:method:: pos() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_vector_extract(res, srcvec, pos, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_insert(dstvec, srcvec, pos, *, results=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.insert'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: dstvec() -> _ods_ir[_ods_ir]


   .. py:method:: srcvec() -> _ods_ir[_ods_ir]


   .. py:method:: pos() -> _ods_ir


   .. py:method:: res() -> _ods_ir[_ods_ir]


.. py:function:: intr_vector_insert(dstvec, srcvec, pos, *, results=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_interleave2(res, vec1, vec2, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.interleave2'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: vec1() -> _ods_ir[_ods_ir]


   .. py:method:: vec2() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_interleave2(res, vec1, vec2, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_add(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.add'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_add(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_and(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.and'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_and(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fadd(res, start_value, input, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fadd'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: start_value() -> _ods_ir[_ods_ir]


   .. py:method:: input() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fadd(res, start_value, input, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fmax(res, in_, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fmax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fmax(res, in_, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fmaximum(res, in_, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fmaximum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fmaximum(res, in_, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fmin(res, in_, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fmin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fmin(res, in_, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fminimum(res, in_, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fminimum'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fminimum(res, in_, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_fmul(res, start_value, input, *, fastmathFlags=None, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.fmul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: start_value() -> _ods_ir[_ods_ir]


   .. py:method:: input() -> _ods_ir[_ods_ir]


   .. py:method:: fastmathFlags() -> _ods_ir


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_fmul(res, start_value, input, *, fastmath_flags=None, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_mul(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.mul'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_mul(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_or(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.or'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_or(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_smax(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.smax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_smax(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_smin(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.smin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_smin(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_umax(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.umax'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_umax(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_umin(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.umin'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_umin(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vector_reduce_xor(res, in_, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vector.reduce.xor'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: in_() -> _ods_ir[_ods_ir]


   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vector_reduce_xor(res, in_, *, loc=None, ip=None) -> _ods_ir

.. py:class:: vscale(res, *, loc=None, ip=None)

   Bases: :py:obj:`_ods_ir`


   .. py:attribute:: OPERATION_NAME
      :value: 'llvm.intr.vscale'



   .. py:attribute:: _ODS_REGIONS
      :value: (0, True)



   .. py:method:: res() -> _ods_ir


.. py:function:: intr_vscale(res, *, loc=None, ip=None) -> _ods_ir

.. py:function:: register_attribute_builder(kind, replace=False)

.. py:class:: AsmDialect

   Bases: :py:obj:`enum.IntEnum`


   
   ATT (0) or Intel (1) asm dialect


   .. py:attribute:: AD_ATT
      :value: 0



   .. py:attribute:: AD_Intel
      :value: 1



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: AtomicBinOp

   Bases: :py:obj:`enum.IntEnum`


   
   llvm.atomicrmw binary operations


   .. py:attribute:: xchg
      :value: 0



   .. py:attribute:: add
      :value: 1



   .. py:attribute:: sub
      :value: 2



   .. py:attribute:: _and
      :value: 3



   .. py:attribute:: nand
      :value: 4



   .. py:attribute:: _or
      :value: 5



   .. py:attribute:: _xor
      :value: 6



   .. py:attribute:: max
      :value: 7



   .. py:attribute:: min
      :value: 8



   .. py:attribute:: umax
      :value: 9



   .. py:attribute:: umin
      :value: 10



   .. py:attribute:: fadd
      :value: 11



   .. py:attribute:: fsub
      :value: 12



   .. py:attribute:: fmax
      :value: 13



   .. py:attribute:: fmin
      :value: 14



   .. py:attribute:: uinc_wrap
      :value: 15



   .. py:attribute:: udec_wrap
      :value: 16



   .. py:attribute:: usub_cond
      :value: 17



   .. py:attribute:: usub_sat
      :value: 18



   .. py:attribute:: fmaximum
      :value: 19



   .. py:attribute:: fminimum
      :value: 20



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: AtomicOrdering

   Bases: :py:obj:`enum.IntEnum`


   
   Atomic ordering for LLVM's memory model


   .. py:attribute:: not_atomic
      :value: 0



   .. py:attribute:: unordered
      :value: 1



   .. py:attribute:: monotonic
      :value: 2



   .. py:attribute:: acquire
      :value: 4



   .. py:attribute:: release
      :value: 5



   .. py:attribute:: acq_rel
      :value: 6



   .. py:attribute:: seq_cst
      :value: 7



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: CConv

   Bases: :py:obj:`enum.IntEnum`


   
   Calling Conventions


   .. py:attribute:: C
      :value: 0



   .. py:attribute:: Fast
      :value: 8



   .. py:attribute:: Cold
      :value: 9



   .. py:attribute:: GHC
      :value: 10



   .. py:attribute:: HiPE
      :value: 11



   .. py:attribute:: AnyReg
      :value: 13



   .. py:attribute:: PreserveMost
      :value: 14



   .. py:attribute:: PreserveAll
      :value: 15



   .. py:attribute:: Swift
      :value: 16



   .. py:attribute:: CXX_FAST_TLS
      :value: 17



   .. py:attribute:: Tail
      :value: 18



   .. py:attribute:: CFGuard_Check
      :value: 19



   .. py:attribute:: SwiftTail
      :value: 20



   .. py:attribute:: X86_StdCall
      :value: 64



   .. py:attribute:: X86_FastCall
      :value: 65



   .. py:attribute:: ARM_APCS
      :value: 66



   .. py:attribute:: ARM_AAPCS
      :value: 67



   .. py:attribute:: ARM_AAPCS_VFP
      :value: 68



   .. py:attribute:: MSP430_INTR
      :value: 69



   .. py:attribute:: X86_ThisCall
      :value: 70



   .. py:attribute:: PTX_Kernel
      :value: 71



   .. py:attribute:: PTX_Device
      :value: 72



   .. py:attribute:: SPIR_FUNC
      :value: 75



   .. py:attribute:: SPIR_KERNEL
      :value: 76



   .. py:attribute:: Intel_OCL_BI
      :value: 77



   .. py:attribute:: X86_64_SysV
      :value: 78



   .. py:attribute:: Win64
      :value: 79



   .. py:attribute:: X86_VectorCall
      :value: 80



   .. py:attribute:: DUMMY_HHVM
      :value: 81



   .. py:attribute:: DUMMY_HHVM_C
      :value: 82



   .. py:attribute:: X86_INTR
      :value: 83



   .. py:attribute:: AVR_INTR
      :value: 84



   .. py:attribute:: AVR_BUILTIN
      :value: 86



   .. py:attribute:: AMDGPU_VS
      :value: 87



   .. py:attribute:: AMDGPU_GS
      :value: 88



   .. py:attribute:: AMDGPU_CS
      :value: 90



   .. py:attribute:: AMDGPU_KERNEL
      :value: 91



   .. py:attribute:: X86_RegCall
      :value: 92



   .. py:attribute:: AMDGPU_HS
      :value: 93



   .. py:attribute:: MSP430_BUILTIN
      :value: 94



   .. py:attribute:: AMDGPU_LS
      :value: 95



   .. py:attribute:: AMDGPU_ES
      :value: 96



   .. py:attribute:: AArch64_VectorCall
      :value: 97



   .. py:attribute:: AArch64_SVE_VectorCall
      :value: 98



   .. py:attribute:: WASM_EmscriptenInvoke
      :value: 99



   .. py:attribute:: AMDGPU_Gfx
      :value: 100



   .. py:attribute:: M68k_INTR
      :value: 101



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: Comdat

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM Comdat Types


   .. py:attribute:: Any
      :value: 0



   .. py:attribute:: ExactMatch
      :value: 1



   .. py:attribute:: Largest
      :value: 2



   .. py:attribute:: NoDeduplicate
      :value: 3



   .. py:attribute:: SameSize
      :value: 4



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: DIFlags

   Bases: :py:obj:`enum.IntFlag`


   
   LLVM DI flags


   .. py:attribute:: Zero
      :value: 0



   .. py:attribute:: Bit0
      :value: 1



   .. py:attribute:: Bit1
      :value: 2



   .. py:attribute:: Private
      :value: 1



   .. py:attribute:: Protected
      :value: 2



   .. py:attribute:: Public
      :value: 3



   .. py:attribute:: FwdDecl
      :value: 4



   .. py:attribute:: AppleBlock
      :value: 8



   .. py:attribute:: ReservedBit4
      :value: 16



   .. py:attribute:: Virtual
      :value: 32



   .. py:attribute:: Artificial
      :value: 64



   .. py:attribute:: Explicit
      :value: 128



   .. py:attribute:: Prototyped
      :value: 256



   .. py:attribute:: ObjcClassComplete
      :value: 512



   .. py:attribute:: ObjectPointer
      :value: 1024



   .. py:attribute:: Vector
      :value: 2048



   .. py:attribute:: StaticMember
      :value: 4096



   .. py:attribute:: LValueReference
      :value: 8192



   .. py:attribute:: RValueReference
      :value: 16384



   .. py:attribute:: ExportSymbols
      :value: 32768



   .. py:attribute:: SingleInheritance
      :value: 65536



   .. py:attribute:: MultipleInheritance
      :value: 65536



   .. py:attribute:: VirtualInheritance
      :value: 65536



   .. py:attribute:: IntroducedVirtual
      :value: 262144



   .. py:attribute:: BitField
      :value: 524288



   .. py:attribute:: NoReturn
      :value: 1048576



   .. py:attribute:: TypePassByValue
      :value: 4194304



   .. py:attribute:: TypePassByReference
      :value: 8388608



   .. py:attribute:: EnumClass
      :value: 16777216



   .. py:attribute:: Thunk
      :value: 33554432



   .. py:attribute:: NonTrivial
      :value: 67108864



   .. py:attribute:: BigEndian
      :value: 134217728



   .. py:attribute:: LittleEndian
      :value: 268435456



   .. py:attribute:: AllCallsDescribed
      :value: 536870912



   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: DISubprogramFlags

   Bases: :py:obj:`enum.IntFlag`


   
   LLVM DISubprogram flags


   .. py:attribute:: Virtual
      :value: 1



   .. py:attribute:: PureVirtual
      :value: 2



   .. py:attribute:: LocalToUnit
      :value: 4



   .. py:attribute:: Definition
      :value: 8



   .. py:attribute:: Optimized
      :value: 16



   .. py:attribute:: Pure
      :value: 32



   .. py:attribute:: Elemental
      :value: 64



   .. py:attribute:: Recursive
      :value: 128



   .. py:attribute:: MainSubprogram
      :value: 256



   .. py:attribute:: Deleted
      :value: 512



   .. py:attribute:: ObjCDirect
      :value: 2048



   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: FCmpPredicate

   Bases: :py:obj:`enum.IntEnum`


   
   llvm.fcmp comparison predicate


   .. py:attribute:: _false
      :value: 0



   .. py:attribute:: oeq
      :value: 1



   .. py:attribute:: ogt
      :value: 2



   .. py:attribute:: oge
      :value: 3



   .. py:attribute:: olt
      :value: 4



   .. py:attribute:: ole
      :value: 5



   .. py:attribute:: one
      :value: 6



   .. py:attribute:: ord
      :value: 7



   .. py:attribute:: ueq
      :value: 8



   .. py:attribute:: ugt
      :value: 9



   .. py:attribute:: uge
      :value: 10



   .. py:attribute:: ult
      :value: 11



   .. py:attribute:: ule
      :value: 12



   .. py:attribute:: une
      :value: 13



   .. py:attribute:: uno
      :value: 14



   .. py:attribute:: _true
      :value: 15



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: FPExceptionBehavior

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM Exception Behavior


   .. py:attribute:: Ignore
      :value: 0



   .. py:attribute:: MayTrap
      :value: 1



   .. py:attribute:: Strict
      :value: 2



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: FastmathFlags

   Bases: :py:obj:`enum.IntFlag`


   
   LLVM fastmath flags


   .. py:attribute:: none
      :value: 0



   .. py:attribute:: nnan
      :value: 1



   .. py:attribute:: ninf
      :value: 2



   .. py:attribute:: nsz
      :value: 4



   .. py:attribute:: arcp
      :value: 8



   .. py:attribute:: contract
      :value: 16



   .. py:attribute:: afn
      :value: 32



   .. py:attribute:: reassoc
      :value: 64



   .. py:attribute:: fast
      :value: 127



   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: FramePointerKind

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM FramePointerKind


   .. py:attribute:: None_
      :value: 0



   .. py:attribute:: NonLeaf
      :value: 1



   .. py:attribute:: All
      :value: 2



   .. py:attribute:: Reserved
      :value: 3



   .. py:attribute:: NonLeafNoReserve
      :value: 4



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: GEPNoWrapFlags

   Bases: :py:obj:`enum.IntFlag`


   
   ::mlir::LLVM::GEPNoWrapFlags


   .. py:attribute:: none
      :value: 0



   .. py:attribute:: inboundsFlag
      :value: 1



   .. py:attribute:: nusw
      :value: 2



   .. py:attribute:: nuw
      :value: 4



   .. py:attribute:: inbounds
      :value: 3



   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: ICmpPredicate

   Bases: :py:obj:`enum.IntEnum`


   
   llvm.icmp comparison predicate


   .. py:attribute:: eq
      :value: 0



   .. py:attribute:: ne
      :value: 1



   .. py:attribute:: slt
      :value: 2



   .. py:attribute:: sle
      :value: 3



   .. py:attribute:: sgt
      :value: 4



   .. py:attribute:: sge
      :value: 5



   .. py:attribute:: ult
      :value: 6



   .. py:attribute:: ule
      :value: 7



   .. py:attribute:: ugt
      :value: 8



   .. py:attribute:: uge
      :value: 9



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: IntegerOverflowFlags

   Bases: :py:obj:`enum.IntFlag`


   
   LLVM integer overflow flags


   .. py:attribute:: none
      :value: 0



   .. py:attribute:: nsw
      :value: 1



   .. py:attribute:: nuw
      :value: 2



   .. py:method:: __iter__()


   .. py:method:: __len__()


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: DIEmissionKind

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM debug emission kind


   .. py:attribute:: None_
      :value: 0



   .. py:attribute:: Full
      :value: 1



   .. py:attribute:: LineTablesOnly
      :value: 2



   .. py:attribute:: DebugDirectivesOnly
      :value: 3



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: DINameTableKind

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM debug name table kind


   .. py:attribute:: Default
      :value: 0



   .. py:attribute:: GNU
      :value: 1



   .. py:attribute:: None_
      :value: 2



   .. py:attribute:: Apple
      :value: 3



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: ProfileSummaryFormatKind

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM ProfileSummary format kinds


   .. py:attribute:: SampleProfile
      :value: 0



   .. py:attribute:: InstrProf
      :value: 1



   .. py:attribute:: CSInstrProf
      :value: 2



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: Linkage

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM linkage types


   .. py:attribute:: External
      :value: 0



   .. py:attribute:: AvailableExternally
      :value: 1



   .. py:attribute:: Linkonce
      :value: 2



   .. py:attribute:: LinkonceODR
      :value: 3



   .. py:attribute:: Weak
      :value: 4



   .. py:attribute:: WeakODR
      :value: 5



   .. py:attribute:: Appending
      :value: 6



   .. py:attribute:: Internal
      :value: 7



   .. py:attribute:: Private
      :value: 8



   .. py:attribute:: ExternWeak
      :value: 9



   .. py:attribute:: Common
      :value: 10



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: ModFlagBehavior

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM Module Flag Behavior


   .. py:attribute:: Error
      :value: 1



   .. py:attribute:: Warning
      :value: 2



   .. py:attribute:: Require
      :value: 3



   .. py:attribute:: Override
      :value: 4



   .. py:attribute:: Append
      :value: 5



   .. py:attribute:: AppendUnique
      :value: 6



   .. py:attribute:: Max
      :value: 7



   .. py:attribute:: Min
      :value: 8



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: ModRefInfo

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM ModRefInfo


   .. py:attribute:: NoModRef
      :value: 0



   .. py:attribute:: Ref
      :value: 1



   .. py:attribute:: Mod
      :value: 2



   .. py:attribute:: ModRef
      :value: 3



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: RoundingMode

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM Rounding Mode


   .. py:attribute:: TowardZero
      :value: 0



   .. py:attribute:: NearestTiesToEven
      :value: 1



   .. py:attribute:: TowardPositive
      :value: 2



   .. py:attribute:: TowardNegative
      :value: 3



   .. py:attribute:: NearestTiesToAway
      :value: 4



   .. py:attribute:: Dynamic
      :value: 7



   .. py:attribute:: Invalid


   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: TailCallKind

   Bases: :py:obj:`enum.IntEnum`


   
   Tail Call Kind


   .. py:attribute:: None_
      :value: 0



   .. py:attribute:: NoTail
      :value: 3



   .. py:attribute:: MustTail
      :value: 2



   .. py:attribute:: Tail
      :value: 1



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: UWTableKind

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM Unwind Behavior


   .. py:attribute:: None_
      :value: 0



   .. py:attribute:: Sync
      :value: 1



   .. py:attribute:: Async
      :value: 2



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: UnnamedAddr

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM GlobalValue UnnamedAddr


   .. py:attribute:: None_
      :value: 0



   .. py:attribute:: Local
      :value: 1



   .. py:attribute:: Global
      :value: 2



   .. py:method:: __str__()

      
      Return str(self).



.. py:class:: Visibility

   Bases: :py:obj:`enum.IntEnum`


   
   LLVM GlobalValue Visibility


   .. py:attribute:: Default
      :value: 0



   .. py:attribute:: Hidden
      :value: 1



   .. py:attribute:: Protected
      :value: 2



   .. py:method:: __str__()

      
      Return str(self).



.. py:function:: mlir_constant(value, *, loc=None, ip=None) -> mlir.ir.Value

