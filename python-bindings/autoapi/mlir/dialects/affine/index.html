<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../../genindex.html"><link rel="search" title="Search" href="../../../../search.html"><link rel="next" title="mlir.dialects.amdgpu" href="../amdgpu/index.html"><link rel="prev" title="mlir.dialects._xegpu_transform_ops_gen" href="../_xegpu_transform_ops_gen/index.html">

    <!-- Generated with Sphinx 8.1.3 and Furo 2025.09.25 -->
        <title>mlir.dialects.affine - MLIR Python bindings documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/ignore_highlight_err.css?v=07bcfcf5" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">MLIR Python bindings  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../../index.html">
  
  <span class="sidebar-brand-text">MLIR Python bindings  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../index.html">mlir namespace</a><input aria-label="Toggle navigation of mlir namespace" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/pdl/index.html">mlir._mlir_libs._mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/quant/index.html">mlir._mlir_libs._mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/transform/index.html">mlir._mlir_libs._mlir.dialects.transform</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/index.html">mlir._mlir_libs</a><input aria-label="Toggle navigation of mlir._mlir_libs" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../_acc_ops_gen/index.html">mlir.dialects._acc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_enum_gen/index.html">mlir.dialects._affine_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_ops_gen/index.html">mlir.dialects._affine_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_enum_gen/index.html">mlir.dialects._amdgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_ops_gen/index.html">mlir.dialects._amdgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_enum_gen/index.html">mlir.dialects._arith_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_ops_gen/index.html">mlir.dialects._arith_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_async_ops_gen/index.html">mlir.dialects._async_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_enum_gen/index.html">mlir.dialects._bufferization_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_ops_gen/index.html">mlir.dialects._bufferization_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_transform_ops_gen/index.html">mlir.dialects._bufferization_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_builtin_ops_gen/index.html">mlir.dialects._builtin_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_cf_ops_gen/index.html">mlir.dialects._cf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_complex_ops_gen/index.html">mlir.dialects._complex_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_emitc_ops_gen/index.html">mlir.dialects._emitc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_func_ops_gen/index.html">mlir.dialects._func_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_enum_gen/index.html">mlir.dialects._gpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_ops_gen/index.html">mlir.dialects._gpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_transform_ops_gen/index.html">mlir.dialects._gpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_enum_gen/index.html">mlir.dialects._index_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_ops_gen/index.html">mlir.dialects._index_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_enum_gen/index.html">mlir.dialects._irdl_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_ops_gen/index.html">mlir.dialects._irdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_enum_gen/index.html">mlir.dialects._linalg_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_ops_gen/index.html">mlir.dialects._linalg_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_enum_gen/index.html">mlir.dialects._llvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_ops_gen/index.html">mlir.dialects._llvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_loop_transform_ops_gen/index.html">mlir.dialects._loop_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_math_ops_gen/index.html">mlir.dialects._math_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_ops_gen/index.html">mlir.dialects._memref_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_transform_ops_gen/index.html">mlir.dialects._memref_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ml_program_ops_gen/index.html">mlir.dialects._ml_program_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_enum_gen/index.html">mlir.dialects._nvgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_ops_gen/index.html">mlir.dialects._nvgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_transform_ops_gen/index.html">mlir.dialects._nvgpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_enum_gen/index.html">mlir.dialects._nvvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_ops_gen/index.html">mlir.dialects._nvvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ods_common/index.html">mlir.dialects._ods_common</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_omp_ops_gen/index.html">mlir.dialects._omp_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_pdl_ops_gen/index.html">mlir.dialects._pdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_python_test_ops_gen/index.html">mlir.dialects._python_test_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_rocdl_ops_gen/index.html">mlir.dialects._rocdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_scf_ops_gen/index.html">mlir.dialects._scf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shape_ops_gen/index.html">mlir.dialects._shape_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_enum_gen/index.html">mlir.dialects._shard_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_ops_gen/index.html">mlir.dialects._shard_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_enum_gen/index.html">mlir.dialects._smt_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_ops_gen/index.html">mlir.dialects._smt_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_enum_gen/index.html">mlir.dialects._sparse_tensor_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_ops_gen/index.html">mlir.dialects._sparse_tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_transform_ops_gen/index.html">mlir.dialects._sparse_tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_spirv_ops_gen/index.html">mlir.dialects._spirv_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_enum_gen/index.html">mlir.dialects._structured_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_ops_gen/index.html">mlir.dialects._structured_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_ops_gen/index.html">mlir.dialects._tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_transform_ops_gen/index.html">mlir.dialects._tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tosa_ops_gen/index.html">mlir.dialects._tosa_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_debug_extension_ops_gen/index.html">mlir.dialects._transform_debug_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_enum_gen/index.html">mlir.dialects._transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_ops_gen/index.html">mlir.dialects._transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_pdl_extension_ops_gen/index.html">mlir.dialects._transform_pdl_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_smt_extension_ops_gen/index.html">mlir.dialects._transform_smt_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_tune_extension_ops_gen/index.html">mlir.dialects._transform_tune_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ub_ops_gen/index.html">mlir.dialects._ub_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_enum_gen/index.html">mlir.dialects._vector_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_ops_gen/index.html">mlir.dialects._vector_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_enum_gen/index.html">mlir.dialects._vector_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_ops_gen/index.html">mlir.dialects._vector_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_xegpu_transform_ops_gen/index.html">mlir.dialects._xegpu_transform_ops_gen</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">mlir.dialects.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../amdgpu/index.html">mlir.dialects.amdgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arith/index.html">mlir.dialects.arith</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../async_dialect/index.html">mlir.dialects.async_dialect</a><input aria-label="Toggle navigation of mlir.dialects.async_dialect" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bufferization/index.html">mlir.dialects.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../builtin/index.html">mlir.dialects.builtin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cf/index.html">mlir.dialects.cf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex/index.html">mlir.dialects.complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../emitc/index.html">mlir.dialects.emitc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../func/index.html">mlir.dialects.func</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../gpu/index.html">mlir.dialects.gpu</a><input aria-label="Toggle navigation of mlir.dialects.gpu" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index/index.html">mlir.dialects.index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../irdl/index.html">mlir.dialects.irdl</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/index.html">mlir.dialects.linalg</a><input aria-label="Toggle navigation of mlir.dialects.linalg" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../llvm/index.html">mlir.dialects.llvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/index.html">mlir.dialects.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memref/index.html">mlir.dialects.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ml_program/index.html">mlir.dialects.ml_program</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvgpu/index.html">mlir.dialects.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvvm/index.html">mlir.dialects.nvvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openacc/index.html">mlir.dialects.openacc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openmp/index.html">mlir.dialects.openmp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pdl/index.html">mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_test/index.html">mlir.dialects.python_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quant/index.html">mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rocdl/index.html">mlir.dialects.rocdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scf/index.html">mlir.dialects.scf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shape/index.html">mlir.dialects.shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shard/index.html">mlir.dialects.shard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smt/index.html">mlir.dialects.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparse_tensor/index.html">mlir.dialects.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spirv/index.html">mlir.dialects.spirv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tensor/index.html">mlir.dialects.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tosa/index.html">mlir.dialects.tosa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../transform/index.html">mlir.dialects.transform</a><input aria-label="Toggle navigation of mlir.dialects.transform" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ub/index.html">mlir.dialects.ub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vector/index.html">mlir.dialects.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../execution_engine/index.html">mlir.execution_engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/meta/index.html">mlir.extras.meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/types/index.html">mlir.extras.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ir/index.html">mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../passmanager/index.html">mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rewrite/index.html">mlir.rewrite</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../runtime/index.html">mlir.runtime</a><input aria-label="Toggle navigation of mlir.runtime" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../../../_sources/autoapi/mlir/dialects/affine/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-mlir.dialects.affine">
<span id="mlir-dialects-affine"></span><h1>mlir.dialects.affine<a class="headerlink" href="#module-mlir.dialects.affine" title="Link to this heading">¶</a></h1>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp" title="mlir.dialects.affine.AffineApplyOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineApplyOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.apply</span></code> operation applies an <a class="reference external" href="#affine-maps">affine mapping</a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp" title="mlir.dialects.affine.AffineDelinearizeIndexOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.delinearize_index</span></code> operation takes a single index value and</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="mlir.dialects.affine.AffineForOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineForOp</span></code></a></p></td>
<td><p>Specialization for the Affine for op class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="mlir.dialects.affine.AffineIfOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineIfOp</span></code></a></p></td>
<td><p>Specialization for the Affine if op class.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp" title="mlir.dialects.affine.AffineLinearizeIndexOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.linearize_index</span></code> operation takes a sequence of index values and a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp" title="mlir.dialects.affine.AffineLoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineLoadOp</span></code></a></p></td>
<td><p>Syntax:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp" title="mlir.dialects.affine.AffineMaxOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineMaxOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.max</span></code> operation computes the maximum value result from a multi-result</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp" title="mlir.dialects.affine.AffineMinOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineMinOp</span></code></a></p></td>
<td><p>Syntax:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp" title="mlir.dialects.affine.AffineParallelOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineParallelOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.parallel</span></code> operation represents a hyper-rectangular affine</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp" title="mlir.dialects.affine.AffinePrefetchOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffinePrefetchOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.prefetch</span></code> op prefetches data from a memref location described</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp" title="mlir.dialects.affine.AffineStoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineStoreOp</span></code></a></p></td>
<td><p>Syntax:</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp" title="mlir.dialects.affine.AffineVectorLoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineVectorLoadOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.vector_load</span></code> is the vector counterpart of</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp" title="mlir.dialects.affine.AffineVectorStoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineVectorStoreOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.vector_store</span></code> is the vector counterpart of</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp" title="mlir.dialects.affine.AffineYieldOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineYieldOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> yields zero or more SSA values from an affine op region and</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id0" title="mlir.dialects.affine.AffineForOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineForOp</span></code></a></p></td>
<td><p>Specialization for the Affine for op class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id7" title="mlir.dialects.affine.AffineIfOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineIfOp</span></code></a></p></td>
<td><p>Specialization for the Affine if op class.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.apply" title="mlir.dialects.affine.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.delinearize_index" title="mlir.dialects.affine.delinearize_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">delinearize_index</span></code></a>(→ Union[_ods_ir, _ods_ir, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id6" title="mlir.dialects.affine.for_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">for_</span></code></a>(start, stop[, step, iter_args, loc, ip])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.if_" title="mlir.dialects.affine.if_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">if_</span></code></a>(→ Union[_ods_ir, _ods_ir, AffineIfOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.linearize_index" title="mlir.dialects.affine.linearize_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">linearize_index</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.load" title="mlir.dialects.affine.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.max" title="mlir.dialects.affine.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.min" title="mlir.dialects.affine.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.parallel" title="mlir.dialects.affine.parallel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parallel</span></code></a>(→ Union[_ods_ir, _ods_ir, AffineParallelOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.prefetch" title="mlir.dialects.affine.prefetch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prefetch</span></code></a>(→ AffinePrefetchOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.store" title="mlir.dialects.affine.store"><code class="xref py py-obj docutils literal notranslate"><span class="pre">store</span></code></a>(→ AffineStoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.vector_load" title="mlir.dialects.affine.vector_load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_load</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.affine.vector_store" title="mlir.dialects.affine.vector_store"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vector_store</span></code></a>(→ AffineVectorStoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.affine.yield_" title="mlir.dialects.affine.yield_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">yield_</span></code></a>(→ AffineYieldOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#id6" title="mlir.dialects.affine.for_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">for_</span></code></a>(start, stop[, step, iter_args, loc, ip])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineApplyOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineApplyOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapOperands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineApplyOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.apply</span></code> operation applies an <a class="reference external" href="#affine-maps">affine mapping</a>
to a list of SSA values, yielding a single SSA value. The number of
dimension and symbol operands to <code class="docutils literal notranslate"><span class="pre">affine.apply</span></code> must be equal to the
respective number of dimensional and symbolic inputs to the affine mapping;
the affine mapping has to be one-dimensional, and so the <code class="docutils literal notranslate"><span class="pre">affine.apply</span></code>
operation always returns one value. The input operands and result must all
have ‘index’ type.</p>
<p>An operand that is a valid dimension as per the <a class="reference external" href="#restrictions-on-dimensions-and-symbols">rules on valid affine
dimensions and symbols</a>
cannot be used as a symbolic operand.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="no">#map</span><span class="o"> =</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="err"> </span><span class="nx">floordiv</span><span class="err"> </span><span class="mf">8</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">d1</span><span class="err"> </span><span class="nx">floordiv</span><span class="err"> </span><span class="mf">128</span><span class="p">)&gt;</span>
<span class="p">...</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="no">#map</span><span class="err"> </span><span class="p">(</span><span class="nv">%s</span><span class="p">,</span><span class="err"> </span><span class="nv">%t</span><span class="p">)</span>

<span class="c1">// Inline example.</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s0</span><span class="p">)&gt;</span><span class="err"> </span><span class="p">(</span><span class="nv">%42</span><span class="p">)[</span><span class="nv">%n</span><span class="p">]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineApplyOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.apply'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineApplyOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineApplyOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineApplyOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineApplyOp.mapOperands">
<span class="sig-name descname"><span class="pre">mapOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineApplyOp.mapOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineApplyOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineApplyOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.apply">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_operands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.apply" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineDelinearizeIndexOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multi_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linear_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.delinearize_index</span></code> operation takes a single index value and
calculates the multi-index according to the given basis.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="n">indices</span><span class="p">:</span><span class="mi">3</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">delinearize_index</span> <span class="o">%</span><span class="n">linear_index</span> <span class="n">into</span> <span class="p">(</span><span class="o">%</span><span class="n">c16</span><span class="p">,</span> <span class="o">%</span><span class="n">c224</span><span class="p">,</span> <span class="o">%</span><span class="n">c224</span><span class="p">)</span> <span class="p">:</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">index</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">%indices:3</span></code> conceptually holds the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#map0 = affine_map&lt;()[s0] -&gt; (s0 floordiv 50176)&gt;</span>
<span class="c1">#map1 = affine_map&lt;()[s0] -&gt; ((s0 mod 50176) floordiv 224)&gt;</span>
<span class="c1">#map2 = affine_map&lt;()[s0] -&gt; (s0 mod 224)&gt;</span>
<span class="o">%</span><span class="n">indices_0</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">apply</span> <span class="c1">#map0()[%linear_index]</span>
<span class="o">%</span><span class="n">indices_1</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">apply</span> <span class="c1">#map1()[%linear_index]</span>
<span class="o">%</span><span class="n">indices_2</span> <span class="o">=</span> <span class="n">affine</span><span class="o">.</span><span class="n">apply</span> <span class="c1">#map2()[%linear_index]</span>
</pre></div>
</div>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">%0:3</span> <span class="pre">=</span> <span class="pre">affine.delinearize_index</span> <span class="pre">%x</span> <span class="pre">into</span> <span class="pre">(B,</span> <span class="pre">C)</span></code> produces
<code class="docutils literal notranslate"><span class="pre">%0</span> <span class="pre">=</span> <span class="pre">{%x</span> <span class="pre">/</span> <span class="pre">(B</span> <span class="pre">*</span> <span class="pre">C),</span> <span class="pre">(%x</span> <span class="pre">mod</span> <span class="pre">(B</span> <span class="pre">*</span> <span class="pre">C))</span> <span class="pre">/</span> <span class="pre">C,</span> <span class="pre">%x</span> <span class="pre">mod</span> <span class="pre">C}</span></code>.</p>
<p>The basis may either contain <code class="docutils literal notranslate"><span class="pre">N</span></code> or <code class="docutils literal notranslate"><span class="pre">N-1</span></code> elements, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of results.
If there are N basis elements, the first one will not be used during computations,
but may be used during analysis and canonicalization to eliminate terms from
the <code class="docutils literal notranslate"><span class="pre">affine.delinearize_index</span></code> or to enable conclusions about the total size of
<code class="docutils literal notranslate"><span class="pre">%linear_index</span></code>.</p>
<p>If the basis is fully provided, the delinearize_index operation is said to “have
an outer bound”. The builders assume that an <code class="docutils literal notranslate"><span class="pre">affine.delinearize_index</span></code> has
an outer bound by default, as this is how the operation was initially defined.</p>
<p>That is, the example above could also have been written</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0:3</span> <span class="o">=</span> <span class="nb">affine.delinearize_index</span><span class="err"> </span><span class="nv">%linear_index</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="p">(</span><span class="mf">244</span><span class="p">,</span><span class="err"> </span><span class="mf">244</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span>
</pre></div>
</div>
<p>Note that, for symmetry with <code class="docutils literal notranslate"><span class="pre">getPaddedBasis()</span></code>, if <code class="docutils literal notranslate"><span class="pre">hasOuterBound</span></code> is <code class="docutils literal notranslate"><span class="pre">true</span></code>
when one of the <code class="docutils literal notranslate"><span class="pre">OpFoldResult</span></code> builders is called but the first element of the
basis is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>, that first element is ignored and the builder proceeds as if
there was no outer bound.</p>
<p>Due to the constraints of affine maps, all the basis elements must
be strictly positive. A dynamic basis element being 0 or negative causes
undefined behavior.</p>
<p>As with other affine operations, lowerings of delinearize_index may assume
that the underlying computations do not overflow the index type in a signed sense</p>
<ul class="simple">
<li><p>that is, the product of all basis elements is positive as an <code class="docutils literal notranslate"><span class="pre">index</span></code> as well.</p></li>
</ul>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.delinearize_index'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp.linear_index">
<span class="sig-name descname"><span class="pre">linear_index</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.linear_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp.dynamic_basis">
<span class="sig-name descname"><span class="pre">dynamic_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.dynamic_basis" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp.static_basis">
<span class="sig-name descname"><span class="pre">static_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.static_basis" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineDelinearizeIndexOp.multi_index">
<span class="sig-name descname"><span class="pre">multi_index</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.multi_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.delinearize_index">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">delinearize_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multi_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">linear_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_basis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp" title="mlir.dialects.affine.AffineDelinearizeIndexOp"><span class="pre">AffineDelinearizeIndexOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.delinearize_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineForOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerBoundOperands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperBoundOperands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerBoundMap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperBoundMap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation   ::= `affine.for` ssa-id `=` lower-bound `to` upper-bound
                (`step` integer-literal)? `{` op* `}`

lower-bound ::= `max`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
upper-bound ::= `min`? affine-map-attribute dim-and-symbol-use-list | shorthand-bound
shorthand-bound ::= ssa-id | `-`? integer-literal
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.for</span></code> operation represents an affine loop nest. It has one region
containing its body. This region must contain one block that terminates with
<code class="docutils literal notranslate"><span class="pre">`affine.yield</span></code> &lt;#affineyield-mliraffineyieldop&gt;`_. <em>Note:</em> when
<code class="docutils literal notranslate"><span class="pre">affine.for</span></code> is printed in custom format, the terminator is omitted. The
block has one argument of <code class="docutils literal notranslate"><span class="pre">`index</span></code> &lt;Builtin.md/#indextype&gt;`_ type that
represents the induction variable of the loop.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.for</span></code> operation executes its body a number of times iterating
from a lower bound to an upper bound by a stride. The stride, represented by
<code class="docutils literal notranslate"><span class="pre">step</span></code>, is a positive constant integer which defaults to “1” if not present.
The lower and upper bounds specify a half-open range: the range includes the
lower bound but does not include the upper bound.</p>
<p>The lower and upper bounds of a <code class="docutils literal notranslate"><span class="pre">affine.for</span></code> operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The <a class="reference external" href="#restrictions-on-dimensions-and-symbols">same restrictions</a> hold for
these SSA values as for all bindings of SSA values to dimensions and
symbols.</p>
<p>The affine mappings for the bounds may return multiple results, in which
case the <code class="docutils literal notranslate"><span class="pre">max</span></code>/<code class="docutils literal notranslate"><span class="pre">min</span></code> keywords are required (for the lower/upper bound
respectively), and the bound is the maximum/minimum of the returned values.
There is no semantic ambiguity, but MLIR syntax requires the use of these
keywords to make things more obvious to human readers.</p>
<p>Many upper and lower bounds are simple, so MLIR accepts two custom form
syntaxes: the form that accepts a single ‘ssa-id’ (e.g. <code class="docutils literal notranslate"><span class="pre">%N</span></code>) is shorthand
for applying that SSA value to a function that maps a single symbol to
itself, e.g., <code class="docutils literal notranslate"><span class="pre">()[s]-&gt;(s)()[%N]</span></code>. The integer literal form (e.g. <code class="docutils literal notranslate"><span class="pre">-42</span></code>) is
shorthand for a nullary mapping function that returns the constant value
(e.g. <code class="docutils literal notranslate"><span class="pre">()-&gt;(-42)()</span></code>).</p>
<p>Example showing reverse iteration of the inner loop:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="no">#map57</span><span class="o"> =</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">s0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="nx">d0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="p">)&gt;</span>

<span class="nb">func.func</span><span class="err"> </span><span class="nf">@simple_example</span><span class="p">(</span><span class="nv">%A:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%B:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%N</span> <span class="o">=</span> <span class="nb">dim</span><span class="err"> </span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%N</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%N</span><span class="err"> </span><span class="p">{</span><span class="err">   </span><span class="c1">// implicitly steps by 1</span>
      <span class="nv">%0</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="no">#map57</span><span class="p">(</span><span class="nv">%j</span><span class="p">)[</span><span class="nv">%N</span><span class="p">]</span>
      <span class="nv">%tmp</span> <span class="o">=</span> <span class="nb">call</span><span class="err"> </span><span class="nf">@F1</span><span class="p">(</span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="kt">f32</span><span class="p">)</span>
      <span class="nb">call</span><span class="err"> </span><span class="nf">@F2</span><span class="p">(</span><span class="nv">%tmp</span><span class="p">,</span><span class="err"> </span><span class="nv">%B</span><span class="p">,</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">()</span>
<span class="err">    </span><span class="p">}</span>
<span class="err">  </span><span class="p">}</span>
  <span class="nb">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">affine.for</span></code> can also operate on loop-carried variables (<code class="docutils literal notranslate"><span class="pre">iter_args</span></code>) and
return the final values after loop termination. The initial values of the
variables are passed as additional SSA operands to the <code class="docutils literal notranslate"><span class="pre">affine.for</span></code>
following the operands for the loop’s lower and upper bounds. The
operation’s region has equivalent arguments for each variable representing
the value of the variable at the current iteration.</p>
<p>The region must terminate with an <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> that passes all the current
iteration variables to the next iteration, or to the <code class="docutils literal notranslate"><span class="pre">affine.for</span></code>’s results
if at the last iteration. For <code class="docutils literal notranslate"><span class="pre">affine.for</span></code>’s that execute zero iterations, the
initial values of the loop-carried variables (corresponding to the SSA
operands) will be the op’s results.</p>
<p>For example, to sum-reduce a memref:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">func.func</span><span class="err"> </span><span class="nf">@reduce</span><span class="p">(</span><span class="nv">%buffer:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1024</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="kt">f32</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
<span class="err"> </span><span class="c1">// Initial sum set to 0.</span>
 <span class="nv">%sum_0</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0.0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err"> </span><span class="c1">// iter_args binds initial values to the loop&#39;s region arguments.</span>
 <span class="nv">%sum</span> <span class="o">=</span> <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">10</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">2</span>
     <span class="nb">iter_args</span><span class="p">(</span><span class="nv">%sum_iter</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%sum_0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="kt">f32</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
   <span class="nv">%t</span> <span class="o">=</span> <span class="nb">affine.load</span><span class="err"> </span><span class="nv">%buffer</span><span class="p">[</span><span class="nv">%i</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1024</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
   <span class="nv">%sum_next</span> <span class="o">=</span> <span class="nb">arith.addf</span><span class="err"> </span><span class="nv">%sum_iter</span><span class="p">,</span><span class="err"> </span><span class="nv">%t</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err">   </span><span class="c1">// Yield current iteration sum to next iteration %sum_iter or to %sum</span>
<span class="err">   </span><span class="c1">// if final iteration.</span>
   <span class="nb">affine.yield</span><span class="err"> </span><span class="nv">%sum_next</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err"> </span><span class="p">}</span>
 <span class="nb">return</span><span class="err"> </span><span class="nv">%sum</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%res:2</span> <span class="o">=</span> <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">128</span><span class="err"> </span><span class="nx">iter_args</span><span class="p">(</span><span class="nv">%arg0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%init0</span><span class="p">,</span><span class="err"> </span><span class="nv">%arg1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%init1</span><span class="p">)</span>
<span class="err">           </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%y0</span> <span class="o">=</span> <span class="nb">arith.addi</span><span class="err"> </span><span class="nv">%arg0</span><span class="p">,</span><span class="err"> </span><span class="nv">%c1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
  <span class="nv">%y1</span> <span class="o">=</span> <span class="nb">arith.addi</span><span class="err"> </span><span class="nv">%arg1</span><span class="p">,</span><span class="err"> </span><span class="nv">%c2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
  <span class="nb">affine.yield</span><span class="err"> </span><span class="nv">%y0</span><span class="p">,</span><span class="err"> </span><span class="nv">%y1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the <code class="docutils literal notranslate"><span class="pre">affine.for</span></code> defines any values, a yield terminator must be
explicitly present. The number and types of the “affine.for” results must
match the initial values in the <code class="docutils literal notranslate"><span class="pre">iter_args</span></code> binding and the yield operands.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.for'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(1,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineForOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.lowerBoundOperands">
<span class="sig-name descname"><span class="pre">lowerBoundOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.lowerBoundOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.upperBoundOperands">
<span class="sig-name descname"><span class="pre">upperBoundOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.upperBoundOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.inits">
<span class="sig-name descname"><span class="pre">inits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.inits" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.lowerBoundMap">
<span class="sig-name descname"><span class="pre">lowerBoundMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.lowerBoundMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.upperBoundMap">
<span class="sig-name descname"><span class="pre">upperBoundMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.upperBoundMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.step">
<span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.step" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.region">
<span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.region" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.for_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">for_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound_operands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound_operands</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#id0" title="mlir.dialects.affine.AffineForOp"><span class="pre">AffineForOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.for_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineIfOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_gen_arg_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation  ::= `affine.if` if-op-cond `{` op* `}` (`else` `{` op* `}`)?
if-op-cond ::= integer-set-attr dim-and-symbol-use-list
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> operation restricts execution to a subset of the loop
iteration space defined by an integer set (a conjunction of affine
constraints). A single <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> may end with an optional <code class="docutils literal notranslate"><span class="pre">else</span></code> clause.</p>
<p>The condition of the <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> is represented by an
<a class="reference external" href="#integer-sets">integer set</a> (a conjunction of affine constraints),
and the SSA values bound to the dimensions and symbols in the integer set.
The <a class="reference external" href="#restrictions-on-dimensions-and-symbols">same restrictions</a> hold for
these SSA values as for all bindings of SSA values to dimensions and
symbols.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> operation contains two regions for the “then” and “else”
clauses.  <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> may return results that are defined in its regions.
The values defined are determined by which execution path is taken.  Each
region of the <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> must contain a single block with no arguments,
and be terminated by <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code>.  If <code class="docutils literal notranslate"><span class="pre">affine.if</span></code> defines no values,
the <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> can be left out, and will be inserted implicitly.
Otherwise, it must be explicit.  If no values are defined, the else block
may be empty (i.e. contain no blocks).</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="no">#set</span><span class="o"> =</span><span class="err"> </span><span class="kr">affine_set</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">10</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="nx">s0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="nx">d0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">9</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span>
                                 <span class="nb">d1</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">10</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="nx">s0</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="nx">d1</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">9</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">)&gt;</span>
<span class="nb">func.func</span><span class="err"> </span><span class="nf">@reduced_domain_example</span><span class="p">(</span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%X</span><span class="p">,</span><span class="err"> </span><span class="nv">%N</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="kt">i32</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%N</span><span class="err"> </span><span class="p">{</span>
     <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%N</span><span class="err"> </span><span class="p">{</span>
       <span class="nv">%0</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="no">#map42</span><span class="p">(</span><span class="nv">%j</span><span class="p">)</span>
       <span class="nv">%tmp</span> <span class="o">=</span> <span class="nb">call</span><span class="err"> </span><span class="nf">@S1</span><span class="p">(</span><span class="nv">%X</span><span class="p">,</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">)</span>
       <span class="nb">affine.if</span><span class="err"> </span><span class="no">#set</span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)[</span><span class="nv">%N</span><span class="p">]</span><span class="err"> </span><span class="p">{</span>
          <span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="no">#map43</span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span>
          <span class="nb">call</span><span class="err"> </span><span class="nf">@S2</span><span class="p">(</span><span class="nv">%tmp</span><span class="p">,</span><span class="err"> </span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">)</span>
<span class="err">       </span><span class="p">}</span>
<span class="err">    </span><span class="p">}</span>
<span class="err">  </span><span class="p">}</span>
  <span class="nb">return</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example with an explicit yield (initialization with edge padding):</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="no">#interior</span><span class="o"> =</span><span class="err"> </span><span class="kr">affine_set</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err">  </span><span class="mf">10</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="nx">i</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">10</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="nx">j</span><span class="err"> </span><span class="o">&gt;=</span><span class="err"> </span><span class="mf">0</span><span class="p">)&gt;</span><span class="err"> </span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span>
<span class="nb">func.func</span><span class="err"> </span><span class="nf">@pad_edges</span><span class="p">(</span><span class="nv">%I</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">12</span><span class="p">x</span><span class="kt">f32</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%O</span> <span class="o">=</span> <span class="nb">alloc</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">12</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
  <span class="nb">affine.parallel</span><span class="err"> </span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">)</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="p">(</span><span class="mf">12</span><span class="p">,</span><span class="err"> </span><span class="mf">12</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
    <span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.if</span><span class="err"> </span><span class="no">#interior</span><span class="err"> </span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
      <span class="nv">%2</span> <span class="o">=</span> <span class="nb">load</span><span class="err"> </span><span class="nv">%I</span><span class="p">[</span><span class="nv">%i</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nb">affine.yield</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">    </span><span class="p">}</span><span class="err"> </span><span class="nx">else</span><span class="err"> </span><span class="p">{</span>
      <span class="nv">%2</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0.0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
      <span class="nb">affine.yield</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err">    </span><span class="p">}</span>
    <span class="nb">affine.store</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%O</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">12</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">  </span><span class="p">}</span>
  <span class="nb">return</span><span class="err"> </span><span class="nv">%O</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.if'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(2,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.condition">
<span class="sig-name descname"><span class="pre">condition</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.condition" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.thenRegion">
<span class="sig-name descname"><span class="pre">thenRegion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.thenRegion" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.elseRegion">
<span class="sig-name descname"><span class="pre">elseRegion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.elseRegion" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.if_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">if_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">_gen_arg_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">condition</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#id7" title="mlir.dialects.affine.AffineIfOp"><span class="pre">AffineIfOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.if_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineLinearizeIndexOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multi_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disjoint</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.linearize_index</span></code> operation takes a sequence of index values and a
basis of the same length and linearizes the indices using that basis.</p>
<p>That is, for indices <code class="docutils literal notranslate"><span class="pre">%idx_0</span></code> to <code class="docutils literal notranslate"><span class="pre">%idx_{N-1}</span></code> and basis elements <code class="docutils literal notranslate"><span class="pre">b_0</span></code>
(or <code class="docutils literal notranslate"><span class="pre">b_1</span></code>) up to <code class="docutils literal notranslate"><span class="pre">b_{N-1}</span></code> it computes</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span><span class="n">idx_i</span> <span class="o">*</span> <span class="n">product</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">B_j</span>
</pre></div>
</div>
<p>In other words, <code class="docutils literal notranslate"><span class="pre">%0</span> <span class="pre">=</span> <span class="pre">affine.linearize_index</span> <span class="pre">[%z,</span> <span class="pre">%y,</span> <span class="pre">%x]</span> <span class="pre">by</span> <span class="pre">(Z,</span> <span class="pre">Y,</span> <span class="pre">X)</span></code>
gives <code class="docutils literal notranslate"><span class="pre">%0</span> <span class="pre">=</span> <span class="pre">%x</span> <span class="pre">+</span> <span class="pre">%y</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">%z</span> <span class="pre">*</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">Y</span></code>, or <code class="docutils literal notranslate"><span class="pre">%0</span> <span class="pre">=</span> <span class="pre">%x</span> <span class="pre">+</span> <span class="pre">X</span> <span class="pre">*</span> <span class="pre">(%y</span> <span class="pre">+</span> <span class="pre">Y</span> <span class="pre">*</span> <span class="pre">(%z))</span></code>.</p>
<p>The basis may either have <code class="docutils literal notranslate"><span class="pre">N</span></code> or <code class="docutils literal notranslate"><span class="pre">N-1</span></code> elements, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the number of
inputs to linearize_index. If <code class="docutils literal notranslate"><span class="pre">N</span></code> inputs are provided, the first one is not used
in computation, but may be used during analysis or canonicalization as a bound
on <code class="docutils literal notranslate"><span class="pre">%idx_0</span></code>.</p>
<p>If all <code class="docutils literal notranslate"><span class="pre">N</span></code> basis elements are provided, the linearize_index operation is said to
“have an outer bound”.</p>
<p>As a convenience, and for symmetry with <code class="docutils literal notranslate"><span class="pre">getPaddedBasis()</span></code>, if the first
element of a set of <code class="docutils literal notranslate"><span class="pre">OpFoldResult``s</span> <span class="pre">passed</span> <span class="pre">to</span> <span class="pre">the</span> <span class="pre">builders</span> <span class="pre">of</span> <span class="pre">this</span> <span class="pre">operation</span> <span class="pre">is</span>
<span class="pre">``nullptr</span></code>, that element is ignored.</p>
<p>If the <code class="docutils literal notranslate"><span class="pre">disjoint</span></code> property is present, this is an optimization hint that,
for all <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">%idx_i</span> <span class="pre">&lt;</span> <span class="pre">B_i</span></code> - that is, no index affects any other index,
except that <code class="docutils literal notranslate"><span class="pre">%idx_0</span></code> may be negative to make the index as a whole negative.
In addition, <code class="docutils literal notranslate"><span class="pre">disjoint</span></code> is an assertion that all bases elements are non-negative.</p>
<p>Note that the outputs of <code class="docutils literal notranslate"><span class="pre">affine.delinearize_index</span></code> are, by definition, <code class="docutils literal notranslate"><span class="pre">disjoint</span></code>.</p>
<p>As with other affine ops, undefined behavior occurs if the linearization
computation overflows in the signed sense.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%linear_index</span> <span class="o">=</span> <span class="nb">affine.linearize_index</span><span class="err"> </span><span class="p">[</span><span class="nv">%index_0</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_1</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_2</span><span class="p">]</span><span class="err"> </span><span class="nx">by</span><span class="err"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">5</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
<span class="c1">// Same effect</span>
<span class="nv">%linear_index</span> <span class="o">=</span> <span class="nb">affine.linearize_index</span><span class="err"> </span><span class="p">[</span><span class="nv">%index_0</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_1</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_2</span><span class="p">]</span><span class="err"> </span><span class="nx">by</span><span class="err"> </span><span class="p">(</span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">5</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">%linear_index</span></code> conceptually holds the following:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="no">#map</span><span class="o"> =</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;()[</span><span class="nx">s0</span><span class="p">,</span><span class="err"> </span><span class="nx">s1</span><span class="p">,</span><span class="err"> </span><span class="nx">s2</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">s0</span><span class="err"> </span><span class="o">*</span><span class="err"> </span><span class="mf">15</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s1</span><span class="err"> </span><span class="o">*</span><span class="err"> </span><span class="mf">5</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s2</span><span class="p">)&gt;</span>
<span class="nv">%linear_index</span> <span class="o">=</span> <span class="nb">affine.apply</span><span class="err"> </span><span class="no">#map</span><span class="p">()[</span><span class="nv">%index_0</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_1</span><span class="p">,</span><span class="err"> </span><span class="nv">%index_2</span><span class="p">]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.linearize_index'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp.multi_index">
<span class="sig-name descname"><span class="pre">multi_index</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp.multi_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp.dynamic_basis">
<span class="sig-name descname"><span class="pre">dynamic_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp.dynamic_basis" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp.static_basis">
<span class="sig-name descname"><span class="pre">static_basis</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp.static_basis" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLinearizeIndexOp.linear_index">
<span class="sig-name descname"><span class="pre">linear_index</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLinearizeIndexOp.linear_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.linearize_index">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">linearize_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">multi_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">disjoint</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.linearize_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineLoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= ssa-id `=` `affine.load` ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.load</span></code> op reads an element from a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The output of <code class="docutils literal notranslate"><span class="pre">affine.load</span></code> is a new value with the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
<code class="docutils literal notranslate"><span class="pre">symbol</span></code> can be used to indicate SSA identifiers which are symbolic.</p>
<p>Example 1:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.load</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">7</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 2: Uses <code class="docutils literal notranslate"><span class="pre">symbol</span></code> keyword for symbols <code class="docutils literal notranslate"><span class="pre">%n</span></code> and <code class="docutils literal notranslate"><span class="pre">%m</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.load</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%n</span><span class="p">),</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%m</span><span class="p">)]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.load'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineLoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineLoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.load">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMaxOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineMaxOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineMaxOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.max</span></code> operation computes the maximum value result from a multi-result
affine map.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">affine.max</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span><span class="err"> </span><span class="nx">d0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">512</span><span class="p">)</span><span class="err"> </span><span class="p">(</span><span class="nv">%i0</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMaxOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.max'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineMaxOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMaxOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineMaxOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMaxOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineMaxOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMaxOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineMaxOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.max">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.max" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMinOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineMinOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineMinOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= ssa-id `=` `affine.min` affine-map-attribute dim-and-symbol-use-list
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.min</span></code> operation applies an <a class="reference external" href="#affine-expressions">affine mapping</a>
to a list of SSA values, and returns the minimum value of all result
expressions. The number of dimension and symbol arguments to <code class="docutils literal notranslate"><span class="pre">affine.min</span></code>
must be equal to the respective number of dimensional and symbolic inputs to
the affine mapping; the <code class="docutils literal notranslate"><span class="pre">affine.min</span></code> operation always returns one value. The
input operands and result must all have ‘index’ type.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">affine.min</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="mf">1000</span><span class="p">,</span><span class="err"> </span><span class="nx">d0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">512</span><span class="p">,</span><span class="err"> </span><span class="nx">s0</span><span class="p">)&gt;</span><span class="err"> </span><span class="p">(</span><span class="nv">%arg0</span><span class="p">)[</span><span class="nv">%arg1</span><span class="p">]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMinOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.min'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineMinOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMinOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineMinOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMinOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineMinOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineMinOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineMinOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.min">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.min" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineParallelOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reductions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerBoundsMap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lowerBoundsGroups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperBoundsMap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upperBoundsGroups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapOperands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.parallel</span></code> operation represents a hyper-rectangular affine
parallel band, defining zero or more SSA values for its induction variables.
It has one region capturing the parallel band body. The induction variables
are represented as arguments of this region. These SSA values always have
type index, which is the size of the machine word. The strides, represented
by steps, are positive constant integers which defaults to “1” if not
present. The lower and upper bounds specify a half-open range: the range
includes the lower bound but does not include the upper bound. The body
region must contain exactly one block that terminates with <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code>.</p>
<p>The lower and upper bounds of a parallel operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The same restrictions hold for these SSA values as for all bindings of SSA
values to dimensions and symbols. The list of expressions in each map is
interpreted according to the respective bounds group attribute. If a single
expression belongs to the group, then the result of this expression is taken
as a lower(upper) bound of the corresponding loop induction variable. If
multiple expressions belong to the group, then the lower(upper) bound is the
max(min) of these values obtained from these expressions. The loop band has
as many loops as elements in the group bounds attributes.</p>
<p>Each value yielded by <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> will be accumulated/reduced via one of
the reduction methods defined in the AtomicRMWKind enum.  The order of
reduction is unspecified, and lowering may produce any valid ordering.
Loops with a 0 trip count will produce as a result the identity value
associated with each reduction (i.e. 0.0 for addf, 1.0 for mulf).  Assign
reductions for loops with a trip count != 1 produces undefined results.</p>
<p>Note: Calling <code class="docutils literal notranslate"><span class="pre">AffineParallelOp::build</span></code> will create the required region and
block, and insert the required terminator if it is trivial (i.e. no values
are yielded).  Parsing will also create the required region, block, and
terminator, even when they are missing from the textual representation.</p>
<p>Example (3x3 valid convolution):</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">func.func</span><span class="err"> </span><span class="nf">@conv_2d</span><span class="p">(</span><span class="nv">%D</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%K</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">98</span><span class="p">x</span><span class="mi">98</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%O</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">98</span><span class="p">x</span><span class="mi">98</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
  <span class="nb">affine.parallel</span><span class="err"> </span><span class="p">(</span><span class="nv">%x</span><span class="p">,</span><span class="err"> </span><span class="nv">%y</span><span class="p">)</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">)</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="p">(</span><span class="mf">98</span><span class="p">,</span><span class="err"> </span><span class="mf">98</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
    <span class="nv">%0</span> <span class="o">=</span> <span class="nb">affine.parallel</span><span class="err"> </span><span class="p">(</span><span class="nv">%kx</span><span class="p">,</span><span class="err"> </span><span class="nv">%ky</span><span class="p">)</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">)</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">)</span><span class="err"> </span><span class="nx">reduce</span><span class="err"> </span><span class="p">(</span><span class="s2">&quot;addf&quot;</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="p">{</span>
      <span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.load</span><span class="err"> </span><span class="nv">%D</span><span class="p">[</span><span class="nv">%x</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%kx</span><span class="p">,</span><span class="err"> </span><span class="nv">%y</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%ky</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nv">%2</span> <span class="o">=</span> <span class="nb">affine.load</span><span class="err"> </span><span class="nv">%K</span><span class="p">[</span><span class="nv">%kx</span><span class="p">,</span><span class="err"> </span><span class="nv">%ky</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nv">%3</span> <span class="o">=</span> <span class="nb">arith.mulf</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
      <span class="nb">affine.yield</span><span class="err"> </span><span class="nv">%3</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err">    </span><span class="p">}</span>
    <span class="nb">affine.store</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%O</span><span class="p">[</span><span class="nv">%x</span><span class="p">,</span><span class="err"> </span><span class="nv">%y</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">98</span><span class="p">x</span><span class="mi">98</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">  </span><span class="p">}</span>
  <span class="nb">return</span><span class="err"> </span><span class="nv">%O</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">98</span><span class="p">x</span><span class="mi">98</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Example (tiling by potentially imperfectly dividing sizes):</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.parallel</span><span class="err"> </span><span class="p">(</span><span class="nv">%ii</span><span class="p">,</span><span class="err"> </span><span class="nv">%jj</span><span class="p">)</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">)</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="p">(</span><span class="nv">%N</span><span class="p">,</span><span class="err"> </span><span class="nv">%M</span><span class="p">)</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="p">(</span><span class="mf">32</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">)</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.parallel</span><span class="err"> </span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="nv">%ii</span><span class="p">,</span><span class="err"> </span><span class="nv">%jj</span><span class="p">)</span>
                          <span class="nb">to</span><span class="err"> </span><span class="p">(</span><span class="nx">min</span><span class="p">(</span><span class="nv">%ii</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">32</span><span class="p">,</span><span class="err"> </span><span class="nv">%N</span><span class="p">),</span><span class="err"> </span><span class="nx">min</span><span class="p">(</span><span class="nv">%jj</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">32</span><span class="p">,</span><span class="err"> </span><span class="nv">%M</span><span class="p">))</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">call</span><span class="err"> </span><span class="nf">@f</span><span class="p">(</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">()</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.parallel'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(1,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.mapOperands">
<span class="sig-name descname"><span class="pre">mapOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.mapOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.reductions">
<span class="sig-name descname"><span class="pre">reductions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.reductions" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.lowerBoundsMap">
<span class="sig-name descname"><span class="pre">lowerBoundsMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.lowerBoundsMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.lowerBoundsGroups">
<span class="sig-name descname"><span class="pre">lowerBoundsGroups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.lowerBoundsGroups" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.upperBoundsMap">
<span class="sig-name descname"><span class="pre">upperBoundsMap</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.upperBoundsMap" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.upperBoundsGroups">
<span class="sig-name descname"><span class="pre">upperBoundsGroups</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.upperBoundsGroups" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.steps">
<span class="sig-name descname"><span class="pre">steps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.steps" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineParallelOp.region">
<span class="sig-name descname"><span class="pre">region</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineParallelOp.region" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.parallel">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">parallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reductions</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bounds_groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bounds_groups</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_operands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp" title="mlir.dialects.affine.AffineParallelOp"><span class="pre">AffineParallelOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.parallel" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffinePrefetchOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isWrite</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localityHint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isDataCache</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.prefetch</span></code> op prefetches data from a memref location described
with an affine subscript similar to affine.load, and has three attributes:
a read/write specifier, a locality hint, and a cache type specifier as shown
below:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.prefetch</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">5</span><span class="p">],</span><span class="err"> </span><span class="nx">read</span><span class="p">,</span><span class="err"> </span><span class="nx">locality</span><span class="p">&lt;</span><span class="mf">3</span><span class="p">&gt;,</span><span class="err"> </span><span class="nx">data</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">400</span><span class="p">x</span><span class="mi">400</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The read/write specifier is either ‘read’ or ‘write’, the locality hint
specifier ranges from locality&lt;0&gt; (no locality) to locality&lt;3&gt; (extremely
local keep in cache). The cache type specifier is either ‘data’ or ‘instr’
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.prefetch'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.isWrite">
<span class="sig-name descname"><span class="pre">isWrite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.isWrite" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.localityHint">
<span class="sig-name descname"><span class="pre">localityHint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.localityHint" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.isDataCache">
<span class="sig-name descname"><span class="pre">isDataCache</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.isDataCache" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffinePrefetchOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffinePrefetchOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.prefetch">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">prefetch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_write</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locality_hint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_data_cache</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp" title="mlir.dialects.affine.AffinePrefetchOp"><span class="pre">AffinePrefetchOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.prefetch" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineStoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `affine.store` ssa-use, ssa-use `[` multi-dim-affine-map-of-ssa-ids `]` `:` memref-type
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.store</span></code> op writes an element to a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The <code class="docutils literal notranslate"><span class="pre">affine.store</span></code> op stores a new value which is the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
<code class="docutils literal notranslate"><span class="pre">symbol</span></code> can be used to indicate SSA identifiers which are symbolic.</p>
<p>Example 1:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.store</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">7</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 2: Uses <code class="docutils literal notranslate"><span class="pre">symbol</span></code> keyword for symbols <code class="docutils literal notranslate"><span class="pre">%n</span></code> and <code class="docutils literal notranslate"><span class="pre">%m</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.store</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%n</span><span class="p">),</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%m</span><span class="p">)]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.store'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp.value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineStoreOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineStoreOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.store">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp" title="mlir.dialects.affine.AffineStoreOp"><span class="pre">AffineStoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.store" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineVectorLoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.vector_load</span></code> is the vector counterpart of
<a class="reference external" href="#affineload-mliraffineloadop">affine.load</a>. It reads a slice from a
<a class="reference external" href="Builtin.md/#memreftype">MemRef</a>, supplied as its first operand,
into a <a class="reference external" href="Builtin.md/#vectortype">vector</a> of the same base elemental type.
The index for each memref dimension is an affine expression of loop induction
variables and symbols. These indices determine the start position of the read
within the memref. The shape of the return vector type determines the shape of
the slice read from the memref. This slice is contiguous along the respective
dimensions of the shape. Strided vector loads will be supported in the future.
An affine expression of loop IVs and symbols must be specified for each
dimension of the memref. The keyword <code class="docutils literal notranslate"><span class="pre">symbol</span></code> can be used to indicate SSA
identifiers which are symbolic.</p>
<p>Example 1: 8-wide f32 vector load.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.vector_load</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">7</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 2: 4-wide f32 vector load. Uses <code class="docutils literal notranslate"><span class="pre">symbol</span></code> keyword for symbols <code class="docutils literal notranslate"><span class="pre">%n</span></code> and <code class="docutils literal notranslate"><span class="pre">%m</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.vector_load</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%n</span><span class="p">),</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%m</span><span class="p">)]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 3: 2-dim f32 vector load.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">affine.vector_load</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>TODOs:</p>
<ul class="simple">
<li><p>Add support for strided vector loads.</p></li>
<li><p>Consider adding a permutation map to permute the slice that is read from memory</p></li>
</ul>
<p>(see <a class="reference external" href="../Vector/#vectortransfer_read-mlirvectortransferreadop">vector.transfer_read</a>).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.vector_load'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorLoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorLoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.vector_load">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">vector_load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.vector_load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineVectorStoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.vector_store</span></code> is the vector counterpart of
<a class="reference external" href="#affinestore-mliraffinestoreop">affine.store</a>. It writes a
<a class="reference external" href="Builtin.md/#vectortype">vector</a>, supplied as its first operand,
into a slice within a <a class="reference external" href="Builtin.md/#memreftype">MemRef</a> of the same base
elemental type, supplied as its second operand.
The index for each memref dimension is an affine expression of loop
induction variables and symbols. These indices determine the start position
of the write within the memref. The shape of the input vector determines the
shape of the slice written to the memref. This slice is contiguous along the
respective dimensions of the shape. Strided vector stores will be supported
in the future.
An affine expression of loop IVs and symbols must be specified for each
dimension of the memref. The keyword <code class="docutils literal notranslate"><span class="pre">symbol</span></code> can be used to indicate SSA
identifiers which are symbolic.</p>
<p>Example 1: 8-wide f32 vector store.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.vector_store</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="mf">7</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 2: 4-wide f32 vector store. Uses <code class="docutils literal notranslate"><span class="pre">symbol</span></code> keyword for symbols <code class="docutils literal notranslate"><span class="pre">%n</span></code> and <code class="docutils literal notranslate"><span class="pre">%m</span></code>.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.vector_store</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%n</span><span class="p">),</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">symbol</span><span class="p">(</span><span class="nv">%m</span><span class="p">)]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example 3: 2-dim f32 vector store.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">affine.vector_store</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>TODOs:</p>
<ul class="simple">
<li><p>Add support for strided vector stores.</p></li>
<li><p>Consider adding a permutation map to permute the slice that is written to memory</p></li>
</ul>
<p>(see <a class="reference external" href="../Vector/#vectortransfer_write-mlirvectortransferwriteop">vector.transfer_write</a>).</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.vector_store'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp.value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineVectorStoreOp.map">
<span class="sig-name descname"><span class="pre">map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineVectorStoreOp.map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.vector_store">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">vector_store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp" title="mlir.dialects.affine.AffineVectorStoreOp"><span class="pre">AffineVectorStoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.vector_store" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineYieldOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineYieldOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.affine.AffineYieldOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> yields zero or more SSA values from an affine op region and
terminates the region. The semantics of how the values yielded are used
is defined by the parent operation.
If <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> has any operands, the operands must match the parent
operation’s results.
If the parent operation defines no values, then the <code class="docutils literal notranslate"><span class="pre">affine.yield</span></code> may be
left out in the custom syntax and the builders will insert one implicitly.
Otherwise, it has to be present in the syntax to indicate which values are
yielded.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineYieldOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'affine.yield'</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineYieldOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineYieldOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineYieldOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineYieldOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.affine.AffineYieldOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.affine.yield_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">yield_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp" title="mlir.dialects.affine.AffineYieldOp"><span class="pre">AffineYieldOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.affine.yield_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id0">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineForOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">mlir.dialects._ods_common.ResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.AffineMap" title="mlir._mlir_libs._mlir.ir.AffineMap"><span class="pre">AffineMap</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">mlir.dialects._ods_common.ResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.AffineMap" title="mlir._mlir_libs._mlir.ir.AffineMap"><span class="pre">AffineMap</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Attribute" title="mlir._mlir_libs._mlir.ir.Attribute"><span class="pre">Attribute</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.ResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound_operands</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.VariadicResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound_operands</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.VariadicResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#id0" title="mlir.dialects.affine.AffineForOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineForOp</span></code></a></p>
<p>Specialization for the Affine for op class.</p>
<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.body">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">body</span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.body" title="Link to this definition">¶</a></dt>
<dd><p>Returns the body (block) of the loop.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.induction_variable">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">induction_variable</span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.induction_variable" title="Link to this definition">¶</a></dt>
<dd><p>Returns the induction variable of the loop.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineForOp.inner_iter_args">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_iter_args</span></span><a class="headerlink" href="#mlir.dialects.affine.AffineForOp.inner_iter_args" title="Link to this definition">¶</a></dt>
<dd><p>Returns the loop-carried arguments usable within the loop.</p>
<p>To obtain the loop-carried operands, use <code class="docutils literal notranslate"><span class="pre">iter_args</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id6">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">for_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_args</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Sequence</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Value" title="mlir._mlir_libs._mlir.ir.Value"><span class="pre">Value</span></a><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id6" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="id7">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.affine.</span></span><span class="sig-name descname"><span class="pre">AffineIfOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cond</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.IntegerSet" title="mlir._mlir_libs._mlir.ir.IntegerSet"><span class="pre">IntegerSet</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">results_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Type" title="mlir._mlir_libs._mlir.ir.Type"><span class="pre">Type</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cond_operands</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.VariadicResultValueT</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">has_else</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id7" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#id7" title="mlir.dialects.affine.AffineIfOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AffineIfOp</span></code></a></p>
<p>Specialization for the Affine if op class.</p>
<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.then_block">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">then_block</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Block" title="mlir._mlir_libs._mlir.ir.Block"><span class="pre">Block</span></a></em><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.then_block" title="Link to this definition">¶</a></dt>
<dd><p>Returns the then block of the if operation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.affine.AffineIfOp.else_block">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">else_block</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Block" title="mlir._mlir_libs._mlir.ir.Block"><span class="pre">Block</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></em><a class="headerlink" href="#mlir.dialects.affine.AffineIfOp.else_block" title="Link to this definition">¶</a></dt>
<dd><p>Returns the else block of the if operation.</p>
</dd></dl>

</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../amdgpu/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">mlir.dialects.amdgpu</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../_xegpu_transform_ops_gen/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">mlir.dialects._xegpu_transform_ops_gen</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, MLIR authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">mlir.dialects.affine</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#module-contents">Module Contents</a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp"><code class="docutils literal notranslate"><span class="pre">AffineApplyOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineApplyOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineApplyOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp.mapOperands"><code class="docutils literal notranslate"><span class="pre">AffineApplyOp.mapOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineApplyOp.map"><code class="docutils literal notranslate"><span class="pre">AffineApplyOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.apply"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.linear_index"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp.linear_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.dynamic_basis"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp.dynamic_basis()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.static_basis"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp.static_basis()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineDelinearizeIndexOp.multi_index"><code class="docutils literal notranslate"><span class="pre">AffineDelinearizeIndexOp.multi_index()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.delinearize_index"><code class="docutils literal notranslate"><span class="pre">delinearize_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp"><code class="docutils literal notranslate"><span class="pre">AffineForOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineForOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">AffineForOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineForOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.lowerBoundOperands"><code class="docutils literal notranslate"><span class="pre">AffineForOp.lowerBoundOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.upperBoundOperands"><code class="docutils literal notranslate"><span class="pre">AffineForOp.upperBoundOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.inits"><code class="docutils literal notranslate"><span class="pre">AffineForOp.inits()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.lowerBoundMap"><code class="docutils literal notranslate"><span class="pre">AffineForOp.lowerBoundMap()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.upperBoundMap"><code class="docutils literal notranslate"><span class="pre">AffineForOp.upperBoundMap()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.step"><code class="docutils literal notranslate"><span class="pre">AffineForOp.step()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.results_"><code class="docutils literal notranslate"><span class="pre">AffineForOp.results_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.region"><code class="docutils literal notranslate"><span class="pre">AffineForOp.region()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.for_"><code class="docutils literal notranslate"><span class="pre">for_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp"><code class="docutils literal notranslate"><span class="pre">AffineIfOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineIfOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.condition"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.condition()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.results_"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.results_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.thenRegion"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.thenRegion()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.elseRegion"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.elseRegion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.if_"><code class="docutils literal notranslate"><span class="pre">if_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp.multi_index"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp.multi_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp.dynamic_basis"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp.dynamic_basis()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp.static_basis"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp.static_basis()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLinearizeIndexOp.linear_index"><code class="docutils literal notranslate"><span class="pre">AffineLinearizeIndexOp.linear_index()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.linearize_index"><code class="docutils literal notranslate"><span class="pre">linearize_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp.memref"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp.indices"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp.map"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp.map()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineLoadOp.result"><code class="docutils literal notranslate"><span class="pre">AffineLoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp"><code class="docutils literal notranslate"><span class="pre">AffineMaxOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineMaxOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineMaxOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp.operands_"><code class="docutils literal notranslate"><span class="pre">AffineMaxOp.operands_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMaxOp.map"><code class="docutils literal notranslate"><span class="pre">AffineMaxOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.max"><code class="docutils literal notranslate"><span class="pre">max()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp"><code class="docutils literal notranslate"><span class="pre">AffineMinOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineMinOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineMinOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp.operands_"><code class="docutils literal notranslate"><span class="pre">AffineMinOp.operands_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineMinOp.map"><code class="docutils literal notranslate"><span class="pre">AffineMinOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.min"><code class="docutils literal notranslate"><span class="pre">min()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.mapOperands"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.mapOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.reductions"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.reductions()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.lowerBoundsMap"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.lowerBoundsMap()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.lowerBoundsGroups"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.lowerBoundsGroups()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.upperBoundsMap"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.upperBoundsMap()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.upperBoundsGroups"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.upperBoundsGroups()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.steps"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.steps()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.results_"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.results_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineParallelOp.region"><code class="docutils literal notranslate"><span class="pre">AffineParallelOp.region()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.parallel"><code class="docutils literal notranslate"><span class="pre">parallel()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.memref"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.indices"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.isWrite"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.isWrite()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.localityHint"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.localityHint()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.isDataCache"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.isDataCache()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffinePrefetchOp.map"><code class="docutils literal notranslate"><span class="pre">AffinePrefetchOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.prefetch"><code class="docutils literal notranslate"><span class="pre">prefetch()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp.value"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp.value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp.memref"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp.indices"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineStoreOp.map"><code class="docutils literal notranslate"><span class="pre">AffineStoreOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.store"><code class="docutils literal notranslate"><span class="pre">store()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp.memref"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp.indices"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp.map"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp.map()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorLoadOp.result"><code class="docutils literal notranslate"><span class="pre">AffineVectorLoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.vector_load"><code class="docutils literal notranslate"><span class="pre">vector_load()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp.value"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp.value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp.memref"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp.indices"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineVectorStoreOp.map"><code class="docutils literal notranslate"><span class="pre">AffineVectorStoreOp.map()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.vector_store"><code class="docutils literal notranslate"><span class="pre">vector_store()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp"><code class="docutils literal notranslate"><span class="pre">AffineYieldOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AffineYieldOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AffineYieldOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineYieldOp.operands_"><code class="docutils literal notranslate"><span class="pre">AffineYieldOp.operands_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.affine.yield_"><code class="docutils literal notranslate"><span class="pre">yield_()</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">AffineForOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.body"><code class="docutils literal notranslate"><span class="pre">AffineForOp.body</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.induction_variable"><code class="docutils literal notranslate"><span class="pre">AffineForOp.induction_variable</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineForOp.inner_iter_args"><code class="docutils literal notranslate"><span class="pre">AffineForOp.inner_iter_args</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6"><code class="docutils literal notranslate"><span class="pre">for_()</span></code></a></li>
<li><a class="reference internal" href="#id7"><code class="docutils literal notranslate"><span class="pre">AffineIfOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.then_block"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.then_block</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.affine.AffineIfOp.else_block"><code class="docutils literal notranslate"><span class="pre">AffineIfOp.else_block</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>