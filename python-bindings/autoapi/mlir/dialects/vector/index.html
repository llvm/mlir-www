<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../../genindex.html"><link rel="search" title="Search" href="../../../../search.html"><link rel="next" title="mlir.execution_engine" href="../../execution_engine/index.html"><link rel="prev" title="mlir.dialects.ub" href="../ub/index.html">

    <!-- Generated with Sphinx 8.1.3 and Furo 2025.09.25 -->
        <title>mlir.dialects.vector - MLIR Python bindings documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/ignore_highlight_err.css?v=07bcfcf5" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">MLIR Python bindings  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../../index.html">
  
  <span class="sidebar-brand-text">MLIR Python bindings  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../index.html">mlir namespace</a><input aria-label="Toggle navigation of mlir namespace" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/pdl/index.html">mlir._mlir_libs._mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/quant/index.html">mlir._mlir_libs._mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/transform/index.html">mlir._mlir_libs._mlir.dialects.transform</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/index.html">mlir._mlir_libs</a><input aria-label="Toggle navigation of mlir._mlir_libs" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../_acc_ops_gen/index.html">mlir.dialects._acc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_enum_gen/index.html">mlir.dialects._affine_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_ops_gen/index.html">mlir.dialects._affine_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_enum_gen/index.html">mlir.dialects._amdgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_ops_gen/index.html">mlir.dialects._amdgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_enum_gen/index.html">mlir.dialects._arith_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_ops_gen/index.html">mlir.dialects._arith_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_async_ops_gen/index.html">mlir.dialects._async_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_enum_gen/index.html">mlir.dialects._bufferization_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_ops_gen/index.html">mlir.dialects._bufferization_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_transform_ops_gen/index.html">mlir.dialects._bufferization_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_builtin_ops_gen/index.html">mlir.dialects._builtin_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_cf_ops_gen/index.html">mlir.dialects._cf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_complex_ops_gen/index.html">mlir.dialects._complex_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_emitc_ops_gen/index.html">mlir.dialects._emitc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_func_ops_gen/index.html">mlir.dialects._func_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_enum_gen/index.html">mlir.dialects._gpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_ops_gen/index.html">mlir.dialects._gpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_transform_ops_gen/index.html">mlir.dialects._gpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_enum_gen/index.html">mlir.dialects._index_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_ops_gen/index.html">mlir.dialects._index_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_enum_gen/index.html">mlir.dialects._irdl_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_ops_gen/index.html">mlir.dialects._irdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_enum_gen/index.html">mlir.dialects._linalg_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_ops_gen/index.html">mlir.dialects._linalg_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_enum_gen/index.html">mlir.dialects._llvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_ops_gen/index.html">mlir.dialects._llvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_loop_transform_ops_gen/index.html">mlir.dialects._loop_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_math_ops_gen/index.html">mlir.dialects._math_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_ops_gen/index.html">mlir.dialects._memref_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_transform_ops_gen/index.html">mlir.dialects._memref_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ml_program_ops_gen/index.html">mlir.dialects._ml_program_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_enum_gen/index.html">mlir.dialects._nvgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_ops_gen/index.html">mlir.dialects._nvgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_transform_ops_gen/index.html">mlir.dialects._nvgpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_enum_gen/index.html">mlir.dialects._nvvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_ops_gen/index.html">mlir.dialects._nvvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ods_common/index.html">mlir.dialects._ods_common</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_omp_ops_gen/index.html">mlir.dialects._omp_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_pdl_ops_gen/index.html">mlir.dialects._pdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_python_test_ops_gen/index.html">mlir.dialects._python_test_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_rocdl_ops_gen/index.html">mlir.dialects._rocdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_scf_ops_gen/index.html">mlir.dialects._scf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shape_ops_gen/index.html">mlir.dialects._shape_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_enum_gen/index.html">mlir.dialects._shard_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_ops_gen/index.html">mlir.dialects._shard_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_enum_gen/index.html">mlir.dialects._smt_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_ops_gen/index.html">mlir.dialects._smt_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_enum_gen/index.html">mlir.dialects._sparse_tensor_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_ops_gen/index.html">mlir.dialects._sparse_tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_transform_ops_gen/index.html">mlir.dialects._sparse_tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_spirv_ops_gen/index.html">mlir.dialects._spirv_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_enum_gen/index.html">mlir.dialects._structured_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_ops_gen/index.html">mlir.dialects._structured_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_ops_gen/index.html">mlir.dialects._tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_transform_ops_gen/index.html">mlir.dialects._tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tosa_ops_gen/index.html">mlir.dialects._tosa_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_debug_extension_ops_gen/index.html">mlir.dialects._transform_debug_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_enum_gen/index.html">mlir.dialects._transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_ops_gen/index.html">mlir.dialects._transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_pdl_extension_ops_gen/index.html">mlir.dialects._transform_pdl_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_smt_extension_ops_gen/index.html">mlir.dialects._transform_smt_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_tune_extension_ops_gen/index.html">mlir.dialects._transform_tune_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ub_ops_gen/index.html">mlir.dialects._ub_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_enum_gen/index.html">mlir.dialects._vector_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_ops_gen/index.html">mlir.dialects._vector_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_enum_gen/index.html">mlir.dialects._vector_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_ops_gen/index.html">mlir.dialects._vector_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_xegpu_transform_ops_gen/index.html">mlir.dialects._xegpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../affine/index.html">mlir.dialects.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../amdgpu/index.html">mlir.dialects.amdgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arith/index.html">mlir.dialects.arith</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../async_dialect/index.html">mlir.dialects.async_dialect</a><input aria-label="Toggle navigation of mlir.dialects.async_dialect" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bufferization/index.html">mlir.dialects.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../builtin/index.html">mlir.dialects.builtin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cf/index.html">mlir.dialects.cf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex/index.html">mlir.dialects.complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../emitc/index.html">mlir.dialects.emitc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../func/index.html">mlir.dialects.func</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../gpu/index.html">mlir.dialects.gpu</a><input aria-label="Toggle navigation of mlir.dialects.gpu" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index/index.html">mlir.dialects.index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../irdl/index.html">mlir.dialects.irdl</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/index.html">mlir.dialects.linalg</a><input aria-label="Toggle navigation of mlir.dialects.linalg" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../llvm/index.html">mlir.dialects.llvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/index.html">mlir.dialects.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="../memref/index.html">mlir.dialects.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ml_program/index.html">mlir.dialects.ml_program</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvgpu/index.html">mlir.dialects.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvvm/index.html">mlir.dialects.nvvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openacc/index.html">mlir.dialects.openacc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openmp/index.html">mlir.dialects.openmp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pdl/index.html">mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_test/index.html">mlir.dialects.python_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quant/index.html">mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rocdl/index.html">mlir.dialects.rocdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scf/index.html">mlir.dialects.scf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shape/index.html">mlir.dialects.shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shard/index.html">mlir.dialects.shard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smt/index.html">mlir.dialects.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparse_tensor/index.html">mlir.dialects.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spirv/index.html">mlir.dialects.spirv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tensor/index.html">mlir.dialects.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tosa/index.html">mlir.dialects.tosa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../transform/index.html">mlir.dialects.transform</a><input aria-label="Toggle navigation of mlir.dialects.transform" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ub/index.html">mlir.dialects.ub</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">mlir.dialects.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../execution_engine/index.html">mlir.execution_engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/meta/index.html">mlir.extras.meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/types/index.html">mlir.extras.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ir/index.html">mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../passmanager/index.html">mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rewrite/index.html">mlir.rewrite</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../runtime/index.html">mlir.runtime</a><input aria-label="Toggle navigation of mlir.runtime" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../../../_sources/autoapi/mlir/dialects/vector/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-mlir.dialects.vector">
<span id="mlir-dialects-vector"></span><h1>mlir.dialects.vector<a class="headerlink" href="#module-mlir.dialects.vector" title="Link to this heading">¶</a></h1>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.VectorScaleOp" title="mlir.dialects.vector.VectorScaleOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VectorScaleOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">vscale</span></code> op returns the scale of the scalable vectors, a positive</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.BitCastOp" title="mlir.dialects.vector.BitCastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BitCastOp</span></code></a></p></td>
<td><p>The bitcast operation casts between vectors of the same rank, the minor 1-D</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp" title="mlir.dialects.vector.BroadcastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">BroadcastOp</span></code></a></p></td>
<td><p>Broadcasts the scalar or k-D vector value in the source operand</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp" title="mlir.dialects.vector.CompressStoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CompressStoreOp</span></code></a></p></td>
<td><p>The compress store operation writes elements from a vector into memory as</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ConstantMaskOp" title="mlir.dialects.vector.ConstantMaskOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantMaskOp</span></code></a></p></td>
<td><p>Creates and returns a vector mask where elements of the result vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ContractionOp" title="mlir.dialects.vector.ContractionOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ContractionOp</span></code></a></p></td>
<td><p>Computes the sum of products of vector elements along contracting</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.CreateMaskOp" title="mlir.dialects.vector.CreateMaskOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CreateMaskOp</span></code></a></p></td>
<td><p>Creates and returns a vector mask where elements of the result vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp" title="mlir.dialects.vector.DeinterleaveOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeinterleaveOp</span></code></a></p></td>
<td><p>The deinterleave operation constructs two vectors from a single input</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp" title="mlir.dialects.vector.ExpandLoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExpandLoadOp</span></code></a></p></td>
<td><p>The expand load reads elements from memory into a vector as defined by a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ExtractOp" title="mlir.dialects.vector.ExtractOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtractOp</span></code></a></p></td>
<td><p>Extracts an (n − k)-D result sub-vector from an n-D source vector at a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp" title="mlir.dialects.vector.ExtractStridedSliceOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtractStridedSliceOp</span></code></a></p></td>
<td><p>Takes an n-D vector, k-D <code class="docutils literal notranslate"><span class="pre">offsets</span></code> integer array attribute, a k-sized</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.FMAOp" title="mlir.dialects.vector.FMAOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FMAOp</span></code></a></p></td>
<td><p>Multiply-add expressions operate on n-D vectors and compute a fused</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp" title="mlir.dialects.vector.FromElementsOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">FromElementsOp</span></code></a></p></td>
<td><p>This operation defines a vector from one or multiple scalar elements. The</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.GatherOp" title="mlir.dialects.vector.GatherOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GatherOp</span></code></a></p></td>
<td><p>The gather operation returns an n-D vector whose elements are either loaded</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.InsertOp" title="mlir.dialects.vector.InsertOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InsertOp</span></code></a></p></td>
<td><p>Inserts an (n - k)-D sub-vector (value-to-store) into an n-D destination</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp" title="mlir.dialects.vector.InsertStridedSliceOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InsertStridedSliceOp</span></code></a></p></td>
<td><p>Takes a k-D valueToStore vector, an n-D destination vector (n &gt;= k), n-sized</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp" title="mlir.dialects.vector.InterleaveOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">InterleaveOp</span></code></a></p></td>
<td><p>The interleave operation constructs a new vector by interleaving the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.LoadOp" title="mlir.dialects.vector.LoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LoadOp</span></code></a></p></td>
<td><p>The 'vector.load' operation reads an n-D slice of memory into an n-D</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.MaskOp" title="mlir.dialects.vector.MaskOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> is a <code class="docutils literal notranslate"><span class="pre">MaskingOpInterface</span></code> operation that predicates the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp" title="mlir.dialects.vector.MaskedLoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskedLoadOp</span></code></a></p></td>
<td><p>The masked load reads elements from memory into a vector as defined</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp" title="mlir.dialects.vector.MaskedStoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MaskedStoreOp</span></code></a></p></td>
<td><p>The masked store operation writes elements from a vector into memory</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp" title="mlir.dialects.vector.MultiDimReductionOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MultiDimReductionOp</span></code></a></p></td>
<td><p>Reduces an n-D vector into an (n-k)-D vector (or a scalar when k == n)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp" title="mlir.dialects.vector.OuterProductOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">OuterProductOp</span></code></a></p></td>
<td><p>Takes 2 1-D vectors and returns the 2-D vector containing the outer-product,</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.PrintOp" title="mlir.dialects.vector.PrintOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PrintOp</span></code></a></p></td>
<td><p>Prints the source vector (or scalar) to stdout in a human-readable format</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ReductionOp" title="mlir.dialects.vector.ReductionOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReductionOp</span></code></a></p></td>
<td><p>Reduces an 1-D vector &quot;horizontally&quot; into a scalar using the given</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp" title="mlir.dialects.vector.ScalableExtractOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScalableExtractOp</span></code></a></p></td>
<td><p>Takes rank-1 source vector and a position <code class="docutils literal notranslate"><span class="pre">pos</span></code> within the source</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp" title="mlir.dialects.vector.ScalableInsertOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScalableInsertOp</span></code></a></p></td>
<td><p>This operations takes a rank-1 fixed-length or scalable subvector and</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ScanOp" title="mlir.dialects.vector.ScanOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScanOp</span></code></a></p></td>
<td><p>Performs an inclusive/exclusive scan on an n-D vector along a single</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ScatterOp" title="mlir.dialects.vector.ScatterOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ScatterOp</span></code></a></p></td>
<td><p>The scatter operation stores elements from a n-D vector into memory or ranked tensor as</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp" title="mlir.dialects.vector.ShapeCastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShapeCastOp</span></code></a></p></td>
<td><p>Casts to a vector with the same number of elements, element type, and</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp" title="mlir.dialects.vector.ShuffleOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ShuffleOp</span></code></a></p></td>
<td><p>The shuffle operation constructs a permutation (or duplication) of elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.StepOp" title="mlir.dialects.vector.StepOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StepOp</span></code></a></p></td>
<td><p>A <code class="docutils literal notranslate"><span class="pre">step</span></code> operation produces an index vector, i.e. a 1-D vector of values of</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.StoreOp" title="mlir.dialects.vector.StoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StoreOp</span></code></a></p></td>
<td><p>The 'vector.store' operation writes an n-D vector to an n-D slice of memory.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp" title="mlir.dialects.vector.ToElementsOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ToElementsOp</span></code></a></p></td>
<td><p>This operation decomposes all the scalar elements from a vector. The</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp" title="mlir.dialects.vector.TransferReadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransferReadOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">vector.transfer_read</span></code> op performs a read from a slice within a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp" title="mlir.dialects.vector.TransferWriteOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransferWriteOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">vector.transfer_write</span></code> op performs a write from a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.TransposeOp" title="mlir.dialects.vector.TransposeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransposeOp</span></code></a></p></td>
<td><p>Takes a n-D vector and returns the transposed n-D vector defined by</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp" title="mlir.dialects.vector.TypeCastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TypeCastOp</span></code></a></p></td>
<td><p>Performs a conversion from a memref with scalar element to a memref with a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.YieldOp" title="mlir.dialects.vector.YieldOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">YieldOp</span></code></a></p></td>
<td><p>&quot;vector.yield&quot; yields an SSA value from the Vector dialect op region and</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.CombiningKind" title="mlir.dialects.vector.CombiningKind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CombiningKind</span></code></a></p></td>
<td><p>Kind of combining function for contractions and reductions</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation" title="mlir.dialects.vector.PrintPunctuation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PrintPunctuation</span></code></a></p></td>
<td><p>Punctuation for separating vectors or vector elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.IteratorType" title="mlir.dialects.vector.IteratorType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IteratorType</span></code></a></p></td>
<td><p>Iterator type</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.vscale" title="mlir.dialects.vector.vscale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">vscale</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.bitcast" title="mlir.dialects.vector.bitcast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bitcast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.broadcast" title="mlir.dialects.vector.broadcast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">broadcast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.compressstore" title="mlir.dialects.vector.compressstore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compressstore</span></code></a>(→ CompressStoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.constant_mask" title="mlir.dialects.vector.constant_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">constant_mask</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.contract" title="mlir.dialects.vector.contract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contract</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.create_mask" title="mlir.dialects.vector.create_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_mask</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.deinterleave" title="mlir.dialects.vector.deinterleave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">deinterleave</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.expandload" title="mlir.dialects.vector.expandload"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expandload</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.extract" title="mlir.dialects.vector.extract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.extract_strided_slice" title="mlir.dialects.vector.extract_strided_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_strided_slice</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.fma" title="mlir.dialects.vector.fma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fma</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.from_elements" title="mlir.dialects.vector.from_elements"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_elements</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.gather" title="mlir.dialects.vector.gather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gather</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.insert" title="mlir.dialects.vector.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.insert_strided_slice" title="mlir.dialects.vector.insert_strided_slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert_strided_slice</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.interleave" title="mlir.dialects.vector.interleave"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interleave</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.load" title="mlir.dialects.vector.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.mask" title="mlir.dialects.vector.mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mask</span></code></a>(→ Union[_ods_ir, _ods_ir, MaskOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.maskedload" title="mlir.dialects.vector.maskedload"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maskedload</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.maskedstore" title="mlir.dialects.vector.maskedstore"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maskedstore</span></code></a>(→ MaskedStoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.multi_reduction" title="mlir.dialects.vector.multi_reduction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multi_reduction</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.outerproduct" title="mlir.dialects.vector.outerproduct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outerproduct</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.print_" title="mlir.dialects.vector.print_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">print_</span></code></a>(→ PrintOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.reduction" title="mlir.dialects.vector.reduction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduction</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.scalable_extract" title="mlir.dialects.vector.scalable_extract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scalable_extract</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.scalable_insert" title="mlir.dialects.vector.scalable_insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scalable_insert</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.scan" title="mlir.dialects.vector.scan"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scan</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.scatter" title="mlir.dialects.vector.scatter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scatter</span></code></a>(→ Union[_ods_ir, _ods_ir, ScatterOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.shape_cast" title="mlir.dialects.vector.shape_cast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape_cast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.shuffle" title="mlir.dialects.vector.shuffle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shuffle</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.step" title="mlir.dialects.vector.step"><code class="xref py py-obj docutils literal notranslate"><span class="pre">step</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.store" title="mlir.dialects.vector.store"><code class="xref py py-obj docutils literal notranslate"><span class="pre">store</span></code></a>(→ StoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.to_elements" title="mlir.dialects.vector.to_elements"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_elements</span></code></a>(→ Union[_ods_ir, _ods_ir, ToElementsOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.transfer_read" title="mlir.dialects.vector.transfer_read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transfer_read</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.transfer_write" title="mlir.dialects.vector.transfer_write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transfer_write</span></code></a>(→ Union[_ods_ir, _ods_ir, TransferWriteOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.transpose" title="mlir.dialects.vector.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.type_cast" title="mlir.dialects.vector.type_cast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type_cast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.vector.yield_" title="mlir.dialects.vector.yield_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">yield_</span></code></a>(→ YieldOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.vector.register_attribute_builder" title="mlir.dialects.vector.register_attribute_builder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">register_attribute_builder</span></code></a>(kind[, replace])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.VectorScaleOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">VectorScaleOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.VectorScaleOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">vscale</span></code> op returns the scale of the scalable vectors, a positive
integer value that is constant at runtime but unknown at compile-time.
The scale of the vector indicates the multiplicity of the vectors and
vector operations. For example, a <code class="docutils literal notranslate"><span class="pre">vector&lt;[4]xi32&gt;</span></code> is equivalent to
<code class="docutils literal notranslate"><span class="pre">vscale</span></code> consecutive <code class="docutils literal notranslate"><span class="pre">vector&lt;4xi32&gt;</span></code>; and an operation on a
<code class="docutils literal notranslate"><span class="pre">vector&lt;[4]xi32&gt;</span></code> is equivalent to performing that operation <code class="docutils literal notranslate"><span class="pre">vscale</span></code>
times, once on each <code class="docutils literal notranslate"><span class="pre">&lt;4xi32&gt;</span></code> segment of the scalable vector. The <code class="docutils literal notranslate"><span class="pre">vscale</span></code>
op can be used to calculate the step in vector-length agnostic (VLA) loops.
Right now we only support one contiguous set of scalable dimensions, all of
them grouped and scaled with the value returned by ‘vscale’.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.VectorScaleOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.vscale'</span></em><a class="headerlink" href="#mlir.dialects.vector.VectorScaleOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.VectorScaleOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.VectorScaleOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.VectorScaleOp.res">
<span class="sig-name descname"><span class="pre">res</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.VectorScaleOp.res" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.vscale">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">vscale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.vscale" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.BitCastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">BitCastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.BitCastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The bitcast operation casts between vectors of the same rank, the minor 1-D
vector size is casted to a vector with a different element type but same
bitwidth. In case of 0-D vectors, the bitwidth of element types must be
equal.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Example casting to a smaller element type.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.bitcast</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">6</span><span class="p">x</span><span class="kt">i16</span><span class="p">&gt;</span>

<span class="c1">// Example casting to a bigger element type.</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.bitcast</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="mi">12</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="mi">12</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>

<span class="c1">// Example casting to an element type of the same size.</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.bitcast</span><span class="err"> </span><span class="nv">%4</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>

<span class="c1">// Example casting of 0-D vectors.</span>
<span class="nv">%7</span> <span class="o">=</span> <span class="nb">vector.bitcast</span><span class="err"> </span><span class="nv">%6</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">i32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.BitCastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.bitcast'</span></em><a class="headerlink" href="#mlir.dialects.vector.BitCastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.BitCastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.BitCastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.BitCastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.BitCastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.BitCastOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.BitCastOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.bitcast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">bitcast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.bitcast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.BroadcastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">BroadcastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.BroadcastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Broadcasts the scalar or k-D vector value in the source operand
to a n-D result vector such that the broadcast makes sense, i.e.,
the source operand is duplicated to match the given rank and sizes
in the result vector. The legality rules are:</p>
<ul class="simple">
<li><p>the source operand must have the same element type as the result type</p></li>
<li><p>a k-D vector &lt;s_1 x .. x s_k x type&gt; can be broadcast to</p></li>
</ul>
<p>a n-D vector &lt;t_1 x .. x t_n x type&gt; if
* k &lt;= n, and
* the sizes in the trailing dimensions n-k &lt; i &lt;= n with j=i+k-n
match exactly as s_j = t_i or s_j = 1:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t_1</span> <span class="n">x</span>   <span class="o">..</span>  <span class="n">t_n</span><span class="o">-</span><span class="n">k</span> <span class="n">x</span> <span class="n">t_n</span><span class="o">-</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="n">x</span> <span class="o">..</span> <span class="n">x</span> <span class="n">t_i</span> <span class="n">x</span> <span class="o">..</span> <span class="n">x</span> <span class="n">t_n</span>
                    <span class="n">s_1</span>     <span class="n">x</span> <span class="o">..</span> <span class="n">x</span> <span class="n">s_j</span> <span class="n">x</span> <span class="o">..</span> <span class="n">x</span> <span class="n">s_k</span>
    <span class="o">&lt;</span><span class="n">duplication</span><span class="o">&gt;</span>         <span class="o">&lt;</span><span class="n">potential</span> <span class="n">stretch</span><span class="o">&gt;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>in addition, any scalable unit dimension, <code class="docutils literal notranslate"><span class="pre">[1]</span></code>, must match exactly.</p></li>
</ul>
<p>The source operand is duplicated over all the missing leading dimensions
and stretched over the trailing dimensions where the source has a non-equal
dimension of 1 (stretching a trailing dimension is also referred to as
“dim-1” broadcasting). These rules imply that any scalar broadcast (k=0) to
any shaped vector with the same element type is always legal.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0.0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.broadcast</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.broadcast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.BroadcastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.broadcast'</span></em><a class="headerlink" href="#mlir.dialects.vector.BroadcastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.BroadcastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.BroadcastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.BroadcastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.BroadcastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.BroadcastOp.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.BroadcastOp.vector" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.broadcast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">broadcast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.broadcast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">CompressStoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The compress store operation writes elements from a vector into memory as
defined by a base with indices and a mask vector. Compression only applies
to the innermost dimension. When the mask is set, the corresponding element
from the vector is written next to memory.  Otherwise, no action is taken
for the element. Informally the semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that the index increment is done conditionally.</p>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, no value
is stored regardless of the index, and the index is allowed to be
out-of-bounds.</p>
<p>The compress store can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for a compress. The semantics of the operation closely
correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.masked.compressstore</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-masked-compressstore-intrinsics">intrinsic</a>.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
store operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<p>Note, at the moment this Op is only available for fixed-width vectors.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.compressstore</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="nb">vector.compressstore</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.compressstore'</span></em><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CompressStoreOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.CompressStoreOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.compressstore">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">compressstore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp" title="mlir.dialects.vector.CompressStoreOp"><span class="pre">CompressStoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.compressstore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ConstantMaskOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ConstantMaskOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_dim_sizes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ConstantMaskOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Creates and returns a vector mask where elements of the result vector
are set to ‘0’ or ‘1’, based on whether the element indices are contained
within a hyper-rectangular region specified by the ‘mask_dim_sizes’
array attribute argument. Each element of the ‘mask_dim_sizes’ array,
specifies an exclusive upper bound [0, mask-dim-size-element-value)
for a unique dimension in the vector result. The conjunction of the ranges
define a hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0). Each value of ‘mask_dim_sizes’ must
be non-negative and not greater than the size of the corresponding vector
dimension (as opposed to vector.create_mask which allows this). Sizes that
correspond to scalable dimensions are implicitly multiplied by vscale,
though currently only zero (none set) or the size of the dim/vscale
(all set) are supported.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a constant vector mask of size 4x3xi1 with elements in range</span>
<span class="c1">// 0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.constant_mask</span><span class="err"> </span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;</span>

<span class="nb">print</span><span class="err"> </span><span class="nv">%1</span>
              <span class="nb">columns</span>
            <span class="nb">0</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">2</span>
<span class="err">          |</span><span class="o">------------</span>
        <span class="nb">0</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
  <span class="nb">rows</span><span class="err">  </span><span class="mf">1</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
        <span class="nb">2</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
        <span class="nb">3</span><span class="err"> | </span><span class="mf">0</span><span class="err">    </span><span class="mf">0</span><span class="err">    </span><span class="mf">0</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ConstantMaskOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.constant_mask'</span></em><a class="headerlink" href="#mlir.dialects.vector.ConstantMaskOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ConstantMaskOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ConstantMaskOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ConstantMaskOp.mask_dim_sizes">
<span class="sig-name descname"><span class="pre">mask_dim_sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ConstantMaskOp.mask_dim_sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.constant_mask">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">constant_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask_dim_sizes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.constant_mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ContractionOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexing_maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterator_types</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Computes the sum of products of vector elements along contracting
dimension pairs from 2 vectors of rank M and N respectively, adds this
intermediate result to the accumulator argument of rank K, and returns a
vector result of rank K (where K = num_lhs_free_dims + num_rhs_free_dims +
num_batch_dims (see dimension type descriptions below)). For K = 0 (no
free or batch dimensions), the accumulator and output are a scalar.</p>
<p>If operands and the result have types of different bitwidths, operands are
promoted to have the same bitwidth as the result before performing the
contraction. For integer types, only signless integer types are supported,
and the promotion happens via sign extension.</p>
<p>An iterator type attribute list must be specified, where each element of
the list represents an iterator with one of the following types:</p>
<ul class="simple">
<li><p>“reduction”: reduction dimensions are present in the lhs and rhs</p></li>
</ul>
<p>arguments but not in the output (and accumulator
argument). These are the dimensions along which the vector
contraction op computes the sum of products, and
contracting dimension pair dimension sizes must match
between lhs/rhs.
* “parallel”: Batch dimensions are iterator type “parallel”, and
are non-contracting dimensions present in the lhs, rhs and
output. The lhs/rhs co-iterate along the batch dimensions,
which should be expressed in their indexing maps.Free dimensions are iterator type “parallel”, and are
non-contraction, non-batch dimensions accessed by either the
lhs or rhs (but not both). The lhs and rhs free dimensions
are unrelated to each other and do not co-iterate, which
should be expressed in their indexing maps.</p>
<p>An indexing map attribute list must be specified with an entry for lhs, rhs
and acc arguments. An indexing map attribute specifies a mapping from each
iterator in the iterator type list, to each dimension of an N-D vector.</p>
<p>An optional kind attribute may be used to specify the combining function
between the intermediate result and accumulator argument of rank K. This
attribute can take the values <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minsi</span></code>/<code class="docutils literal notranslate"><span class="pre">minui</span></code>/<code class="docutils literal notranslate"><span class="pre">maxsi</span></code>/<code class="docutils literal notranslate"><span class="pre">maxui</span></code>
/<code class="docutils literal notranslate"><span class="pre">and</span></code>/<code class="docutils literal notranslate"><span class="pre">or</span></code>/<code class="docutils literal notranslate"><span class="pre">xor</span></code> for integers, and <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maxnumf</span></code>
/<code class="docutils literal notranslate"><span class="pre">minimumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maximumf</span></code> for floats. The default is <code class="docutils literal notranslate"><span class="pre">add</span></code>.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Simple DOT product (K = 0).</span>
<span class="no">#contraction_accesses</span><span class="o"> =</span><span class="err"> </span><span class="p">[</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">)&gt;,</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">)&gt;,</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">()&gt;</span>
<span class="p">]</span>
<span class="no">#contraction_trait</span><span class="o"> =</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">indexing_maps</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="no">#contraction_accesses</span><span class="p">,</span>
  <span class="nb">iterator_types</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="s2">&quot;reduction&quot;</span><span class="p">]</span>
<span class="p">}</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.contract</span><span class="err"> </span><span class="no">#contraction_trait</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">f32</span>

<span class="c1">// 2D vector contraction with one contracting dimension (matmul, K = 2).</span>
<span class="no">#contraction_accesses</span><span class="o"> =</span><span class="err"> </span><span class="p">[</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">,</span><span class="err"> </span><span class="nx">k</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">k</span><span class="p">)&gt;,</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">,</span><span class="err"> </span><span class="nx">k</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">k</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">)&gt;,</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">,</span><span class="err"> </span><span class="nx">k</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">)&gt;</span>
<span class="p">]</span>
<span class="no">#contraction_trait</span><span class="o"> =</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">indexing_maps</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="no">#contraction_accesses</span><span class="p">,</span>
  <span class="nb">iterator_types</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span><span class="err"> </span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span><span class="err"> </span><span class="s2">&quot;reduction&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.contract</span><span class="err"> </span><span class="no">#contraction_trait</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">7</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">7</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// 4D to 3D vector contraction with two contracting dimensions and</span>
<span class="c1">// one batch dimension (K = 3).</span>
<span class="no">#contraction_accesses</span><span class="o"> =</span><span class="err"> </span><span class="p">[</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">f0</span><span class="p">,</span><span class="err"> </span><span class="nx">f1</span><span class="p">,</span><span class="err"> </span><span class="nx">c0</span><span class="p">,</span><span class="err"> </span><span class="nx">c1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">c0</span><span class="p">,</span><span class="err"> </span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">c1</span><span class="p">,</span><span class="err"> </span><span class="nx">f0</span><span class="p">)&gt;,</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">f0</span><span class="p">,</span><span class="err"> </span><span class="nx">f1</span><span class="p">,</span><span class="err"> </span><span class="nx">c0</span><span class="p">,</span><span class="err"> </span><span class="nx">c1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">c1</span><span class="p">,</span><span class="err"> </span><span class="nx">c0</span><span class="p">,</span><span class="err"> </span><span class="nx">f1</span><span class="p">)&gt;,</span>
<span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">f0</span><span class="p">,</span><span class="err"> </span><span class="nx">f1</span><span class="p">,</span><span class="err"> </span><span class="nx">c0</span><span class="p">,</span><span class="err"> </span><span class="nx">c1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">b0</span><span class="p">,</span><span class="err"> </span><span class="nx">f0</span><span class="p">,</span><span class="err"> </span><span class="nx">f1</span><span class="p">)&gt;</span>
<span class="p">]</span>
<span class="no">#contraction_trait</span><span class="o"> =</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">indexing_maps</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="no">#contraction_accesses</span><span class="p">,</span>
  <span class="nb">iterator_types</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span><span class="err"> </span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span><span class="err"> </span><span class="s2">&quot;parallel&quot;</span><span class="p">,</span>
<span class="err">                    </span><span class="s2">&quot;reduction&quot;</span><span class="p">,</span><span class="err"> </span><span class="s2">&quot;reduction&quot;</span><span class="p">]</span>
<span class="p">}</span>

<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.contract</span><span class="err"> </span><span class="no">#contraction_trait</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">7</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">15</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">7</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">15</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Vector contraction with mixed typed. lhs/rhs have different element</span>
<span class="c1">// types than accumulator/result.</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.contract</span><span class="err"> </span><span class="no">#contraction_trait</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f16</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f16</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">f32</span>

<span class="c1">// Contract with max (K = 0).</span>
<span class="no">#contraction_accesses</span><span class="o"> =</span><span class="err"> </span><span class="p">[</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">)&gt;,</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">)&gt;,</span>
<span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">()&gt;</span>
<span class="p">]</span>
<span class="no">#contraction_trait</span><span class="o"> =</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">indexing_maps</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="no">#contraction_accesses</span><span class="p">,</span>
  <span class="nb">iterator_types</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="s2">&quot;reduction&quot;</span><span class="p">],</span>
  <span class="nb">kind</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="no">#vector.kind</span><span class="p">&lt;</span><span class="nx">maxnumf</span><span class="p">&gt;</span>
<span class="p">}</span>
<span class="nv">%6</span> <span class="o">=</span> <span class="nb">vector.contract</span><span class="err"> </span><span class="no">#contraction_trait</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">f32</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.contract'</span></em><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ContractionOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.lhs">
<span class="sig-name descname"><span class="pre">lhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.lhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.rhs">
<span class="sig-name descname"><span class="pre">rhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.rhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.acc">
<span class="sig-name descname"><span class="pre">acc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.acc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.indexing_maps">
<span class="sig-name descname"><span class="pre">indexing_maps</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.indexing_maps" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.iterator_types">
<span class="sig-name descname"><span class="pre">iterator_types</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.iterator_types" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ContractionOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ContractionOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.contract">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">contract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indexing_maps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterator_types</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.contract" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.CreateMaskOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">CreateMaskOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.CreateMaskOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Creates and returns a vector mask where elements of the result vector
are set to ‘0’ or ‘1’, based on whether the element indices are contained
within a hyper-rectangular region specified by the operands. Specifically,
each operand specifies a range [0, operand-value) for a unique dimension in
the vector result. The conjunction of the operand ranges define a
hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0). If operand-value is negative, it is
treated as if it were zero, and if it is greater than the corresponding
dimension size, it is treated as if it were equal to the dimension size.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// create a vector mask of size 4x3xi1 where elements in range</span>
<span class="c1">// 0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.create_mask</span><span class="err"> </span><span class="nv">%c3</span><span class="p">,</span><span class="err"> </span><span class="nv">%c2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;</span>

<span class="nb">print</span><span class="err"> </span><span class="nv">%1</span>
              <span class="nb">columns</span>
            <span class="nb">0</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">2</span>
<span class="err">          |</span><span class="o">------------</span>
        <span class="nb">0</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
  <span class="nb">rows</span><span class="err">  </span><span class="mf">1</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
        <span class="nb">2</span><span class="err"> | </span><span class="mf">1</span><span class="err">    </span><span class="mf">1</span><span class="err">    </span><span class="mf">0</span>
        <span class="nb">3</span><span class="err"> | </span><span class="mf">0</span><span class="err">    </span><span class="mf">0</span><span class="err">    </span><span class="mf">0</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CreateMaskOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.create_mask'</span></em><a class="headerlink" href="#mlir.dialects.vector.CreateMaskOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CreateMaskOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.CreateMaskOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CreateMaskOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.CreateMaskOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.create_mask">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">create_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.create_mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">DeinterleaveOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The deinterleave operation constructs two vectors from a single input
vector. The first result vector contains the elements from even indexes
of the input, and the second contains elements from odd indexes. This is
the inverse of a <code class="docutils literal notranslate"><span class="pre">vector.interleave</span></code> operation.</p>
<p>Each output’s trailing dimension is half of the size of the input
vector’s trailing dimension. This operation requires the input vector
to have a rank &gt; 0 and an even number of elements in its trailing
dimension.</p>
<p>The operation supports scalable vectors.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span><span class="p">,</span> <span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%a</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span>
<span class="nv">%2</span><span class="p">,</span> <span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%b</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span>
<span class="nv">%4</span><span class="p">,</span> <span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%c</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span>
<span class="nv">%6</span><span class="p">,</span> <span class="nv">%7</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%d</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%8</span><span class="p">,</span> <span class="nv">%9</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%e</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x[</span><span class="mi">6</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x[</span><span class="mi">3</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span>
<span class="nv">%10</span><span class="p">,</span> <span class="nv">%11</span> <span class="o">=</span> <span class="nb">vector.deinterleave</span><span class="err"> </span><span class="nv">%f</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x[</span><span class="mi">6</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x[</span><span class="mi">3</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.deinterleave'</span></em><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp.res1">
<span class="sig-name descname"><span class="pre">res1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp.res1" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.DeinterleaveOp.res2">
<span class="sig-name descname"><span class="pre">res2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.DeinterleaveOp.res2" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.deinterleave">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">deinterleave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.deinterleave" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ExpandLoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The expand load reads elements from memory into a vector as defined by a
base with indices and a mask vector. Expansion only applies to the innermost
dimension. When the mask is set, the next element is read from memory.
Otherwise, the corresponding element is taken from a pass-through vector.
Informally the semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span>
<span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">then</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="k">else</span> <span class="n">pass_thru</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="k">else</span> <span class="n">pass_thru</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that the index increment is done conditionally.</p>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, the value
comes from the pass-through vector regardless of the index, and the index is
allowed to be out-of-bounds.</p>
<p>The expand load can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for an expand. The semantics of the operation closely
correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.masked.expandload</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-masked-expandload-intrinsics">intrinsic</a>.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
load operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<p>Note, at the moment this Op is only available for fixed-width vectors.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.expandload</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.expandload</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.expandload'</span></em><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.pass_thru">
<span class="sig-name descname"><span class="pre">pass_thru</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.pass_thru" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExpandLoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExpandLoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.expandload">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">expandload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.expandload" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ExtractOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_position</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ExtractOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Extracts an (n − k)-D result sub-vector from an n-D source vector at a
specified k-D position. When n = k, the result degenerates to a scalar
element.</p>
<p>Static and dynamic indices must be greater or equal to zero and less than
the size of the corresponding dimension. The result is undefined if any
index is out-of-bounds. The value <code class="docutils literal notranslate"><span class="pre">-1</span></code> represents a poison index, which
specifies that the extracted element is poison.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">3</span><span class="p">]:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">,</span><span class="err"> </span><span class="nv">%c</span><span class="p">]:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">]:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%6</span> <span class="o">=</span> <span class="nb">vector.extract</span><span class="err"> </span><span class="nv">%10</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="nv">%c</span><span class="p">]:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.extract'</span></em><a class="headerlink" href="#mlir.dialects.vector.ExtractOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ExtractOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp.dynamic_position">
<span class="sig-name descname"><span class="pre">dynamic_position</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractOp.dynamic_position" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp.static_position">
<span class="sig-name descname"><span class="pre">static_position</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractOp.static_position" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.extract">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_position</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.extract" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ExtractStridedSliceOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Takes an n-D vector, k-D <code class="docutils literal notranslate"><span class="pre">offsets</span></code> integer array attribute, a k-sized
<code class="docutils literal notranslate"><span class="pre">sizes</span></code> integer array attribute, a k-sized <code class="docutils literal notranslate"><span class="pre">strides</span></code> integer array
attribute and extracts the n-D subvector at the proper offset.</p>
<p>At the moment strides must contain only 1s.</p>
<p>Returns an n-D vector where the first k-D dimensions match the <code class="docutils literal notranslate"><span class="pre">sizes</span></code>
attribute. The returned subvector contains the elements starting at offset
<code class="docutils literal notranslate"><span class="pre">offsets</span></code> and ending at <code class="docutils literal notranslate"><span class="pre">offsets</span> <span class="pre">+</span> <span class="pre">sizes</span></code>.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.extract_strided_slice</span><span class="err"> </span><span class="nv">%0</span>
<span class="err">    </span><span class="p">{</span><span class="nx">offsets</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">],</span><span class="err"> </span><span class="nx">sizes</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">],</span><span class="err"> </span><span class="nx">strides</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]}:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// TODO: Evolve to a range form syntax similar to:</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.extract_strided_slice</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">0</span><span class="p">:</span><span class="mf">2</span><span class="p">:</span><span class="mf">1</span><span class="p">][</span><span class="mf">2</span><span class="p">:</span><span class="mf">4</span><span class="p">:</span><span class="mf">1</span><span class="p">]</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>TODO: Implement support for poison indices.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.extract_strided_slice'</span></em><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp.sizes">
<span class="sig-name descname"><span class="pre">sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp.sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ExtractStridedSliceOp.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ExtractStridedSliceOp.strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.extract_strided_slice">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">extract_strided_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.extract_strided_slice" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">FMAOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.FMAOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Multiply-add expressions operate on n-D vectors and compute a fused
pointwise multiply-and-accumulate: <code class="docutils literal notranslate"><span class="pre">$result</span> <span class="pre">=</span> <span class="pre">$lhs</span> <span class="pre">*</span> <span class="pre">$rhs</span> <span class="pre">+</span> <span class="pre">$acc</span></code>.
All operands and result have the same vector type. The semantics
of the operation correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.fma</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#int-fma">intrinsic</a>. In the
particular case of lowering to LLVM, this is guaranteed to lower
to the <code class="docutils literal notranslate"><span class="pre">llvm.fma.*</span></code> intrinsic.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.fma</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%2:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.fma'</span></em><a class="headerlink" href="#mlir.dialects.vector.FMAOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.FMAOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp.lhs">
<span class="sig-name descname"><span class="pre">lhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.FMAOp.lhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp.rhs">
<span class="sig-name descname"><span class="pre">rhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.FMAOp.rhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp.acc">
<span class="sig-name descname"><span class="pre">acc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.FMAOp.acc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FMAOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.FMAOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.fma">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">fma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.fma" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.FromElementsOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">FromElementsOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.FromElementsOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>This operation defines a vector from one or multiple scalar elements. The
scalar elements are arranged in row-major within the vector. The number of
elements must match the number of elements in the result type. All elements
must have the same type, which must match the element type of the result
vector type. Scalable vectors are not supported.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define a 0-D vector.</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.from_elements</span><span class="err"> </span><span class="nv">%f1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// [%f1]</span>

<span class="c1">// Define a 1-D vector.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.from_elements</span><span class="err"> </span><span class="nv">%f1</span><span class="p">,</span><span class="err"> </span><span class="nv">%f2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// [%f1, %f2]</span>

<span class="c1">// Define a 2-D vector.</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.from_elements</span><span class="err"> </span><span class="nv">%f1</span><span class="p">,</span><span class="err"> </span><span class="nv">%f2</span><span class="p">,</span><span class="err"> </span><span class="nv">%f3</span><span class="p">,</span><span class="err"> </span><span class="nv">%f4</span><span class="p">,</span><span class="err"> </span><span class="nv">%f5</span><span class="p">,</span><span class="err"> </span><span class="nv">%f6</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// [[%f1, %f2, %f3], [%f4, %f5, %f6]]</span>

<span class="c1">// Define a 3-D vector.</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.from_elements</span><span class="err"> </span><span class="nv">%f1</span><span class="p">,</span><span class="err"> </span><span class="nv">%f2</span><span class="p">,</span><span class="err"> </span><span class="nv">%f3</span><span class="p">,</span><span class="err"> </span><span class="nv">%f4</span><span class="p">,</span><span class="err"> </span><span class="nv">%f5</span><span class="p">,</span><span class="err"> </span><span class="nv">%f6</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// [[[%f1, %f2]], [[%f3, %f4]], [[%f5, %f6]]]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.FromElementsOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.from_elements'</span></em><a class="headerlink" href="#mlir.dialects.vector.FromElementsOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.FromElementsOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.FromElementsOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FromElementsOp.elements">
<span class="sig-name descname"><span class="pre">elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.FromElementsOp.elements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.FromElementsOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.FromElementsOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.from_elements">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">from_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elements</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.from_elements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">GatherOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.GatherOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The gather operation returns an n-D vector whose elements are either loaded
from a k-D memref or tensor, or taken from an n-D pass-through vector, depending
on the values of an n-D mask vector.</p>
<p>If a mask bit is set, the corresponding result element is taken from <code class="docutils literal notranslate"><span class="pre">base</span></code>
at an index defined by k indices and n-D <code class="docutils literal notranslate"><span class="pre">index_vec</span></code>. Otherwise, the element
is taken from the pass-through vector. As an example, suppose that <code class="docutils literal notranslate"><span class="pre">base</span></code> is
3-D and the result is 2-D:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">func.func</span><span class="err"> </span><span class="nf">@gather_3D_to_2D</span><span class="p">(</span>
<span class="err">    </span><span class="nv">%base:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="mi">10</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%ofs_0:</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="nv">%ofs_1:</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="nv">%ofs_2:</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span>
<span class="err">    </span><span class="nv">%indices:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%mask:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span>
<span class="err">    </span><span class="nv">%fall_thru:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="p">{</span>
        <span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.gather</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%ofs_0</span><span class="p">,</span><span class="err"> </span><span class="nv">%ofs_1</span><span class="p">,</span><span class="err"> </span><span class="nv">%ofs_2</span><span class="p">]</span>
<span class="err">                               </span><span class="p">[</span><span class="nv">%indices</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%fall_thru</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">[...]</span>
        <span class="nb">return</span><span class="err"> </span><span class="nv">%result</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The indexing semantics are then,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="n">then</span> <span class="n">base</span><span class="p">[</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">+</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]]</span>
               <span class="k">else</span> <span class="n">pass_thru</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>The index into <code class="docutils literal notranslate"><span class="pre">base</span></code> only varies in the innermost ((k-1)-th) dimension.</p>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, the value
comes from the pass-through vector regardless of the index, and the index is
allowed to be out-of-bounds.</p>
<p>The gather operation can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for a gather.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
gather operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1-D memref gathered to 2-D vector.</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.gather</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%c0</span><span class="p">][</span><span class="nv">%v</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// 2-D memref gathered to 1-D vector.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.gather</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">][</span><span class="nv">%v</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.gather'</span></em><a class="headerlink" href="#mlir.dialects.vector.GatherOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.GatherOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.pass_thru">
<span class="sig-name descname"><span class="pre">pass_thru</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.pass_thru" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.GatherOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.GatherOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.gather">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">gather</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.gather" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">InsertOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_position</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.InsertOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Inserts an (n - k)-D sub-vector (value-to-store) into an n-D destination
vector at a specified k-D position. When n = 0, value-to-store degenerates
to a scalar element inserted into the n-D destination vector.</p>
<p>Static and dynamic indices must be greater or equal to zero and less than
the size of the corresponding dimension. The result is undefined if any
index is out-of-bounds. The value <code class="docutils literal notranslate"><span class="pre">-1</span></code> represents a poison index, which
specifies that the resulting vector is poison.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">[</span><span class="mf">3</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%3</span><span class="p">,</span><span class="err"> </span><span class="nv">%4</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%11</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%9</span><span class="p">,</span><span class="err"> </span><span class="nv">%10</span><span class="p">[</span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">,</span><span class="err"> </span><span class="nv">%c</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%12</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%4</span><span class="p">,</span><span class="err"> </span><span class="nv">%10</span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%13</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%20</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">[</span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="nv">%c</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.insert'</span></em><a class="headerlink" href="#mlir.dialects.vector.InsertOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.InsertOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.dynamic_position">
<span class="sig-name descname"><span class="pre">dynamic_position</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertOp.dynamic_position" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.static_position">
<span class="sig-name descname"><span class="pre">static_position</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertOp.static_position" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.insert">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_position</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_position</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.insert" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">InsertStridedSliceOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Takes a k-D valueToStore vector, an n-D destination vector (n &gt;= k), n-sized
<code class="docutils literal notranslate"><span class="pre">offsets</span></code> integer array attribute, a k-sized <code class="docutils literal notranslate"><span class="pre">strides</span></code> integer array attribute
and inserts the k-D valueToStore vector as a strided subvector at the proper offset
into the n-D destination vector.</p>
<p>At the moment strides must contain only 1s.</p>
<p>Returns an n-D vector that is a copy of the n-D destination vector in which
the last k-D dimensions contain the k-D valueToStore vector elements strided at
the proper location as specified by the offsets.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.insert_strided_slice</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span>
<span class="err">    </span><span class="p">{</span><span class="nx">offsets</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">],</span><span class="err"> </span><span class="nx">strides</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]}:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.insert_strided_slice'</span></em><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InsertStridedSliceOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InsertStridedSliceOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.insert_strided_slice">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">insert_strided_slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.insert_strided_slice" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">InterleaveOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The interleave operation constructs a new vector by interleaving the
elements from the trailing (or final) dimension of two input vectors,
returning a new vector where the trailing dimension is twice the size.</p>
<p>Note that for the n-D case this differs from the interleaving possible with
<code class="docutils literal notranslate"><span class="pre">vector.shuffle</span></code>, which would only operate on the leading dimension.</p>
<p>Another key difference is this operation supports scalable vectors, though
currently a general LLVM lowering is limited to the case where only the
trailing dimension is scalable.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%a</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]&gt;</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>
<span class="nv">%b</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]&gt;</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>
<span class="c1">// The value of `%0` is `[0, 2, 1, 3]`.</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.interleave</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>

<span class="c1">// Examples showing allowed input and result types.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.interleave</span><span class="err"> </span><span class="nv">%c</span><span class="p">,</span><span class="err"> </span><span class="nv">%d</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f16</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f16</span><span class="p">&gt;</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.interleave</span><span class="err"> </span><span class="nv">%e</span><span class="p">,</span><span class="err"> </span><span class="nv">%f</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">6</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">6</span><span class="p">x</span><span class="mi">6</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.interleave</span><span class="err"> </span><span class="nv">%g</span><span class="p">,</span><span class="err"> </span><span class="nv">%h</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">i32</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">i32</span><span class="p">&gt;</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.interleave</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x[</span><span class="mi">2</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">4</span><span class="p">x[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">f64</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.interleave'</span></em><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp.lhs">
<span class="sig-name descname"><span class="pre">lhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp.lhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp.rhs">
<span class="sig-name descname"><span class="pre">rhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp.rhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.InterleaveOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.InterleaveOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.interleave">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">interleave</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.interleave" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">LoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.LoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The ‘vector.load’ operation reads an n-D slice of memory into an n-D
vector. It takes a ‘base’ memref, an index for each memref dimension and a
result vector type as arguments. It returns a value of the result vector
type. The ‘base’ memref and indices determine the start memory address from
which to read. Each index provides an offset for each memref dimension
based on the element type of the memref. The shape of the result vector
type determines the shape of the slice read from the start memory address.
The elements along each dimension of the slice are strided by the memref
strides. When loading more than 1 element, only unit strides are allowed
along the most minor memref dimension. These constraints guarantee that
elements read along the first dimension of the slice are contiguous in
memory.</p>
<p>The memref element type can be a scalar or a vector type. If the memref
element type is a scalar, it should match the element type of the result
vector. If the memref element type is vector, it should match the result
vector type.</p>
<p>Example: 0-D vector load on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example: 1-D vector load on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">100</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example: 1-D vector load on a vector memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  2-D vector load on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  2-D vector load on a vector memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Representation-wise, the ‘vector.load’ operation permits out-of-bounds
reads. Support and implementation of out-of-bounds vector loads is
target-specific. No assumptions should be made on the value of elements
loaded out of bounds. Not all targets may support out-of-bounds vector
loads.</p>
<p>Example:  Potential out-of-bound vector load.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%index</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  Explicit out-of-bound vector load.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">vector.load</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%c0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">7</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
load operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.load'</span></em><a class="headerlink" href="#mlir.dialects.vector.LoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.LoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.LoadOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.LoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.nontemporal">
<span class="sig-name descname"><span class="pre">nontemporal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.LoadOp.nontemporal" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.LoadOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.LoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.LoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.load">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">MaskOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passthru</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.MaskOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> is a <code class="docutils literal notranslate"><span class="pre">MaskingOpInterface</span></code> operation that predicates the
execution of another operation. It takes an <code class="docutils literal notranslate"><span class="pre">i1</span></code> vector mask and an
optional passthru vector as arguments.</p>
<p>A implicitly <code class="docutils literal notranslate"><span class="pre">vector.yield</span></code>-terminated region encloses the operation to be
masked. Values used within the region are captured from above. Only one
<em>maskable</em> operation can be masked with a <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> operation at a time.
An operation is <em>maskable</em> if it implements the <code class="docutils literal notranslate"><span class="pre">MaskableOpInterface</span></code>. The
terminator yields all results from the maskable operation to the result of
this operation. No other values are allowed to be yielded.</p>
<p>An empty <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> operation is currently legal to enable optimizations
across the <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> region. However, this might change in the future
once vector transformations gain better support for <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code>.
TODO: Consider making empty <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> illegal.</p>
<p>The vector mask argument holds a bit for each vector lane and determines
which vector lanes should execute the maskable operation and which ones
should not. The <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> operation returns the value produced by the
masked execution of the nested operation, if any. The masked-off lanes in
the result vector are taken from the corresponding lanes of the pass-thru
argument, if provided, or left unmodified, otherwise. At this point, 0-D
vectors are not supported by <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code>. They may be supported in the
future.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">vector.mask</span></code> operation does not prescribe how a maskable operation
should be masked or how a masked operation should be lowered. Masking
constraints and some semantic details are provided by each maskable
operation through the <code class="docutils literal notranslate"><span class="pre">MaskableOpInterface</span></code>. Lowering of masked operations
is implementation defined. For instance, scalarizing the masked operation
or executing the operation for the masked-off lanes are valid lowerings as
long as the execution of masked-off lanes does not change the observable
behavior of the program.</p>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">mask</span> <span class="o">%</span><span class="n">mask</span> <span class="p">{</span> <span class="n">vector</span><span class="o">.</span><span class="n">reduction</span> <span class="o">&lt;</span><span class="n">add</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xi32</span><span class="o">&gt;</span> <span class="n">into</span> <span class="n">i32</span> <span class="p">}</span> <span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xi1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">i32</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">mask</span> <span class="o">%</span><span class="n">mask</span><span class="p">,</span> <span class="o">%</span><span class="n">passthru</span> <span class="p">{</span> <span class="n">arith</span><span class="o">.</span><span class="n">divsi</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xi32</span><span class="o">&gt;</span> <span class="p">}</span> <span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xi1</span><span class="o">&gt;</span> <span class="o">-&gt;</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xi32</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vector.mask %mask { vector.transfer_write %val, %t0[%idx] : vector&lt;16xf32&gt;, memref&lt;?xf32&gt; } : vector&lt;16xi1&gt;
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>vector.mask %mask { vector.transfer_write %val, %t0[%idx] : vector&lt;16xf32&gt;, tensor&lt;?xf32&gt; } : vector&lt;16xi1&gt; -&gt; tensor&lt;?xf32&gt;
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.mask'</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(1,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp.passthru">
<span class="sig-name descname"><span class="pre">passthru</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskOp.passthru" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskOp.maskRegion">
<span class="sig-name descname"><span class="pre">maskRegion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskOp.maskRegion" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.mask">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">passthru</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.vector.MaskOp" title="mlir.dialects.vector.MaskOp"><span class="pre">MaskOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">MaskedLoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The masked load reads elements from memory into a vector as defined
by a base with indices and a mask vector. When the mask is set, the
element is read from memory. Otherwise, the corresponding element is taken
from a pass-through vector. Informally the semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">then</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">pass_thru</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:=</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">then</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">pass_thru</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, the value
comes from the pass-through vector regardless of the index, and the index is
allowed to be out-of-bounds.</p>
<p>The masked load can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for a masked load. The semantics of the operation
closely correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.masked.load</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-masked-load-intrinsics">intrinsic</a>.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.maskedload</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.maskedload</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%pass_thru</span>
<span class="err">   </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
load operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.maskedload'</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.pass_thru">
<span class="sig-name descname"><span class="pre">pass_thru</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.pass_thru" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedLoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedLoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.maskedload">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">maskedload</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pass_thru</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.maskedload" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">MaskedStoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The masked store operation writes elements from a vector into memory
as defined by a base with indices and a mask vector. When the mask is
set, the corresponding element from the vector is written to memory. Otherwise,
no action is taken for the element. Informally the semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, no value
is stored regardless of the index, and the index is allowed to be
out-of-bounds.</p>
<p>The masked store can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for a masked store. The semantics of the operation
closely correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.masked.store</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-masked-store-intrinsics">intrinsic</a>.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.maskedstore</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="nb">vector.maskedstore</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
store operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.maskedstore'</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MaskedStoreOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MaskedStoreOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.maskedstore">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">maskedstore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp" title="mlir.dialects.vector.MaskedStoreOp"><span class="pre">MaskedStoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.maskedstore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">MultiDimReductionOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_dims</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Reduces an n-D vector into an (n-k)-D vector (or a scalar when k == n)
using the given operation: <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minsi</span></code>/<code class="docutils literal notranslate"><span class="pre">minui</span></code>/<code class="docutils literal notranslate"><span class="pre">maxsi</span></code>/<code class="docutils literal notranslate"><span class="pre">maxui</span></code>
/<code class="docutils literal notranslate"><span class="pre">and</span></code>/<code class="docutils literal notranslate"><span class="pre">or</span></code>/<code class="docutils literal notranslate"><span class="pre">xor</span></code> for integers, and <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maxnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">minimumf</span></code>
/<code class="docutils literal notranslate"><span class="pre">maximumf</span></code> for floats.
Takes an initial accumulator operand.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.multi_reduction</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">add</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%acc0</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.multi_reduction</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">add</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%1</span><span class="p">,</span><span class="err"> </span><span class="nv">%acc1</span><span class="err"> </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">f32</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.multi_reduction'</span></em><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.acc">
<span class="sig-name descname"><span class="pre">acc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.acc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.reduction_dims">
<span class="sig-name descname"><span class="pre">reduction_dims</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.reduction_dims" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.MultiDimReductionOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.MultiDimReductionOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.multi_reduction">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">multi_reduction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_dims</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.multi_reduction" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">OuterProductOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Takes 2 1-D vectors and returns the 2-D vector containing the outer-product,
as illustrated below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">outer</span> <span class="o">|</span>   <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span>
<span class="o">------+------------</span>
  <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="o">|</span> <span class="p">[</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">*</span><span class="n">d</span><span class="p">],</span>
   <span class="n">b</span><span class="p">]</span> <span class="o">|</span>   <span class="p">[</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="o">*</span><span class="n">d</span><span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>This operation also accepts a 1-D vector lhs and a scalar rhs. In this
case a simple AXPY operation is performed, which returns a 1-D vector.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">]</span>
</pre></div>
</div>
<p>An optional extra vector argument with the same shape as the output
vector may be specified in which case the operation returns the sum of
the outer-product and the extra vector. In this multiply-accumulate
scenario for floating-point arguments, the rounding mode is enforced
by guaranteeing that a fused-multiply add operation is emitted. When
lowered to the LLVMIR dialect, this form emits <code class="docutils literal notranslate"><span class="pre">llvm.intr.fma</span></code>, which
is guaranteed to lower to actual <code class="docutils literal notranslate"><span class="pre">fma</span></code> instructions on x86.</p>
<p>An optional kind attribute may be specified to be: <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minsi</span></code>
/<code class="docutils literal notranslate"><span class="pre">minui</span></code>/<code class="docutils literal notranslate"><span class="pre">maxsi</span></code>/<code class="docutils literal notranslate"><span class="pre">maxui</span></code>/<code class="docutils literal notranslate"><span class="pre">and</span></code>/<code class="docutils literal notranslate"><span class="pre">or</span></code>/<code class="docutils literal notranslate"><span class="pre">xor</span></code> for integers, and <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>
/<code class="docutils literal notranslate"><span class="pre">minnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maxnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">minimumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maximumf</span></code> for floats. The default is
<code class="docutils literal notranslate"><span class="pre">add</span></code>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">outerproduct</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xf32</span><span class="o">&gt;</span>
<span class="k">return</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">x8xf32</span><span class="o">&gt;</span>

<span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">outerproduct</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span><span class="p">:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">x8xf32</span><span class="o">&gt;</span>
<span class="k">return</span> <span class="o">%</span><span class="mi">3</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">x8xf32</span><span class="o">&gt;</span>

<span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">outerproduct</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="mi">2</span> <span class="p">{</span><span class="n">kind</span> <span class="o">=</span> <span class="c1">#vector.kind&lt;maxnumf&gt;}:</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">8</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">x8xf32</span><span class="o">&gt;</span>
<span class="k">return</span> <span class="o">%</span><span class="mi">3</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">4</span><span class="n">x8xf32</span><span class="o">&gt;</span>

<span class="o">%</span><span class="mi">6</span> <span class="o">=</span> <span class="n">vector</span><span class="o">.</span><span class="n">outerproduct</span> <span class="o">%</span><span class="mi">4</span><span class="p">,</span> <span class="o">%</span><span class="mi">5</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">10</span><span class="n">xf32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">f32</span>
<span class="k">return</span> <span class="o">%</span><span class="mi">6</span><span class="p">:</span> <span class="n">vector</span><span class="o">&lt;</span><span class="mi">10</span><span class="n">xf32</span><span class="o">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.outerproduct'</span></em><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp.lhs">
<span class="sig-name descname"><span class="pre">lhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp.lhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp.rhs">
<span class="sig-name descname"><span class="pre">rhs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp.rhs" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp.acc">
<span class="sig-name descname"><span class="pre">acc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp.acc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.OuterProductOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.OuterProductOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.outerproduct">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">outerproduct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lhs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhs</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.outerproduct" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">PrintOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">punctuation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stringLiteral</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.PrintOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Prints the source vector (or scalar) to stdout in a human-readable format
(for testing and debugging). No return value.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%v</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;</span><span class="mf">0.0</span><span class="p">&gt;</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nb">vector.print</span><span class="err"> </span><span class="nv">%v</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>When lowered to LLVM, the vector print is decomposed into elementary
printing method calls that at runtime will yield:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">)</span>
</pre></div>
</div>
<p>This is printed to stdout via a small runtime support library, which only
needs to provide a few printing methods (single value for all data
types, opening/closing bracket, comma, newline).</p>
<p>By default <code class="docutils literal notranslate"><span class="pre">vector.print</span></code> adds a newline after the vector, but this can be
controlled by the <code class="docutils literal notranslate"><span class="pre">punctuation</span></code> attribute. For example, to print a comma
after instead do:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.print</span><span class="err"> </span><span class="nv">%v</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">punctuation</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">comma</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Note that it is possible to use the punctuation attribute alone. The
following will print a single newline:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.print</span><span class="err"> </span><span class="nx">punctuation</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">newline</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Additionally, to aid with debugging and testing <code class="docutils literal notranslate"><span class="pre">vector.print</span></code> can also
print constant strings:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.print</span><span class="err"> </span><span class="nx">str</span><span class="err"> </span><span class="s2">&quot;Hello, World!&quot;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.print'</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.PrintOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp.punctuation">
<span class="sig-name descname"><span class="pre">punctuation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.PrintOp.punctuation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintOp.stringLiteral">
<span class="sig-name descname"><span class="pre">stringLiteral</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.PrintOp.stringLiteral" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.print_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">print_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">punctuation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">string_literal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.vector.PrintOp" title="mlir.dialects.vector.PrintOp"><span class="pre">PrintOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.print_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ReductionOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fastmath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Reduces an 1-D vector “horizontally” into a scalar using the given
operation: <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minsi</span></code>/<code class="docutils literal notranslate"><span class="pre">minui</span></code>/<code class="docutils literal notranslate"><span class="pre">maxsi</span></code>/<code class="docutils literal notranslate"><span class="pre">maxui</span></code>/<code class="docutils literal notranslate"><span class="pre">and</span></code>/<code class="docutils literal notranslate"><span class="pre">or</span></code>/<code class="docutils literal notranslate"><span class="pre">xor</span></code> for
integers, and <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maxnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">minimumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maximumf</span></code> for
floats. Reductions also allow an optional fused accumulator.</p>
<p>Note that these operations are restricted to 1-D vectors to remain
close to the corresponding LLVM intrinsics:</p>
<p><a class="reference external" href="http://llvm.org/docs/LangRef.html#vector-reduction-intrinsics">http://llvm.org/docs/LangRef.html#vector-reduction-intrinsics</a></p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.reduction</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">add</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">f32</span>

<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.reduction</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">xor</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">i32</span>

<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.reduction</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">mul</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">f32</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.reduction'</span></em><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ReductionOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.vector" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.acc">
<span class="sig-name descname"><span class="pre">acc</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.acc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.fastmath">
<span class="sig-name descname"><span class="pre">fastmath</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.fastmath" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ReductionOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ReductionOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.reduction">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">reduction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fastmath</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.reduction" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ScalableExtractOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Takes rank-1 source vector and a position <code class="docutils literal notranslate"><span class="pre">pos</span></code> within the source
vector, and extracts a subvector starting from that position.</p>
<p>The extraction position must be a multiple of the minimum size of the result
vector. For the operation to be well defined, the destination vector must
fit within the source vector from the specified position. Since the source
vector is scalable and its runtime length is unknown, the validity of the
operation can’t be verified nor guaranteed at compile time.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.scalable.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">8</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.scalable.extract</span><span class="err"> </span><span class="nv">%2</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Invalid example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.scalable.extract</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">5</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">from</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.scalable.extract'</span></em><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp.pos">
<span class="sig-name descname"><span class="pre">pos</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp.pos" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableExtractOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableExtractOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.scalable_extract">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">scalable_extract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.scalable_extract" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ScalableInsertOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>This operations takes a rank-1 fixed-length or scalable subvector and
inserts it within the destination scalable vector starting from the
position specificed by <code class="docutils literal notranslate"><span class="pre">pos</span></code>. If the source vector is scalable, the
insertion position will be scaled by the runtime scaling factor of the
source subvector.</p>
<p>The insertion position must be a multiple of the minimum size of the source
vector. For the operation to be well defined, the source vector must fit in
the destination vector from the specified position. Since the destination
vector is scalable and its runtime length is unknown, the validity of the
operation can’t be verified nor guaranteed at compile time.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.scalable.insert</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">[</span><span class="mf">8</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.scalable.insert</span><span class="err"> </span><span class="nv">%3</span><span class="p">,</span><span class="err"> </span><span class="nv">%4</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%8</span> <span class="o">=</span> <span class="nb">vector.scalable.insert</span><span class="err"> </span><span class="nv">%6</span><span class="p">,</span><span class="err"> </span><span class="nv">%7</span><span class="p">[</span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Invalid example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.scalable.insert</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%1</span><span class="p">[</span><span class="mf">5</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">]x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.scalable.insert'</span></em><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp.pos">
<span class="sig-name descname"><span class="pre">pos</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp.pos" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScalableInsertOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScalableInsertOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.scalable_insert">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">scalable_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.scalable_insert" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ScanOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusive</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ScanOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Performs an inclusive/exclusive scan on an n-D vector along a single
dimension returning an n-D result vector using the given
operation (<code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minsi</span></code>/<code class="docutils literal notranslate"><span class="pre">minui</span></code>/<code class="docutils literal notranslate"><span class="pre">maxsi</span></code>/<code class="docutils literal notranslate"><span class="pre">maxui</span></code>/<code class="docutils literal notranslate"><span class="pre">and</span></code>/<code class="docutils literal notranslate"><span class="pre">or</span></code>/<code class="docutils literal notranslate"><span class="pre">xor</span></code> for
integers, and <code class="docutils literal notranslate"><span class="pre">add</span></code>/<code class="docutils literal notranslate"><span class="pre">mul</span></code>/<code class="docutils literal notranslate"><span class="pre">minnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maxnumf</span></code>/<code class="docutils literal notranslate"><span class="pre">minimumf</span></code>/<code class="docutils literal notranslate"><span class="pre">maximumf</span></code> for
floats), and a specified value for the initial value. The operator returns
the result of scan as well as the result of the last reduction in the scan.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1:2</span> <span class="o">=</span> <span class="nb">vector.scan</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">add</span><span class="p">&gt;,</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%acc</span><span class="err"> </span><span class="p">{</span><span class="nx">inclusive</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nx">false</span><span class="p">,</span><span class="err"> </span><span class="nx">reduction_dim</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">i64</span><span class="p">}</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.scan'</span></em><a class="headerlink" href="#mlir.dialects.vector.ScanOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ScanOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.initial_value">
<span class="sig-name descname"><span class="pre">initial_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.initial_value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.reduction_dim">
<span class="sig-name descname"><span class="pre">reduction_dim</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.reduction_dim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.inclusive">
<span class="sig-name descname"><span class="pre">inclusive</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.inclusive" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScanOp.accumulated_value">
<span class="sig-name descname"><span class="pre">accumulated_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScanOp.accumulated_value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.scan">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">scan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduction_dim</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inclusive</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.scan" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ScatterOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The scatter operation stores elements from a n-D vector into memory or ranked tensor as
defined by a base with indices and an additional n-D index vector, but
only if the corresponding bit in a n-D mask vector is set. Otherwise, no
action is taken for that element. Informally the semantics are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>If a mask bit is set and the corresponding index is out-of-bounds for the
given base, the behavior is undefined. If a mask bit is not set, no value
is stored regardless of the index, and the index is allowed to be
out-of-bounds.</p>
<p>If the index vector contains two or more duplicate indices, the behavior is
undefined. Underlying implementation may enforce strict sequential
semantics.
TODO: always enforce strict sequential semantics?</p>
<p>The scatter operation can be used directly where applicable, or can be used
during progressively lowering to bring other memory operations closer to
hardware ISA support for a scatter. The semantics of the operation closely
correspond to those of the <code class="docutils literal notranslate"><span class="pre">llvm.masked.scatter</span></code>
<a class="reference external" href="https://llvm.org/docs/LangRef.html#llvm-masked-scatter-intrinsics">intrinsic</a>.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
scatter operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.scatter</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%c0</span><span class="p">][</span><span class="nv">%v</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="nb">vector.scatter</span><span class="err"> </span><span class="nv">%base</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">][</span><span class="nv">%v</span><span class="p">],</span><span class="err"> </span><span class="nv">%mask</span><span class="p">,</span><span class="err"> </span><span class="nv">%value</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">i1</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.scatter'</span></em><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ScatterOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ScatterOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ScatterOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.scatter">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">scatter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.vector.ScatterOp" title="mlir.dialects.vector.ScatterOp"><span class="pre">ScatterOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.scatter" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShapeCastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ShapeCastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ShapeCastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Casts to a vector with the same number of elements, element type, and
number of scalable dimensions.</p>
<p>It is currently assumed that this operation does not require moving data,
and that it will be folded away before lowering vector operations.</p>
<p>There is an exception to the folding expectation when targeting
llvm.intr.matrix operations. We need a type conversion back and forth from a
2-D MLIR vector to a 1-D flattened LLVM vector.shape_cast lowering to LLVM
is supported in that particular case, for now.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.shape_cast</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// with 2 scalable dimensions (number of which must be preserved).</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.shape_cast</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">2</span><span class="p">]x</span><span class="mi">3</span><span class="p">x[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x[</span><span class="mi">1</span><span class="p">]x[</span><span class="mi">8</span><span class="p">]x</span><span class="kt">i8</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShapeCastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.shape_cast'</span></em><a class="headerlink" href="#mlir.dialects.vector.ShapeCastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShapeCastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ShapeCastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShapeCastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShapeCastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShapeCastOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShapeCastOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.shape_cast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">shape_cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.shape_cast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ShuffleOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The shuffle operation constructs a permutation (or duplication) of elements
from two input vectors, returning a vector with the same element type as
the input and a length that is the same as the shuffle mask. The two input
vectors must have the same element type, same rank, and trailing dimension
sizes and shuffles their values in the leading dimension (which may differ
in size) according to the given mask. The legality rules are:</p>
<ul class="simple">
<li><p>the two operands must have the same element type as the result</p></li>
<li><p>Either, the two operands and the result must have the same</p></li>
</ul>
<p>rank and trailing dimension sizes, viz. given two k-D operands
v1 : &lt;s_1 x s_2 x .. x s_k x type&gt; and
v2 : &lt;t_1 x t_2 x .. x t_k x type&gt;
we have s_i = t_i for all 1 &lt; i &lt;= k
* Or, the two operands must be 0-D vectors and the result is a 1-D vector.</p>
<ul class="simple">
<li><p>the mask length equals the leading dimension size of the result</p></li>
<li><p>numbering the input vector indices left to right across the operands, all</p></li>
</ul>
<p>mask values must be within range, viz. given two k-D operands v1 and v2
above, all mask values are in the range [0,s_1+t_1). The value <code class="docutils literal notranslate"><span class="pre">-1</span></code>
represents a poison mask value, which specifies that the selected element
is poison.</p>
<p>Note, scalable vectors are not supported.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.shuffle</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err">       ; </span><span class="nx">yields</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.shuffle</span><span class="err"> </span><span class="nv">%c</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> ; </span><span class="nx">yields</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">vector.shuffle</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">]</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err">       ; </span><span class="nx">yields</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.shuffle</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err">           ; </span><span class="nx">yields</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.shuffle</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="o">-</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="o">-</span><span class="mf">1</span><span class="p">]</span>
<span class="err">           </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err">       ; </span><span class="nx">yields</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">6</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.shuffle'</span></em><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp.v1">
<span class="sig-name descname"><span class="pre">v1</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp.v1" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp.v2">
<span class="sig-name descname"><span class="pre">v2</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp.v2" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ShuffleOp.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ShuffleOp.vector" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.shuffle">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">shuffle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.shuffle" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.StepOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">StepOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.StepOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>A <code class="docutils literal notranslate"><span class="pre">step</span></code> operation produces an index vector, i.e. a 1-D vector of values of
index type that represents a linear sequence from 0 to N-1, where N is the
number of elements in the <code class="docutils literal notranslate"><span class="pre">result</span></code> vector.</p>
<p>Supports fixed-width and scalable vectors.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.step</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">index</span><span class="p">&gt;</span><span class="err"> ; </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">]</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.step</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">]x</span><span class="kt">index</span><span class="p">&gt;</span><span class="err"> ; </span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="p">..,</span><span class="err"> </span><span class="p">&lt;</span><span class="nx">vscale</span><span class="err"> </span><span class="o">*</span><span class="err"> </span><span class="mf">4</span><span class="err"> </span><span class="o">-</span><span class="err"> </span><span class="mf">1</span><span class="p">&gt;]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.StepOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.step'</span></em><a class="headerlink" href="#mlir.dialects.vector.StepOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.StepOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.StepOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StepOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.StepOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.step">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.step" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">StoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.StoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The ‘vector.store’ operation writes an n-D vector to an n-D slice of memory.
It takes the vector value to be stored, a ‘base’ memref and an index for
each memref dimension. The ‘base’ memref and indices determine the start
memory address from which to write. Each index provides an offset for each
memref dimension based on the element type of the memref. The shape of the
vector value to store determines the shape of the slice written from the
start memory address. The elements along each dimension of the slice are
strided by the memref strides. When storing more than 1 element, only unit
strides are allowed along the most minor memref dimension. These constraints
guarantee that elements written along the first dimension of the slice are
contiguous in memory.</p>
<p>The memref element type can be a scalar or a vector type. If the memref
element type is a scalar, it should match the element type of the value
to store. If the memref element type is vector, it should match the type
of the value to store.</p>
<p>Example: 0-D vector store on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example: 1-D vector store on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example: 1-D vector store on a vector memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  2-D vector store on a scalar memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  2-D vector store on a vector memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">200</span><span class="p">x</span><span class="mi">100</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Representation-wise, the ‘vector.store’ operation permits out-of-bounds
writes. Support and implementation of out-of-bounds vector stores are
target-specific. No assumptions should be made on the memory written out of
bounds. Not all targets may support out-of-bounds vector stores.</p>
<p>Example:  Potential out-of-bounds vector store.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%index</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Example:  Explicit out-of-bounds vector store.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.store</span><span class="err"> </span><span class="nv">%valueToStore</span><span class="p">,</span><span class="err"> </span><span class="nv">%memref</span><span class="p">[</span><span class="nv">%c0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">7</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
store operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violating this requirement
triggers immediate undefined behavior.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.store'</span></em><a class="headerlink" href="#mlir.dialects.vector.StoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.StoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.StoreOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.StoreOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.StoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.nontemporal">
<span class="sig-name descname"><span class="pre">nontemporal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.StoreOp.nontemporal" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.StoreOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.StoreOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.store">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.vector.StoreOp" title="mlir.dialects.vector.StoreOp"><span class="pre">StoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.store" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.ToElementsOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">ToElementsOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.ToElementsOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>This operation decomposes all the scalar elements from a vector. The
decomposed scalar elements are returned in row-major order. The number of
scalar results must match the number of elements in the input vector type.
All the result elements have the same result type, which must match the
element type of the input vector. Scalable vectors are not supported.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Decompose a 0-D vector.</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.to_elements</span><span class="err"> </span><span class="nv">%v0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// %0 = %v0[0]</span>

<span class="c1">// Decompose a 1-D vector.</span>
<span class="nv">%0:2</span> <span class="o">=</span> <span class="nb">vector.to_elements</span><span class="err"> </span><span class="nv">%v1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// %0#0 = %v1[0]</span>
<span class="c1">// %0#1 = %v1[1]</span>

<span class="c1">// Decompose a 2-D.</span>
<span class="nv">%0:6</span> <span class="o">=</span> <span class="nb">vector.to_elements</span><span class="err"> </span><span class="nv">%v2</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// %0#0 = %v2[0, 0]</span>
<span class="c1">// %0#1 = %v2[0, 1]</span>
<span class="c1">// %0#2 = %v2[0, 2]</span>
<span class="c1">// %0#3 = %v2[1, 0]</span>
<span class="c1">// %0#4 = %v2[1, 1]</span>
<span class="c1">// %0#5 = %v2[1, 2]</span>

<span class="c1">// Decompose a 3-D vector.</span>
<span class="nv">%0:6</span> <span class="o">=</span> <span class="nb">vector.to_elements</span><span class="err"> </span><span class="nv">%v3</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// %0#0 = %v3[0, 0, 0]</span>
<span class="c1">// %0#1 = %v3[0, 0, 1]</span>
<span class="c1">// %0#2 = %v3[1, 0, 0]</span>
<span class="c1">// %0#3 = %v3[1, 0, 1]</span>
<span class="c1">// %0#4 = %v3[2, 0, 0]</span>
<span class="c1">// %0#5 = %v3[2, 0, 1]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ToElementsOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.to_elements'</span></em><a class="headerlink" href="#mlir.dialects.vector.ToElementsOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.ToElementsOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.ToElementsOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ToElementsOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.ToElementsOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.ToElementsOp.elements">
<span class="sig-name descname"><span class="pre">elements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.ToElementsOp.elements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.to_elements">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">to_elements</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp" title="mlir.dialects.vector.ToElementsOp"><span class="pre">ToElementsOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.to_elements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">TransferReadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_bounds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">vector.transfer_read</span></code> op performs a read from a slice within a
<a class="reference external" href="../LangRef.md#memref-type">MemRef</a> or a Ranked
<a class="reference external" href="../LangRef.md#tensor-type">Tensor</a> supplied as its first operand
into a <a class="reference external" href="../LangRef.md#vector-type">vector</a> of the same base elemental type.</p>
<p>A memref/tensor operand with vector element type, must have its vector
element type match a suffix (shape and element type) of the vector (e.g.
memref&lt;3x2x6x4x3xf32&gt;, vector&lt;1x1x4x3xf32&gt;).</p>
<p>The slice is further defined by a full-rank index within the MemRef/Tensor,
supplied as the operands <code class="docutils literal notranslate"><span class="pre">[1</span> <span class="pre">..</span> <span class="pre">1</span> <span class="pre">+</span> <span class="pre">rank(memref/tensor))</span></code> that defines the
starting point of the transfer (e.g. <code class="docutils literal notranslate"><span class="pre">%A[%i0,</span> <span class="pre">%i1,</span> <span class="pre">%i2]</span></code>).</p>
<p>The permutation_map <a class="reference external" href="../LangRef.md#attributes">attribute</a> is an
<a class="reference external" href="Affine.md#affine-maps">affine-map</a> which specifies the transposition on the
slice to match the vector shape. The permutation map may be implicit and
omitted from parsing and printing if it is the canonical minor identity map
(i.e. if it does not permute or broadcast any dimension).</p>
<p>The size of the slice is specified by the size of the vector, given as the
return type.</p>
<p>An SSA value <code class="docutils literal notranslate"><span class="pre">padding</span></code> of the same elemental type as the MemRef/Tensor is
provided to specify a fallback value in the case of out-of-bounds accesses
and/or masking.</p>
<p>An optional SSA value <code class="docutils literal notranslate"><span class="pre">mask</span></code> may be specified to mask out elements read from
the MemRef/Tensor. The <code class="docutils literal notranslate"><span class="pre">mask</span></code> type is an <code class="docutils literal notranslate"><span class="pre">i1</span></code> vector with a shape that
matches how elements are read from the MemRef/Tensor, <em>before</em> any
permutation or broadcasting. Elements whose corresponding mask element is
<code class="docutils literal notranslate"><span class="pre">0</span></code> are masked out and replaced with <code class="docutils literal notranslate"><span class="pre">padding</span></code>.</p>
<p>For every vector dimension, the boolean array attribute <code class="docutils literal notranslate"><span class="pre">in_bounds</span></code>
specifies if the transfer is guaranteed to be within the source bounds. If
set to “false”, accesses (including the starting point) may run
out-of-bounds along the respective vector dimension as the index increases.
Non-vector dimensions <em>must</em> always be in-bounds. The <code class="docutils literal notranslate"><span class="pre">in_bounds</span></code> array
length has to be equal to the vector rank. This attribute has a default
value: <code class="docutils literal notranslate"><span class="pre">false</span></code> (i.e. “out-of-bounds”). When skipped in the textual IR, the
default value is assumed. Similarly, the OP printer will omit this
attribute when all dimensions are out-of-bounds (i.e. the default value is
used).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">vector.transfer_read</span></code> can be lowered to a simple load if all dimensions
are specified to be within bounds and no <code class="docutils literal notranslate"><span class="pre">mask</span></code> was specified.</p>
<p>This operation is called ‘read’ by opposition to ‘load’ because the
super-vector granularity is generally not representable with a single
hardware register. A <code class="docutils literal notranslate"><span class="pre">vector.transfer_read</span></code> is thus a mid-level abstraction
that supports super-vectorization with non-effecting padding for full-tile
only operations.</p>
<p>More precisely, let’s dive deeper into the permutation_map for the following
MLIR:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%expr1</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr2</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr3</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr4</span><span class="p">]</span>
<span class="err">  </span><span class="p">{</span><span class="err"> </span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="nx">d1</span><span class="p">,</span><span class="nx">d2</span><span class="p">,</span><span class="nx">d3</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d2</span><span class="p">,</span><span class="mf">0</span><span class="p">,</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="p">}</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>This operation always reads a slice starting at <code class="docutils literal notranslate"><span class="pre">%A[%expr1,</span> <span class="pre">%expr2,</span> <span class="pre">%expr3,</span> <span class="pre">%expr4]</span></code>. The size of the slice can be inferred from the resulting vector
shape and walking back through the permutation map: 3 along d2 and 5 along
d0, so the slice is: <code class="docutils literal notranslate"><span class="pre">%A[%expr1</span> <span class="pre">:</span> <span class="pre">%expr1</span> <span class="pre">+</span> <span class="pre">5,</span> <span class="pre">%expr2,</span> <span class="pre">%expr3:%expr3</span> <span class="pre">+</span> <span class="pre">3,</span> <span class="pre">%expr4]</span></code></p>
<p>That slice needs to be read into a <code class="docutils literal notranslate"><span class="pre">vector&lt;3x4x5xf32&gt;</span></code>. Since the
permutation map is not full rank, there must be a broadcast along vector
dimension <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<p>A notional lowering of vector.transfer_read could generate code resembling:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// %expr1, %expr2, %expr3, %expr4 defined before this point</span>
<span class="c1">// alloc a temporary buffer for performing the &quot;gather&quot; of the slice.</span>
<span class="nv">%tmp</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>
<span class="nb">for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">3</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%j</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">4</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%k</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">5</span><span class="err"> </span><span class="p">{</span>
<span class="err">      </span><span class="c1">// Note that this load does not involve %j.</span>
      <span class="nv">%a</span> <span class="o">=</span> <span class="nb">load</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%expr1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%k</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr2</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr3</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr4</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">      </span><span class="c1">// Update the temporary gathered slice with the individual element</span>
      <span class="nv">%slice</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nv">%updated</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%slice</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">,</span><span class="err"> </span><span class="nv">%k</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nb">memref.store</span><span class="err"> </span><span class="nv">%updated</span><span class="p">,</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>
<span class="p">}}}</span>
<span class="c1">// At this point we gathered the elements from the original</span>
<span class="c1">// memref into the desired vector layout, stored in the `%tmp` allocation.</span>
<span class="nv">%vec</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>On a GPU one could then map <code class="docutils literal notranslate"><span class="pre">i</span></code>, <code class="docutils literal notranslate"><span class="pre">j</span></code>, <code class="docutils literal notranslate"><span class="pre">k</span></code> to blocks and threads. Notice that
the temporary storage footprint could conceptually be only <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code> values but
<code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">4</span> <span class="pre">*</span> <span class="pre">5</span></code> values are actually transferred between <code class="docutils literal notranslate"><span class="pre">%A</span></code> and <code class="docutils literal notranslate"><span class="pre">%tmp</span></code>.</p>
<p>Alternatively, if a notional vector broadcast operation were available, we
could avoid the loop on <code class="docutils literal notranslate"><span class="pre">%j</span></code> and the lowered code would resemble:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// %expr1, %expr2, %expr3, %expr4 defined before this point</span>
<span class="nv">%tmp</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>
<span class="nb">for</span><span class="err"> </span><span class="nv">%i</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">3</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%k</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="mf">5</span><span class="err"> </span><span class="p">{</span>
    <span class="nv">%a</span> <span class="o">=</span> <span class="nb">load</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%expr1</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%k</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr2</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr3</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%expr4</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
    <span class="nv">%slice</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">    </span><span class="c1">// Here we only store to the first element in dimension one</span>
    <span class="nv">%updated</span> <span class="o">=</span> <span class="nb">vector.insert</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%slice</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="nv">%k</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
    <span class="nb">memref.store</span><span class="err"> </span><span class="nv">%updated</span><span class="p">,</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>
<span class="p">}}</span>
<span class="c1">// At this point we gathered the elements from the original</span>
<span class="c1">// memref into the desired vector layout, stored in the `%tmp` allocation.</span>
<span class="c1">// However we haven&#39;t replicated them alongside the first dimension, we need</span>
<span class="c1">// to broadcast now.</span>
<span class="nv">%partialVec</span> <span class="o">=</span> <span class="nb">load</span><span class="err"> </span><span class="nv">%tmp</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%vec</span> <span class="o">=</span> <span class="nb">broadcast</span><span class="err"> </span><span class="nv">%tmpvec</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">5</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">broadcast</span></code> broadcasts from element 0 to all others along the
specified dimension. This time, the number of loaded element is <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">5</span></code>
values.
An additional <code class="docutils literal notranslate"><span class="pre">1</span></code> broadcast is required. On a GPU this broadcast could be
implemented using a warp-shuffle if loop <code class="docutils literal notranslate"><span class="pre">j</span></code> were mapped to <code class="docutils literal notranslate"><span class="pre">threadIdx.x</span></code>.</p>
<p>Syntax</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= ssa-id `=` `vector.transfer_read` ssa-use-list
  `{` attribute-entry `} :` memref-type `,` vector-type
</pre></div>
</div>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Read the slice `%A[%i0, %i1:%i1+256, %i2:%i2+32]` into vector&lt;32x256xf32&gt;</span>
<span class="c1">// and pad with %f0 to handle the boundary case:</span>
<span class="nv">%f0</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0.</span><span class="err">0f </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">256</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i2</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">32</span><span class="err"> </span><span class="p">{</span>
      <span class="nv">%v</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">,</span><span class="err"> </span><span class="nv">%i2</span><span class="p">],</span><span class="err"> </span><span class="p">(</span><span class="nv">%f0</span><span class="p">)</span>
<span class="err">           </span><span class="p">{</span><span class="nx">permutation_map</span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d2</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)}</span><span class="err"> </span><span class="p">:</span>
<span class="err">           </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">32</span><span class="p">x</span><span class="mi">256</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}}}</span>

<span class="c1">// or equivalently (rewrite with vector.transpose)</span>
<span class="nv">%f0</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0.</span><span class="err">0f </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">256</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i2</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">32</span><span class="err"> </span><span class="p">{</span>
      <span class="nv">%v0</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">,</span><span class="err"> </span><span class="nv">%i2</span><span class="p">],</span><span class="err"> </span><span class="p">(</span><span class="nv">%f0</span><span class="p">)</span>
<span class="err">           </span><span class="p">{</span><span class="nx">permutation_map</span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">)}</span><span class="err"> </span><span class="p">:</span>
<span class="err">           </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">256</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
      <span class="nv">%v</span> <span class="o">=</span> <span class="nb">vector.transpose</span><span class="err"> </span><span class="nv">%v0</span><span class="p">,</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">          </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">256</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">32</span><span class="p">x</span><span class="mi">256</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}}}</span>

<span class="c1">// Read the slice `%A[%i0, %i1]` (i.e. the element `%A[%i0, %i1]`) into</span>
<span class="c1">// vector&lt;128xf32&gt;. The underlying implementation will require a 1-D vector</span>
<span class="c1">// broadcast:</span>
<span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">{</span>
    <span class="nv">%3</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">]</span>
<span class="err">         </span><span class="p">{</span><span class="nx">permutation_map</span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="mf">0</span><span class="p">)}</span><span class="err"> </span><span class="p">:</span>
<span class="err">         </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">128</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Read from a memref with vector element type.</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%arg1</span><span class="p">[</span><span class="nv">%c3</span><span class="p">,</span><span class="err"> </span><span class="nv">%c3</span><span class="p">],</span><span class="err"> </span><span class="nv">%vf0</span>
<span class="err">  </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)}</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Read from a tensor with vector element type.</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%arg1</span><span class="p">[</span><span class="nv">%c3</span><span class="p">,</span><span class="err"> </span><span class="nv">%c3</span><span class="p">],</span><span class="err"> </span><span class="nv">%vf0</span>
<span class="err">  </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)}</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">tensor</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Special encoding for 0-d transfer with 0-d tensor/memref, vector shape</span>
<span class="c1">// {1} and permutation_map () -&gt; (0).</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">vector.transfer_read</span><span class="err"> </span><span class="nv">%arg0</span><span class="p">[],</span><span class="err"> </span><span class="nv">%f0</span><span class="err"> </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;()</span><span class="o">-&gt;</span><span class="p">(</span><span class="mf">0</span><span class="p">)&gt;}</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">tensor</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.transfer_read'</span></em><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.padding">
<span class="sig-name descname"><span class="pre">padding</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.padding" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.permutation_map">
<span class="sig-name descname"><span class="pre">permutation_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.permutation_map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.in_bounds">
<span class="sig-name descname"><span class="pre">in_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.in_bounds" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferReadOp.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferReadOp.vector" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.transfer_read">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">transfer_read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_bounds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.transfer_read" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">TransferWriteOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">valueToStore</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_bounds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">vector.transfer_write</span></code> op performs a write from a
<a class="reference external" href="../LangRef.md#vector-type">vector</a>, supplied as its first operand, into a
slice within a <a class="reference external" href="../LangRef.md#memref-type">MemRef</a> or a Ranked
<a class="reference external" href="../LangRef.md#tensor-type">Tensor</a> of the same base elemental type,
supplied as its second operand.</p>
<p>A vector memref/tensor operand must have its vector element type match a
suffix (shape and element type) of the vector (e.g. memref&lt;3x2x6x4x3xf32&gt;,
vector&lt;1x1x4x3xf32&gt;). If the operand is a tensor, the operation returns a
new tensor of the same type.</p>
<p>The slice is further defined by a full-rank index within the MemRef/Tensor,
supplied as the operands <code class="docutils literal notranslate"><span class="pre">[2</span> <span class="pre">..</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">rank(memref/tensor))</span></code> that defines the
starting point of the transfer (e.g. <code class="docutils literal notranslate"><span class="pre">%A[%i0,</span> <span class="pre">%i1,</span> <span class="pre">%i2,</span> <span class="pre">%i3]</span></code>).</p>
<p>The permutation_map <a class="reference external" href="../LangRef.md#attributes">attribute</a> is an
<a class="reference external" href="Affine.md#affine-maps">affine-map</a> which specifies the transposition on the
slice to match the vector shape. The permutation map may be implicit and
omitted from parsing and printing if it is the canonical minor identity map
(i.e. if it does not permute any dimension). In contrast to <code class="docutils literal notranslate"><span class="pre">transfer_read</span></code>,
write ops cannot have broadcast dimensions.</p>
<p>The size of the slice is specified by the size of the vector.</p>
<p>An optional SSA value <code class="docutils literal notranslate"><span class="pre">mask</span></code> may be specified to mask out elements written
to the MemRef/Tensor. The <code class="docutils literal notranslate"><span class="pre">mask</span></code> type is an <code class="docutils literal notranslate"><span class="pre">i1</span></code> vector with a shape that
matches how elements are written into the MemRef/Tensor, <em>after</em> applying
any permutation. Elements whose corresponding mask element is <code class="docutils literal notranslate"><span class="pre">0</span></code> are
masked out.</p>
<p>For every vector dimension, the boolean array attribute <code class="docutils literal notranslate"><span class="pre">in_bounds</span></code>
specifies if the transfer is guaranteed to be within the source bounds. If
set to “false”, accesses (including the starting point) may run
out-of-bounds along the respective vector dimension as the index increases.
Non-vector dimensions <em>must</em> always be in-bounds. The <code class="docutils literal notranslate"><span class="pre">in_bounds</span></code> array
length has to be equal to the vector rank. This attribute has a default
value: <code class="docutils literal notranslate"><span class="pre">false</span></code> (i.e. “out-of-bounds”). When skipped in the textual IR, the
default value is assumed. Similarly, the OP printer will omit this
attribute when all dimensions are out-of-bounds (i.e. the default value is
used).</p>
<p>A <code class="docutils literal notranslate"><span class="pre">vector.transfer_write</span></code> can be lowered to a simple store if all
dimensions are specified to be within bounds and no <code class="docutils literal notranslate"><span class="pre">mask</span></code> was specified.</p>
<p>This operation is called ‘write’ by opposition to ‘store’ because the
super-vector granularity is generally not representable with a single
hardware register. A <code class="docutils literal notranslate"><span class="pre">vector.transfer_write</span></code> is thus a
mid-level abstraction that supports super-vectorization with non-effecting
padding for full-tile-only code. It is the responsibility of
<code class="docutils literal notranslate"><span class="pre">vector.transfer_write</span></code>’s implementation to ensure the memory writes are
valid. Different lowerings may be pertinent depending on the hardware
support.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// write vector&lt;16x32x64xf32&gt; into the slice</span>
<span class="c1">//   `%A[%i0, %i1:%i1+32, %i2:%i2+64, %i3:%i3+16]`:</span>
<span class="nb">for</span><span class="err"> </span><span class="nv">%i0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">32</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i2</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">64</span><span class="err"> </span><span class="p">{</span>
      <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i3</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%3</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">16</span><span class="err"> </span><span class="p">{</span>
<span class="err">        </span><span class="nv">%val</span><span class="err"> </span><span class="p">=</span><span class="err"> `</span><span class="nx">ssa-value</span><span class="err">` </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
        <span class="nb">vector.transfer_write</span><span class="err"> </span><span class="nv">%val</span><span class="p">,</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">,</span><span class="err"> </span><span class="nv">%i2</span><span class="p">,</span><span class="err"> </span><span class="nv">%i3</span><span class="p">]</span>
<span class="err">          </span><span class="p">{</span><span class="nx">permutation_map</span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">,</span><span class="err"> </span><span class="nx">d3</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d3</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">)}</span><span class="err"> </span><span class="p">:</span>
<span class="err">          </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}}}}</span>

<span class="c1">// or equivalently (rewrite with vector.transpose)</span>
<span class="nb">for</span><span class="err"> </span><span class="nv">%i0</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">{</span>
  <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i1</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">32</span><span class="err"> </span><span class="p">{</span>
    <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i2</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%2</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">64</span><span class="err"> </span><span class="p">{</span>
      <span class="nb">affine.for</span><span class="err"> </span><span class="nv">%i3</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="nv">%3</span><span class="err"> </span><span class="nx">step</span><span class="err"> </span><span class="mf">16</span><span class="err"> </span><span class="p">{</span>
<span class="err">        </span><span class="nv">%val</span><span class="err"> </span><span class="p">=</span><span class="err"> `</span><span class="nx">ssa-value</span><span class="err">` </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
        <span class="nv">%valt</span> <span class="o">=</span> <span class="nb">vector.transpose</span><span class="err"> </span><span class="nv">%val</span><span class="p">,</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">              </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
        <span class="nb">vector.transfer_write</span><span class="err"> </span><span class="nv">%valt</span><span class="p">,</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%i0</span><span class="p">,</span><span class="err"> </span><span class="nv">%i1</span><span class="p">,</span><span class="err"> </span><span class="nv">%i2</span><span class="p">,</span><span class="err"> </span><span class="nv">%i3</span><span class="p">]</span>
<span class="err">          </span><span class="p">{</span><span class="nx">permutation_map</span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">,</span><span class="err"> </span><span class="nx">d3</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d1</span><span class="p">,</span><span class="err"> </span><span class="nx">d2</span><span class="p">,</span><span class="err"> </span><span class="nx">d3</span><span class="p">)}</span><span class="err"> </span><span class="p">:</span>
<span class="err">          </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">32</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="p">}}}}</span>

<span class="c1">// write to a memref with vector element type.</span>
<span class="nb">vector.transfer_write</span><span class="err"> </span><span class="nv">%4</span><span class="p">,</span><span class="err"> </span><span class="nv">%arg1</span><span class="p">[</span><span class="nv">%c3</span><span class="p">,</span><span class="err"> </span><span class="nv">%c3</span><span class="p">]</span>
<span class="err">  </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)}</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>

<span class="c1">// return a tensor where the vector is inserted into the source tensor.</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">vector.transfer_write</span><span class="err"> </span><span class="nv">%4</span><span class="p">,</span><span class="err"> </span><span class="nv">%arg1</span><span class="p">[</span><span class="nv">%c3</span><span class="p">,</span><span class="err"> </span><span class="nv">%c3</span><span class="p">]</span>
<span class="err">  </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="o">-&gt;</span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)}</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">tensor</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="err">vector</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>

<span class="c1">// Special encoding for 0-d transfer with 0-d tensor/memref, vector shape</span>
<span class="c1">// {1} and permutation_map () -&gt; (0).</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.transfer_write</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="nv">%arg0</span><span class="p">[]</span><span class="err"> </span><span class="p">{</span><span class="nx">permutation_map</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;()</span><span class="o">-&gt;</span><span class="p">(</span><span class="mf">0</span><span class="p">)&gt;}</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">tensor</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.transfer_write'</span></em><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.valueToStore">
<span class="sig-name descname"><span class="pre">valueToStore</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.valueToStore" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.base">
<span class="sig-name descname"><span class="pre">base</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.base" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.mask">
<span class="sig-name descname"><span class="pre">mask</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.mask" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.permutation_map">
<span class="sig-name descname"><span class="pre">permutation_map</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.permutation_map" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.in_bounds">
<span class="sig-name descname"><span class="pre">in_bounds</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.in_bounds" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransferWriteOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransferWriteOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.transfer_write">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">transfer_write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_to_store</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_bounds</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp" title="mlir.dialects.vector.TransferWriteOp"><span class="pre">TransferWriteOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.transfer_write" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">TransposeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.TransposeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Takes a n-D vector and returns the transposed n-D vector defined by
the permutation of ranks in the n-sized integer array attribute (in case
of 0-D vectors the array attribute must be empty).</p>
<p>In the operation</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.transpose</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="p">[</span><span class="nx">i_1</span><span class="p">,</span><span class="err"> </span><span class="p">..,</span><span class="err"> </span><span class="nx">i_n</span><span class="p">]</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="nx">d_1</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="p">..</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="nx">d_n</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;</span>
  <span class="nb">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="nx">d_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="p">..</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="nx">d_trans</span><span class="p">[</span><span class="nx">n-1</span><span class="p">]</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>the <code class="docutils literal notranslate"><span class="pre">permutation</span></code> array [i_1, .., i_n] must be a permutation of [0, .., n-1].</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">vector.transpose</span><span class="err"> </span><span class="nv">%0</span><span class="p">,</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="err"> </span><span class="p">[</span><span class="err"> </span><span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="err"> </span><span class="nx">b</span><span class="p">,</span><span class="err"> </span><span class="nx">c</span><span class="p">],</span><span class="err">       </span><span class="p">[</span><span class="err"> </span><span class="p">[</span><span class="nx">a</span><span class="p">,</span><span class="err"> </span><span class="nx">d</span><span class="p">],</span>
<span class="err">   </span><span class="p">[</span><span class="nx">d</span><span class="p">,</span><span class="err"> </span><span class="nx">e</span><span class="p">,</span><span class="err"> </span><span class="nx">f</span><span class="p">]</span><span class="err"> </span><span class="p">]</span><span class="err">  </span><span class="o">-&gt;</span><span class="err">    </span><span class="p">[</span><span class="nx">b</span><span class="p">,</span><span class="err"> </span><span class="nx">e</span><span class="p">],</span>
<span class="err">                      </span><span class="p">[</span><span class="nx">c</span><span class="p">,</span><span class="err"> </span><span class="nx">f</span><span class="p">]</span><span class="err"> </span><span class="p">]</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.transpose'</span></em><a class="headerlink" href="#mlir.dialects.vector.TransposeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.TransposeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransposeOp.vector" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp.permutation">
<span class="sig-name descname"><span class="pre">permutation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransposeOp.permutation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TransposeOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TransposeOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.transpose">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.transpose" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.TypeCastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">TypeCastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.TypeCastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Performs a conversion from a memref with scalar element to a memref with a
<em>single</em> vector element, copying the shape of the memref to the vector. This
is the minimal viable operation that is required to makeke
super-vectorization operational. It can be seen as a special case of the
<code class="docutils literal notranslate"><span class="pre">view</span></code> operation but scoped in the super-vectorization context.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%A</span>  <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%VA</span> <span class="o">=</span> <span class="nb">vector.type_cast</span><span class="err"> </span><span class="nv">%A</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">vector</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TypeCastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.type_cast'</span></em><a class="headerlink" href="#mlir.dialects.vector.TypeCastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.TypeCastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.TypeCastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TypeCastOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TypeCastOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.TypeCastOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.vector.TypeCastOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.type_cast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">type_cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.type_cast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.YieldOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">YieldOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.YieldOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>“vector.yield” yields an SSA value from the Vector dialect op region and
terminates the regions. The semantics of how the values are yielded is
defined by the parent operation.
If “vector.yield” has any operands, the operands must correspond to the
parent operation’s results.
If the parent operation defines no value the vector.yield may be omitted
when printing the region.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.YieldOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'vector.yield'</span></em><a class="headerlink" href="#mlir.dialects.vector.YieldOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.YieldOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.vector.YieldOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.YieldOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.vector.YieldOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.yield_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">yield_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.vector.YieldOp" title="mlir.dialects.vector.YieldOp"><span class="pre">YieldOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.vector.yield_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.vector.register_attribute_builder">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">register_attribute_builder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.register_attribute_builder" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">CombiningKind</span></span><a class="headerlink" href="#mlir.dialects.vector.CombiningKind" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Kind of combining function for contractions and reductions</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.ADD">
<span class="sig-name descname"><span class="pre">ADD</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.ADD" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MUL">
<span class="sig-name descname"><span class="pre">MUL</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MUL" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MINUI">
<span class="sig-name descname"><span class="pre">MINUI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MINUI" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MINSI">
<span class="sig-name descname"><span class="pre">MINSI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MINSI" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MINNUMF">
<span class="sig-name descname"><span class="pre">MINNUMF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MINNUMF" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MAXUI">
<span class="sig-name descname"><span class="pre">MAXUI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">5</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MAXUI" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MAXSI">
<span class="sig-name descname"><span class="pre">MAXSI</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">6</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MAXSI" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MAXNUMF">
<span class="sig-name descname"><span class="pre">MAXNUMF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">7</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MAXNUMF" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.AND">
<span class="sig-name descname"><span class="pre">AND</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">8</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.AND" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.OR">
<span class="sig-name descname"><span class="pre">OR</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">9</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.OR" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.XOR">
<span class="sig-name descname"><span class="pre">XOR</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">10</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.XOR" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MAXIMUMF">
<span class="sig-name descname"><span class="pre">MAXIMUMF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">12</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MAXIMUMF" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.MINIMUMF">
<span class="sig-name descname"><span class="pre">MINIMUMF</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">11</span></em><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.MINIMUMF" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.CombiningKind.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.CombiningKind.__str__" title="Link to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">PrintPunctuation</span></span><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Punctuation for separating vectors or vector elements</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.NoPunctuation">
<span class="sig-name descname"><span class="pre">NoPunctuation</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.NoPunctuation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.NewLine">
<span class="sig-name descname"><span class="pre">NewLine</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.NewLine" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.Comma">
<span class="sig-name descname"><span class="pre">Comma</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">2</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.Comma" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.Open">
<span class="sig-name descname"><span class="pre">Open</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">3</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.Open" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.Close">
<span class="sig-name descname"><span class="pre">Close</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">4</span></em><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.Close" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.PrintPunctuation.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.PrintPunctuation.__str__" title="Link to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.vector.IteratorType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.vector.</span></span><span class="sig-name descname"><span class="pre">IteratorType</span></span><a class="headerlink" href="#mlir.dialects.vector.IteratorType" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Iterator type</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.IteratorType.parallel">
<span class="sig-name descname"><span class="pre">parallel</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0</span></em><a class="headerlink" href="#mlir.dialects.vector.IteratorType.parallel" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.vector.IteratorType.reduction">
<span class="sig-name descname"><span class="pre">reduction</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">1</span></em><a class="headerlink" href="#mlir.dialects.vector.IteratorType.reduction" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.vector.IteratorType.__str__">
<span class="sig-name descname"><span class="pre">__str__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.vector.IteratorType.__str__" title="Link to this definition">¶</a></dt>
<dd><p>Return str(self).</p>
</dd></dl>

</dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../../execution_engine/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">mlir.execution_engine</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../ub/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">mlir.dialects.ub</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, MLIR authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">mlir.dialects.vector</a><ul>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#module-contents">Module Contents</a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.VectorScaleOp"><code class="docutils literal notranslate"><span class="pre">VectorScaleOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.VectorScaleOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">VectorScaleOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.VectorScaleOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">VectorScaleOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.VectorScaleOp.res"><code class="docutils literal notranslate"><span class="pre">VectorScaleOp.res()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.vscale"><code class="docutils literal notranslate"><span class="pre">vscale()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BitCastOp"><code class="docutils literal notranslate"><span class="pre">BitCastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.BitCastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">BitCastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BitCastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">BitCastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BitCastOp.source"><code class="docutils literal notranslate"><span class="pre">BitCastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BitCastOp.result"><code class="docutils literal notranslate"><span class="pre">BitCastOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.bitcast"><code class="docutils literal notranslate"><span class="pre">bitcast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp"><code class="docutils literal notranslate"><span class="pre">BroadcastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">BroadcastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">BroadcastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp.source"><code class="docutils literal notranslate"><span class="pre">BroadcastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.BroadcastOp.vector"><code class="docutils literal notranslate"><span class="pre">BroadcastOp.vector()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.broadcast"><code class="docutils literal notranslate"><span class="pre">broadcast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.base"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.indices"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.mask"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CompressStoreOp.alignment"><code class="docutils literal notranslate"><span class="pre">CompressStoreOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.compressstore"><code class="docutils literal notranslate"><span class="pre">compressstore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ConstantMaskOp"><code class="docutils literal notranslate"><span class="pre">ConstantMaskOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ConstantMaskOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ConstantMaskOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ConstantMaskOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ConstantMaskOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ConstantMaskOp.mask_dim_sizes"><code class="docutils literal notranslate"><span class="pre">ConstantMaskOp.mask_dim_sizes()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.constant_mask"><code class="docutils literal notranslate"><span class="pre">constant_mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp"><code class="docutils literal notranslate"><span class="pre">ContractionOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ContractionOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ContractionOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.lhs"><code class="docutils literal notranslate"><span class="pre">ContractionOp.lhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.rhs"><code class="docutils literal notranslate"><span class="pre">ContractionOp.rhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.acc"><code class="docutils literal notranslate"><span class="pre">ContractionOp.acc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.indexing_maps"><code class="docutils literal notranslate"><span class="pre">ContractionOp.indexing_maps()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.iterator_types"><code class="docutils literal notranslate"><span class="pre">ContractionOp.iterator_types()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ContractionOp.kind"><code class="docutils literal notranslate"><span class="pre">ContractionOp.kind()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.contract"><code class="docutils literal notranslate"><span class="pre">contract()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CreateMaskOp"><code class="docutils literal notranslate"><span class="pre">CreateMaskOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.CreateMaskOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">CreateMaskOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CreateMaskOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">CreateMaskOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CreateMaskOp.operands_"><code class="docutils literal notranslate"><span class="pre">CreateMaskOp.operands_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.create_mask"><code class="docutils literal notranslate"><span class="pre">create_mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp.source"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp.res1"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp.res1()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.DeinterleaveOp.res2"><code class="docutils literal notranslate"><span class="pre">DeinterleaveOp.res2()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.deinterleave"><code class="docutils literal notranslate"><span class="pre">deinterleave()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.base"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.indices"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.mask"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.pass_thru"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.pass_thru()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.alignment"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExpandLoadOp.result"><code class="docutils literal notranslate"><span class="pre">ExpandLoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.expandload"><code class="docutils literal notranslate"><span class="pre">expandload()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp"><code class="docutils literal notranslate"><span class="pre">ExtractOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExtractOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExtractOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp.source"><code class="docutils literal notranslate"><span class="pre">ExtractOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp.dynamic_position"><code class="docutils literal notranslate"><span class="pre">ExtractOp.dynamic_position()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp.static_position"><code class="docutils literal notranslate"><span class="pre">ExtractOp.static_position()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractOp.result"><code class="docutils literal notranslate"><span class="pre">ExtractOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.extract"><code class="docutils literal notranslate"><span class="pre">extract()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp.source"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp.offsets"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp.sizes"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp.sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ExtractStridedSliceOp.strides"><code class="docutils literal notranslate"><span class="pre">ExtractStridedSliceOp.strides()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.extract_strided_slice"><code class="docutils literal notranslate"><span class="pre">extract_strided_slice()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp"><code class="docutils literal notranslate"><span class="pre">FMAOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">FMAOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">FMAOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp.lhs"><code class="docutils literal notranslate"><span class="pre">FMAOp.lhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp.rhs"><code class="docutils literal notranslate"><span class="pre">FMAOp.rhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp.acc"><code class="docutils literal notranslate"><span class="pre">FMAOp.acc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FMAOp.result"><code class="docutils literal notranslate"><span class="pre">FMAOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.fma"><code class="docutils literal notranslate"><span class="pre">fma()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp"><code class="docutils literal notranslate"><span class="pre">FromElementsOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">FromElementsOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">FromElementsOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp.elements"><code class="docutils literal notranslate"><span class="pre">FromElementsOp.elements()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.FromElementsOp.dest"><code class="docutils literal notranslate"><span class="pre">FromElementsOp.dest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.from_elements"><code class="docutils literal notranslate"><span class="pre">from_elements()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp"><code class="docutils literal notranslate"><span class="pre">GatherOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">GatherOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">GatherOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.base"><code class="docutils literal notranslate"><span class="pre">GatherOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.offsets"><code class="docutils literal notranslate"><span class="pre">GatherOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.indices"><code class="docutils literal notranslate"><span class="pre">GatherOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.mask"><code class="docutils literal notranslate"><span class="pre">GatherOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.pass_thru"><code class="docutils literal notranslate"><span class="pre">GatherOp.pass_thru()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.alignment"><code class="docutils literal notranslate"><span class="pre">GatherOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.GatherOp.result"><code class="docutils literal notranslate"><span class="pre">GatherOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.gather"><code class="docutils literal notranslate"><span class="pre">gather()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp"><code class="docutils literal notranslate"><span class="pre">InsertOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">InsertOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">InsertOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">InsertOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.dest"><code class="docutils literal notranslate"><span class="pre">InsertOp.dest()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.dynamic_position"><code class="docutils literal notranslate"><span class="pre">InsertOp.dynamic_position()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.static_position"><code class="docutils literal notranslate"><span class="pre">InsertOp.static_position()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertOp.result"><code class="docutils literal notranslate"><span class="pre">InsertOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.insert"><code class="docutils literal notranslate"><span class="pre">insert()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.dest"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.dest()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.offsets"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.strides"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.strides()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InsertStridedSliceOp.result"><code class="docutils literal notranslate"><span class="pre">InsertStridedSliceOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.insert_strided_slice"><code class="docutils literal notranslate"><span class="pre">insert_strided_slice()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp"><code class="docutils literal notranslate"><span class="pre">InterleaveOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">InterleaveOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">InterleaveOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp.lhs"><code class="docutils literal notranslate"><span class="pre">InterleaveOp.lhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp.rhs"><code class="docutils literal notranslate"><span class="pre">InterleaveOp.rhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.InterleaveOp.result"><code class="docutils literal notranslate"><span class="pre">InterleaveOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.interleave"><code class="docutils literal notranslate"><span class="pre">interleave()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp"><code class="docutils literal notranslate"><span class="pre">LoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">LoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">LoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.base"><code class="docutils literal notranslate"><span class="pre">LoadOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.indices"><code class="docutils literal notranslate"><span class="pre">LoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.nontemporal"><code class="docutils literal notranslate"><span class="pre">LoadOp.nontemporal()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.alignment"><code class="docutils literal notranslate"><span class="pre">LoadOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.LoadOp.result"><code class="docutils literal notranslate"><span class="pre">LoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp"><code class="docutils literal notranslate"><span class="pre">MaskOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">MaskOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">MaskOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp.mask"><code class="docutils literal notranslate"><span class="pre">MaskOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp.passthru"><code class="docutils literal notranslate"><span class="pre">MaskOp.passthru()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp.results_"><code class="docutils literal notranslate"><span class="pre">MaskOp.results_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskOp.maskRegion"><code class="docutils literal notranslate"><span class="pre">MaskOp.maskRegion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.mask"><code class="docutils literal notranslate"><span class="pre">mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.base"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.indices"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.mask"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.pass_thru"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.pass_thru()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.alignment"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedLoadOp.result"><code class="docutils literal notranslate"><span class="pre">MaskedLoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.maskedload"><code class="docutils literal notranslate"><span class="pre">maskedload()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.base"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.indices"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.mask"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MaskedStoreOp.alignment"><code class="docutils literal notranslate"><span class="pre">MaskedStoreOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.maskedstore"><code class="docutils literal notranslate"><span class="pre">maskedstore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.source"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.acc"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.acc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.kind"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.kind()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.reduction_dims"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.reduction_dims()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.MultiDimReductionOp.dest"><code class="docutils literal notranslate"><span class="pre">MultiDimReductionOp.dest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.multi_reduction"><code class="docutils literal notranslate"><span class="pre">multi_reduction()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp"><code class="docutils literal notranslate"><span class="pre">OuterProductOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">OuterProductOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">OuterProductOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp.lhs"><code class="docutils literal notranslate"><span class="pre">OuterProductOp.lhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp.rhs"><code class="docutils literal notranslate"><span class="pre">OuterProductOp.rhs()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp.acc"><code class="docutils literal notranslate"><span class="pre">OuterProductOp.acc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.OuterProductOp.kind"><code class="docutils literal notranslate"><span class="pre">OuterProductOp.kind()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.outerproduct"><code class="docutils literal notranslate"><span class="pre">outerproduct()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp"><code class="docutils literal notranslate"><span class="pre">PrintOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">PrintOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">PrintOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp.source"><code class="docutils literal notranslate"><span class="pre">PrintOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp.punctuation"><code class="docutils literal notranslate"><span class="pre">PrintOp.punctuation()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintOp.stringLiteral"><code class="docutils literal notranslate"><span class="pre">PrintOp.stringLiteral()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.print_"><code class="docutils literal notranslate"><span class="pre">print_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp"><code class="docutils literal notranslate"><span class="pre">ReductionOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ReductionOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ReductionOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.vector"><code class="docutils literal notranslate"><span class="pre">ReductionOp.vector()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.acc"><code class="docutils literal notranslate"><span class="pre">ReductionOp.acc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.kind"><code class="docutils literal notranslate"><span class="pre">ReductionOp.kind()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.fastmath"><code class="docutils literal notranslate"><span class="pre">ReductionOp.fastmath()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ReductionOp.dest"><code class="docutils literal notranslate"><span class="pre">ReductionOp.dest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.reduction"><code class="docutils literal notranslate"><span class="pre">reduction()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp.source"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp.pos"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp.pos()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableExtractOp.result"><code class="docutils literal notranslate"><span class="pre">ScalableExtractOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.scalable_extract"><code class="docutils literal notranslate"><span class="pre">scalable_extract()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp.dest"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp.dest()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp.pos"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp.pos()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScalableInsertOp.result"><code class="docutils literal notranslate"><span class="pre">ScalableInsertOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.scalable_insert"><code class="docutils literal notranslate"><span class="pre">scalable_insert()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp"><code class="docutils literal notranslate"><span class="pre">ScanOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ScanOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ScanOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.source"><code class="docutils literal notranslate"><span class="pre">ScanOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.initial_value"><code class="docutils literal notranslate"><span class="pre">ScanOp.initial_value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.kind"><code class="docutils literal notranslate"><span class="pre">ScanOp.kind()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.reduction_dim"><code class="docutils literal notranslate"><span class="pre">ScanOp.reduction_dim()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.inclusive"><code class="docutils literal notranslate"><span class="pre">ScanOp.inclusive()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.dest"><code class="docutils literal notranslate"><span class="pre">ScanOp.dest()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScanOp.accumulated_value"><code class="docutils literal notranslate"><span class="pre">ScanOp.accumulated_value()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.scan"><code class="docutils literal notranslate"><span class="pre">scan()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp"><code class="docutils literal notranslate"><span class="pre">ScatterOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ScatterOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ScatterOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.base"><code class="docutils literal notranslate"><span class="pre">ScatterOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.offsets"><code class="docutils literal notranslate"><span class="pre">ScatterOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.indices"><code class="docutils literal notranslate"><span class="pre">ScatterOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.mask"><code class="docutils literal notranslate"><span class="pre">ScatterOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">ScatterOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.alignment"><code class="docutils literal notranslate"><span class="pre">ScatterOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ScatterOp.result"><code class="docutils literal notranslate"><span class="pre">ScatterOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.scatter"><code class="docutils literal notranslate"><span class="pre">scatter()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp"><code class="docutils literal notranslate"><span class="pre">ShapeCastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ShapeCastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ShapeCastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp.source"><code class="docutils literal notranslate"><span class="pre">ShapeCastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShapeCastOp.result"><code class="docutils literal notranslate"><span class="pre">ShapeCastOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.shape_cast"><code class="docutils literal notranslate"><span class="pre">shape_cast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp"><code class="docutils literal notranslate"><span class="pre">ShuffleOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ShuffleOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ShuffleOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp.v1"><code class="docutils literal notranslate"><span class="pre">ShuffleOp.v1()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp.v2"><code class="docutils literal notranslate"><span class="pre">ShuffleOp.v2()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp.mask"><code class="docutils literal notranslate"><span class="pre">ShuffleOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ShuffleOp.vector"><code class="docutils literal notranslate"><span class="pre">ShuffleOp.vector()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.shuffle"><code class="docutils literal notranslate"><span class="pre">shuffle()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StepOp"><code class="docutils literal notranslate"><span class="pre">StepOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.StepOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">StepOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StepOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">StepOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StepOp.result"><code class="docutils literal notranslate"><span class="pre">StepOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.step"><code class="docutils literal notranslate"><span class="pre">step()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp"><code class="docutils literal notranslate"><span class="pre">StoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">StoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">StoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">StoreOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.base"><code class="docutils literal notranslate"><span class="pre">StoreOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.indices"><code class="docutils literal notranslate"><span class="pre">StoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.nontemporal"><code class="docutils literal notranslate"><span class="pre">StoreOp.nontemporal()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.StoreOp.alignment"><code class="docutils literal notranslate"><span class="pre">StoreOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.store"><code class="docutils literal notranslate"><span class="pre">store()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp"><code class="docutils literal notranslate"><span class="pre">ToElementsOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ToElementsOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ToElementsOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp.source"><code class="docutils literal notranslate"><span class="pre">ToElementsOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.ToElementsOp.elements"><code class="docutils literal notranslate"><span class="pre">ToElementsOp.elements()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.to_elements"><code class="docutils literal notranslate"><span class="pre">to_elements()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp"><code class="docutils literal notranslate"><span class="pre">TransferReadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">TransferReadOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">TransferReadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.base"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.indices"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.padding"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.padding()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.mask"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.permutation_map"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.permutation_map()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.in_bounds"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.in_bounds()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferReadOp.vector"><code class="docutils literal notranslate"><span class="pre">TransferReadOp.vector()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.transfer_read"><code class="docutils literal notranslate"><span class="pre">transfer_read()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.valueToStore"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.valueToStore()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.base"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.base()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.indices"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.mask"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.mask()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.permutation_map"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.permutation_map()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.in_bounds"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.in_bounds()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransferWriteOp.result"><code class="docutils literal notranslate"><span class="pre">TransferWriteOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.transfer_write"><code class="docutils literal notranslate"><span class="pre">transfer_write()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp"><code class="docutils literal notranslate"><span class="pre">TransposeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">TransposeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">TransposeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp.vector"><code class="docutils literal notranslate"><span class="pre">TransposeOp.vector()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp.permutation"><code class="docutils literal notranslate"><span class="pre">TransposeOp.permutation()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TransposeOp.result"><code class="docutils literal notranslate"><span class="pre">TransposeOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.transpose"><code class="docutils literal notranslate"><span class="pre">transpose()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp"><code class="docutils literal notranslate"><span class="pre">TypeCastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">TypeCastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">TypeCastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp.memref"><code class="docutils literal notranslate"><span class="pre">TypeCastOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.TypeCastOp.result"><code class="docutils literal notranslate"><span class="pre">TypeCastOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.type_cast"><code class="docutils literal notranslate"><span class="pre">type_cast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.YieldOp"><code class="docutils literal notranslate"><span class="pre">YieldOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.YieldOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">YieldOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.YieldOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">YieldOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.YieldOp.operands_"><code class="docutils literal notranslate"><span class="pre">YieldOp.operands_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.yield_"><code class="docutils literal notranslate"><span class="pre">yield_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.register_attribute_builder"><code class="docutils literal notranslate"><span class="pre">register_attribute_builder()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind"><code class="docutils literal notranslate"><span class="pre">CombiningKind</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.ADD"><code class="docutils literal notranslate"><span class="pre">CombiningKind.ADD</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MUL"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MUL</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MINUI"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MINUI</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MINSI"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MINSI</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MINNUMF"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MINNUMF</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MAXUI"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MAXUI</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MAXSI"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MAXSI</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MAXNUMF"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MAXNUMF</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.AND"><code class="docutils literal notranslate"><span class="pre">CombiningKind.AND</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.OR"><code class="docutils literal notranslate"><span class="pre">CombiningKind.OR</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.XOR"><code class="docutils literal notranslate"><span class="pre">CombiningKind.XOR</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MAXIMUMF"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MAXIMUMF</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.MINIMUMF"><code class="docutils literal notranslate"><span class="pre">CombiningKind.MINIMUMF</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.CombiningKind.__str__"><code class="docutils literal notranslate"><span class="pre">CombiningKind.__str__()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.NoPunctuation"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.NoPunctuation</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.NewLine"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.NewLine</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.Comma"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.Comma</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.Open"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.Open</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.Close"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.Close</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.PrintPunctuation.__str__"><code class="docutils literal notranslate"><span class="pre">PrintPunctuation.__str__()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.vector.IteratorType"><code class="docutils literal notranslate"><span class="pre">IteratorType</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.vector.IteratorType.parallel"><code class="docutils literal notranslate"><span class="pre">IteratorType.parallel</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.IteratorType.reduction"><code class="docutils literal notranslate"><span class="pre">IteratorType.reduction</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.vector.IteratorType.__str__"><code class="docutils literal notranslate"><span class="pre">IteratorType.__str__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>