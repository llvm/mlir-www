<!doctype html>
<html class="no-js" lang="en" data-content_root="../../../../">
  <head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />
<link rel="index" title="Index" href="../../../../genindex.html"><link rel="search" title="Search" href="../../../../search.html"><link rel="next" title="mlir.dialects.ml_program" href="../ml_program/index.html"><link rel="prev" title="mlir.dialects.math" href="../math/index.html">

    <!-- Generated with Sphinx 8.1.3 and Furo 2025.09.25 -->
        <title>mlir.dialects.memref - MLIR Python bindings documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo.css?v=580074bf" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/furo-extensions.css?v=8dab3a3b" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/ignore_highlight_err.css?v=07bcfcf5" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #202020;
  --color-code-foreground: #d0d0d0;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle site navigation sidebar">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc" aria-label="Toggle table of contents sidebar">
<label class="overlay sidebar-overlay" for="__navigation"></label>
<label class="overlay toc-overlay" for="__toc"></label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <span class="icon"><svg><use href="#svg-menu"></use></svg></span>
      </label>
    </div>
    <div class="header-center">
      <a href="../../../../index.html"><div class="brand">MLIR Python bindings  documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../../../../index.html">
  
  <span class="sidebar-brand-text">MLIR Python bindings  documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../../../../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1 current has-children"><a class="reference internal" href="../../index.html">mlir namespace</a><input aria-label="Toggle navigation of mlir namespace" checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/pdl/index.html">mlir._mlir_libs._mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/quant/index.html">mlir._mlir_libs._mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/dialects/transform/index.html">mlir._mlir_libs._mlir.dialects.transform</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_mlir_libs/index.html">mlir._mlir_libs</a><input aria-label="Toggle navigation of mlir._mlir_libs" class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_mlir_libs/_mlir/index.html">mlir._mlir_libs._mlir</a><input aria-label="Toggle navigation of mlir._mlir_libs._mlir" class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html">mlir._mlir_libs._mlir.ir</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/passmanager/index.html">mlir._mlir_libs._mlir.passmanager</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_mlir_libs/_mlir/rewrite/index.html">mlir._mlir_libs._mlir.rewrite</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirExecutionEngine/index.html">mlir._mlir_libs._mlirExecutionEngine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_mlir_libs/_mlirPythonTestNanobind/index.html">mlir._mlir_libs._mlirPythonTestNanobind</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../_acc_ops_gen/index.html">mlir.dialects._acc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_enum_gen/index.html">mlir.dialects._affine_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_affine_ops_gen/index.html">mlir.dialects._affine_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_enum_gen/index.html">mlir.dialects._amdgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_amdgpu_ops_gen/index.html">mlir.dialects._amdgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_enum_gen/index.html">mlir.dialects._arith_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_arith_ops_gen/index.html">mlir.dialects._arith_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_async_ops_gen/index.html">mlir.dialects._async_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_enum_gen/index.html">mlir.dialects._bufferization_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_ops_gen/index.html">mlir.dialects._bufferization_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_bufferization_transform_ops_gen/index.html">mlir.dialects._bufferization_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_builtin_ops_gen/index.html">mlir.dialects._builtin_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_cf_ops_gen/index.html">mlir.dialects._cf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_complex_ops_gen/index.html">mlir.dialects._complex_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_emitc_ops_gen/index.html">mlir.dialects._emitc_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_func_ops_gen/index.html">mlir.dialects._func_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_enum_gen/index.html">mlir.dialects._gpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_ops_gen/index.html">mlir.dialects._gpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_gpu_transform_ops_gen/index.html">mlir.dialects._gpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_enum_gen/index.html">mlir.dialects._index_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_index_ops_gen/index.html">mlir.dialects._index_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_enum_gen/index.html">mlir.dialects._irdl_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_irdl_ops_gen/index.html">mlir.dialects._irdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_enum_gen/index.html">mlir.dialects._linalg_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_linalg_ops_gen/index.html">mlir.dialects._linalg_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_enum_gen/index.html">mlir.dialects._llvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_llvm_ops_gen/index.html">mlir.dialects._llvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_loop_transform_ops_gen/index.html">mlir.dialects._loop_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_math_ops_gen/index.html">mlir.dialects._math_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_ops_gen/index.html">mlir.dialects._memref_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_memref_transform_ops_gen/index.html">mlir.dialects._memref_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ml_program_ops_gen/index.html">mlir.dialects._ml_program_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_enum_gen/index.html">mlir.dialects._nvgpu_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_ops_gen/index.html">mlir.dialects._nvgpu_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvgpu_transform_ops_gen/index.html">mlir.dialects._nvgpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_enum_gen/index.html">mlir.dialects._nvvm_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_nvvm_ops_gen/index.html">mlir.dialects._nvvm_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ods_common/index.html">mlir.dialects._ods_common</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_omp_ops_gen/index.html">mlir.dialects._omp_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_pdl_ops_gen/index.html">mlir.dialects._pdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_python_test_ops_gen/index.html">mlir.dialects._python_test_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_rocdl_ops_gen/index.html">mlir.dialects._rocdl_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_scf_ops_gen/index.html">mlir.dialects._scf_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shape_ops_gen/index.html">mlir.dialects._shape_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_enum_gen/index.html">mlir.dialects._shard_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_shard_ops_gen/index.html">mlir.dialects._shard_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_enum_gen/index.html">mlir.dialects._smt_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_smt_ops_gen/index.html">mlir.dialects._smt_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_enum_gen/index.html">mlir.dialects._sparse_tensor_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_ops_gen/index.html">mlir.dialects._sparse_tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_sparse_tensor_transform_ops_gen/index.html">mlir.dialects._sparse_tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_spirv_ops_gen/index.html">mlir.dialects._spirv_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_enum_gen/index.html">mlir.dialects._structured_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_structured_transform_ops_gen/index.html">mlir.dialects._structured_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_ops_gen/index.html">mlir.dialects._tensor_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tensor_transform_ops_gen/index.html">mlir.dialects._tensor_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_tosa_ops_gen/index.html">mlir.dialects._tosa_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_debug_extension_ops_gen/index.html">mlir.dialects._transform_debug_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_enum_gen/index.html">mlir.dialects._transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_ops_gen/index.html">mlir.dialects._transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_pdl_extension_ops_gen/index.html">mlir.dialects._transform_pdl_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_smt_extension_ops_gen/index.html">mlir.dialects._transform_smt_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_transform_tune_extension_ops_gen/index.html">mlir.dialects._transform_tune_extension_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_ub_ops_gen/index.html">mlir.dialects._ub_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_enum_gen/index.html">mlir.dialects._vector_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_ops_gen/index.html">mlir.dialects._vector_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_enum_gen/index.html">mlir.dialects._vector_transform_enum_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_vector_transform_ops_gen/index.html">mlir.dialects._vector_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../_xegpu_transform_ops_gen/index.html">mlir.dialects._xegpu_transform_ops_gen</a></li>
<li class="toctree-l2"><a class="reference internal" href="../affine/index.html">mlir.dialects.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../amdgpu/index.html">mlir.dialects.amdgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../arith/index.html">mlir.dialects.arith</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../async_dialect/index.html">mlir.dialects.async_dialect</a><input aria-label="Toggle navigation of mlir.dialects.async_dialect" class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" role="switch" type="checkbox"/><label for="toctree-checkbox-5"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../async_dialect/passes/index.html">mlir.dialects.async_dialect.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../bufferization/index.html">mlir.dialects.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../builtin/index.html">mlir.dialects.builtin</a></li>
<li class="toctree-l2"><a class="reference internal" href="../cf/index.html">mlir.dialects.cf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../complex/index.html">mlir.dialects.complex</a></li>
<li class="toctree-l2"><a class="reference internal" href="../emitc/index.html">mlir.dialects.emitc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../func/index.html">mlir.dialects.func</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../gpu/index.html">mlir.dialects.gpu</a><input aria-label="Toggle navigation of mlir.dialects.gpu" class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" role="switch" type="checkbox"/><label for="toctree-checkbox-6"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../gpu/passes/index.html">mlir.dialects.gpu.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../index/index.html">mlir.dialects.index</a></li>
<li class="toctree-l2"><a class="reference internal" href="../irdl/index.html">mlir.dialects.irdl</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/index.html">mlir.dialects.linalg</a><input aria-label="Toggle navigation of mlir.dialects.linalg" class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" role="switch" type="checkbox"/><label for="toctree-checkbox-7"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" role="switch" type="checkbox"/><label for="toctree-checkbox-8"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" role="switch" type="checkbox"/><label for="toctree-checkbox-9"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l4 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-10" name="toctree-checkbox-10" role="switch" type="checkbox"/><label for="toctree-checkbox-10"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l5"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/index.html">mlir.dialects.linalg.opdsl</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl" class="toctree-checkbox" id="toctree-checkbox-11" name="toctree-checkbox-11" role="switch" type="checkbox"/><label for="toctree-checkbox-11"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/dump_oplib/index.html">mlir.dialects.linalg.opdsl.dump_oplib</a></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-12" name="toctree-checkbox-12" role="switch" type="checkbox"/><label for="toctree-checkbox-12"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-13" name="toctree-checkbox-13" role="switch" type="checkbox"/><label for="toctree-checkbox-13"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l4"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/lang/index.html">mlir.dialects.linalg.opdsl.lang</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.lang" class="toctree-checkbox" id="toctree-checkbox-14" name="toctree-checkbox-14" role="switch" type="checkbox"/><label for="toctree-checkbox-14"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/affine/index.html">mlir.dialects.linalg.opdsl.lang.affine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/comprehension/index.html">mlir.dialects.linalg.opdsl.lang.comprehension</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/config/index.html">mlir.dialects.linalg.opdsl.lang.config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/dsl/index.html">mlir.dialects.linalg.opdsl.lang.dsl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/emitter/index.html">mlir.dialects.linalg.opdsl.lang.emitter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/scalar_expr/index.html">mlir.dialects.linalg.opdsl.lang.scalar_expr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/types/index.html">mlir.dialects.linalg.opdsl.lang.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/lang/yaml_helper/index.html">mlir.dialects.linalg.opdsl.lang.yaml_helper</a></li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../linalg/opdsl/ops/index.html">mlir.dialects.linalg.opdsl.ops</a><input aria-label="Toggle navigation of mlir.dialects.linalg.opdsl.ops" class="toctree-checkbox" id="toctree-checkbox-15" name="toctree-checkbox-15" role="switch" type="checkbox"/><label for="toctree-checkbox-15"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../linalg/opdsl/ops/core_named_ops/index.html">mlir.dialects.linalg.opdsl.ops.core_named_ops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../linalg/passes/index.html">mlir.dialects.linalg.passes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../llvm/index.html">mlir.dialects.llvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../math/index.html">mlir.dialects.math</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">mlir.dialects.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ml_program/index.html">mlir.dialects.ml_program</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvgpu/index.html">mlir.dialects.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../nvvm/index.html">mlir.dialects.nvvm</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openacc/index.html">mlir.dialects.openacc</a></li>
<li class="toctree-l2"><a class="reference internal" href="../openmp/index.html">mlir.dialects.openmp</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pdl/index.html">mlir.dialects.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../python_test/index.html">mlir.dialects.python_test</a></li>
<li class="toctree-l2"><a class="reference internal" href="../quant/index.html">mlir.dialects.quant</a></li>
<li class="toctree-l2"><a class="reference internal" href="../rocdl/index.html">mlir.dialects.rocdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scf/index.html">mlir.dialects.scf</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shape/index.html">mlir.dialects.shape</a></li>
<li class="toctree-l2"><a class="reference internal" href="../shard/index.html">mlir.dialects.shard</a></li>
<li class="toctree-l2"><a class="reference internal" href="../smt/index.html">mlir.dialects.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sparse_tensor/index.html">mlir.dialects.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../spirv/index.html">mlir.dialects.spirv</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tensor/index.html">mlir.dialects.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tosa/index.html">mlir.dialects.tosa</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../transform/index.html">mlir.dialects.transform</a><input aria-label="Toggle navigation of mlir.dialects.transform" class="toctree-checkbox" id="toctree-checkbox-16" name="toctree-checkbox-16" role="switch" type="checkbox"/><label for="toctree-checkbox-16"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../transform/bufferization/index.html">mlir.dialects.transform.bufferization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/debug/index.html">mlir.dialects.transform.debug</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/extras/index.html">mlir.dialects.transform.extras</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/gpu/index.html">mlir.dialects.transform.gpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../transform/interpreter/index.html">mlir.dialects.transform.interpreter</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/loop/index.html">mlir.dialects.transform.loop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/memref/index.html">mlir.dialects.transform.memref</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/nvgpu/index.html">mlir.dialects.transform.nvgpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/pdl/index.html">mlir.dialects.transform.pdl</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/smt/index.html">mlir.dialects.transform.smt</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/sparse_tensor/index.html">mlir.dialects.transform.sparse_tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/structured/index.html">mlir.dialects.transform.structured</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tensor/index.html">mlir.dialects.transform.tensor</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/tune/index.html">mlir.dialects.transform.tune</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/vector/index.html">mlir.dialects.transform.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../transform/xegpu/index.html">mlir.dialects.transform.xegpu</a></li>
<li class="toctree-l2"><a class="reference internal" href="../ub/index.html">mlir.dialects.ub</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vector/index.html">mlir.dialects.vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../execution_engine/index.html">mlir.execution_engine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/meta/index.html">mlir.extras.meta</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../extras/types/index.html">mlir.extras.types</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../ir/index.html">mlir.ir</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../passmanager/index.html">mlir.passmanager</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../rewrite/index.html">mlir.rewrite</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../runtime/index.html">mlir.runtime</a><input aria-label="Toggle navigation of mlir.runtime" class="toctree-checkbox" id="toctree-checkbox-17" name="toctree-checkbox-17" role="switch" type="checkbox"/><label for="toctree-checkbox-17"><span class="icon"><svg><use href="#svg-arrow-right"></use></svg></span></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../runtime/np_to_memref/index.html">mlir.runtime.np_to_memref</a></li>
</ul>
</li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../../../../_sources/autoapi/mlir/dialects/memref/index.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle" aria-label="Toggle Light / Dark / Auto color theme">
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <span class="icon"><svg><use href="#svg-toc"></use></svg></span>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="module-mlir.dialects.memref">
<span id="mlir-dialects-memref"></span><h1>mlir.dialects.memref<a class="headerlink" href="#module-mlir.dialects.memref" title="Link to this heading">¶</a></h1>
<section id="attributes">
<h2>Attributes<a class="headerlink" href="#attributes" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.MixedValues" title="mlir.dialects.memref.MixedValues"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MixedValues</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref._generated_subview" title="mlir.dialects.memref._generated_subview"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_generated_subview</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="classes">
<h2>Classes<a class="headerlink" href="#classes" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp" title="mlir.dialects.memref.AssumeAlignmentOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AssumeAlignmentOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">assume_alignment</span></code> operation takes a memref and an integer alignment</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp" title="mlir.dialects.memref.AtomicRMWOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicRMWOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.atomic_rmw</span></code> operation provides a way to perform a read-modify-write</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp" title="mlir.dialects.memref.AtomicYieldOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AtomicYieldOp</span></code></a></p></td>
<td><p>&quot;memref.atomic_yield&quot; yields an SSA value from a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.CopyOp" title="mlir.dialects.memref.CopyOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CopyOp</span></code></a></p></td>
<td><p>Copies the data from the source to the destination memref.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp" title="mlir.dialects.memref.DistinctObjectsOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DistinctObjectsOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">distinct_objects</span></code> operation takes a list of memrefs and returns the same</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp" title="mlir.dialects.memref.GenericAtomicRMWOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GenericAtomicRMWOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.generic_atomic_rmw</span></code> operation provides a way to perform a</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.LoadOp" title="mlir.dialects.memref.LoadOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LoadOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">load</span></code> op reads an element from a memref at the specified indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.AllocOp" title="mlir.dialects.memref.AllocOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AllocOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">alloc</span></code> operation allocates a region of memory, as specified by its</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.AllocaOp" title="mlir.dialects.memref.AllocaOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AllocaOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">alloca</span></code> operation allocates memory on the stack, to be automatically</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp" title="mlir.dialects.memref.AllocaScopeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AllocaScopeOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code> operation represents an explicitly-delimited</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp" title="mlir.dialects.memref.AllocaScopeReturnOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">AllocaScopeReturnOp</span></code></a></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">memref.alloca_scope.return</span></code> operation returns zero or more SSA values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.CastOp" title="mlir.dialects.memref.CastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CastOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.cast</span></code> operation converts a memref from one type to an equivalent</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp" title="mlir.dialects.memref.CollapseShapeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CollapseShapeOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.collapse_shape</span></code> op produces a new view with a smaller rank</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.DeallocOp" title="mlir.dialects.memref.DeallocOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeallocOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> operation frees the region of memory referenced by a memref</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.DimOp" title="mlir.dialects.memref.DimOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DimOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">dim</span></code> operation takes a memref and a dimension operand of type <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp" title="mlir.dialects.memref.DmaStartOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DmaStartOp</span></code></a></p></td>
<td><p>Syntax:</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp" title="mlir.dialects.memref.DmaWaitOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DmaWaitOp</span></code></a></p></td>
<td><p>DmaWaitOp blocks until the completion of a DMA operation associated with the</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp" title="mlir.dialects.memref.ExpandShapeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExpandShapeOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.expand_shape</span></code> op produces a new view with a higher rank whose</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp" title="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp</span></code></a></p></td>
<td><p>Extracts the underlying aligned pointer as an index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp" title="mlir.dialects.memref.ExtractStridedMetadataOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp</span></code></a></p></td>
<td><p>Extracts a base buffer, offset and strides. This op allows additional layers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp" title="mlir.dialects.memref.GetGlobalOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GetGlobalOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.get_global</span></code> operation retrieves the memref pointing to a</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.GlobalOp" title="mlir.dialects.memref.GlobalOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">GlobalOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.global</span></code> operation declares or defines a named global memref</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp" title="mlir.dialects.memref.MemorySpaceCastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MemorySpaceCastOp</span></code></a></p></td>
<td><p>This operation casts memref values between memory spaces.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp" title="mlir.dialects.memref.PrefetchOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PrefetchOp</span></code></a></p></td>
<td><p>The &quot;prefetch&quot; op prefetches data from a memref location described with</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.RankOp" title="mlir.dialects.memref.RankOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">RankOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">memref.rank</span></code> operation takes a memref operand and returns its rank.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.ReallocOp" title="mlir.dialects.memref.ReallocOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReallocOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">realloc</span></code> operation changes the size of a memory region. The memory</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp" title="mlir.dialects.memref.ReinterpretCastOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReinterpretCastOp</span></code></a></p></td>
<td><p>Modify offset, sizes and strides of an unranked/ranked memref.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp" title="mlir.dialects.memref.ReshapeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ReshapeOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">reshape</span></code> operation converts a memref from one type to an</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.StoreOp" title="mlir.dialects.memref.StoreOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StoreOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">store</span></code> op stores an element into a memref at the specified indices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.TransposeOp" title="mlir.dialects.memref.TransposeOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TransposeOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">transpose</span></code> op produces a strided memref whose sizes and strides</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.ViewOp" title="mlir.dialects.memref.ViewOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ViewOp</span></code></a></p></td>
<td><p>The &quot;view&quot; operation extracts an N-D contiguous memref with empty layout map</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.SubViewOp" title="mlir.dialects.memref.SubViewOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SubViewOp</span></code></a></p></td>
<td><p>The <code class="docutils literal notranslate"><span class="pre">subview</span></code> operation converts a memref type to a memref type which</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.ConstantOp" title="mlir.dialects.memref.ConstantOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantOp</span></code></a></p></td>
<td><p>Specialization for the constant op class.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Link to this heading">¶</a></h2>
<div class="table-wrapper autosummary longtable docutils container">
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.assume_alignment" title="mlir.dialects.memref.assume_alignment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assume_alignment</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.atomic_rmw" title="mlir.dialects.memref.atomic_rmw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atomic_rmw</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.atomic_yield" title="mlir.dialects.memref.atomic_yield"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atomic_yield</span></code></a>(→ AtomicYieldOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.copy" title="mlir.dialects.memref.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(→ CopyOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.distinct_objects" title="mlir.dialects.memref.distinct_objects"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distinct_objects</span></code></a>(→ Union[_ods_ir, _ods_ir, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.generic_atomic_rmw" title="mlir.dialects.memref.generic_atomic_rmw"><code class="xref py py-obj docutils literal notranslate"><span class="pre">generic_atomic_rmw</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.load" title="mlir.dialects.memref.load"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.alloc" title="mlir.dialects.memref.alloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alloc</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.alloca" title="mlir.dialects.memref.alloca"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alloca</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.alloca_scope" title="mlir.dialects.memref.alloca_scope"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alloca_scope</span></code></a>(→ Union[_ods_ir, _ods_ir, AllocaScopeOp])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.alloca_scope_return" title="mlir.dialects.memref.alloca_scope_return"><code class="xref py py-obj docutils literal notranslate"><span class="pre">alloca_scope_return</span></code></a>(→ AllocaScopeReturnOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.cast" title="mlir.dialects.memref.cast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.collapse_shape" title="mlir.dialects.memref.collapse_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">collapse_shape</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.dealloc" title="mlir.dialects.memref.dealloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dealloc</span></code></a>(→ DeallocOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.dim" title="mlir.dialects.memref.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.dma_start" title="mlir.dialects.memref.dma_start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dma_start</span></code></a>(→ DmaStartOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.dma_wait" title="mlir.dialects.memref.dma_wait"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dma_wait</span></code></a>(→ DmaWaitOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.expand_shape" title="mlir.dialects.memref.expand_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">expand_shape</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.extract_aligned_pointer_as_index" title="mlir.dialects.memref.extract_aligned_pointer_as_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_aligned_pointer_as_index</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.extract_strided_metadata" title="mlir.dialects.memref.extract_strided_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract_strided_metadata</span></code></a>(→ Union[_ods_ir, _ods_ir, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.get_global" title="mlir.dialects.memref.get_global"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_global</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.global_" title="mlir.dialects.memref.global_"><code class="xref py py-obj docutils literal notranslate"><span class="pre">global_</span></code></a>(→ GlobalOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.memory_space_cast" title="mlir.dialects.memref.memory_space_cast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_space_cast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.prefetch" title="mlir.dialects.memref.prefetch"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prefetch</span></code></a>(→ PrefetchOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.rank" title="mlir.dialects.memref.rank"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rank</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.realloc" title="mlir.dialects.memref.realloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">realloc</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.reinterpret_cast" title="mlir.dialects.memref.reinterpret_cast"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reinterpret_cast</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.reshape" title="mlir.dialects.memref.reshape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reshape</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.store" title="mlir.dialects.memref.store"><code class="xref py py-obj docutils literal notranslate"><span class="pre">store</span></code></a>(→ StoreOp)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref.transpose" title="mlir.dialects.memref.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref.view" title="mlir.dialects.memref.view"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view</span></code></a>(→ _ods_ir)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id0" title="mlir.dialects.memref.subview"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subview</span></code></a>(source, offsets, sizes, strides, *[, ...])</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref._is_constant_int_like" title="mlir.dialects.memref._is_constant_int_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_is_constant_int_like</span></code></a>(i)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#mlir.dialects.memref._is_static_int_like" title="mlir.dialects.memref._is_static_int_like"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_is_static_int_like</span></code></a>(i)</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#mlir.dialects.memref._infer_memref_subview_result_type" title="mlir.dialects.memref._infer_memref_subview_result_type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">_infer_memref_subview_result_type</span></code></a>(source_memref_type, ...)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#id0" title="mlir.dialects.memref.subview"><code class="xref py py-obj docutils literal notranslate"><span class="pre">subview</span></code></a>(source, offsets, sizes, strides, *[, ...])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-contents">
<h2>Module Contents<a class="headerlink" href="#module-contents" title="Link to this heading">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AssumeAlignmentOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">assume_alignment</span></code> operation takes a memref and an integer alignment
value. It returns a new SSA value of the same memref type, but associated
with the assumption that the underlying buffer is aligned to the given
alignment.</p>
<p>If the buffer isn’t aligned to the given alignment, its result is poison.
This operation doesn’t affect the semantics of a program where the
alignment assumption holds true. It is intended for optimization purposes,
allowing the compiler to generate more efficient code based on the
alignment assumption. The optimization is best-effort.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.assume_alignment'</span></em><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AssumeAlignmentOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.AssumeAlignmentOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.assume_alignment">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">assume_alignment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.assume_alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AtomicRMWOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.atomic_rmw</span></code> operation provides a way to perform a read-modify-write
sequence that is free from data races. The kind enumeration specifies the
modification to perform. The value operand represents the new value to be
applied during the modification. The memref operand represents the buffer
that the read and write will be performed against, as accessed by the
specified indices. The arity of the indices is the rank of the memref. The
result represents the latest value that was stored.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%x</span> <span class="o">=</span> <span class="nb">memref.atomic_rmw</span><span class="err"> </span><span class="s2">&quot;addf&quot;</span><span class="err"> </span><span class="nv">%value</span><span class="p">,</span><span class="err"> </span><span class="nv">%I</span><span class="p">[</span><span class="nv">%i</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">f32</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.atomic_rmw'</span></em><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.kind">
<span class="sig-name descname"><span class="pre">kind</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.kind" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicRMWOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicRMWOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.atomic_rmw">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">atomic_rmw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">kind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.atomic_rmw" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicYieldOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AtomicYieldOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AtomicYieldOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>“memref.atomic_yield” yields an SSA value from a
GenericAtomicRMWOp region.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicYieldOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.atomic_yield'</span></em><a class="headerlink" href="#mlir.dialects.memref.AtomicYieldOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicYieldOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AtomicYieldOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AtomicYieldOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AtomicYieldOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.atomic_yield">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">atomic_yield</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp" title="mlir.dialects.memref.AtomicYieldOp"><span class="pre">AtomicYieldOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.atomic_yield" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.CopyOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">CopyOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.CopyOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Copies the data from the source to the destination memref.</p>
<p>Usage:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.copy</span><span class="err"> </span><span class="nv">%arg0</span><span class="p">,</span><span class="err"> </span><span class="nv">%arg1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Source and destination are expected to have the same element type and shape.
Otherwise, the result is undefined. They may have different layouts.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CopyOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.copy'</span></em><a class="headerlink" href="#mlir.dialects.memref.CopyOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CopyOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.CopyOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CopyOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.CopyOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CopyOp.target">
<span class="sig-name descname"><span class="pre">target</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.CopyOp.target" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.copy">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.CopyOp" title="mlir.dialects.memref.CopyOp"><span class="pre">CopyOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.copy" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.DistinctObjectsOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">DistinctObjectsOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.DistinctObjectsOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">distinct_objects</span></code> operation takes a list of memrefs and returns the same
memrefs, with the additional assumption that accesses to them will never
alias with each other. This means that loads and stores to different
memrefs in the list can be safely reordered.</p>
<p>If the memrefs do alias, the load/store behavior is undefined. This
operation doesn’t affect the semantics of a valid program. It is
intended for optimization purposes, allowing the compiler to generate more
efficient code based on the non-aliasing assumption. The optimization is
best-effort.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span><span class="p">,</span> <span class="nv">%2</span> <span class="o">=</span> <span class="nb">memref.distinct_objects</span><span class="err"> </span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DistinctObjectsOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.distinct_objects'</span></em><a class="headerlink" href="#mlir.dialects.memref.DistinctObjectsOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DistinctObjectsOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.DistinctObjectsOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DistinctObjectsOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DistinctObjectsOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DistinctObjectsOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DistinctObjectsOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.distinct_objects">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">distinct_objects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp" title="mlir.dialects.memref.DistinctObjectsOp"><span class="pre">DistinctObjectsOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.distinct_objects" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">GenericAtomicRMWOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.generic_atomic_rmw</span></code> operation provides a way to perform a
read-modify-write sequence that is free from data races. The memref operand
represents the buffer that the read and write will be performed against, as
accessed by the specified indices. The arity of the indices is the rank of
the memref. The result represents the latest value that was stored. The
region contains the code for the modification itself. The entry block has
a single argument that represents the value stored in <code class="docutils literal notranslate"><span class="pre">memref[indices]</span></code>
before the write is performed. No side-effecting ops are allowed in the
body of <code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp</span></code>.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%x</span> <span class="o">=</span> <span class="nb">memref.generic_atomic_rmw</span><span class="err"> </span><span class="nv">%I</span><span class="p">[</span><span class="nv">%i</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="p">{</span>
<span class="err">  </span><span class="nl">^bb0</span><span class="p">(</span><span class="nv">%current_value</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span><span class="p">):</span>
    <span class="nv">%c1</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">1.0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
    <span class="nv">%inc</span> <span class="o">=</span> <span class="nb">arith.addf</span><span class="err"> </span><span class="nv">%c1</span><span class="p">,</span><span class="err"> </span><span class="nv">%current_value</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
    <span class="nb">memref.atomic_yield</span><span class="err"> </span><span class="nv">%inc</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.generic_atomic_rmw'</span></em><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(1,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GenericAtomicRMWOp.atomic_body">
<span class="sig-name descname"><span class="pre">atomic_body</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GenericAtomicRMWOp.atomic_body" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.generic_atomic_rmw">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">generic_atomic_rmw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.generic_atomic_rmw" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">LoadOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.LoadOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">load</span></code> op reads an element from a memref at the specified indices.</p>
<p>The number of indices must match the rank of the memref. The indices must
be in-bounds: <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">idx</span> <span class="pre">&lt;</span> <span class="pre">dim_size</span></code>.</p>
<p>Lowerings of <code class="docutils literal notranslate"><span class="pre">memref.load</span></code> may emit attributes, e.g. <code class="docutils literal notranslate"><span class="pre">inbouds</span></code> + <code class="docutils literal notranslate"><span class="pre">nuw</span></code>
when converting to LLVM’s <code class="docutils literal notranslate"><span class="pre">llvm.getelementptr</span></code>, that would cause undefined
behavior if indices are out of bounds or if computing the offset in the
memref would cause signed overflow of the <code class="docutils literal notranslate"><span class="pre">index</span></code> type.</p>
<p>The single result of <code class="docutils literal notranslate"><span class="pre">memref.load</span></code> is a value with the same type as the
element type of the memref.</p>
<p>A set <code class="docutils literal notranslate"><span class="pre">nontemporal</span></code> attribute indicates that this load is not expected to
be reused in the cache. For details, refer to the
<a class="reference external" href="https://llvm.org/docs/LangRef.html#load-instruction">LLVM load instruction</a>.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
load operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violations may lead to
architecture-specific faults or performance penalties.
A value of 0 indicates no specific alignment requirement.
Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="no">#layout</span><span class="p">,</span><span class="err"> </span><span class="nx">memspace0</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.load'</span></em><a class="headerlink" href="#mlir.dialects.memref.LoadOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.LoadOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.LoadOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.LoadOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.nontemporal">
<span class="sig-name descname"><span class="pre">nontemporal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.LoadOp.nontemporal" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.LoadOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.LoadOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.LoadOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.load">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.load" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AllocOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamicSizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolOperands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AllocOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">alloc</span></code> operation allocates a region of memory, as specified by its
memref type.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the ssa value ‘%d’ is
bound to the second dimension of the memref (which is dynamic).</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">(</span><span class="nv">%d</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The optional list of symbol operands are bound to the symbols of the
memrefs affine map. In the example below, the ssa value ‘%s’ is bound to
the symbol ‘s0’ in the affine map specified in the allocs memref type.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()[</span><span class="nv">%s</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span>
<span class="err">                          </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">((</span><span class="nx">d0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s0</span><span class="p">),</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mf">1</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>This operation returns a single ssa value of memref type, which can be used
by subsequent load and store operations.</p>
<p>The optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute may be specified to ensure that the
region of memory that will be indexed is aligned at the specified byte
boundary.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()[</span><span class="nv">%s</span><span class="p">]</span><span class="err"> </span><span class="p">{</span><span class="nx">alignment</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">8</span><span class="p">}</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">((</span><span class="nx">d0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s0</span><span class="p">),</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.alloc'</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.memref.AllocOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp.dynamicSizes">
<span class="sig-name descname"><span class="pre">dynamicSizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocOp.dynamicSizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp.symbolOperands">
<span class="sig-name descname"><span class="pre">symbolOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocOp.symbolOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.alloc">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">alloc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_operands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.alloc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AllocaOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamicSizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbolOperands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">alloca</span></code> operation allocates memory on the stack, to be automatically
released when control transfers back from the region of its closest
surrounding operation with an
<code class="docutils literal notranslate"><span class="pre">`AutomaticAllocationScope</span></code> &lt;../Traits/#automaticallocationscope&gt;`_ trait.
The amount of memory allocated is specified by its memref and additional
operands. For example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloca</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The optional list of dimension operands are bound to the dynamic dimensions
specified in its memref type. In the example below, the SSA value ‘%d’ is
bound to the second dimension of the memref (which is dynamic).</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloca</span><span class="p">(</span><span class="nv">%d</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The optional list of symbol operands are bound to the symbols of the
memref’s affine map. In the example below, the SSA value ‘%s’ is bound to
the symbol ‘s0’ in the affine map specified in the allocs memref type.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloca</span><span class="p">()[</span><span class="nv">%s</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span>
<span class="err">                           </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">((</span><span class="nx">d0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">s0</span><span class="p">),</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;&gt;</span>
</pre></div>
</div>
<p>This operation returns a single SSA value of memref type, which can be used
by subsequent load and store operations. An optional alignment attribute, if
specified, guarantees alignment at least to that boundary. If not specified,
an alignment on any convenient boundary compatible with the type will be
chosen.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.alloca'</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp.dynamicSizes">
<span class="sig-name descname"><span class="pre">dynamicSizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp.dynamicSizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp.symbolOperands">
<span class="sig-name descname"><span class="pre">symbolOperands</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp.symbolOperands" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.alloca">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">alloca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symbol_operands</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.alloca" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AllocaScopeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code> operation represents an explicitly-delimited
scope for the alloca allocations. Any <code class="docutils literal notranslate"><span class="pre">memref.alloca</span></code> operations that are
used within this scope are going to be cleaned up automatically once
the control-flow exits the nested region. For example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.alloca_scope</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%myalloca</span> <span class="o">=</span> <span class="nb">memref.alloca</span><span class="p">():</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">  </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">%myalloca</span></code> memref is valid within the explicitly delimited scope
and is automatically deallocated at the end of the given region. Conceptually,
<code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code> is a passthrough operation with
<code class="docutils literal notranslate"><span class="pre">AutomaticAllocationScope</span></code> that spans the body of the region within the operation.</p>
<p><code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code> may also return results that are defined in the nested
region. To return a value, one should use <code class="docutils literal notranslate"><span class="pre">memref.alloca_scope.return</span></code>
operation:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result</span> <span class="o">=</span> <span class="nb">memref.alloca_scope</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">f32</span><span class="err"> </span><span class="p">{</span>
  <span class="nv">%value</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">1.0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="err">  </span><span class="p">...</span>
  <span class="nb">memref.alloca_scope.return</span><span class="err"> </span><span class="nv">%value</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code> returns no value, the <a href="#id1"><span class="problematic" id="id2">``</span></a>memref.alloca_scope.return `` can
be left out, and will be inserted implicitly.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.alloca_scope'</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(1,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeOp.bodyRegion">
<span class="sig-name descname"><span class="pre">bodyRegion</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeOp.bodyRegion" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.alloca_scope">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">alloca_scope</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp" title="mlir.dialects.memref.AllocaScopeOp"><span class="pre">AllocaScopeOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.alloca_scope" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeReturnOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">AllocaScopeReturnOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeReturnOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">memref.alloca_scope.return</span></code> operation returns zero or more SSA values
from the region within <code class="docutils literal notranslate"><span class="pre">memref.alloca_scope</span></code>. If no values are returned,
the return operation may be omitted. Otherwise, it has to be present
to indicate which values are going to be returned. For example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.alloca_scope.return</span><span class="err"> </span><span class="nv">%value</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">f32</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeReturnOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.alloca_scope.return'</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeReturnOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeReturnOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeReturnOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.AllocaScopeReturnOp.results_">
<span class="sig-name descname"><span class="pre">results_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.AllocaScopeReturnOp.results_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.alloca_scope_return">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">alloca_scope_return</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">results_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp" title="mlir.dialects.memref.AllocaScopeReturnOp"><span class="pre">AllocaScopeReturnOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.alloca_scope_return" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.CastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">CastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.CastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.cast</span></code> operation converts a memref from one type to an equivalent
type with a compatible shape. The source and destination types are
compatible if:</p>
<p>a. Both are ranked memref types with the same element type, address space,
and rank and:</p>
<ol class="arabic simple">
<li><p>Both have the same layout or both have compatible strided layouts.</p></li>
</ol>
<p>#. The individual sizes (resp. offset and strides in the case of strided
memrefs) may convert constant dimensions to dynamic dimensions and
vice-versa.</p>
<p>If the cast converts any dimensions from an unknown to a known size, then it
acts as an assertion that fails at runtime if the dynamic dimensions
disagree with resultant destination size.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Assert that the input dynamic shape matches the destination static shape.</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// Erase static shape information, replacing it with dynamic information.</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// The same holds true for offsets and strides.</span>

<span class="c1">// Assert that the input dynamic shape matches the destination static stride.</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">                      </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">5</span><span class="p">&gt;&gt;</span>
<span class="c1">// Erase static offset and stride information, replacing it with</span>
<span class="c1">// dynamic information.</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">5</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">                      </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">12</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>b. Either or both memref types are unranked with the same element type, and
address space.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Cast to concrete shape.</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Erase rank information.</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">memref.cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.cast'</span></em><a class="headerlink" href="#mlir.dialects.memref.CastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.CastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.CastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CastOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.CastOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.cast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.cast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">CollapseShapeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reassociation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.collapse_shape</span></code> op produces a new view with a smaller rank
whose sizes are a reassociation of the original <code class="docutils literal notranslate"><span class="pre">view</span></code>. The operation is
limited to such reassociations, where subsequent, contiguous dimensions are
collapsed into a single dimension. Such reassociations never require
additional allocs or copies.</p>
<p>Collapsing non-contiguous dimensions is undefined behavior. When a group of
dimensions can be statically proven to be non-contiguous, collapses of such
groups are rejected in the verifier on a best-effort basis. In the general
case, collapses of dynamically-sized dims with dynamic strides cannot be
proven to be contiguous or non-contiguous due to limitations in the memref
type.</p>
<p>A reassociation is defined as a continuous grouping of dimensions and is
represented with an array of DenseI64ArrayAttr attribute.</p>
<p>Note: Only the dimensions within a reassociation group must be contiguous.
The remaining dimensions may be non-contiguous.</p>
<p>The result memref type can be zero-ranked if the source memref type is
statically shaped with all dimensions being unit extent. In such a case, the
reassociation indices must be empty.</p>
<p>Examples:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Dimension collapse (i, j) -&gt; i&#39; and k -&gt; k&#39;</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.collapse_shape</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">[[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">],</span><span class="err"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]]</span><span class="err"> </span><span class="p">:</span>
<span class="err">    </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">stride_spec</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">stride_spec_2</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>For simplicity, this op may not be used to cast dynamicity of dimension
sizes and/or strides. I.e., a result dimension must be dynamic if and only
if at least one dimension in the corresponding reassociation group is
dynamic. Similarly, the stride of a result dimension must be dynamic if and
only if the corresponding start dimension in the source type is dynamic.</p>
<p>Note: This op currently assumes that the inner strides are of the
source/result layout map are the faster-varying ones.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.collapse_shape'</span></em><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp.src">
<span class="sig-name descname"><span class="pre">src</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp.src" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp.reassociation">
<span class="sig-name descname"><span class="pre">reassociation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp.reassociation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.CollapseShapeOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.CollapseShapeOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.collapse_shape">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">collapse_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reassociation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.collapse_shape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.DeallocOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">DeallocOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.DeallocOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> operation frees the region of memory referenced by a memref
which was originally created by the <code class="docutils literal notranslate"><span class="pre">alloc</span></code> operation.
The <code class="docutils literal notranslate"><span class="pre">dealloc</span></code> operation should not be called on memrefs which alias an
alloc’d memref (e.g. memrefs returned by <code class="docutils literal notranslate"><span class="pre">view</span></code> operations).</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;</span>
<span class="nb">memref.dealloc</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err">  </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DeallocOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.dealloc'</span></em><a class="headerlink" href="#mlir.dialects.memref.DeallocOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DeallocOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.DeallocOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DeallocOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DeallocOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.dealloc">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">dealloc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.DeallocOp" title="mlir.dialects.memref.DeallocOp"><span class="pre">DeallocOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.dealloc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">DimOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.DimOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">dim</span></code> operation takes a memref and a dimension operand of type <code class="docutils literal notranslate"><span class="pre">index</span></code>.
It returns the size of the requested dimension of the given memref.
If the dimension index is out of bounds the behavior is undefined.</p>
<p>The specified memref type is that of the first operand.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Always returns 4, can be constant folded:</span>
<span class="nv">%c0</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
<span class="nv">%x</span> <span class="o">=</span> <span class="nb">memref.dim</span><span class="err"> </span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%c0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="n n-Integer">?</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Returns the dynamic dimension of %A.</span>
<span class="nv">%c1</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
<span class="nv">%y</span> <span class="o">=</span> <span class="nb">memref.dim</span><span class="err"> </span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%c1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="n n-Integer">?</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// Equivalent generic form:</span>
<span class="nv">%x</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="s2">&quot;memref.dim&quot;</span><span class="p">(</span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%c0</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="n n-Integer">?</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">index</span>
<span class="nv">%y</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="s2">&quot;memref.dim&quot;</span><span class="p">(</span><span class="nv">%A</span><span class="p">,</span><span class="err"> </span><span class="nv">%c1</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="n n-Integer">?</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">index</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">index</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.dim'</span></em><a class="headerlink" href="#mlir.dialects.memref.DimOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.DimOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DimOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp.index">
<span class="sig-name descname"><span class="pre">index</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.DimOp.index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DimOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.DimOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.dim">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">dim</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.dim" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaStartOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">DmaStartOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.DmaStartOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>operation ::= `memref.dma_start` ssa-use`[`ssa-use-list`]` `,`
               ssa-use`[`ssa-use-list`]` `,` ssa-use `,`
               ssa-use`[`ssa-use-list`]` (`,` ssa-use `,` ssa-use)?
              `:` memref-type `,` memref-type `,` memref-type
</pre></div>
</div>
<p>DmaStartOp starts a non-blocking DMA operation that transfers data from a
source memref to a destination memref. The source and destination memref
need not be of the same dimensionality, but need to have the same elemental
type. The operands include the source and destination memref’s each followed
by its indices, size of the data transfer in terms of the number of elements
(of the elemental type of the memref), a tag memref with its indices, and
optionally at the end, a stride and a number_of_elements_per_stride
arguments. The tag location is used by a DmaWaitOp to check for completion.
The indices of the source memref, destination memref, and the tag memref
have the same restrictions as any load/store. The optional stride arguments
should be of ‘index’ type, and specify a stride for the slower memory space
(memory space with a lower memory space id), transferring chunks of
number_of_elements_per_stride every stride until %num_elements are
transferred. Either both or no stride arguments should be specified. If the
source and destination locations overlap the behavior of this operation is
not defined.</p>
<p>For example, a DmaStartOp operation that transfers 256 elements of a memref
‘%src’ in memory space 0 at indices [%i, %j] to memref ‘%dst’ in memory
space 1 at indices [%k, %l], would be specified as follows:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%num_elements</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">256</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
<span class="nv">%idx</span> <span class="o">=</span> <span class="nb">arith.constant</span><span class="err"> </span><span class="mf">0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">index</span>
<span class="nv">%tag</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">2</span><span class="p">&gt;</span>
<span class="nb">memref.dma_start</span><span class="err"> </span><span class="nv">%src</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%dst</span><span class="p">[</span><span class="nv">%k</span><span class="p">,</span><span class="err"> </span><span class="nv">%l</span><span class="p">],</span><span class="err"> </span><span class="nv">%num_elements</span><span class="p">,</span><span class="err"> </span><span class="nv">%tag</span><span class="p">[</span><span class="nv">%idx</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">40</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="mi">128</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;,</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="mi">1024</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;,</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">2</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>If %stride and %num_elt_per_stride are specified, the DMA is expected to
transfer %num_elt_per_stride elements every %stride elements apart from
memory space 0 until %num_elements are transferred.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.dma_start</span><span class="err"> </span><span class="nv">%src</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%dst</span><span class="p">[</span><span class="nv">%k</span><span class="p">,</span><span class="err"> </span><span class="nv">%l</span><span class="p">],</span><span class="err"> </span><span class="nv">%num_elements</span><span class="p">,</span><span class="err"> </span><span class="nv">%tag</span><span class="p">[</span><span class="nv">%idx</span><span class="p">],</span><span class="err"> </span><span class="nv">%stride</span><span class="p">,</span>
<span class="err">                 </span><span class="nv">%num_elt_per_stride</span><span class="err"> </span><span class="p">:</span>
</pre></div>
</div>
<ul class="simple">
<li><p>TODO: add additional operands to allow source and destination striding, and</p></li>
</ul>
<p>multiple stride levels.
* TODO: Consider replacing src/dst memref indices with view memrefs.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaStartOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.dma_start'</span></em><a class="headerlink" href="#mlir.dialects.memref.DmaStartOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaStartOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.DmaStartOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaStartOp.operands_">
<span class="sig-name descname"><span class="pre">operands_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DmaStartOp.operands_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.dma_start">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">dma_start</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">operands_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp" title="mlir.dialects.memref.DmaStartOp"><span class="pre">DmaStartOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.dma_start" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">DmaWaitOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tagMemRef</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tagIndices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">numElements</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>DmaWaitOp blocks until the completion of a DMA operation associated with the
tag element ‘%tag[%index]’. %tag is a memref, and %index has to be an index
with the same restrictions as any load/store index. %num_elements is the
number of elements associated with the DMA operation.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.dma_start</span><span class="err"> </span><span class="nv">%src</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nv">%dst</span><span class="p">[</span><span class="nv">%k</span><span class="p">,</span><span class="err"> </span><span class="nv">%l</span><span class="p">],</span><span class="err"> </span><span class="nv">%num_elements</span><span class="p">,</span><span class="err"> </span><span class="nv">%tag</span><span class="p">[</span><span class="nv">%index</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2048</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;,</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">256</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">1</span><span class="p">&gt;,</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">2</span><span class="p">&gt;</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="nb">dma_wait</span><span class="err"> </span><span class="nv">%tag</span><span class="p">[</span><span class="nv">%index</span><span class="p">],</span><span class="err"> </span><span class="nv">%num_elements</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="err"> </span><span class="p">x</span><span class="err"> </span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d0</span><span class="p">)&gt;,</span><span class="err"> </span><span class="mi">2</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.dma_wait'</span></em><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp.tagMemRef">
<span class="sig-name descname"><span class="pre">tagMemRef</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp.tagMemRef" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp.tagIndices">
<span class="sig-name descname"><span class="pre">tagIndices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp.tagIndices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.DmaWaitOp.numElements">
<span class="sig-name descname"><span class="pre">numElements</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.DmaWaitOp.numElements" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.dma_wait">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">dma_wait</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tag_mem_ref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tag_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_elements</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp" title="mlir.dialects.memref.DmaWaitOp"><span class="pre">DmaWaitOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.dma_wait" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ExpandShapeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reassociation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_output_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.expand_shape</span></code> op produces a new view with a higher rank whose
sizes are a reassociation of the original <code class="docutils literal notranslate"><span class="pre">view</span></code>. The operation is limited
to such reassociations, where a dimension is expanded into one or multiple
contiguous dimensions. Such reassociations never require additional allocs
or copies.</p>
<p>A reassociation is defined as a grouping of dimensions and is represented
with an array of DenseI64ArrayAttr attributes.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%r</span> <span class="o">=</span> <span class="nb">memref.expand_shape</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">[[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">],</span><span class="err"> </span><span class="p">[</span><span class="mf">2</span><span class="p">]]</span><span class="err"> </span><span class="nx">output_shape</span><span class="err"> </span><span class="p">[</span><span class="nv">%sz0</span><span class="p">,</span><span class="err"> </span><span class="nv">%sz1</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">into</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="mi">32</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>If an op can be statically proven to be invalid (e.g, an expansion from
<code class="docutils literal notranslate"><span class="pre">memref&lt;10xf32&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">memref&lt;2x6xf32&gt;</span></code>), it is rejected by the verifier. If
it cannot statically be proven invalid (e.g., the full example above; it is
unclear whether the first source dimension is divisible by 5), the op is
accepted by the verifier. However, if the op is in fact invalid at runtime,
the behavior is undefined.</p>
<p>The source memref can be zero-ranked. In that case, the reassociation
indices must be empty and the result shape may only consist of unit
dimensions.</p>
<p>For simplicity, this op may not be used to cast dynamicity of dimension
sizes and/or strides. I.e., if and only if a source dimension is dynamic,
there must be a dynamic result dimension in the corresponding reassociation
group. Same for strides.</p>
<p>The representation for the output shape supports a partially-static
specification via attributes specified through the <code class="docutils literal notranslate"><span class="pre">static_output_shape</span></code>
argument.  A special sentinel value <code class="docutils literal notranslate"><span class="pre">ShapedType::kDynamic</span></code> encodes that the
corresponding entry has a dynamic value.  There must be exactly as many SSA
inputs in <code class="docutils literal notranslate"><span class="pre">output_shape</span></code> as there are <code class="docutils literal notranslate"><span class="pre">ShapedType::kDynamic</span></code> entries in
<code class="docutils literal notranslate"><span class="pre">static_output_shape</span></code>.</p>
<p>Note: This op currently assumes that the inner strides are of the
source/result layout map are the faster-varying ones.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.expand_shape'</span></em><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.src">
<span class="sig-name descname"><span class="pre">src</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.src" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.output_shape">
<span class="sig-name descname"><span class="pre">output_shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.output_shape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.reassociation">
<span class="sig-name descname"><span class="pre">reassociation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.reassociation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.static_output_shape">
<span class="sig-name descname"><span class="pre">static_output_shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.static_output_shape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExpandShapeOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExpandShapeOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.expand_shape">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">expand_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reassociation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_output_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.expand_shape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ExtractAlignedPointerAsIndexOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Extracts the underlying aligned pointer as an index.</p>
<p>This operation is useful for lowering to lower-level dialects while still
avoiding the need to define a pointer type in higher-level dialects such as
the memref dialect.</p>
<p>This operation is intended solely as step during lowering, it has no side
effects. A reverse operation that creates a memref from an index interpreted
as a pointer is explicitly discouraged.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>%0 = memref.extract_aligned_pointer_as_index %arg : memref&lt;4x4xf32&gt; -&gt; index
%1 = arith.index_cast %0 : index to i64
%2 = llvm.inttoptr %1 : i64 to !llvm.ptr
call @foo(%2) : (!llvm.ptr) -&gt;()
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.extract_aligned_pointer_as_index'</span></em><a class="headerlink" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.aligned_pointer">
<span class="sig-name descname"><span class="pre">aligned_pointer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.aligned_pointer" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.extract_aligned_pointer_as_index">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">extract_aligned_pointer_as_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.extract_aligned_pointer_as_index" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ExtractStridedMetadataOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Extracts a base buffer, offset and strides. This op allows additional layers
of transformations and foldings to be added as lowering progresses from
higher-level dialect to lower-level dialects such as the LLVM dialect.</p>
<p>The op requires a strided memref source operand. If the source operand is not
a strided memref, then verification fails.</p>
<p>This operation is also useful for completeness to the existing memref.dim op.
While accessing strides, offsets and the base pointer independently is not
available, this is useful for composing with its natural complement op:
<code class="docutils literal notranslate"><span class="pre">memref.reinterpret_cast</span></code>.</p>
<p>Intended Use Cases:</p>
<p>The main use case is to expose the logic for manipulate memref metadata at a
higher level than the LLVM dialect.
This makes lowering more progressive and brings the following benefits:</p>
<ul class="simple">
<li><p>not all users of MLIR want to lower to LLVM and the information to e.g.</p></li>
</ul>
<p>lower to library calls—like libxsmm—or to SPIR-V was not available.
* foldings and canonicalizations can happen at a higher level in MLIR:
before this op existed, lowering to LLVM would create large amounts of
LLVMIR. Even when LLVM does a good job at folding the low-level IR from
a performance perspective, it is unnecessarily opaque and inefficient to
send unkempt IR to LLVM.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%base</span><span class="p">,</span> <span class="nv">%offset</span><span class="p">,</span> <span class="nv">%sizes:2</span><span class="p">,</span> <span class="nv">%strides:2</span> <span class="o">=</span>
  <span class="nb">memref.extract_strided_metadata</span><span class="err"> </span><span class="nv">%memref</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">10</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="err">    </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span><span class="p">,</span><span class="err"> </span><span class="kt">index</span>

<span class="c1">// After folding, the type of %m2 can be memref&lt;10x?xf32&gt; and further</span>
<span class="c1">// folded to %memref.</span>
<span class="nv">%m2</span> <span class="o">=</span> <span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%base</span><span class="err"> </span><span class="nx">to</span>
<span class="err">    </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%offset</span><span class="p">],</span>
<span class="err">    </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%sizes#0</span><span class="p">,</span><span class="err"> </span><span class="nv">%sizes#1</span><span class="p">],</span>
<span class="err">    </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%strides#0</span><span class="p">,</span><span class="err"> </span><span class="nv">%strides#1</span><span class="p">]</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.extract_strided_metadata'</span></em><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.base_buffer">
<span class="sig-name descname"><span class="pre">base_buffer</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.base_buffer" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.offset">
<span class="sig-name descname"><span class="pre">offset</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.offset" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.sizes">
<span class="sig-name descname"><span class="pre">sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ExtractStridedMetadataOp.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ExtractStridedMetadataOp.strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.extract_strided_metadata">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">extract_strided_metadata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp" title="mlir.dialects.memref.ExtractStridedMetadataOp"><span class="pre">ExtractStridedMetadataOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.extract_strided_metadata" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.GetGlobalOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">GetGlobalOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.GetGlobalOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.get_global</span></code> operation retrieves the memref pointing to a
named global variable. If the global variable is marked constant, writing
to the result memref (such as through a <code class="docutils literal notranslate"><span class="pre">memref.store</span></code> operation) is
undefined.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%x</span> <span class="o">=</span> <span class="nb">memref.get_global</span><span class="err"> </span><span class="nf">@foo</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GetGlobalOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.get_global'</span></em><a class="headerlink" href="#mlir.dialects.memref.GetGlobalOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GetGlobalOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.GetGlobalOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GetGlobalOp.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GetGlobalOp.name" title="Link to this definition">¶</a></dt>
<dd><p>Returns the fully qualified name of the operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GetGlobalOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.GetGlobalOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.get_global">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">get_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.get_global" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">GlobalOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sym_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym_visibility</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.global</span></code> operation declares or defines a named global memref
variable. The backing memory for the variable is allocated statically and is
described by the type of the variable (which should be a statically shaped
memref type). The operation is a declaration if no <code class="docutils literal notranslate"><span class="pre">initial_value</span></code> is
specified, else it is a definition. The <code class="docutils literal notranslate"><span class="pre">initial_value</span></code> can either be a unit
attribute to represent a definition of an uninitialized global variable, or
an elements attribute to represent the definition of a global variable with
an initial value. The global variable can also be marked constant using the
<code class="docutils literal notranslate"><span class="pre">constant</span></code> unit attribute. Writing to such constant global variables is
undefined.</p>
<p>The global variable can be accessed by using the <code class="docutils literal notranslate"><span class="pre">memref.get_global</span></code> to
retrieve the memref for the global variable. Note that the memref
for such global variable itself is immutable (i.e., memref.get_global for a
given global variable will always return the same memref descriptor).</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Private variable with an initial value.</span>
<span class="nb">memref.global</span><span class="err"> </span><span class="s2">&quot;private&quot;</span><span class="err"> </span><span class="nf">@x</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">0.0</span><span class="p">,</span><span class="err"> </span><span class="mf">2.0</span><span class="p">]&gt;</span>

<span class="c1">// Private variable with an initial value and an alignment (power of 2).</span>
<span class="nb">memref.global</span><span class="err"> </span><span class="s2">&quot;private&quot;</span><span class="err"> </span><span class="nf">@x</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">0.0</span><span class="p">,</span><span class="err"> </span><span class="mf">2.0</span><span class="p">]&gt;</span><span class="err"> </span><span class="p">{</span><span class="nx">alignment</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">64</span><span class="p">}</span>

<span class="c1">// Declaration of an external variable.</span>
<span class="nb">memref.global</span><span class="err"> </span><span class="s2">&quot;private&quot;</span><span class="err"> </span><span class="nf">@y</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>

<span class="c1">// Uninitialized externally visible variable.</span>
<span class="nb">memref.global</span><span class="err"> </span><span class="nf">@z</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">3</span><span class="p">x</span><span class="kt">f16</span><span class="p">&gt;</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nx">uninitialized</span>

<span class="c1">// Externally visible constant variable.</span>
<span class="nb">memref.global</span><span class="err"> </span><span class="nx">constant</span><span class="err"> </span><span class="nf">@c</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nx">dense</span><span class="p">&lt;[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">]&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.global'</span></em><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.GlobalOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.sym_name">
<span class="sig-name descname"><span class="pre">sym_name</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.sym_name" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.sym_visibility">
<span class="sig-name descname"><span class="pre">sym_visibility</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.sym_visibility" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.type_">
<span class="sig-name descname"><span class="pre">type_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.type_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.initial_value">
<span class="sig-name descname"><span class="pre">initial_value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.initial_value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.constant">
<span class="sig-name descname"><span class="pre">constant</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.constant" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.GlobalOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.GlobalOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.global_">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">global_</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sym_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">type_</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym_visibility</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.GlobalOp" title="mlir.dialects.memref.GlobalOp"><span class="pre">GlobalOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.global_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.MemorySpaceCastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">MemorySpaceCastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.MemorySpaceCastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>This operation casts memref values between memory spaces.
The input and result will be memrefs of the same types and shape that alias
the same underlying memory, though, for some casts on some targets,
the underlying values of the pointer stored in the memref may be affected
by the cast.</p>
<p>The input and result must have the same shape, element type, rank, and layout.</p>
<p>If the source and target address spaces are the same, this operation is a noop.</p>
<p>Finally, if the target memory-space is the generic/default memory-space,
then it is assumed this cast can be bubbled down safely. See the docs of
<code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOpInterface</span></code> interface for more details.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Cast a GPU private memory attribution into a generic pointer</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">memref.memory_space_cast</span><span class="err"> </span><span class="nv">%1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="mi">5</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// Cast a generic pointer to workgroup-local memory</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">memref.memory_space_cast</span><span class="err"> </span><span class="nv">%3</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">5</span><span class="p">x</span><span class="mi">34</span><span class="p">x</span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="mi">3</span><span class="p">&gt;</span>
<span class="c1">// Cast between two non-default memory spaces</span>
<span class="nv">%6</span> <span class="o">=</span> <span class="nb">memref.memory_space_cast</span><span class="err"> </span><span class="nv">%5</span>
<span class="err">  </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="err">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="mi">5</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="err">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="mi">3</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.MemorySpaceCastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.memory_space_cast'</span></em><a class="headerlink" href="#mlir.dialects.memref.MemorySpaceCastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.MemorySpaceCastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.MemorySpaceCastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.MemorySpaceCastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.MemorySpaceCastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.MemorySpaceCastOp.dest">
<span class="sig-name descname"><span class="pre">dest</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.MemorySpaceCastOp.dest" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.memory_space_cast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">memory_space_cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.memory_space_cast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">PrefetchOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isWrite</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">localityHint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isDataCache</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The “prefetch” op prefetches data from a memref location described with
subscript indices similar to memref.load, and with three attributes: a
read/write specifier, a locality hint, and a cache type specifier as shown
below:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.prefetch</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%i</span><span class="p">,</span><span class="err"> </span><span class="nv">%j</span><span class="p">],</span><span class="err"> </span><span class="nx">read</span><span class="p">,</span><span class="err"> </span><span class="nx">locality</span><span class="p">&lt;</span><span class="mf">3</span><span class="p">&gt;,</span><span class="err"> </span><span class="nx">data</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">400</span><span class="p">x</span><span class="mi">400</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The read/write specifier is either ‘read’ or ‘write’, the locality hint
ranges from locality&lt;0&gt; (no locality) to locality&lt;3&gt; (extremely local keep
in cache). The cache type specifier is either ‘data’ or ‘instr’
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.prefetch'</span></em><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.isWrite">
<span class="sig-name descname"><span class="pre">isWrite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.isWrite" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.localityHint">
<span class="sig-name descname"><span class="pre">localityHint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.localityHint" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.PrefetchOp.isDataCache">
<span class="sig-name descname"><span class="pre">isDataCache</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.PrefetchOp.isDataCache" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.prefetch">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">prefetch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_write</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locality_hint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_data_cache</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp" title="mlir.dialects.memref.PrefetchOp"><span class="pre">PrefetchOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.prefetch" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.RankOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">RankOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.RankOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">memref.rank</span></code> operation takes a memref operand and returns its rank.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.rank</span><span class="err"> </span><span class="nv">%arg0</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.rank</span><span class="err"> </span><span class="nv">%arg1</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.RankOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.rank'</span></em><a class="headerlink" href="#mlir.dialects.memref.RankOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.RankOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.RankOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.RankOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.RankOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.rank">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">rank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">results</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.rank" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ReallocOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamicResultSize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ReallocOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">realloc</span></code> operation changes the size of a memory region. The memory
region is specified by a 1D source memref and the size of the new memory
region is specified by a 1D result memref type and an optional dynamic Value
of <code class="docutils literal notranslate"><span class="pre">Index</span></code> type. The source and the result memref must be in the same memory
space and have the same element type.</p>
<p>The operation may move the memory region to a new location. In this case,
the content of the memory block is preserved up to the lesser of the new
and old sizes. If the new size if larger, the value of the extended memory
is undefined. This is consistent with the ISO C realloc.</p>
<p>The operation returns an SSA value for the memref.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.realloc</span><span class="err"> </span><span class="nv">%src</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">124</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>The source memref may have a dynamic shape, in which case, the compiler will
generate code to extract its size from the runtime data structure for the
memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.realloc</span><span class="err"> </span><span class="nv">%src</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">124</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>If the result memref has a dynamic shape, a result dimension operand is
needed to spefify its dynamic dimension. In the example below, the ssa value
‘%d’ specifies the unknown dimension of the result memref.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%2</span> <span class="o">=</span> <span class="nb">memref.realloc</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%d</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute may be specified to ensure that the
region of memory that will be indexed is aligned at the specified byte
boundary.  This is consistent with the fact that memref.alloc supports such
an optional alignment attribute. Note that in ISO C standard, neither alloc
nor realloc supports alignment, though there is aligned_alloc but not
aligned_realloc.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%3</span> <span class="o">=</span> <span class="nb">memref.realloc</span><span class="err"> </span><span class="nv">%src</span><span class="err"> </span><span class="p">{</span><span class="nx">alignment</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="mf">8</span><span class="p">}</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">124</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>Referencing the memref through the old SSA value after realloc is undefined
behavior.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%new</span> <span class="o">=</span> <span class="nb">memref.realloc</span><span class="err"> </span><span class="nv">%old</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">124</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%4</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%new</span><span class="p">[</span><span class="nv">%index</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">124</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="c1">// ok</span>
<span class="nv">%5</span> <span class="o">=</span> <span class="nb">memref.load</span><span class="err"> </span><span class="nv">%old</span><span class="p">[</span><span class="nv">%index</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err">  </span><span class="c1">// undefined behavior</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.realloc'</span></em><a class="headerlink" href="#mlir.dialects.memref.ReallocOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ReallocOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReallocOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp.dynamicResultSize">
<span class="sig-name descname"><span class="pre">dynamicResultSize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReallocOp.dynamicResultSize" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReallocOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReallocOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.realloc">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">realloc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dynamic_result_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.realloc" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ReinterpretCastOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>Modify offset, sizes and strides of an unranked/ranked memref.</p>
<p>Example 1:</p>
<p>Consecutive <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> operations on memref’s with static
dimensions.</p>
<p>We distinguish between <em>underlying memory</em> — the sequence of elements as
they appear in the contiguous memory of the memref — and the
<em>strided memref</em>, which refers to the underlying memory interpreted
according to specified offsets, sizes, and strides.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result1</span> <span class="o">=</span> <span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%arg0</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">9</span><span class="p">],</span>
<span class="err">  </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">],</span>
<span class="err">  </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">16</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">,</span><span class="err"> </span><span class="mi">2</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">9</span><span class="p">&gt;&gt;</span>

<span class="nv">%result2</span> <span class="o">=</span> <span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%result1</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">0</span><span class="p">],</span>
<span class="err">  </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">],</span>
<span class="err">  </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">,</span><span class="err"> </span><span class="mi">2</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">9</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">,</span><span class="err"> </span><span class="mi">2</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>The underlying memory of <code class="docutils literal notranslate"><span class="pre">%arg0</span></code> consists of a linear sequence of integers
from 1 to 64. Its memref has the following 8x8 elements:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="err">  </span><span class="mf">2</span><span class="p">,</span><span class="err">  </span><span class="mf">3</span><span class="p">,</span><span class="err">  </span><span class="mf">4</span><span class="p">,</span><span class="err">  </span><span class="mf">5</span><span class="p">,</span><span class="err">  </span><span class="mf">6</span><span class="p">,</span><span class="err">  </span><span class="mf">7</span><span class="p">,</span><span class="err">  </span><span class="mf">8</span><span class="p">],</span>
<span class="p">[</span><span class="mf">9</span><span class="p">,</span><span class="err">  </span><span class="mf">10</span><span class="p">,</span><span class="err"> </span><span class="mf">11</span><span class="p">,</span><span class="err"> </span><span class="mf">12</span><span class="p">,</span><span class="err"> </span><span class="mf">13</span><span class="p">,</span><span class="err"> </span><span class="mf">14</span><span class="p">,</span><span class="err"> </span><span class="mf">15</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">],</span>
<span class="p">[</span><span class="mf">17</span><span class="p">,</span><span class="err"> </span><span class="mf">18</span><span class="p">,</span><span class="err"> </span><span class="mf">19</span><span class="p">,</span><span class="err"> </span><span class="mf">20</span><span class="p">,</span><span class="err"> </span><span class="mf">21</span><span class="p">,</span><span class="err"> </span><span class="mf">22</span><span class="p">,</span><span class="err"> </span><span class="mf">23</span><span class="p">,</span><span class="err"> </span><span class="mf">24</span><span class="p">],</span>
<span class="p">[</span><span class="mf">25</span><span class="p">,</span><span class="err"> </span><span class="mf">26</span><span class="p">,</span><span class="err"> </span><span class="mf">27</span><span class="p">,</span><span class="err"> </span><span class="mf">28</span><span class="p">,</span><span class="err"> </span><span class="mf">29</span><span class="p">,</span><span class="err"> </span><span class="mf">30</span><span class="p">,</span><span class="err"> </span><span class="mf">31</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">],</span>
<span class="p">[</span><span class="mf">33</span><span class="p">,</span><span class="err"> </span><span class="mf">34</span><span class="p">,</span><span class="err"> </span><span class="mf">35</span><span class="p">,</span><span class="err"> </span><span class="mf">36</span><span class="p">,</span><span class="err"> </span><span class="mf">37</span><span class="p">,</span><span class="err"> </span><span class="mf">38</span><span class="p">,</span><span class="err"> </span><span class="mf">39</span><span class="p">,</span><span class="err"> </span><span class="mf">40</span><span class="p">],</span>
<span class="p">[</span><span class="mf">41</span><span class="p">,</span><span class="err"> </span><span class="mf">42</span><span class="p">,</span><span class="err"> </span><span class="mf">43</span><span class="p">,</span><span class="err"> </span><span class="mf">44</span><span class="p">,</span><span class="err"> </span><span class="mf">45</span><span class="p">,</span><span class="err"> </span><span class="mf">46</span><span class="p">,</span><span class="err"> </span><span class="mf">47</span><span class="p">,</span><span class="err"> </span><span class="mf">48</span><span class="p">],</span>
<span class="p">[</span><span class="mf">49</span><span class="p">,</span><span class="err"> </span><span class="mf">50</span><span class="p">,</span><span class="err"> </span><span class="mf">51</span><span class="p">,</span><span class="err"> </span><span class="mf">52</span><span class="p">,</span><span class="err"> </span><span class="mf">53</span><span class="p">,</span><span class="err"> </span><span class="mf">54</span><span class="p">,</span><span class="err"> </span><span class="mf">55</span><span class="p">,</span><span class="err"> </span><span class="mf">56</span><span class="p">],</span>
<span class="p">[</span><span class="mf">57</span><span class="p">,</span><span class="err"> </span><span class="mf">58</span><span class="p">,</span><span class="err"> </span><span class="mf">59</span><span class="p">,</span><span class="err"> </span><span class="mf">60</span><span class="p">,</span><span class="err"> </span><span class="mf">61</span><span class="p">,</span><span class="err"> </span><span class="mf">62</span><span class="p">,</span><span class="err"> </span><span class="mf">63</span><span class="p">,</span><span class="err"> </span><span class="mf">64</span><span class="p">]]</span>
</pre></div>
</div>
<p>Following the first <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>, the strided memref elements
of <code class="docutils literal notranslate"><span class="pre">%result1</span></code> are:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">10</span><span class="p">,</span><span class="err"> </span><span class="mf">12</span><span class="p">,</span><span class="err"> </span><span class="mf">14</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">],</span>
<span class="p">[</span><span class="mf">26</span><span class="p">,</span><span class="err"> </span><span class="mf">28</span><span class="p">,</span><span class="err"> </span><span class="mf">30</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">],</span>
<span class="p">[</span><span class="mf">42</span><span class="p">,</span><span class="err"> </span><span class="mf">44</span><span class="p">,</span><span class="err"> </span><span class="mf">46</span><span class="p">,</span><span class="err"> </span><span class="mf">48</span><span class="p">],</span>
<span class="p">[</span><span class="mf">58</span><span class="p">,</span><span class="err"> </span><span class="mf">60</span><span class="p">,</span><span class="err"> </span><span class="mf">62</span><span class="p">,</span><span class="err"> </span><span class="mf">64</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note: The offset and strides are relative to the underlying memory of
<code class="docutils literal notranslate"><span class="pre">%arg0</span></code>.</p>
<p>The second <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> results in the following strided memref
for <code class="docutils literal notranslate"><span class="pre">%result2</span></code>:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">],</span>
<span class="p">[</span><span class="mf">5</span><span class="p">,</span><span class="err"> </span><span class="mf">7</span><span class="p">]]</span>
</pre></div>
</div>
<p>Notice that it does not matter if you use %result1 or %arg0 as a source
for the second <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> operation. Only the underlying memory
pointers will be reused.</p>
<p>The offset and stride are relative to the base underlying memory of the
memref, starting at 1, not at 10 as seen in the output of <code class="docutils literal notranslate"><span class="pre">%result1</span></code>.
This behavior contrasts with the <code class="docutils literal notranslate"><span class="pre">subview</span></code> operator, where values are
relative to the strided memref (refer to <code class="docutils literal notranslate"><span class="pre">subview</span></code> examples).
Consequently, the second <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> behaves as if <code class="docutils literal notranslate"><span class="pre">%arg0</span></code> were
passed directly as its argument.</p>
<p>Example 2:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%ranked</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">0</span><span class="p">],</span>
<span class="err">  </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%size0</span><span class="p">,</span><span class="err"> </span><span class="mf">10</span><span class="p">],</span>
<span class="err">  </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="nv">%stride1</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="mi">10</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">1</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;&gt;</span>

<span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%unranked</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%offset</span><span class="p">],</span>
<span class="err">  </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%size0</span><span class="p">,</span><span class="err"> </span><span class="nv">%size1</span><span class="p">],</span>
<span class="err">  </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%stride0</span><span class="p">,</span><span class="err"> </span><span class="nv">%stride1</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>This operation creates a new memref descriptor using the base of the
source and applying the input arguments to the other metadata.
In other words:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%dst</span> <span class="o">=</span> <span class="nb">memref.reinterpret_cast</span><span class="err"> </span><span class="nv">%src</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%offset</span><span class="p">],</span>
<span class="err">  </span><span class="nx">sizes</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%sizes</span><span class="p">],</span>
<span class="err">  </span><span class="nx">strides</span><span class="p">:</span><span class="err"> </span><span class="p">[</span><span class="nv">%strides</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>means that <code class="docutils literal notranslate"><span class="pre">%dst</span></code>’s descriptor will be:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%dst.base</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%src.base</span>
<span class="nv">%dst.aligned</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%src.aligned</span>
<span class="nv">%dst.offset</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%offset</span>
<span class="nv">%dst.sizes</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%sizes</span>
<span class="nv">%dst.strides</span><span class="err"> </span><span class="p">=</span><span class="err"> </span><span class="nv">%strides</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.reinterpret_cast'</span></em><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.sizes">
<span class="sig-name descname"><span class="pre">sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.static_offsets">
<span class="sig-name descname"><span class="pre">static_offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.static_offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.static_sizes">
<span class="sig-name descname"><span class="pre">static_sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.static_sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.static_strides">
<span class="sig-name descname"><span class="pre">static_strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.static_strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReinterpretCastOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReinterpretCastOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.reinterpret_cast">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">reinterpret_cast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.reinterpret_cast" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ReshapeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">reshape</span></code> operation converts a memref from one type to an
equivalent type with a provided shape. The data is never copied or
modified. The source and destination types are compatible if both have the
same element type, same number of elements, address space and identity
layout map. The following combinations are possible:</p>
<p>a. Source type is ranked or unranked. Shape argument has static size.
Result type is ranked.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reshape statically-shaped memref.</span>
<span class="nv">%dst</span> <span class="o">=</span> <span class="nb">memref.reshape</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%shape</span><span class="p">)</span>
<span class="err">         </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%dst0</span> <span class="o">=</span> <span class="nb">memref.reshape</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%shape0</span><span class="p">)</span>
<span class="err">         </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">1</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// Flatten unranked memref.</span>
<span class="nv">%dst</span> <span class="o">=</span> <span class="nb">memref.reshape</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%shape</span><span class="p">)</span>
<span class="err">         </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">1</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<p>b. Source type is ranked or unranked. Shape argument has dynamic size.
Result type is unranked.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Reshape dynamically-shaped 1D memref.</span>
<span class="nv">%dst</span> <span class="o">=</span> <span class="nb">memref.reshape</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%shape</span><span class="p">)</span>
<span class="err">         </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="c1">// Reshape unranked memref.</span>
<span class="nv">%dst</span> <span class="o">=</span> <span class="nb">memref.reshape</span><span class="err"> </span><span class="nv">%src</span><span class="p">(</span><span class="nv">%shape</span><span class="p">)</span>
<span class="err">         </span><span class="p">:</span><span class="err"> </span><span class="p">(</span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;,</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">i32</span><span class="p">&gt;)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="o">*</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.reshape'</span></em><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp.shape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ReshapeOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ReshapeOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.reshape">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.reshape" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">StoreOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.StoreOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">store</span></code> op stores an element into a memref at the specified indices.</p>
<p>The number of indices must match the rank of the memref. The indices must
be in-bounds: <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">idx</span> <span class="pre">&lt;</span> <span class="pre">dim_size</span></code>.</p>
<p>Lowerings of <code class="docutils literal notranslate"><span class="pre">memref.store</span></code> may emit attributes, e.g. <code class="docutils literal notranslate"><span class="pre">inbouds</span></code> + <code class="docutils literal notranslate"><span class="pre">nuw</span></code>
when converting to LLVM’s <code class="docutils literal notranslate"><span class="pre">llvm.getelementptr</span></code>, that would cause undefined
behavior if indices are out of bounds or if computing the offset in the
memref would cause signed overflow of the <code class="docutils literal notranslate"><span class="pre">index</span></code> type.</p>
<p>A set <code class="docutils literal notranslate"><span class="pre">nontemporal</span></code> attribute indicates that this store is not expected to
be reused in the cache. For details, refer to the
<a class="reference external" href="https://llvm.org/docs/LangRef.html#store-instruction">LLVM store instruction</a>.</p>
<p>An optional <code class="docutils literal notranslate"><span class="pre">alignment</span></code> attribute allows to specify the byte alignment of the
store operation. It must be a positive power of 2. The operation must access
memory at an address aligned to this boundary. Violations may lead to
architecture-specific faults or performance penalties.
A value of 0 indicates no specific alignment requirement.
Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nb">memref.store</span><span class="err"> </span><span class="nv">%val</span><span class="p">,</span><span class="err"> </span><span class="nv">%A</span><span class="p">[</span><span class="nv">%a</span><span class="p">,</span><span class="err"> </span><span class="nv">%b</span><span class="p">]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">i32</span><span class="p">,</span><span class="err"> </span><span class="no">#layout</span><span class="p">,</span><span class="err"> </span><span class="nx">memspace0</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.store'</span></em><a class="headerlink" href="#mlir.dialects.memref.StoreOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.StoreOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.StoreOp.value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.memref">
<span class="sig-name descname"><span class="pre">memref</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.StoreOp.memref" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.indices">
<span class="sig-name descname"><span class="pre">indices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.StoreOp.indices" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.nontemporal">
<span class="sig-name descname"><span class="pre">nontemporal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.StoreOp.nontemporal" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.StoreOp.alignment">
<span class="sig-name descname"><span class="pre">alignment</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span></span><a class="headerlink" href="#mlir.dialects.memref.StoreOp.alignment" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.store">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">store</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">memref</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nontemporal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alignment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#mlir.dialects.memref.StoreOp" title="mlir.dialects.memref.StoreOp"><span class="pre">StoreOp</span></a></span></span><a class="headerlink" href="#mlir.dialects.memref.store" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.TransposeOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">TransposeOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.TransposeOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">transpose</span></code> op produces a strided memref whose sizes and strides
are a permutation of the original <code class="docutils literal notranslate"><span class="pre">in</span></code> memref. This is purely a metadata
transformation.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.transpose</span><span class="err"> </span><span class="nv">%0</span><span class="err"> </span><span class="p">(</span><span class="nx">i</span><span class="p">,</span><span class="err"> </span><span class="nx">j</span><span class="p">)</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">j</span><span class="p">,</span><span class="err"> </span><span class="nx">i</span><span class="p">)</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="kr">affine_map</span><span class="p">&lt;(</span><span class="nx">d0</span><span class="p">,</span><span class="err"> </span><span class="nx">d1</span><span class="p">)[</span><span class="nx">s0</span><span class="p">]</span><span class="err"> </span><span class="o">-&gt;</span><span class="err"> </span><span class="p">(</span><span class="nx">d1</span><span class="err"> </span><span class="o">*</span><span class="err"> </span><span class="nx">s0</span><span class="err"> </span><span class="o">+</span><span class="err"> </span><span class="nx">d0</span><span class="p">)&gt;&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.TransposeOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.transpose'</span></em><a class="headerlink" href="#mlir.dialects.memref.TransposeOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.TransposeOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.TransposeOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.TransposeOp.in_">
<span class="sig-name descname"><span class="pre">in_</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.TransposeOp.in_" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.TransposeOp.permutation">
<span class="sig-name descname"><span class="pre">permutation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.TransposeOp.permutation" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.transpose">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">permutation</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.transpose" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ViewOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byte_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ViewOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The “view” operation extracts an N-D contiguous memref with empty layout map
with arbitrary element type from a 1-D contiguous memref with empty layout
map of i8 element  type. The ViewOp supports the following arguments:</p>
<ul class="simple">
<li><p>A single dynamic byte-shift operand must be specified which represents a</p></li>
</ul>
<p>a shift of the base 1-D memref pointer from which to create the resulting
contiguous memref view with identity layout.
* A dynamic size operand that must be specified for each dynamic dimension
in the resulting view memref type.</p>
<p>The “view” operation gives a structured indexing form to a flat 1-D buffer.
Unlike “subview” it can perform a type change. The type change behavior
requires the op to have special semantics because, e.g. a byte shift of 3
cannot be represented as an offset on f64.
For now, a “view” op:</p>
<ol class="arabic simple">
<li><p>Only takes a contiguous source memref with 0 offset and empty layout.</p></li>
</ol>
<p>#. Must specify a byte_shift operand (in the future, a special integer
attribute may be added to support the folded case).
#. Returns a contiguous memref with 0 offset and empty layout.</p>
<p>Example:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Allocate a flat 1D/i8 memref.</span>
<span class="nv">%0</span> <span class="o">=</span> <span class="nb">memref.alloc</span><span class="p">()</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2048</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span>

<span class="c1">// ViewOp with dynamic offset and static sizes.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.view</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%offset_1024</span><span class="p">][]</span><span class="err"> </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2048</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>

<span class="c1">// ViewOp with dynamic offset and two dynamic size.</span>
<span class="nv">%2</span> <span class="o">=</span> <span class="nb">memref.view</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%offset_1024</span><span class="p">][</span><span class="nv">%size0</span><span class="p">,</span><span class="err"> </span><span class="nv">%size1</span><span class="p">]</span><span class="err"> </span><span class="p">:</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2048</span><span class="p">x</span><span class="kt">i8</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.view'</span></em><a class="headerlink" href="#mlir.dialects.memref.ViewOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.ViewOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ViewOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp.byte_shift">
<span class="sig-name descname"><span class="pre">byte_shift</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.ViewOp.byte_shift" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ViewOp.sizes">
<span class="sig-name descname"><span class="pre">sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.ViewOp.sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.view">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">view</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">byte_shift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.view" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">SubViewOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp" title="Link to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-obj docutils literal notranslate"><span class="pre">_ods_ir</span></code></p>
<p>The <code class="docutils literal notranslate"><span class="pre">subview</span></code> operation converts a memref type to a memref type which
represents a reduced-size view of the original memref as specified by the
operation’s offsets, sizes and strides arguments.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">subview</span></code> operation supports the following arguments:</p>
<ul class="simple">
<li><p>source: the “base” memref on which to create a “view” memref.</p></li>
<li><p>offsets: memref-rank number of offsets into the “base” memref at which to</p></li>
</ul>
<p>create the “view” memref.
* sizes: memref-rank number of sizes which specify the sizes of the result
“view” memref type.
* strides: memref-rank number of strides that compose multiplicatively with
the base memref strides in each dimension.</p>
<p>The representation based on offsets, sizes and strides support a
partially-static specification via attributes specified through the
<code class="docutils literal notranslate"><span class="pre">static_offsets</span></code>, <code class="docutils literal notranslate"><span class="pre">static_sizes</span></code> and <code class="docutils literal notranslate"><span class="pre">static_strides</span></code> arguments. A special
sentinel value <code class="docutils literal notranslate"><span class="pre">ShapedType::kDynamic</span></code> encodes that the corresponding entry
has a dynamic value.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">subview</span></code> operation may additionally reduce the rank of the resulting
view by removing dimensions that are statically known to be of size 1.</p>
<p>In the absence of rank reductions, the resulting memref type is computed
as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">size_operands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">result_strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_strides</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">stride_operands</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="n">result_offset</span> <span class="o">=</span> <span class="n">src_offset</span> <span class="o">+</span> <span class="n">dot_product</span><span class="p">(</span><span class="n">offset_operands</span><span class="p">,</span> <span class="n">src_strides</span><span class="p">)</span>
</pre></div>
</div>
<p>The offset, size and stride operands must be in-bounds with respect to the
source memref. When possible, the static operation verifier will detect
out-of-bounds subviews. Subviews that cannot be confirmed to be in-bounds
or out-of-bounds based on compile-time information are valid. However,
performing an out-of-bounds subview at runtime is undefined behavior.</p>
<p>Example 1:</p>
<p>Consecutive <code class="docutils literal notranslate"><span class="pre">subview</span></code> operations on memref’s with static dimensions.</p>
<p>We distinguish between <em>underlying memory</em> — the sequence of elements as
they appear in the contiguous memory of the memref — and the
<em>strided memref</em>, which refers to the underlying memory interpreted
according to specified offsets, sizes, and strides.</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="nv">%result1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%arg0</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">][</span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">8</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">8</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">0</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">,</span><span class="err"> </span><span class="mi">2</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">9</span><span class="p">&gt;&gt;</span>

<span class="nv">%result2</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%result1</span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">][</span><span class="mf">2</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">16</span><span class="p">,</span><span class="err"> </span><span class="mi">2</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">9</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">  </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">2</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">32</span><span class="p">,</span><span class="err"> </span><span class="mi">4</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">27</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>The underlying memory of <code class="docutils literal notranslate"><span class="pre">%arg0</span></code> consists of a linear sequence of integers
from 1 to 64. Its memref has the following 8x8 elements:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">1</span><span class="p">,</span><span class="err">  </span><span class="mf">2</span><span class="p">,</span><span class="err">  </span><span class="mf">3</span><span class="p">,</span><span class="err">  </span><span class="mf">4</span><span class="p">,</span><span class="err">  </span><span class="mf">5</span><span class="p">,</span><span class="err">  </span><span class="mf">6</span><span class="p">,</span><span class="err">  </span><span class="mf">7</span><span class="p">,</span><span class="err">  </span><span class="mf">8</span><span class="p">],</span>
<span class="p">[</span><span class="mf">9</span><span class="p">,</span><span class="err">  </span><span class="mf">10</span><span class="p">,</span><span class="err"> </span><span class="mf">11</span><span class="p">,</span><span class="err"> </span><span class="mf">12</span><span class="p">,</span><span class="err"> </span><span class="mf">13</span><span class="p">,</span><span class="err"> </span><span class="mf">14</span><span class="p">,</span><span class="err"> </span><span class="mf">15</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">],</span>
<span class="p">[</span><span class="mf">17</span><span class="p">,</span><span class="err"> </span><span class="mf">18</span><span class="p">,</span><span class="err"> </span><span class="mf">19</span><span class="p">,</span><span class="err"> </span><span class="mf">20</span><span class="p">,</span><span class="err"> </span><span class="mf">21</span><span class="p">,</span><span class="err"> </span><span class="mf">22</span><span class="p">,</span><span class="err"> </span><span class="mf">23</span><span class="p">,</span><span class="err"> </span><span class="mf">24</span><span class="p">],</span>
<span class="p">[</span><span class="mf">25</span><span class="p">,</span><span class="err"> </span><span class="mf">26</span><span class="p">,</span><span class="err"> </span><span class="mf">27</span><span class="p">,</span><span class="err"> </span><span class="mf">28</span><span class="p">,</span><span class="err"> </span><span class="mf">29</span><span class="p">,</span><span class="err"> </span><span class="mf">30</span><span class="p">,</span><span class="err"> </span><span class="mf">31</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">],</span>
<span class="p">[</span><span class="mf">33</span><span class="p">,</span><span class="err"> </span><span class="mf">34</span><span class="p">,</span><span class="err"> </span><span class="mf">35</span><span class="p">,</span><span class="err"> </span><span class="mf">36</span><span class="p">,</span><span class="err"> </span><span class="mf">37</span><span class="p">,</span><span class="err"> </span><span class="mf">38</span><span class="p">,</span><span class="err"> </span><span class="mf">39</span><span class="p">,</span><span class="err"> </span><span class="mf">40</span><span class="p">],</span>
<span class="p">[</span><span class="mf">41</span><span class="p">,</span><span class="err"> </span><span class="mf">42</span><span class="p">,</span><span class="err"> </span><span class="mf">43</span><span class="p">,</span><span class="err"> </span><span class="mf">44</span><span class="p">,</span><span class="err"> </span><span class="mf">45</span><span class="p">,</span><span class="err"> </span><span class="mf">46</span><span class="p">,</span><span class="err"> </span><span class="mf">47</span><span class="p">,</span><span class="err"> </span><span class="mf">48</span><span class="p">],</span>
<span class="p">[</span><span class="mf">49</span><span class="p">,</span><span class="err"> </span><span class="mf">50</span><span class="p">,</span><span class="err"> </span><span class="mf">51</span><span class="p">,</span><span class="err"> </span><span class="mf">52</span><span class="p">,</span><span class="err"> </span><span class="mf">53</span><span class="p">,</span><span class="err"> </span><span class="mf">54</span><span class="p">,</span><span class="err"> </span><span class="mf">55</span><span class="p">,</span><span class="err"> </span><span class="mf">56</span><span class="p">],</span>
<span class="p">[</span><span class="mf">57</span><span class="p">,</span><span class="err"> </span><span class="mf">58</span><span class="p">,</span><span class="err"> </span><span class="mf">59</span><span class="p">,</span><span class="err"> </span><span class="mf">60</span><span class="p">,</span><span class="err"> </span><span class="mf">61</span><span class="p">,</span><span class="err"> </span><span class="mf">62</span><span class="p">,</span><span class="err"> </span><span class="mf">63</span><span class="p">,</span><span class="err"> </span><span class="mf">64</span><span class="p">]]</span>
</pre></div>
</div>
<p>Following the first <code class="docutils literal notranslate"><span class="pre">subview</span></code>, the strided memref elements of <code class="docutils literal notranslate"><span class="pre">%result1</span></code>
are:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">10</span><span class="p">,</span><span class="err"> </span><span class="mf">12</span><span class="p">,</span><span class="err"> </span><span class="mf">14</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">],</span>
<span class="p">[</span><span class="mf">26</span><span class="p">,</span><span class="err"> </span><span class="mf">28</span><span class="p">,</span><span class="err"> </span><span class="mf">30</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">],</span>
<span class="p">[</span><span class="mf">42</span><span class="p">,</span><span class="err"> </span><span class="mf">44</span><span class="p">,</span><span class="err"> </span><span class="mf">46</span><span class="p">,</span><span class="err"> </span><span class="mf">48</span><span class="p">],</span>
<span class="p">[</span><span class="mf">58</span><span class="p">,</span><span class="err"> </span><span class="mf">60</span><span class="p">,</span><span class="err"> </span><span class="mf">62</span><span class="p">,</span><span class="err"> </span><span class="mf">64</span><span class="p">]]</span>
</pre></div>
</div>
<p>Note: The offset and strides are relative to the strided memref of <code class="docutils literal notranslate"><span class="pre">%arg0</span></code>
(compare to the corresponding <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code> example).</p>
<p>The second <code class="docutils literal notranslate"><span class="pre">subview</span></code> results in the following strided memref for
<code class="docutils literal notranslate"><span class="pre">%result2</span></code>:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mf">28</span><span class="p">,</span><span class="err"> </span><span class="mf">32</span><span class="p">],</span>
<span class="p">[</span><span class="mf">60</span><span class="p">,</span><span class="err"> </span><span class="mf">64</span><span class="p">]]</span>
</pre></div>
</div>
<p>Unlike the <code class="docutils literal notranslate"><span class="pre">reinterpret_cast</span></code>, the values are relative to the strided
memref of the input (<code class="docutils literal notranslate"><span class="pre">%result1</span></code> in this case) and not its
underlying memory.</p>
<p>Example 2:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Subview of static memref with strided layout at static offsets, sizes</span>
<span class="c1">// and strides.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">][</span><span class="mf">8</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">][</span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">7</span><span class="p">,</span><span class="err"> </span><span class="mi">9</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">91</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">      </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">2</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">21</span><span class="p">,</span><span class="err"> </span><span class="mi">18</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">137</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>Example 3:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Subview of static memref with identity layout at dynamic offsets, sizes</span>
<span class="c1">// and strides.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%off0</span><span class="p">,</span><span class="err"> </span><span class="nv">%off1</span><span class="p">][</span><span class="nv">%sz0</span><span class="p">,</span><span class="err"> </span><span class="nv">%sz1</span><span class="p">][</span><span class="nv">%str0</span><span class="p">,</span><span class="err"> </span><span class="nv">%str1</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">64</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>Example 4:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Subview of dynamic memref with strided layout at dynamic offsets and</span>
<span class="c1">// strides, but static sizes.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="nv">%off0</span><span class="p">,</span><span class="err"> </span><span class="nv">%off1</span><span class="p">][</span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">][</span><span class="nv">%str0</span><span class="p">,</span><span class="err"> </span><span class="nv">%str1</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="n n-Integer">?</span><span class="p">x</span><span class="n n-Integer">?</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span><span class="err"> </span><span class="nx">to</span>
<span class="err">      </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">4</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="n n-Integer">?</span><span class="p">,</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="n n-Integer">?</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>Example 5:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Rank-reducing subviews.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">][</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">][</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
<span class="nv">%3</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%2</span><span class="p">[</span><span class="mf">3</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">,</span><span class="err"> </span><span class="mf">2</span><span class="p">][</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">6</span><span class="p">,</span><span class="err"> </span><span class="mf">3</span><span class="p">][</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">6</span><span class="p">x</span><span class="mi">3</span><span class="p">x</span><span class="kt">f32</span><span class="p">,</span><span class="err"> </span><span class="nx">strided</span><span class="p">&lt;[</span><span class="mi">4</span><span class="p">,</span><span class="err"> </span><span class="mi">1</span><span class="p">],</span><span class="err"> </span><span class="nx">offset</span><span class="p">:</span><span class="err"> </span><span class="mi">210</span><span class="p">&gt;&gt;</span>
</pre></div>
</div>
<p>Example 6:</p>
<div class="highlight-mlir notranslate"><div class="highlight"><pre><span></span><span class="c1">// Identity subview. The subview is the full source memref.</span>
<span class="nv">%1</span> <span class="o">=</span> <span class="nb">memref.subview</span><span class="err"> </span><span class="nv">%0</span><span class="p">[</span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">,</span><span class="err"> </span><span class="mf">0</span><span class="p">]</span><span class="err"> </span><span class="p">[</span><span class="mf">8</span><span class="p">,</span><span class="err"> </span><span class="mf">16</span><span class="p">,</span><span class="err"> </span><span class="mf">4</span><span class="p">]</span><span class="err"> </span><span class="p">[</span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">,</span><span class="err"> </span><span class="mf">1</span><span class="p">]</span>
<span class="err">    </span><span class="p">:</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span><span class="err"> </span><span class="nx">to</span><span class="err"> </span><span class="kt">memref</span><span class="p">&lt;</span><span class="mi">8</span><span class="p">x</span><span class="mi">16</span><span class="p">x</span><span class="mi">4</span><span class="p">x</span><span class="kt">f32</span><span class="p">&gt;</span>
</pre></div>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.OPERATION_NAME">
<span class="sig-name descname"><span class="pre">OPERATION_NAME</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">'memref.subview'</span></em><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.OPERATION_NAME" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp._ODS_OPERAND_SEGMENTS">
<span class="sig-name descname"><span class="pre">_ODS_OPERAND_SEGMENTS</span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp._ODS_OPERAND_SEGMENTS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp._ODS_REGIONS">
<span class="sig-name descname"><span class="pre">_ODS_REGIONS</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">(0,</span> <span class="pre">True)</span></em><a class="headerlink" href="#mlir.dialects.memref.SubViewOp._ODS_REGIONS" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.source">
<span class="sig-name descname"><span class="pre">source</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.source" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.offsets">
<span class="sig-name descname"><span class="pre">offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.sizes">
<span class="sig-name descname"><span class="pre">sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.strides">
<span class="sig-name descname"><span class="pre">strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.static_offsets">
<span class="sig-name descname"><span class="pre">static_offsets</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.static_offsets" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.static_sizes">
<span class="sig-name descname"><span class="pre">static_sizes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.static_sizes" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.static_strides">
<span class="sig-name descname"><span class="pre">static_strides</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.static_strides" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.SubViewOp.result">
<span class="sig-name descname"><span class="pre">result</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span><span class="p"><span class="pre">[</span></span><span class="pre">_ods_ir</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#mlir.dialects.memref.SubViewOp.result" title="Link to this definition">¶</a></dt>
<dd><p>Shortcut to get an op result if it has only one (throws an error otherwise).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref.subview">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">subview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_strides</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">_ods_ir</span></span></span><a class="headerlink" href="#mlir.dialects.memref.subview" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlir.dialects.memref.MixedValues">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">MixedValues</span></span><a class="headerlink" href="#mlir.dialects.memref.MixedValues" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="mlir.dialects.memref.ConstantOp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ConstantOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Attribute" title="mlir._mlir_libs._mlir.ir.Attribute"><span class="pre">Attribute</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ConstantOp" title="Link to this definition">¶</a></dt>
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">ConstantOp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="../../_mlir_libs/_mlir/ir/index.html#mlir._mlir_libs._mlir.ir.Type" title="mlir._mlir_libs._mlir.ir.Type"><span class="pre">Type</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">array.array</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Bases: <a class="reference internal" href="#mlir.dialects.memref.ConstantOp" title="mlir.dialects.memref.ConstantOp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ConstantOp</span></code></a></p>
<p>Specialization for the constant op class.</p>
<dl class="py method">
<dt class="sig sig-object py" id="mlir.dialects.memref.ConstantOp.create_index">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref.ConstantOp.create_index" title="Link to this definition">¶</a></dt>
<dd><p>Create an index-typed constant.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.memref.ConstantOp.type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">type</span></span><a class="headerlink" href="#mlir.dialects.memref.ConstantOp.type" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.memref.ConstantOp.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#mlir.dialects.memref.ConstantOp.value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="mlir.dialects.memref.ConstantOp.literal_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">literal_value</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float</span></em><a class="headerlink" href="#mlir.dialects.memref.ConstantOp.literal_value" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref._is_constant_int_like">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">_is_constant_int_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref._is_constant_int_like" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref._is_static_int_like">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">_is_static_int_like</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref._is_static_int_like" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="mlir.dialects.memref._infer_memref_subview_result_type">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">_infer_memref_subview_result_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_memref_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_sizes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">static_strides</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#mlir.dialects.memref._infer_memref_subview_result_type" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="mlir.dialects.memref._generated_subview">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">_generated_subview</span></span><a class="headerlink" href="#mlir.dialects.memref._generated_subview" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="id0">
<span class="sig-prename descclassname"><span class="pre">mlir.dialects.memref.</span></span><span class="sig-name descname"><span class="pre">subview</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.ir.Value</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offsets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.MixedValues</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.MixedValues</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strides</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.dialects._ods_common.MixedValues</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">result_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">mlir.ir.MemRefType</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#id0" title="Link to this definition">¶</a></dt>
<dd></dd></dl>

</section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../ml_program/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">mlir.dialects.ml_program</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="../math/index.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">mlir.dialects.math</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2025, MLIR authors
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">mlir.dialects.memref</a><ul>
<li><a class="reference internal" href="#attributes">Attributes</a></li>
<li><a class="reference internal" href="#classes">Classes</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#module-contents">Module Contents</a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp.memref"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp.alignment"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AssumeAlignmentOp.result"><code class="docutils literal notranslate"><span class="pre">AssumeAlignmentOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.assume_alignment"><code class="docutils literal notranslate"><span class="pre">assume_alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.value"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.memref"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.indices"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.kind"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.kind()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicRMWOp.result"><code class="docutils literal notranslate"><span class="pre">AtomicRMWOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.atomic_rmw"><code class="docutils literal notranslate"><span class="pre">atomic_rmw()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp"><code class="docutils literal notranslate"><span class="pre">AtomicYieldOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AtomicYieldOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AtomicYieldOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AtomicYieldOp.result"><code class="docutils literal notranslate"><span class="pre">AtomicYieldOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.atomic_yield"><code class="docutils literal notranslate"><span class="pre">atomic_yield()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CopyOp"><code class="docutils literal notranslate"><span class="pre">CopyOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.CopyOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">CopyOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CopyOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">CopyOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CopyOp.source"><code class="docutils literal notranslate"><span class="pre">CopyOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CopyOp.target"><code class="docutils literal notranslate"><span class="pre">CopyOp.target()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.copy"><code class="docutils literal notranslate"><span class="pre">copy()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp"><code class="docutils literal notranslate"><span class="pre">DistinctObjectsOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DistinctObjectsOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DistinctObjectsOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp.operands_"><code class="docutils literal notranslate"><span class="pre">DistinctObjectsOp.operands_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DistinctObjectsOp.results_"><code class="docutils literal notranslate"><span class="pre">DistinctObjectsOp.results_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.distinct_objects"><code class="docutils literal notranslate"><span class="pre">distinct_objects()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp.memref"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp.indices"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp.result"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp.result()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GenericAtomicRMWOp.atomic_body"><code class="docutils literal notranslate"><span class="pre">GenericAtomicRMWOp.atomic_body()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.generic_atomic_rmw"><code class="docutils literal notranslate"><span class="pre">generic_atomic_rmw()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp"><code class="docutils literal notranslate"><span class="pre">LoadOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">LoadOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">LoadOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.memref"><code class="docutils literal notranslate"><span class="pre">LoadOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.indices"><code class="docutils literal notranslate"><span class="pre">LoadOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.nontemporal"><code class="docutils literal notranslate"><span class="pre">LoadOp.nontemporal()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.alignment"><code class="docutils literal notranslate"><span class="pre">LoadOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.LoadOp.result"><code class="docutils literal notranslate"><span class="pre">LoadOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp"><code class="docutils literal notranslate"><span class="pre">AllocOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AllocOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">AllocOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AllocOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp.dynamicSizes"><code class="docutils literal notranslate"><span class="pre">AllocOp.dynamicSizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp.symbolOperands"><code class="docutils literal notranslate"><span class="pre">AllocOp.symbolOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp.alignment"><code class="docutils literal notranslate"><span class="pre">AllocOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocOp.memref"><code class="docutils literal notranslate"><span class="pre">AllocOp.memref()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.alloc"><code class="docutils literal notranslate"><span class="pre">alloc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp"><code class="docutils literal notranslate"><span class="pre">AllocaOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AllocaOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">AllocaOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AllocaOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp.dynamicSizes"><code class="docutils literal notranslate"><span class="pre">AllocaOp.dynamicSizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp.symbolOperands"><code class="docutils literal notranslate"><span class="pre">AllocaOp.symbolOperands()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp.alignment"><code class="docutils literal notranslate"><span class="pre">AllocaOp.alignment()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaOp.memref"><code class="docutils literal notranslate"><span class="pre">AllocaOp.memref()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.alloca"><code class="docutils literal notranslate"><span class="pre">alloca()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp"><code class="docutils literal notranslate"><span class="pre">AllocaScopeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AllocaScopeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AllocaScopeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp.results_"><code class="docutils literal notranslate"><span class="pre">AllocaScopeOp.results_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeOp.bodyRegion"><code class="docutils literal notranslate"><span class="pre">AllocaScopeOp.bodyRegion()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.alloca_scope"><code class="docutils literal notranslate"><span class="pre">alloca_scope()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp"><code class="docutils literal notranslate"><span class="pre">AllocaScopeReturnOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">AllocaScopeReturnOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">AllocaScopeReturnOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.AllocaScopeReturnOp.results_"><code class="docutils literal notranslate"><span class="pre">AllocaScopeReturnOp.results_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.alloca_scope_return"><code class="docutils literal notranslate"><span class="pre">alloca_scope_return()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CastOp"><code class="docutils literal notranslate"><span class="pre">CastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.CastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">CastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">CastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CastOp.source"><code class="docutils literal notranslate"><span class="pre">CastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CastOp.dest"><code class="docutils literal notranslate"><span class="pre">CastOp.dest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.cast"><code class="docutils literal notranslate"><span class="pre">cast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp.src"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp.src()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp.reassociation"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp.reassociation()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.CollapseShapeOp.result"><code class="docutils literal notranslate"><span class="pre">CollapseShapeOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.collapse_shape"><code class="docutils literal notranslate"><span class="pre">collapse_shape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DeallocOp"><code class="docutils literal notranslate"><span class="pre">DeallocOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.DeallocOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DeallocOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DeallocOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DeallocOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DeallocOp.memref"><code class="docutils literal notranslate"><span class="pre">DeallocOp.memref()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.dealloc"><code class="docutils literal notranslate"><span class="pre">dealloc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp"><code class="docutils literal notranslate"><span class="pre">DimOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DimOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DimOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp.source"><code class="docutils literal notranslate"><span class="pre">DimOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp.index"><code class="docutils literal notranslate"><span class="pre">DimOp.index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DimOp.result"><code class="docutils literal notranslate"><span class="pre">DimOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.dim"><code class="docutils literal notranslate"><span class="pre">dim()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp"><code class="docutils literal notranslate"><span class="pre">DmaStartOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DmaStartOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DmaStartOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaStartOp.operands_"><code class="docutils literal notranslate"><span class="pre">DmaStartOp.operands_()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.dma_start"><code class="docutils literal notranslate"><span class="pre">dma_start()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp.tagMemRef"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp.tagMemRef()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp.tagIndices"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp.tagIndices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.DmaWaitOp.numElements"><code class="docutils literal notranslate"><span class="pre">DmaWaitOp.numElements()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.dma_wait"><code class="docutils literal notranslate"><span class="pre">dma_wait()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.src"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.src()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.output_shape"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.output_shape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.reassociation"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.reassociation()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.static_output_shape"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.static_output_shape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExpandShapeOp.result"><code class="docutils literal notranslate"><span class="pre">ExpandShapeOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.expand_shape"><code class="docutils literal notranslate"><span class="pre">expand_shape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp"><code class="docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.source"><code class="docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractAlignedPointerAsIndexOp.aligned_pointer"><code class="docutils literal notranslate"><span class="pre">ExtractAlignedPointerAsIndexOp.aligned_pointer()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.extract_aligned_pointer_as_index"><code class="docutils literal notranslate"><span class="pre">extract_aligned_pointer_as_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.source"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.base_buffer"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.base_buffer()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.offset"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.offset()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.sizes"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ExtractStridedMetadataOp.strides"><code class="docutils literal notranslate"><span class="pre">ExtractStridedMetadataOp.strides()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.extract_strided_metadata"><code class="docutils literal notranslate"><span class="pre">extract_strided_metadata()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp"><code class="docutils literal notranslate"><span class="pre">GetGlobalOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">GetGlobalOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">GetGlobalOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp.name"><code class="docutils literal notranslate"><span class="pre">GetGlobalOp.name()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GetGlobalOp.result"><code class="docutils literal notranslate"><span class="pre">GetGlobalOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.get_global"><code class="docutils literal notranslate"><span class="pre">get_global()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp"><code class="docutils literal notranslate"><span class="pre">GlobalOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">GlobalOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">GlobalOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.sym_name"><code class="docutils literal notranslate"><span class="pre">GlobalOp.sym_name()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.sym_visibility"><code class="docutils literal notranslate"><span class="pre">GlobalOp.sym_visibility()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.type_"><code class="docutils literal notranslate"><span class="pre">GlobalOp.type_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.initial_value"><code class="docutils literal notranslate"><span class="pre">GlobalOp.initial_value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.constant"><code class="docutils literal notranslate"><span class="pre">GlobalOp.constant()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.GlobalOp.alignment"><code class="docutils literal notranslate"><span class="pre">GlobalOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.global_"><code class="docutils literal notranslate"><span class="pre">global_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp"><code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp.source"><code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.MemorySpaceCastOp.dest"><code class="docutils literal notranslate"><span class="pre">MemorySpaceCastOp.dest()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.memory_space_cast"><code class="docutils literal notranslate"><span class="pre">memory_space_cast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp"><code class="docutils literal notranslate"><span class="pre">PrefetchOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">PrefetchOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.memref"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.indices"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.isWrite"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.isWrite()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.localityHint"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.localityHint()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.PrefetchOp.isDataCache"><code class="docutils literal notranslate"><span class="pre">PrefetchOp.isDataCache()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.prefetch"><code class="docutils literal notranslate"><span class="pre">prefetch()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.RankOp"><code class="docutils literal notranslate"><span class="pre">RankOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.RankOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">RankOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.RankOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">RankOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.RankOp.memref"><code class="docutils literal notranslate"><span class="pre">RankOp.memref()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.rank"><code class="docutils literal notranslate"><span class="pre">rank()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp"><code class="docutils literal notranslate"><span class="pre">ReallocOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ReallocOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ReallocOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp.source"><code class="docutils literal notranslate"><span class="pre">ReallocOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp.dynamicResultSize"><code class="docutils literal notranslate"><span class="pre">ReallocOp.dynamicResultSize()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReallocOp.alignment"><code class="docutils literal notranslate"><span class="pre">ReallocOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.realloc"><code class="docutils literal notranslate"><span class="pre">realloc()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.source"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.offsets"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.sizes"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.strides"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.strides()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.static_offsets"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.static_offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.static_sizes"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.static_sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.static_strides"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.static_strides()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReinterpretCastOp.result"><code class="docutils literal notranslate"><span class="pre">ReinterpretCastOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.reinterpret_cast"><code class="docutils literal notranslate"><span class="pre">reinterpret_cast()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp"><code class="docutils literal notranslate"><span class="pre">ReshapeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ReshapeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ReshapeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp.source"><code class="docutils literal notranslate"><span class="pre">ReshapeOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp.shape"><code class="docutils literal notranslate"><span class="pre">ReshapeOp.shape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ReshapeOp.result"><code class="docutils literal notranslate"><span class="pre">ReshapeOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.reshape"><code class="docutils literal notranslate"><span class="pre">reshape()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp"><code class="docutils literal notranslate"><span class="pre">StoreOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">StoreOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">StoreOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.value"><code class="docutils literal notranslate"><span class="pre">StoreOp.value()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.memref"><code class="docutils literal notranslate"><span class="pre">StoreOp.memref()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.indices"><code class="docutils literal notranslate"><span class="pre">StoreOp.indices()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.nontemporal"><code class="docutils literal notranslate"><span class="pre">StoreOp.nontemporal()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.StoreOp.alignment"><code class="docutils literal notranslate"><span class="pre">StoreOp.alignment()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.store"><code class="docutils literal notranslate"><span class="pre">store()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.TransposeOp"><code class="docutils literal notranslate"><span class="pre">TransposeOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.TransposeOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">TransposeOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.TransposeOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">TransposeOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.TransposeOp.in_"><code class="docutils literal notranslate"><span class="pre">TransposeOp.in_()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.TransposeOp.permutation"><code class="docutils literal notranslate"><span class="pre">TransposeOp.permutation()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.transpose"><code class="docutils literal notranslate"><span class="pre">transpose()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp"><code class="docutils literal notranslate"><span class="pre">ViewOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">ViewOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">ViewOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp.source"><code class="docutils literal notranslate"><span class="pre">ViewOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp.byte_shift"><code class="docutils literal notranslate"><span class="pre">ViewOp.byte_shift()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ViewOp.sizes"><code class="docutils literal notranslate"><span class="pre">ViewOp.sizes()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.view"><code class="docutils literal notranslate"><span class="pre">view()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp"><code class="docutils literal notranslate"><span class="pre">SubViewOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.OPERATION_NAME"><code class="docutils literal notranslate"><span class="pre">SubViewOp.OPERATION_NAME</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp._ODS_OPERAND_SEGMENTS"><code class="docutils literal notranslate"><span class="pre">SubViewOp._ODS_OPERAND_SEGMENTS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp._ODS_REGIONS"><code class="docutils literal notranslate"><span class="pre">SubViewOp._ODS_REGIONS</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.source"><code class="docutils literal notranslate"><span class="pre">SubViewOp.source()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.offsets"><code class="docutils literal notranslate"><span class="pre">SubViewOp.offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.sizes"><code class="docutils literal notranslate"><span class="pre">SubViewOp.sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.strides"><code class="docutils literal notranslate"><span class="pre">SubViewOp.strides()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.static_offsets"><code class="docutils literal notranslate"><span class="pre">SubViewOp.static_offsets()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.static_sizes"><code class="docutils literal notranslate"><span class="pre">SubViewOp.static_sizes()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.static_strides"><code class="docutils literal notranslate"><span class="pre">SubViewOp.static_strides()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.SubViewOp.result"><code class="docutils literal notranslate"><span class="pre">SubViewOp.result()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref.subview"><code class="docutils literal notranslate"><span class="pre">subview()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.MixedValues"><code class="docutils literal notranslate"><span class="pre">MixedValues</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ConstantOp"><code class="docutils literal notranslate"><span class="pre">ConstantOp</span></code></a><ul>
<li><a class="reference internal" href="#mlir.dialects.memref.ConstantOp.create_index"><code class="docutils literal notranslate"><span class="pre">ConstantOp.create_index()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ConstantOp.type"><code class="docutils literal notranslate"><span class="pre">ConstantOp.type</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ConstantOp.value"><code class="docutils literal notranslate"><span class="pre">ConstantOp.value</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref.ConstantOp.literal_value"><code class="docutils literal notranslate"><span class="pre">ConstantOp.literal_value</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#mlir.dialects.memref._is_constant_int_like"><code class="docutils literal notranslate"><span class="pre">_is_constant_int_like()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref._is_static_int_like"><code class="docutils literal notranslate"><span class="pre">_is_static_int_like()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref._infer_memref_subview_result_type"><code class="docutils literal notranslate"><span class="pre">_infer_memref_subview_result_type()</span></code></a></li>
<li><a class="reference internal" href="#mlir.dialects.memref._generated_subview"><code class="docutils literal notranslate"><span class="pre">_generated_subview</span></code></a></li>
<li><a class="reference internal" href="#id0"><code class="docutils literal notranslate"><span class="pre">subview()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../../../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/scripts/furo.js?v=46bd48cc"></script>
    </body>
</html>