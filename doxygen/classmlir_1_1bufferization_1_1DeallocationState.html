<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::bufferization::DeallocationState Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1bufferization.html">bufferization</a></li><li class="navelem"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html">DeallocationState</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classmlir_1_1bufferization_1_1DeallocationState-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::bufferization::DeallocationState Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class collects all the state that we need to perform the buffer deallocation pass with associated helper functions such that we have easy access to it in the BufferDeallocationOpInterface implementations and the BufferDeallocation pass.  
 <a href="classmlir_1_1bufferization_1_1DeallocationState.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="BufferDeallocationOpInterface_8h_source.html">mlir/Dialect/Bufferization/IR/BufferDeallocationOpInterface.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a203f484d39294b30de4d5974885d64eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a203f484d39294b30de4d5974885d64eb">DeallocationState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;symbolTables)</td></tr>
<tr class="separator:a203f484d39294b30de4d5974885d64eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63212e990628d6d95b5eed34a32bbcbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a63212e990628d6d95b5eed34a32bbcbc">DeallocationState</a> (const <a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html">DeallocationState</a> &amp;)=delete</td></tr>
<tr class="separator:a63212e990628d6d95b5eed34a32bbcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45793cb3a7ee42027425f298936e21e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a45793cb3a7ee42027425f298936e21e8">updateOwnership</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a> ownership, <a class="el" href="classmlir_1_1Block.html">Block</a> *block=nullptr)</td></tr>
<tr class="memdesc:a45793cb3a7ee42027425f298936e21e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Small helper function to update the ownership map by taking the current ownership ('Uninitialized' state if not yet present), computing the join with the passed ownership and storing this new value in the map.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#a45793cb3a7ee42027425f298936e21e8">More...</a><br /></td></tr>
<tr class="separator:a45793cb3a7ee42027425f298936e21e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a602b090db59b6836af9b59a63ea933"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a3a602b090db59b6836af9b59a63ea933">resetOwnerships</a> (<a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> memrefs, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a3a602b090db59b6836af9b59a63ea933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes ownerships associated with all values in the passed range for 'block'.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#a3a602b090db59b6836af9b59a63ea933">More...</a><br /></td></tr>
<tr class="separator:a3a602b090db59b6836af9b59a63ea933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156eb68a5cf568db1a19c5bfe0d36ac1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a156eb68a5cf568db1a19c5bfe0d36ac1">getOwnership</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block) const</td></tr>
<tr class="memdesc:a156eb68a5cf568db1a19c5bfe0d36ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ownership of 'memref' for the given basic block.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#a156eb68a5cf568db1a19c5bfe0d36ac1">More...</a><br /></td></tr>
<tr class="separator:a156eb68a5cf568db1a19c5bfe0d36ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d387aa4f593a70c623386f40709887"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#a03d387aa4f593a70c623386f40709887">addMemrefToDeallocate</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:a03d387aa4f593a70c623386f40709887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remember the given 'memref' to deallocate it at the end of the 'block'.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#a03d387aa4f593a70c623386f40709887">More...</a><br /></td></tr>
<tr class="separator:a03d387aa4f593a70c623386f40709887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22221510e48c4283fd6d724e9d1ac88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#ae22221510e48c4283fd6d724e9d1ac88">dropMemrefToDeallocate</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:ae22221510e48c4283fd6d724e9d1ac88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forget about a MemRef that we originally wanted to deallocate at the end of 'block', possibly because it already gets deallocated before the end of the block.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#ae22221510e48c4283fd6d724e9d1ac88">More...</a><br /></td></tr>
<tr class="separator:ae22221510e48c4283fd6d724e9d1ac88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbd4dd1ff4a2f33f6887bdadade61d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#acbbd4dd1ff4a2f33f6887bdadade61d3">getLiveMemrefsIn</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefs)</td></tr>
<tr class="memdesc:acbbd4dd1ff4a2f33f6887bdadade61d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted list of MemRef values which are live at the start of the given block.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#acbbd4dd1ff4a2f33f6887bdadade61d3">More...</a><br /></td></tr>
<tr class="separator:acbbd4dd1ff4a2f33f6887bdadade61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f36fb929ae48ab30aa63722d3b0690"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#ab5f36fb929ae48ab30aa63722d3b0690">getMemrefWithUniqueOwnership</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Value.html">Value</a> memref, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memdesc:ab5f36fb929ae48ab30aa63722d3b0690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an SSA value of MemRef type, this function queries the ownership and if it is not already in the 'Unique' state, potentially inserts IR to get a new SSA value, returned as the first element of the pair, which has 'Unique' ownership and can be used instead of the passed <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> with the the ownership indicator returned as the second element of the pair.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#ab5f36fb929ae48ab30aa63722d3b0690">More...</a><br /></td></tr>
<tr class="separator:ab5f36fb929ae48ab30aa63722d3b0690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc3a7abb40a8c1eaa1e7fdfdd8d35f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#aecc3a7abb40a8c1eaa1e7fdfdd8d35f8">getMemrefsToRetain</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *fromBlock, <a class="el" href="classmlir_1_1Block.html">Block</a> *toBlock, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> destOperands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;toRetain) const</td></tr>
<tr class="memdesc:aecc3a7abb40a8c1eaa1e7fdfdd8d35f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two basic blocks and the values passed via block arguments to the destination block, compute the list of MemRefs that have to be retained in the 'fromBlock' to not run into a use-after-free situation.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#aecc3a7abb40a8c1eaa1e7fdfdd8d35f8">More...</a><br /></td></tr>
<tr class="separator:aecc3a7abb40a8c1eaa1e7fdfdd8d35f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca92c3822f0d1e8a6ff77e84b55863f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#aca92c3822f0d1e8a6ff77e84b55863f8">getMemrefsAndConditionsToDeallocate</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Block.html">Block</a> *block, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefs, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;conditions) const</td></tr>
<tr class="memdesc:aca92c3822f0d1e8a6ff77e84b55863f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given block, computes the list of MemRefs that potentially need to be deallocated at the end of that block.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#aca92c3822f0d1e8a6ff77e84b55863f8">More...</a><br /></td></tr>
<tr class="separator:aca92c3822f0d1e8a6ff77e84b55863f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb96f0caf02a8a10d10f3ab80d3b4ca2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html#acb96f0caf02a8a10d10f3ab80d3b4ca2">getSymbolTable</a> ()</td></tr>
<tr class="memdesc:acb96f0caf02a8a10d10f3ab80d3b4ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the symbol cache to lookup functions from call operations to check attributes on the function operation.  <a href="classmlir_1_1bufferization_1_1DeallocationState.html#acb96f0caf02a8a10d10f3ab80d3b4ca2">More...</a><br /></td></tr>
<tr class="separator:acb96f0caf02a8a10d10f3ab80d3b4ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class collects all the state that we need to perform the buffer deallocation pass with associated helper functions such that we have easy access to it in the BufferDeallocationOpInterface implementations and the BufferDeallocation pass. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8h_source.html#l00105">105</a> of file <a class="el" href="BufferDeallocationOpInterface_8h_source.html">BufferDeallocationOpInterface.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a203f484d39294b30de4d5974885d64eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203f484d39294b30de4d5974885d64eb">&#9670;&nbsp;</a></span>DeallocationState() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DeallocationState::DeallocationState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a> &amp;&#160;</td>
          <td class="paramname"><em>symbolTables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00096">96</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

</div>
</div>
<a id="a63212e990628d6d95b5eed34a32bbcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63212e990628d6d95b5eed34a32bbcbc">&#9670;&nbsp;</a></span>DeallocationState() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::bufferization::DeallocationState::DeallocationState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1bufferization_1_1DeallocationState.html">DeallocationState</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a03d387aa4f593a70c623386f40709887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d387aa4f593a70c623386f40709887">&#9670;&nbsp;</a></span>addMemrefToDeallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::addMemrefToDeallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remember the given 'memref' to deallocate it at the end of the 'block'. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00119">119</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

</div>
</div>
<a id="ae22221510e48c4283fd6d724e9d1ac88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22221510e48c4283fd6d724e9d1ac88">&#9670;&nbsp;</a></span>dropMemrefToDeallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::dropMemrefToDeallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Forget about a MemRef that we originally wanted to deallocate at the end of 'block', possibly because it already gets deallocated before the end of the block. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00123">123</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

</div>
</div>
<a id="acbbd4dd1ff4a2f33f6887bdadade61d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbd4dd1ff4a2f33f6887bdadade61d3">&#9670;&nbsp;</a></span>getLiveMemrefsIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::getLiveMemrefsIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a sorted list of MemRef values which are live at the start of the given block. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00127">127</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Liveness_8cpp_source.html#l00231">mlir::Liveness::getLiveIn()</a>, and <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00041">isMemref()</a>.</p>

</div>
</div>
<a id="aca92c3822f0d1e8a6ff77e84b55863f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca92c3822f0d1e8a6ff77e84b55863f8">&#9670;&nbsp;</a></span>getMemrefsAndConditionsToDeallocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult DeallocationState::getMemrefsAndConditionsToDeallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>memrefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conditions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a given block, computes the list of MemRefs that potentially need to be deallocated at the end of that block. </p>
<p>This list also contains values that have to be retained (and are thus part of the list returned by <code>getMemrefsToRetain</code>) and is computed by taking the MemRefs in the 'in' set of the liveness analysis of 'block' appended by the set of MemRefs allocated in 'block' itself and subtracted by the set of MemRefs deallocated in 'block'. Note that we don't have to take the intersection of the liveness 'in' set with the 'out' set of the predecessor block because a value that is in the 'in' set must be defined in an ancestor block that dominates all direct predecessors and thus the 'in' set of this block is a subset of the 'out' sets of each predecessor.</p>
<p>memrefs = filter((liveIn(block) U allocated(block) U arguments(block)) \ deallocated(block), isMemRef)</p>
<p>The list of conditions is then populated by querying the internal datastructures for the ownership value of that MemRef. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00185">185</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00065">mlir::bufferization::Ownership::getIndicator()</a>, and <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00062">mlir::bufferization::Ownership::isUnique()</a>.</p>

</div>
</div>
<a id="aecc3a7abb40a8c1eaa1e7fdfdd8d35f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc3a7abb40a8c1eaa1e7fdfdd8d35f8">&#9670;&nbsp;</a></span>getMemrefsToRetain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::getMemrefsToRetain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>fromBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>toBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>destOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>toRetain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two basic blocks and the values passed via block arguments to the destination block, compute the list of MemRefs that have to be retained in the 'fromBlock' to not run into a use-after-free situation. </p>
<p>This list consists of the MemRefs in the successor operand list of the terminator and the MemRefs in the 'out' set of the liveness analysis intersected with the 'in' set of the destination block.</p>
<p>toRetain = filter(successorOperands + (liveOut(fromBlock) insersect liveIn(toBlock)), isMemRef) </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00161">161</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Liveness_8cpp_source.html#l00231">mlir::Liveness::getLiveIn()</a>, <a class="el" href="Liveness_8cpp_source.html#l00236">mlir::Liveness::getLiveOut()</a>, and <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00041">isMemref()</a>.</p>

</div>
</div>
<a id="ab5f36fb929ae48ab30aa63722d3b0690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f36fb929ae48ab30aa63722d3b0690">&#9670;&nbsp;</a></span>getMemrefWithUniqueOwnership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; DeallocationState::getMemrefWithUniqueOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an SSA value of MemRef type, this function queries the ownership and if it is not already in the 'Unique' state, potentially inserts IR to get a new SSA value, returned as the first element of the pair, which has 'Unique' ownership and can be used instead of the passed <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> with the the ownership indicator returned as the second element of the pair. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00136">136</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00037">buildBoolValue()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00065">mlir::bufferization::Ownership::getIndicator()</a>, <a class="el" href="Value_8cpp_source.html#l00024">mlir::Value::getLoc()</a>, <a class="el" href="Value_8cpp_source.html#l00046">mlir::Value::getParentBlock()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00062">mlir::bufferization::Ownership::isUnique()</a>, and <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00100">updateOwnership()</a>.</p>

</div>
</div>
<a id="a156eb68a5cf568db1a19c5bfe0d36ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156eb68a5cf568db1a19c5bfe0d36ac1">&#9670;&nbsp;</a></span>getOwnership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a> DeallocationState::getOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ownership of 'memref' for the given basic block. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00115">115</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

</div>
</div>
<a id="acb96f0caf02a8a10d10f3ab80d3b4ca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb96f0caf02a8a10d10f3ab80d3b4ca2">&#9670;&nbsp;</a></span>getSymbolTable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1SymbolTableCollection.html">SymbolTableCollection</a>* mlir::bufferization::DeallocationState::getSymbolTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the symbol cache to lookup functions from call operations to check attributes on the function operation. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8h_source.html#l00187">187</a> of file <a class="el" href="BufferDeallocationOpInterface_8h_source.html">BufferDeallocationOpInterface.h</a>.</p>

</div>
</div>
<a id="a3a602b090db59b6836af9b59a63ea933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a602b090db59b6836af9b59a63ea933">&#9670;&nbsp;</a></span>resetOwnerships()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::resetOwnerships </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>memrefs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes ownerships associated with all values in the passed range for 'block'. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00110">110</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00057">mlir::bufferization::Ownership::getUninitialized()</a>.</p>

</div>
</div>
<a id="a45793cb3a7ee42027425f298936e21e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45793cb3a7ee42027425f298936e21e8">&#9670;&nbsp;</a></span>updateOwnership()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeallocationState::updateOwnership </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>memref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1bufferization_1_1Ownership.html">Ownership</a>&#160;</td>
          <td class="paramname"><em>ownership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Small helper function to update the ownership map by taking the current ownership ('Uninitialized' state if not yet present), computing the join with the passed ownership and storing this new value in the map. </p>
<p>By default, it will be performed for the block where 'owned' is defined. If the ownership of the given value should be updated for another block, the 'block' argument can be explicitly passed. </p>

<p class="definition">Definition at line <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00100">100</a> of file <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00046">mlir::Value::getParentBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00136">getMemrefWithUniqueOwnership()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Bufferization/IR/<a class="el" href="BufferDeallocationOpInterface_8h_source.html">BufferDeallocationOpInterface.h</a></li>
<li>lib/Dialect/Bufferization/IR/<a class="el" href="BufferDeallocationOpInterface_8cpp_source.html">BufferDeallocationOpInterface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
