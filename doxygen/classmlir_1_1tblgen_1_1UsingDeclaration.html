<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tblgen::UsingDeclaration Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1tblgen.html">tblgen</a></li><li class="navelem"><a href="classmlir_1_1tblgen_1_1UsingDeclaration.html">UsingDeclaration</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classmlir_1_1tblgen_1_1UsingDeclaration-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::tblgen::UsingDeclaration Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class describes a using-declaration for a class.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Class_8h_source.html">mlir/TableGen/Class.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::tblgen::UsingDeclaration:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1tblgen_1_1UsingDeclaration__inherit__graph.svg" width="400" height="331"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3d10bd49b9e1ba0025be027823f2d019" id="r_a3d10bd49b9e1ba0025be027823f2d019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d10bd49b9e1ba0025be027823f2d019">isStruct</a></td></tr>
<tr class="memdesc:a3d10bd49b9e1ba0025be027823f2d019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a using declaration that either aliases <span class="tt">name</span> to <span class="tt">value</span> or inherits the parent methods `name.  <br /></td></tr>
<tr class="memitem:ad038e7df5b6d969fe08dd3a20a5a98b7" id="r_ad038e7df5b6d969fe08dd3a20a5a98b7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html">ClassDeclaration</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad038e7df5b6d969fe08dd3a20a5a98b7">declarations</a></td></tr>
<tr class="memdesc:ad038e7df5b6d969fe08dd3a20a5a98b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of declarations in the class, emitted in order.  <br /></td></tr>
<tr class="memitem:ab773e8cf81e348023923207da85bf944" id="r_ab773e8cf81e348023923207da85bf944"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; std::string, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; std::string &gt;, <a class="el" href="namespacemlir.html#a84d105d34b85fe809ec98a1391e35811">StringSet</a>&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab773e8cf81e348023923207da85bf944">templateParams</a></td></tr>
<tr class="memdesc:ab773e8cf81e348023923207da85bf944"><td class="mdescLeft">&#160;</td><td class="mdescRight">An optional list of class template parameters.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-inherited" class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1tblgen_1_1ClassDeclarationBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classmlir_1_1tblgen_1_1ClassDeclarationBase')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Types inherited from <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html">mlir::tblgen::ClassDeclarationBase&lt; ClassDeclaration::UsingDeclaration &gt;</a></td></tr>
<tr class="memitem:afe96042f5c4748ab2246be47a2bf1073 inherit pub_types_classmlir_1_1tblgen_1_1ClassDeclarationBase" id="r_afe96042f5c4748ab2246be47a2bf1073"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#afe96042f5c4748ab2246be47a2bf1073">Base</a></td></tr>
<tr class="inherit_header pub_types_classmlir_1_1tblgen_1_1ClassDeclaration"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_types_classmlir_1_1tblgen_1_1ClassDeclaration')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Types inherited from <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html">mlir::tblgen::ClassDeclaration</a></td></tr>
<tr class="memitem:ad2b89b2153711dfca29b6305e2405e8a inherit pub_types_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_ad2b89b2153711dfca29b6305e2405e8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8a">Kind</a> { <br />
&#160;&#160;<a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aaf661b9f845c2979266fb6b69122ed9f6">Method</a>
, <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aaebfb2c23c048a58926d42466df357ac4">UsingDeclaration</a>
, <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aa6846557e3f469fb0a7350f1835798df3">VisibilityDeclaration</a>
, <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aa5bcb6194a1b3bd22b31357163746c529">Field</a>
, <br />
&#160;&#160;<a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aad61735ae8d2df9697f646158a47b0539">ExtraClassDeclaration</a>
<br />
 }</td></tr>
<tr class="memdesc:ad2b89b2153711dfca29b6305e2405e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kinds for LLVM-style RTTI.  <a href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8a">More...</a><br /></td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html">mlir::tblgen::ClassDeclarationBase&lt; ClassDeclaration::UsingDeclaration &gt;</a></td></tr>
<tr class="memitem:a62549a563c7a52f669a2315d3fe65b52 inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase" id="r_a62549a563c7a52f669a2315d3fe65b52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#a62549a563c7a52f669a2315d3fe65b52">ClassDeclarationBase</a> ()</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Public Member Functions inherited from <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html">mlir::tblgen::ClassDeclaration</a></td></tr>
<tr class="memitem:a01a3f31aeb6f9ff4cbb88e41e7e84344 inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_a01a3f31aeb6f9ff4cbb88e41e7e84344"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a01a3f31aeb6f9ff4cbb88e41e7e84344">~ClassDeclaration</a> ()=default</td></tr>
<tr class="memitem:a081a82eddbb2444b709ad8f4618729fc inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_a081a82eddbb2444b709ad8f4618729fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a081a82eddbb2444b709ad8f4618729fc">ClassDeclaration</a> (<a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8a">Kind</a> kind)</td></tr>
<tr class="memdesc:a081a82eddbb2444b709ad8f4618729fc inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a class declaration with a given kind.  <br /></td></tr>
<tr class="memitem:aa4116229ad59f414c74c26fb4c342b7e inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_aa4116229ad59f414c74c26fb4c342b7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8a">Kind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#aa4116229ad59f414c74c26fb4c342b7e">getKind</a> () const</td></tr>
<tr class="memdesc:aa4116229ad59f414c74c26fb4c342b7e inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the class declaration kind.  <br /></td></tr>
<tr class="memitem:a93163d45d29a2db951ef5d9357ee9a6c inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_a93163d45d29a2db951ef5d9357ee9a6c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c">writeDeclTo</a> (<a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a> &amp;os) const =0</td></tr>
<tr class="memdesc:a93163d45d29a2db951ef5d9357ee9a6c inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the declaration.  <br /></td></tr>
<tr class="memitem:af48e155b5ad91b1206aac8baf7086194 inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration" id="r_af48e155b5ad91b1206aac8baf7086194"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#af48e155b5ad91b1206aac8baf7086194">writeDefTo</a> (<a class="el" href="classmlir_1_1raw__indented__ostream.html">raw_indented_ostream</a> &amp;os, StringRef namePrefix) const</td></tr>
<tr class="memdesc:af48e155b5ad91b1206aac8baf7086194 inherit pub_methods_classmlir_1_1tblgen_1_1ClassDeclaration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the definition, if any.  <br /></td></tr>
<tr class="inherit_header pub_static_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase')"><span class="dynarrow"><span class="arrowhead closed"></span></span>Static Public Member Functions inherited from <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html">mlir::tblgen::ClassDeclarationBase&lt; ClassDeclaration::UsingDeclaration &gt;</a></td></tr>
<tr class="memitem:a8e4ac524053f60acff7e832dc5f197a3 inherit pub_static_methods_classmlir_1_1tblgen_1_1ClassDeclarationBase" id="r_a8e4ac524053f60acff7e832dc5f197a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#a8e4ac524053f60acff7e832dc5f197a3">classof</a> (const <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html">ClassDeclaration</a> *other)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class describes a using-declaration for a class. </p>
<p>E.g.</p>
<p>using <a class="el" href="classmlir_1_1Op.html#abe9f320696122f31b6b22509d137d33d" title="This is a public constructor. Any op can be initialized to null.">Op::Op</a>; using Adaptor = OpAdaptor; </p>

<p class="definition">Definition at line <a class="el" href="Class_8h_source.html#l00556">556</a> of file <a class="el" href="Class_8h_source.html">Class.h</a>.</p>
</div><a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="ad038e7df5b6d969fe08dd3a20a5a98b7" name="ad038e7df5b6d969fe08dd3a20a5a98b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad038e7df5b6d969fe08dd3a20a5a98b7">&#9670;&#160;</a></span>declarations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html">ClassDeclaration</a>&gt; &gt; mlir::tblgen::UsingDeclaration::declarations</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of declarations in the class, emitted in order. </p>

<p class="definition">Definition at line <a class="el" href="Class_8h_source.html#l00894">894</a> of file <a class="el" href="Class_8h_source.html">Class.h</a>.</p>

</div>
</div>
<a id="a3d10bd49b9e1ba0025be027823f2d019" name="a3d10bd49b9e1ba0025be027823f2d019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d10bd49b9e1ba0025be027823f2d019">&#9670;&#160;</a></span>isStruct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::tblgen::UsingDeclaration::isStruct</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a using declaration that either aliases <span class="tt">name</span> to <span class="tt">value</span> or inherits the parent methods `name. </p>
<p>template &lt;typename NameT, typename ValueT = std::string&gt; <a class="el" href="classmlir_1_1tblgen_1_1UsingDeclaration.html" title="This class describes a using-declaration for a class.">UsingDeclaration</a>(NameT &amp;&amp;name, ValueT &amp;&amp;value = "") : name(stringify(std::forward&lt;NameT&gt;(name))), value(stringify(std::forward&lt;ValueT&gt;(value))) {}</p>
<p>/ Write the using declaration. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c" title="Write the declaration.">writeDeclTo(raw_indented_ostream &amp;os) const </a>override;</p>
<p>/ Add a template parameter. template &lt;typename ParamT&gt; void addTemplateParam(ParamT param) { templateParams.insert(stringify(param)); }</p>
<p>/ Add a list of template parameters. template &lt;typename ContainerT&gt; void addTemplateParams(ContainerT &amp;&amp;container) { templateParams.insert(std::begin(container), std::end(container)); }</p>
<p>private: / The name of the declaration, or a resolved name to an inherited function. std::string name; / The type that is being aliased. Leave empty for inheriting functions. std::string value; / An optional list of class template parameters. / This is simply a ordered list of parameter names that are then added as / template type parameters when the using declaration is emitted. <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt;std::string, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::string&gt;</a>, <a class="el" href="namespacemlir.html#a84d105d34b85fe809ec98a1391e35811">StringSet&lt;&gt;</a>&gt; templateParams; };</p>
<p>/ This class describes a class field. class Field : public <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#a62549a563c7a52f669a2315d3fe65b52">ClassDeclarationBase&lt;ClassDeclaration::Field&gt;</a> { public: / Create a class field with a type and variable name. template &lt;typename TypeT, typename NameT&gt; <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aa5bcb6194a1b3bd22b31357163746c529">Field(TypeT &amp;&amp;type, NameT &amp;&amp;name)</a> : type(stringify(std::forward&lt;TypeT&gt;(type))), name(stringify(std::forward&lt;NameT&gt;(name))) {}</p>
<p>/ Write the declaration of the field. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c" title="Write the declaration.">writeDeclTo(raw_indented_ostream &amp;os) const </a>override;</p>
<p>private: / The C++ type of the field. std::string type; / The variable name of the class whether. std::string name; };</p>
<p>/ A declaration for the visibility of subsequent declarations. class VisibilityDeclaration : public <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#a62549a563c7a52f669a2315d3fe65b52">ClassDeclarationBase&lt;ClassDeclaration::VisibilityDeclaration&gt;</a> { public: / Create a declaration for the given visibility. <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#ad2b89b2153711dfca29b6305e2405e8aa6846557e3f469fb0a7350f1835798df3">VisibilityDeclaration(Visibility visibility)</a> : visibility(visibility) {}</p>
<p>/ Get the visibility. <a class="el" href="namespacemlir_1_1tblgen.html#a0b021f35cd8a8e0e16cb63ce60f99228" title="This enum describes C++ inheritance visibility.">Visibility</a> getVisibility() const { return visibility; }</p>
<p>/ Write the visibility declaration. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c" title="Write the declaration.">writeDeclTo(raw_indented_ostream &amp;os) const </a>override;</p>
<p>private: / The visibility of subsequent class declarations. <a class="el" href="namespacemlir_1_1tblgen.html#a0b021f35cd8a8e0e16cb63ce60f99228" title="This enum describes C++ inheritance visibility.">Visibility</a> visibility; };</p>
<p>/ Unstructured extra class declarations and definitions, from TableGen / definitions. The default visibility of extra class declarations is up to the / owning class. class ExtraClassDeclaration : public <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclarationBase.html#a62549a563c7a52f669a2315d3fe65b52">ClassDeclarationBase&lt;ClassDeclaration::ExtraClassDeclaration&gt;</a> { public: / Create an extra class declaration. ExtraClassDeclaration(StringRef extraClassDeclaration, std::string extraClassDefinition = "") : ExtraClassDeclaration(extraClassDeclaration.str(), std::move(extraClassDefinition)) {}</p>
<p>ExtraClassDeclaration(std::string extraClassDeclaration, std::string extraClassDefinition = "") : extraClassDeclaration(extraClassDeclaration), extraClassDefinition(extraClassDefinition) {}</p>
<p>/ Write the extra class declarations. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c" title="Write the declaration.">writeDeclTo(raw_indented_ostream &amp;os) const </a>override;</p>
<p>/ Write the extra class definitions. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#af48e155b5ad91b1206aac8baf7086194" title="Write the definition, if any.">writeDefTo(raw_indented_ostream &amp;os,
                  StringRef namePrefix) const </a>override;</p>
<p>private: / The string of the extra class declarations. It is re-indented before / printed. std::string extraClassDeclaration; / The string of the extra class definitions. It is re-indented before / printed. std::string extraClassDefinition; };</p>
<p>/ A class used to emit C++ classes from Tablegen. Contains a list of public / methods and a list of private fields to be emitted. class Class { public: virtual ~Class() = default;</p>
<p>/ Explicitly delete the copy constructor. This is to work around a gcc-5 bug / with std::is_trivially_move_constructible. Class(const Class &amp;) = delete;</p>
<p>/ Create a class with a name, and whether it should be declared as a <span class="tt">class</span> / or <span class="tt">struct</span>. Also, prevent this from being mistaken as a move constructor / candidate. template &lt;typename NameT, typename = std::enable_if_t&lt;!std::is_same&lt;NameT, Class&gt;::value&gt;&gt; Class(NameT &amp;&amp;name, bool isStruct = false) : className(stringify(std::forward&lt;NameT&gt;(name))), <a class="el" href="#a3d10bd49b9e1ba0025be027823f2d019" title="Create a using declaration that either aliases name to value or inherits the parent methods `name.">isStruct(isStruct)</a> {}</p>
<p>/ Add a new constructor to this class and prune and constructors made / redundant by it. Returns null if the constructor was not added. Else, / returns a pointer to the new constructor. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Constructor.html">Constructor</a> *addConstructor(Args &amp;&amp;...args) { <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> defaultProperties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da1676372a93b7c2abd1e8b6e521e38a2f">Method::Constructor</a>; If the class has template parameters, the constructor has to be defined inline. if (!templateParams.empty()) defaultProperties |= <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da5c0e15c6969b7bbdf0d7b741739d258d">Method::Inline</a>; return addConstructorAndPrune(<a class="el" href="classmlir_1_1tblgen_1_1Constructor.html">Constructor</a>(getClassName(), Properties | defaultProperties, std::forward&lt;Args&gt;(args)...)); }</p>
<p>/ Add a new method to this class and prune any methods made redundant by it. / Returns null if the method was not added (because an existing method would / make it redundant). Else, returns a pointer to the new method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> properties, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;MethodParameter&gt;</a> parameters) { If the class has template parameters, then it has to be defined inline. if (!templateParams.empty()) properties |= <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da5c0e15c6969b7bbdf0d7b741739d258d">Method::Inline</a>; return addMethodAndPrune(<a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a>(std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), Properties | properties, parameters)); }</p>
<p>/ Add a method with statically-known properties. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;MethodParameter&gt;</a> parameters) { return addMethod(std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), Properties, parameters); }</p>
<p>template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> properties, Args &amp;&amp;...args) { return addMethod(std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), properties | Properties, {std::forward&lt;Args&gt;(args)...}); }</p>
<p>/ Add a method with statically-known properties. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod(std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), Properties, std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add a static method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addStaticMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da9c91a27a74916d3715f36469880bcc75">Method::Static</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add an inline static method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addStaticInlineMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da05cffe34c2e51d13cf008e2a3dcad118">Method::StaticInline</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add an inline method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addInlineMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da5c0e15c6969b7bbdf0d7b741739d258d">Method::Inline</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add a const method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addConstMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da6c2557d6db6f86d3dfad8a95afd674ba">Method::Const</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add a declaration for a method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *declareMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da97ba0adf2971e2cd371ae9574c23b32a">Method::Declaration</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>/ Add a declaration for a static method. template &lt;<a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093d" title="Properties (qualifiers) of class methods.">Method::Properties</a> Properties = <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093daa73e407f66726b880075ddc4d2dbef16">Method::None</a>, typename RetTypeT, typename NameT, typename... Args&gt; <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *declareStaticMethod(RetTypeT &amp;&amp;retType, NameT &amp;&amp;name, Args &amp;&amp;...args) { return addMethod&lt;Properties | <a class="el" href="classmlir_1_1tblgen_1_1Method.html#a6bd57c10aac328cbe7ef23b1d798093da53e94994857d5971d14e19b706bf80c4">Method::StaticDeclaration</a>&gt;( std::forward&lt;RetTypeT&gt;(retType), std::forward&lt;NameT&gt;(name), std::forward&lt;Args&gt;(args)...); }</p>
<p>const std::vector&lt;std::unique_ptr&lt;Method&gt;&gt; &amp;getMethods() const { return methods; }</p>
<p>/ Add a new field to the class. Class fields added this way are always / private. template &lt;typename TypeT, typename NameT&gt; void addField(TypeT &amp;&amp;type, NameT &amp;&amp;name) { fields.emplace_back(std::forward&lt;TypeT&gt;(type), std::forward&lt;NameT&gt;(name)); }</p>
<p>/ Add a parent class. <a class="el" href="classmlir_1_1tblgen_1_1ParentClass.html" title="This class describes a C++ parent class declaration.">ParentClass</a> &amp;addParent(ParentClass parent);</p>
<p>/ Add a template parameter. template &lt;typename ParamT&gt; void addTemplateParam(ParamT param) { templateParams.insert(stringify(param)); }</p>
<p>/ Add a list of template parameters. template &lt;typename ContainerT&gt; void addTemplateParams(ContainerT &amp;&amp;container) { templateParams.insert(std::begin(container), std::end(container)); }</p>
<p>/ Return the C++ name of the class. StringRef getClassName() const { return className; }</p>
<p>/ Write the declaration of this class, all declarations, and definitions of / inline functions. Wrap the output stream in an indented stream. void writeDeclTo(raw_ostream &amp;rawOs) const { <a class="el" href="classmlir_1_1raw__indented__ostream.html" title="raw_ostream subclass that simplifies indention a sequence of code.">raw_indented_ostream</a> os(rawOs); writeDeclTo(os); } / Write the definitions of thiss class's out-of-line constructors and / methods. Wrap the output stream in an indented stream. void writeDefTo(raw_ostream &amp;rawOs) const { <a class="el" href="classmlir_1_1raw__indented__ostream.html" title="raw_ostream subclass that simplifies indention a sequence of code.">raw_indented_ostream</a> os(rawOs); writeDefTo(os); }</p>
<p>/ Write the declaration of this class, all declarations, and definitions of / inline functions. void <a class="el" href="classmlir_1_1tblgen_1_1ClassDeclaration.html#a93163d45d29a2db951ef5d9357ee9a6c" title="Write the declaration.">writeDeclTo(raw_indented_ostream &amp;os) const</a>; / Write the definitions of thiss class's out-of-line constructors and / methods. void writeDefTo(raw_indented_ostream &amp;os) const;</p>
<p>/ Add a declaration. The declaration is appended directly to the list of / class declarations. template &lt;typename DeclT, typename... Args&gt; DeclT *declare(Args &amp;&amp;...args) { auto decl = std::make_unique&lt;DeclT&gt;(std::forward&lt;Args&gt;(args)...); auto *ret = decl.get(); declarations.push_back(std::move(decl)); return ret; }</p>
<p>/ The declaration of a class needs to be "finalized". / / Class constructors, methods, and fields can be added in any order, / regardless of whether they are public or private. These are stored in / lists separate from list of declarations <span class="tt">declarations</span>. / / So that the generated C++ code is somewhat organised, public methods are / declared together, and so are private methods and class fields. This / function iterates through all the added methods and fields and organises / them into the list of declarations, adding visibility declarations as / needed, as follows: / / 1. public methods and constructors / 2. private methods and constructors / 3. class fields &ndash; all are private / / <span class="tt">Class::finalize</span> clears the lists of pending methods and fields, and can / be called multiple times. virtual void finalize();</p>
<p>protected: / Add a new constructor if it is not made redundant by any existing / constructors and prune and existing constructors made redundant. <a class="el" href="classmlir_1_1tblgen_1_1Constructor.html">Constructor</a> *addConstructorAndPrune(<a class="el" href="classmlir_1_1tblgen_1_1Constructor.html">Constructor</a> &amp;&amp;newCtor); / Add a new method if it is not made redundant by any existing methods and / prune and existing methods made redundant. <a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> *addMethodAndPrune(<a class="el" href="classmlir_1_1tblgen_1_1Method.html" title="Class for holding an op&#39;s method for C++ code emission.">Method</a> &amp;&amp;newMethod);</p>
<p>/ Get the last visibility declaration. <a class="el" href="namespacemlir_1_1tblgen.html#a0b021f35cd8a8e0e16cb63ce60f99228" title="This enum describes C++ inheritance visibility.">Visibility</a> getLastVisibilityDecl() const;</p>
<p>/ The C++ class name. std::string className; / The list of parent classes. <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;ParentClass&gt;</a> parents; / The pending list of methods and constructors. std::vector&lt;std::unique_ptr&lt;Method&gt;&gt; methods; / The pending list of private class fields. <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;Field&gt;</a> fields; / Whether this is a <span class="tt">class</span> or a <span class="tt">struct</span>. </p>

<p class="definition">Definition at line <a class="el" href="Class_8h_source.html#l00891">891</a> of file <a class="el" href="Class_8h_source.html">Class.h</a>.</p>

</div>
</div>
<a id="ab773e8cf81e348023923207da85bf944" name="ab773e8cf81e348023923207da85bf944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab773e8cf81e348023923207da85bf944">&#9670;&#160;</a></span>templateParams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt;std::string, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;std::string&gt;, <a class="el" href="namespacemlir.html#a84d105d34b85fe809ec98a1391e35811">StringSet</a>&lt;&gt; &gt; mlir::tblgen::UsingDeclaration::templateParams</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An optional list of class template parameters. </p>

<p class="definition">Definition at line <a class="el" href="Class_8h_source.html#l00897">897</a> of file <a class="el" href="Class_8h_source.html">Class.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/mlir/TableGen/<a class="el" href="Class_8h_source.html">Class.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
