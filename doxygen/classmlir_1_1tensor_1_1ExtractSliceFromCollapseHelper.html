<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tensor::ExtractSliceFromCollapseHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1tensor.html">tensor</a></li><li class="navelem"><a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::tensor::ExtractSliceFromCollapseHelper Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TransformUtils_8h_source.html">mlir/Dialect/Tensor/Transforms/TransformUtils.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1c7806dffa074ba1dd1f4add8307e55" id="r_af1c7806dffa074ba1dd1f4add8307e55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1c7806dffa074ba1dd1f4add8307e55">ExtractSliceFromCollapseHelper</a> (tensor::CollapseShapeOp collapseShapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; collapseShapeInputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; collapseShapeOutputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; extractSliceParams, const llvm::SmallBitVector &amp;linearizedDimensions, const llvm::SmallBitVector &amp;slicedDimensions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tiledSizes)</td></tr>
<tr class="memitem:aec30410af86eea7b189118af29f2b9ca" id="r_aec30410af86eea7b189118af29f2b9ca"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec30410af86eea7b189118af29f2b9ca">getIterationSpaceSizes</a> ()</td></tr>
<tr class="memdesc:aec30410af86eea7b189118af29f2b9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the desired slice.  <br /></td></tr>
<tr class="memitem:a80bdabd8cfd2a338d190a581a90b528e" id="r_a80bdabd8cfd2a338d190a581a90b528e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e">emitLoopNestBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileInductionVars)</td></tr>
<tr class="memdesc:a80bdabd8cfd2a338d190a581a90b528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the IR inside of the caller's loop nest for 1) inverting the index mappings of the ExtractSliceOp-&gt;CollapseShapeOp chain and 2) extracting the CollapseShapeOp source tensor tile for this specified iteration space point <span class="tt">tileInductionVars</span> and 3) calculating where to insert the extracted tile.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9f5104a95d8dfc7b580d2d49981f1bda" id="r_a9f5104a95d8dfc7b580d2d49981f1bda"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f5104a95d8dfc7b580d2d49981f1bda">create</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::CollapseShapeOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; sliceParams)</td></tr>
<tr class="memdesc:a9f5104a95d8dfc7b580d2d49981f1bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a CollapseShapeOp and a set of ranges describing the desired slice of its result, emits IR to materialize the shapes of the input and output tensors, and returns an instance of the initialized class.  <br /></td></tr>
<tr class="memitem:a8294cd4753b432286af1672114d7c28a" id="r_a8294cd4753b432286af1672114d7c28a"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8294cd4753b432286af1672114d7c28a">create</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, tensor::CollapseShapeOp collapseOp, tensor::ExtractSliceOp extractOp)</td></tr>
<tr class="memdesc:a8294cd4753b432286af1672114d7c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a CollapseShapeOp and an ExtractSliceOp acting on its result, emits IR to materialize the shapes of the input and output tensors of the CollapseShapeOp, and returns an instance of the initialized class.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp. </p>
<p>In order to accomplish this, a loop nest or similar operation must be created by the caller. The purpose of the loop nest is to generate a "tiling by 1" of all sliced dimensions. The "tiling by 1" assembles all elements of the result tile over dimensions that would have been impossible to directly slice.</p>
<p>The class provides three methods:</p><ol type="1">
<li><span class="tt"><a class="el" href="#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></span>: emits IR that should appear before the loop nest and populates the internal state.</li>
<li><span class="tt"><a class="el" href="#aec30410af86eea7b189118af29f2b9ca" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></span>: returns parameters used by the caller to construct the loop nest.</li>
<li><span class="tt"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></span>: emits IR to construct a "size-1 tile" of the desired result and returns a set of ranges where the tile should be inserted into the destination tensor.</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md20"></a>
Intended usage:</h3>
<p>The caller should first call <span class="tt"><a class="el" href="#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></span> and then create a destination tensor that is the same size as the desired slice. The caller then creates a loop nest that iterates over the multi-dimensional iteration space defined by <span class="tt">[0, ub[0]) x [0, ub[1]] x ... x [0, ub[N-1]]</span> where <span class="tt">ub</span> is the upper bound given by <span class="tt"><a class="el" href="#aec30410af86eea7b189118af29f2b9ca" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></span>. Inside the body of the loop nest, the caller should call <span class="tt"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></span> and provide the induction variables. This returns a sub-tile and a set of ranges that describe where this tile should be inserted into the result by the caller. For a complete example of usage, see the examples in the TestTensorTransforms pass.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md21"></a>
Example:</h3>
<p>Consider the following IR: </p><div class="fragment"><div class="line">%0 = <a class="code hl_namespace" href="namespacemlir_1_1linalg.html">linalg</a>.generic ... -&gt; <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a></div>
<div class="line">%1 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %0 [[0, 1, 2], [3, 4]]</div>
<div class="line">       : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a> into <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="line">%2 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %1 [%offt0, %offt1][%size0, %size1][1, 1]</div>
<div class="line">       : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="ttc" id="anamespacemlir_1_1linalg_html"><div class="ttname"><a href="namespacemlir_1_1linalg.html">mlir::linalg</a></div><div class="ttdef"><b>Definition</b> <a href="LinalgToStandard_8h_source.html#l00024">LinalgToStandard.h:24</a></div></div>
<div class="ttc" id="anamespacemlir_1_1tensor_html"><div class="ttname"><a href="namespacemlir_1_1tensor.html">mlir::tensor</a></div><div class="ttdef"><b>Definition</b> <a href="BufferizationTransformOps_8h_source.html#l00019">BufferizationTransformOps.h:19</a></div></div>
</div><!-- fragment --><p>We can construct %2 by generating the following, which only uses <span class="tt">%0</span>:</p>
<div class="fragment"><div class="line">%dest = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.empty(%size0, %size1) : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="line">%1 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.dim %0, %c1 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a></div>
<div class="line">%2 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.dim %0, %c2 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a></div>
<div class="line">%3 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.dim %0, %c4 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a></div>
<div class="line"> </div>
<div class="line">%<a class="code hl_variable" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a> = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv0 = %c0 to %arg2 step %c1 iter_args(%arg6 = %dest) -&gt;</div>
<div class="line">                                                 (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a>) {</div>
<div class="line">  %5 = <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.for %iv1 = %c0 to %arg4 step %c1 iter_args(%arg8 = %arg6)</div>
<div class="line">                                                 -&gt; (<a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a>) {</div>
<div class="line">    %lin0 = (<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.apply) %iv0 + %offt0</div>
<div class="line">    %lin1 = (<a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.apply) %iv1 + %offt1</div>
<div class="line"> </div>
<div class="line">    %mi0:3 = <a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.delinearize_index %lin0 into (%c3, %1, %2)</div>
<div class="line">    %mi1:2 = <a class="code hl_namespace" href="namespacemlir_1_1affine.html">affine</a>.delinearize_index %lin1 into (%c11, %3)</div>
<div class="line"> </div>
<div class="line">    %sub_tile = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.extract_slice %0</div>
<div class="line">                   [%mi0#0, %mi0#1, %mi0#2, %mi1#0, %mi1#1]</div>
<div class="line">                   [1, 1, 1, 1, 1]</div>
<div class="line">                   [1, 1, 1, 1, 1]</div>
<div class="line">           : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;3x?x?x11x?xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x1x1x1x1xf32&gt;</a></div>
<div class="line">    %sub_tile_collapsed = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.collapse_shape %sub_tile</div>
<div class="line">            [[0, 1, 2], [3, 4]]</div>
<div class="line">           : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x1x1x1x1xf32&gt;</a> into <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>&lt;1x1xf3</div>
<div class="line"> </div>
<div class="line">    %12 = <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor</a>.insert_slice %sub_tile_collapsed into</div>
<div class="line">            %arg8[%iv0, %iv1] [1, 1] [1, 1]</div>
<div class="line">            : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;1x1xf32&gt;</a> into <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="line">    <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %12 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="line">  }</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1scf.html">scf</a>.yield %5 : <a class="code hl_namespace" href="namespacemlir_1_1tensor.html">tensor&lt;?x?xf32&gt;</a></div>
<div class="line">}</div>
<div class="ttc" id="aLinalgTransformOps_8cpp_html_a937d4dd628a8858b443a399410d2600b"><div class="ttname"><a href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a></div><div class="ttdeci">result</div><div class="ttdef"><b>Definition</b> <a href="LinalgTransformOps_8cpp_source.html#l02098">LinalgTransformOps.cpp:2098</a></div></div>
<div class="ttc" id="anamespacemlir_1_1affine_html"><div class="ttname"><a href="namespacemlir_1_1affine.html">mlir::affine</a></div><div class="ttdef"><b>Definition</b> <a href="AffineToStandard_8h_source.html#l00023">AffineToStandard.h:23</a></div></div>
<div class="ttc" id="anamespacemlir_1_1scf_html"><div class="ttname"><a href="namespacemlir_1_1scf.html">mlir::scf</a></div><div class="ttdef"><b>Definition</b> <a href="SCFToGPU_8h_source.html#l00024">SCFToGPU.h:24</a></div></div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md22"></a>
Explanation of example:</h3>
<p>Each step above is explained below.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md23"></a>
Step 0: Create dest and materialization of shapes.</h4>
<p>This step is self-explanatory and performed by the caller. It can be done before or after calling <span class="tt"><a class="el" href="#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></span>, which materializes the source shape (<span class="tt">%0, %1, %2</span>).</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md24"></a>
Step 1: Create loop nest.</h4>
<p>The caller creates the loop nest (depicted here is <span class="tt">scf.for</span>, but any other similar op can be used). The iteration should start at zero and proceed with step size 1 to the upper bounds given by <span class="tt"><a class="el" href="#aec30410af86eea7b189118af29f2b9ca" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></span>. This forms the basis for the "tiling by 1".</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md25"></a>
Step 2: Transform (iv0, iv1) from the index space of %3 to the index</h4>
<p>space of %0.</p>
<p>This step is performed by <span class="tt"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></span>.</p>
<p>The induction variables <span class="tt">iv0</span> and <span class="tt">iv1</span> live in the index space of %2 (for dimensions 0 and 1, respectively). <span class="tt">lin0</span> and <span class="tt">lin1</span> are the result of inverting or resolve the index space transformation represented by the slice operation, accounting for offset and stride. Subsequently, <span class="tt">mi0</span> and <span class="tt">mi1</span> are the result of applying the inverse index space transformation represented by <span class="tt">tensor.collapse_shape</span>. This is accomplished using <span class="tt">affine.delinearize_index</span>. Note that iv0 and iv1 now correspond to multi-indices <span class="tt">mi0:3</span> and <span class="tt">mi1:2</span>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md26"></a>
Step 3: Extract a sub-tile slice from the source.</h4>
<p>This step is also performed by <span class="tt"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></span>.</p>
<p>The indices <span class="tt">mi0</span> and <span class="tt">mi1</span> are used to extract a slice from %0. This slice is then collapsed down to match the result rank.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md27"></a>
Step 4: Insert sub-tile into the destination</h4>
<p>This step is performed by the caller using the results of <span class="tt"><a class="el" href="#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></span>.</p>
<p>In the above example, the slice insertion parameters are straightforward, but in other possible situations, the slice parameters are more complicated, which is why this helper calculates them for the caller. These other situations correspond to:</p><ol type="1">
<li>The presence of linearized dimensions that are not sliced</li>
<li>The presence of non-linearized dimensions that are sliced. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00149">149</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1c7806dffa074ba1dd1f4add8307e55" name="af1c7806dffa074ba1dd1f4add8307e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c7806dffa074ba1dd1f4add8307e55">&#9670;&#160;</a></span>ExtractSliceFromCollapseHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::tensor::ExtractSliceFromCollapseHelper::ExtractSliceFromCollapseHelper </td>
          <td>(</td>
          <td class="paramtype">tensor::CollapseShapeOp</td>          <td class="paramname"><span class="paramname"><em>collapseShapeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>collapseShapeInputShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>collapseShapeOutputShape</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>extractSliceParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>linearizedDimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>slicedDimensions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tiledSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00166">166</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">create()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a8294cd4753b432286af1672114d7c28a" name="a8294cd4753b432286af1672114d7c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8294cd4753b432286af1672114d7c28a">&#9670;&#160;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt; tensor::ExtractSliceFromCollapseHelper::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::CollapseShapeOp</td>          <td class="paramname"><span class="paramname"><em>collapseOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp</td>          <td class="paramname"><span class="paramname"><em>extractOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a CollapseShapeOp and an ExtractSliceOp acting on its result, emits IR to materialize the shapes of the input and output tensors of the CollapseShapeOp, and returns an instance of the initialized class. </p>
<p>Returns failure if the slice is rank-reducing. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">create()</a>.</p>

</div>
</div>
<a id="a9f5104a95d8dfc7b580d2d49981f1bda" name="a9f5104a95d8dfc7b580d2d49981f1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5104a95d8dfc7b580d2d49981f1bda">&#9670;&#160;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt; tensor::ExtractSliceFromCollapseHelper::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::CollapseShapeOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sliceParams</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a CollapseShapeOp and a set of ranges describing the desired slice of its result, emits IR to materialize the shapes of the input and output tensors, and returns an instance of the initialized class. </p>
<p>Returns failure if the slice is rank-reducing. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">78</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="TransformUtils_8h_source.html#l00166">ExtractSliceFromCollapseHelper()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00549">mlir::getLinearizedDimensions()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00532">mlir::getSlicedDimensions()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00061">create()</a>.</p>

</div>
</div>
<a id="a80bdabd8cfd2a338d190a581a90b528e" name="a80bdabd8cfd2a338d190a581a90b528e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bdabd8cfd2a338d190a581a90b528e">&#9670;&#160;</a></span>emitLoopNestBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &gt; tensor::ExtractSliceFromCollapseHelper::emitLoopNestBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>tileInductionVars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the IR inside of the caller's loop nest for 1) inverting the index mappings of the ExtractSliceOp-&gt;CollapseShapeOp chain and 2) extracting the CollapseShapeOp source tensor tile for this specified iteration space point <span class="tt">tileInductionVars</span> and 3) calculating where to insert the extracted tile. </p>
<p>The returned pair consists of the results of (2) and (3) and should be used by the caller to insert into the destination tensor. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00048">invertCollapseShapeIndexing()</a>, and <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>.</p>

</div>
</div>
<a id="aec30410af86eea7b189118af29f2b9ca" name="aec30410af86eea7b189118af29f2b9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec30410af86eea7b189118af29f2b9ca">&#9670;&#160;</a></span>getIterationSpaceSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp; mlir::tensor::ExtractSliceFromCollapseHelper::getIterationSpaceSizes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the desired slice. </p>
<p>Note that this is not the same as the <span class="tt">sizes</span> parameters of the ExtractSliceOp because not all dimensions of the slice are required to be tiled to form the result. </p>

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00184">184</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Tensor/Transforms/<a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a></li>
<li>lib/Dialect/Tensor/Transforms/<a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
