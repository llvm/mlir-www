<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::tensor::ExtractSliceFromCollapseHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1tensor.html">tensor</a></li><li class="navelem"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::tensor::ExtractSliceFromCollapseHelper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp.  
 <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TransformUtils_8h_source.html">mlir/Dialect/Tensor/Transforms/TransformUtils.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af1c7806dffa074ba1dd1f4add8307e55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#af1c7806dffa074ba1dd1f4add8307e55">ExtractSliceFromCollapseHelper</a> (tensor::CollapseShapeOp collapseShapeOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; collapseShapeInputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; collapseShapeOutputShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; extractSliceParams, const llvm::SmallBitVector &amp;linearizedDimensions, const llvm::SmallBitVector &amp;slicedDimensions, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tiledSizes)</td></tr>
<tr class="separator:af1c7806dffa074ba1dd1f4add8307e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74016ae87c5c9ef3289e5fedea9fc3d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#ad74016ae87c5c9ef3289e5fedea9fc3d">getIterationSpaceSizes</a> ()</td></tr>
<tr class="memdesc:ad74016ae87c5c9ef3289e5fedea9fc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the desired slice.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#ad74016ae87c5c9ef3289e5fedea9fc3d">More...</a><br /></td></tr>
<tr class="separator:ad74016ae87c5c9ef3289e5fedea9fc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bdabd8cfd2a338d190a581a90b528e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e">emitLoopNestBody</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> tileInductionVars)</td></tr>
<tr class="memdesc:a80bdabd8cfd2a338d190a581a90b528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the IR inside of the caller's loop nest for 1) inverting the index mappings of the ExtractSliceOp-&gt;CollapseShapeOp chain and 2) extracting the CollapseShapeOp source tensor tile for this specified iteration space point <code>tileInductionVars</code> and 3) calculating where to insert the extracted tile.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e">More...</a><br /></td></tr>
<tr class="separator:a80bdabd8cfd2a338d190a581a90b528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9f5104a95d8dfc7b580d2d49981f1bda"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a9f5104a95d8dfc7b580d2d49981f1bda">create</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::CollapseShapeOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; sliceParams)</td></tr>
<tr class="memdesc:a9f5104a95d8dfc7b580d2d49981f1bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a CollapseShapeOp and a set of ranges describing the desired slice of its result, emits IR to materialize the shapes of the input and output tensors, and returns an instance of the initialized class.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a9f5104a95d8dfc7b580d2d49981f1bda">More...</a><br /></td></tr>
<tr class="separator:a9f5104a95d8dfc7b580d2d49981f1bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8294cd4753b432286af1672114d7c28a"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a8294cd4753b432286af1672114d7c28a">create</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, tensor::CollapseShapeOp collapseOp, tensor::ExtractSliceOp extractOp)</td></tr>
<tr class="memdesc:a8294cd4753b432286af1672114d7c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a CollapseShapeOp and an ExtractSliceOp acting on its result, emits IR to materialize the shapes of the input and output tensors of the CollapseShapeOp, and returns an instance of the initialized class.  <a href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a8294cd4753b432286af1672114d7c28a">More...</a><br /></td></tr>
<tr class="separator:a8294cd4753b432286af1672114d7c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class assists with generating IR required to materialize an arbitrary-sized slice from the result of a CollapseShapeOp. </p>
<p>In order to accomplish this, a loop nest or similar operation must be created by the caller. The purpose of the loop nest is to generate a "tiling by 1" of all sliced dimensions. The "tiling by 1" assembles all elements of the result tile over dimensions that would have been impossible to directly slice.</p>
<p>The class provides three methods:</p><ol type="1">
<li><code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></code>: emits IR that should appear before the loop nest and populates the internal state.</li>
<li><code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#ad74016ae87c5c9ef3289e5fedea9fc3d" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></code>: returns parameters used by the caller to construct the loop nest.</li>
<li><code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></code>: emits IR to construct a "size-1 tile" of the desired result and returns a set of ranges where the tile should be inserted into the destination tensor.</li>
</ol>
<h3><a class="anchor" id="autotoc_md20"></a>
Intended usage:</h3>
<p>The caller should first call <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></code> and then create a destination tensor that is the same size as the desired slice. The caller then creates a loop nest that iterates over the multi-dimensional iteration space defined by <code>[0, ub[0]) x [0, ub[1]] x ... x [0, ub[N-1]]</code> where <code>ub</code> is the upper bound given by <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#ad74016ae87c5c9ef3289e5fedea9fc3d" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></code>. Inside the body of the loop nest, the caller should call <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></code> and provide the induction variables. This returns a sub-tile and a set of ranges that describe where this tile should be inserted into the result by the caller. For a complete example of usage, see the examples in the TestTensorTransforms pass.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Example:</h3>
<p>Consider the following IR: </p><div class="fragment"><div class="line">%0 = linalg.generic ... -&gt; tensor&lt;3x?x?x11x?xf32&gt;</div>
<div class="line">%1 = tensor.collapse_shape %0 [[0, 1, 2], [3, 4]]</div>
<div class="line">       : tensor&lt;3x?x?x11x?xf32&gt; into tensor&lt;?x?xf32&gt;</div>
<div class="line">%2 = tensor.extract_slice %1 [%offt0, %offt1][%size0, %size1][1, 1]</div>
<div class="line">       : tensor&lt;?x?xf32&gt; to tensor&lt;?x?xf32&gt;</div>
</div><!-- fragment --><p>We can construct %2 by generating the following, which only uses <code>%0</code>:</p>
<div class="fragment"><div class="line">%dest = tensor.empty(%size0, %size1) : tensor&lt;?x?xf32&gt;</div>
<div class="line">%1 = tensor.dim %0, %c1 : tensor&lt;3x?x?x11x?xf32&gt;</div>
<div class="line">%2 = tensor.dim %0, %c2 : tensor&lt;3x?x?x11x?xf32&gt;</div>
<div class="line">%3 = tensor.dim %0, %c4 : tensor&lt;3x?x?x11x?xf32&gt;</div>
<div class="line"> </div>
<div class="line">%result = scf.for %iv0 = %c0 to %arg2 step %c1 iter_args(%arg6 = %dest) -&gt;</div>
<div class="line">                                                 (tensor&lt;?x?xf32&gt;) {</div>
<div class="line">  %5 = scf.for %iv1 = %c0 to %arg4 step %c1 iter_args(%arg8 = %arg6)</div>
<div class="line">                                                 -&gt; (tensor&lt;?x?xf32&gt;) {</div>
<div class="line">    %lin0 = (affine.apply) %iv0 + %offt0</div>
<div class="line">    %lin1 = (affine.apply) %iv1 + %offt1</div>
<div class="line"> </div>
<div class="line">    %mi0:3 = affine.delinearize_index %lin0 into (%c3, %1, %2)</div>
<div class="line">    %mi1:2 = affine.delinearize_index %lin1 into (%c11, %3)</div>
<div class="line"> </div>
<div class="line">    %sub_tile = tensor.extract_slice %0</div>
<div class="line">                   [%mi0#0, %mi0#1, %mi0#2, %mi1#0, %mi1#1]</div>
<div class="line">                   [1, 1, 1, 1, 1]</div>
<div class="line">                   [1, 1, 1, 1, 1]</div>
<div class="line">           : tensor&lt;3x?x?x11x?xf32&gt; to tensor&lt;1x1x1x1x1xf32&gt;</div>
<div class="line">    %sub_tile_collapsed = tensor.collapse_shape %sub_tile</div>
<div class="line">            [[0, 1, 2], [3, 4]]</div>
<div class="line">           : tensor&lt;1x1x1x1x1xf32&gt; into tensor&lt;1x1xf3</div>
<div class="line"> </div>
<div class="line">    %12 = tensor.insert_slice %sub_tile_collapsed into</div>
<div class="line">            %arg8[%iv0, %iv1] [1, 1] [1, 1]</div>
<div class="line">            : tensor&lt;1x1xf32&gt; into tensor&lt;?x?xf32&gt;</div>
<div class="line">    scf.yield %12 : tensor&lt;?x?xf32&gt;</div>
<div class="line">  }</div>
<div class="line">  scf.yield %5 : tensor&lt;?x?xf32&gt;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md22"></a>
Explanation of example:</h3>
<p>Each step above is explained below.</p>
<h4><a class="anchor" id="autotoc_md23"></a>
Step 0: Create %dest and materialization of shapes.</h4>
<p>This step is self-explanatory and performed by the caller. It can be done before or after calling <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a9f5104a95d8dfc7b580d2d49981f1bda" title="Given a CollapseShapeOp and a set of ranges describing the desired slice of its result,...">ExtractSliceFromCollapseHelper::create</a></code>, which materializes the source shape (<code>%0, %1, %2</code>).</p>
<h4><a class="anchor" id="autotoc_md24"></a>
Step 1: Create loop nest.</h4>
<p>The caller creates the loop nest (depicted here is <code>scf.for</code>, but any other similar op can be used). The iteration should start at zero and proceed with step size 1 to the upper bounds given by <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#ad74016ae87c5c9ef3289e5fedea9fc3d" title="Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the de...">ExtractSliceFromCollapseHelper::getIterationSpaceSizes</a></code>. This forms the basis for the "tiling by 1".</p>
<h4><a class="anchor" id="autotoc_md25"></a>
Step 2: Transform (%iv0, %iv1) from the index space of %3 to the index</h4>
<p>space of %0.</p>
<p>This step is performed by <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></code>.</p>
<p>The induction variables <code>iv0</code> and <code>iv1</code> live in the index space of %2 (for dimensions 0 and 1, respectively). <code>lin0</code> and <code>lin1</code> are the result of inverting or resolve the index space transformation represented by the slice operation, accounting for offset and stride. Subsequently, <code>mi0</code> and <code>mi1</code> are the result of applying the inverse index space transformation represented by <code>tensor.collapse_shape</code>. This is accomplished using <code>affine.delinearize_index</code>. Note that iv0 and iv1 now correspond to multi-indices <code>mi0:3</code> and <code>mi1:2</code>.</p>
<h4><a class="anchor" id="autotoc_md26"></a>
Step 3: Extract a sub-tile slice from the source.</h4>
<p>This step is also performed by <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></code>.</p>
<p>The indices <code>mi0</code> and <code>mi1</code> are used to extract a slice from %0. This slice is then collapsed down to match the result rank.</p>
<h4><a class="anchor" id="autotoc_md27"></a>
Step 4: Insert sub-tile into the destination</h4>
<p>This step is performed by the caller using the results of <code><a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html#a80bdabd8cfd2a338d190a581a90b528e" title="Generates the IR inside of the caller&#39;s loop nest for 1) inverting the index mappings of the ExtractS...">ExtractSliceFromCollapseHelper::emitLoopNestBody</a></code>.</p>
<p>In the above example, the slice insertion parameters are straightforward, but in other possible situations, the slice parameters are more complicated, which is why this helper calculates them for the caller. These other situations correspond to:</p><ol type="1">
<li>The presence of linearized dimensions that are not sliced</li>
<li>The presence of non-linearized dimensions that are sliced. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00149">149</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af1c7806dffa074ba1dd1f4add8307e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c7806dffa074ba1dd1f4add8307e55">&#9670;&nbsp;</a></span>ExtractSliceFromCollapseHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::tensor::ExtractSliceFromCollapseHelper::ExtractSliceFromCollapseHelper </td>
          <td>(</td>
          <td class="paramtype">tensor::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>collapseShapeOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>collapseShapeInputShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>collapseShapeOutputShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>extractSliceParams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>linearizedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>slicedDimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tiledSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00166">166</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8294cd4753b432286af1672114d7c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8294cd4753b432286af1672114d7c28a">&#9670;&nbsp;</a></span>create() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt; tensor::ExtractSliceFromCollapseHelper::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>collapseOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::ExtractSliceOp&#160;</td>
          <td class="paramname"><em>extractOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a CollapseShapeOp and an ExtractSliceOp acting on its result, emits IR to materialize the shapes of the input and output tensors of the CollapseShapeOp, and returns an instance of the initialized class. </p>
<p>Returns failure if the slice is rank-reducing. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

</div>
</div>
<a id="a9f5104a95d8dfc7b580d2d49981f1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5104a95d8dfc7b580d2d49981f1bda">&#9670;&nbsp;</a></span>create() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1tensor_1_1ExtractSliceFromCollapseHelper.html">ExtractSliceFromCollapseHelper</a> &gt; tensor::ExtractSliceFromCollapseHelper::create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tensor::CollapseShapeOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt;&#160;</td>
          <td class="paramname"><em>sliceParams</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a CollapseShapeOp and a set of ranges describing the desired slice of its result, emits IR to materialize the shapes of the input and output tensors, and returns an instance of the initialized class. </p>
<p>Returns failure if the slice is rank-reducing. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00078">78</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Remarks_8h_source.html#l00491">mlir::remark::failed()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00549">mlir::getLinearizedDimensions()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00070">mlir::tensor::getMixedSizes()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00532">mlir::getSlicedDimensions()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00027">mlir::reifyResultShapes()</a>.</p>

</div>
</div>
<a id="a80bdabd8cfd2a338d190a581a90b528e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bdabd8cfd2a338d190a581a90b528e">&#9670;&nbsp;</a></span>emitLoopNestBody()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; &gt; tensor::ExtractSliceFromCollapseHelper::emitLoopNestBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>tileInductionVars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates the IR inside of the caller's loop nest for 1) inverting the index mappings of the ExtractSliceOp-&gt;CollapseShapeOp chain and 2) extracting the CollapseShapeOp source tensor tile for this specified iteration space point <code>tileInductionVars</code> and 3) calculating where to insert the extracted tile. </p>
<p>The returned pair consists of the results of (2) and (3) and should be used by the caller to insert into the destination tensor. </p>

<p class="definition">Definition at line <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00048">invertCollapseShapeIndexing()</a>, and <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>.</p>

</div>
</div>
<a id="ad74016ae87c5c9ef3289e5fedea9fc3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74016ae87c5c9ef3289e5fedea9fc3d">&#9670;&nbsp;</a></span>getIterationSpaceSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>&gt;&amp; mlir::tensor::ExtractSliceFromCollapseHelper::getIterationSpaceSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the upper bounds of the iteration space (with 0 offset and stride 1) required to create the desired slice. </p>
<p>Note that this is not the same as the <code>sizes</code> parameters of the ExtractSliceOp because not all dimensions of the slice are required to be tiled to form the result. </p>

<p class="definition">Definition at line <a class="el" href="TransformUtils_8h_source.html#l00184">184</a> of file <a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Dialect/Tensor/Transforms/<a class="el" href="TransformUtils_8h_source.html">TransformUtils.h</a></li>
<li>lib/Dialect/Tensor/Transforms/<a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html">ExtractSliceFromReshapeUtils.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:13 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
