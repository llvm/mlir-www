<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Linalg/Transforms/Transforms.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a href="dir_7d4534fbf0715cf3ed7975990f2820c5.html">Linalg</a></li><li class="navelem"><a href="dir_2bf7b27484b15c8c863e85164c5e8ee5.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Transforms.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;utility&gt;</code><br />
<code>#include &quot;<a class="el" href="VectorToSCF_8h_source.html">mlir/Conversion/VectorToSCF/VectorToSCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Bufferization_8h_source.html">mlir/Dialect/Bufferization/IR/Bufferization.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">mlir/Dialect/SCF/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorTransforms_8h_source.html">mlir/Dialect/Vector/Transforms/VectorTransforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2X86Vector_2Transforms_8h_source.html">mlir/Dialect/X86Vector/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
</div>
<p><a href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ABufferizeToAllocationOptions" id="r_mlir_3A_3Alinalg_3A_3ABufferizeToAllocationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">mlir::linalg::BufferizeToAllocationOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgTilingOptions" id="r_mlir_3A_3Alinalg_3A_3ALinalgTilingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">mlir::linalg::LinalgTilingOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgTilingAndFusionOptions" id="r_mlir_3A_3Alinalg_3A_3ALinalgTilingAndFusionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">mlir::linalg::LinalgTilingAndFusionOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgPaddingOptions" id="r_mlir_3A_3Alinalg_3A_3ALinalgPaddingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">mlir::linalg::LinalgPaddingOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3APadTilingInterfaceOptions" id="r_mlir_3A_3Alinalg_3A_3APadTilingInterfaceOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">mlir::linalg::PadTilingInterfaceOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgPromotionOptions" id="r_mlir_3A_3Alinalg_3A_3ALinalgPromotionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">mlir::linalg::LinalgPromotionOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ASplitReductionOptions" id="r_mlir_3A_3Alinalg_3A_3ASplitReductionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">mlir::linalg::SplitReductionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Reduction options.  <a href="structmlir_1_1linalg_1_1SplitReductionOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AControlDropUnitDims" id="r_mlir_3A_3Alinalg_3A_3AControlDropUnitDims"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">mlir::linalg::ControlDropUnitDims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to drop unit-extent dimensions from <span class="tt">linalg.generic</span> operations.  <a href="structmlir_1_1linalg_1_1ControlDropUnitDims.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADropUnitDimsResult" id="r_mlir_3A_3Alinalg_3A_3ADropUnitDimsResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">mlir::linalg::DropUnitDimsResult</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AElementwiseOpFusionResult" id="r_mlir_3A_3Alinalg_3A_3AElementwiseOpFusionResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">mlir::linalg::ElementwiseOpFusionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two <span class="tt">linalg.generic</span> operations that have a producer-consumer relationship captured through <span class="tt">fusedOperand</span>.  <a href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3APadTilingInterfaceResult" id="r_mlir_3A_3Alinalg_3A_3APadTilingInterfaceResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html">mlir::linalg::PadTilingInterfaceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations and values created in the process of padding a TilingInterface operation.  <a href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3Adetail_3A_3APackingResult" id="r_mlir_3A_3Alinalg_3A_3Adetail_3A_3APackingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html">mlir::linalg::detail::PackingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to hold the results of building a packing loop nest.  <a href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ATiledLinalgOp" id="r_mlir_3A_3Alinalg_3A_3ATiledLinalgOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">mlir::linalg::TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform standalone tiling of a single LinalgOp by <span class="tt">tileSizes</span>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3APromotionInfo" id="r_mlir_3A_3Alinalg_3A_3APromotionInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">mlir::linalg::PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer using the <span class="tt">allocationFn</span> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AVectorizationResult" id="r_mlir_3A_3Alinalg_3A_3AVectorizationResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">mlir::linalg::VectorizationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after vectorizing.  <a href="structmlir_1_1linalg_1_1VectorizationResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3Adetail_3A_3AMultiSizeSpecificationBase_3C_20T_20_3E" id="r_mlir_3A_3Alinalg_3A_3Adetail_3A_3AMultiSizeSpecificationBase_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1MultiSizeSpecificationBase.html">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3Adetail_3A_3AContinuousTileSizeSpecificationBase_3C_20T_20_3E" id="r_mlir_3A_3Alinalg_3A_3Adetail_3A_3AContinuousTileSizeSpecificationBase_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1ContinuousTileSizeSpecificationBase.html">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AMultiSizeSpecification" id="r_mlir_3A_3Alinalg_3A_3AMultiSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">mlir::linalg::MultiSizeSpecification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a multi-size tiling comprising tile sizes and numbers of tiles, expressed as Values which may or may not be constant.  <a href="structmlir_1_1linalg_1_1MultiSizeSpecification.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AStaticMultiSizeSpecification" id="r_mlir_3A_3Alinalg_3A_3AStaticMultiSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">mlir::linalg::StaticMultiSizeSpecification</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AContinuousTileSizeSpecification" id="r_mlir_3A_3Alinalg_3A_3AContinuousTileSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">mlir::linalg::ContinuousTileSizeSpecification</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AStaticContinuousTileSizeSpecification" id="r_mlir_3A_3Alinalg_3A_3AStaticContinuousTileSizeSpecification"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">mlir::linalg::StaticContinuousTileSizeSpecification</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AForallReductionTilingResult" id="r_mlir_3A_3Alinalg_3A_3AForallReductionTilingResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">mlir::linalg::ForallReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ASplitReductionResult" id="r_mlir_3A_3Alinalg_3A_3ASplitReductionResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">mlir::linalg::SplitReductionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to split the single linalg op reduction into a parallel and reduction dimension.  <a href="structmlir_1_1linalg_1_1SplitReductionResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ACollapseResult" id="r_mlir_3A_3Alinalg_3A_3ACollapseResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">mlir::linalg::CollapseResult</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALowerPackResult" id="r_mlir_3A_3Alinalg_3A_3ALowerPackResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">mlir::linalg::LowerPackResult</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALowerUnPackOpResult" id="r_mlir_3A_3Alinalg_3A_3ALowerUnPackOpResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">mlir::linalg::LowerUnPackOpResult</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3APackResult" id="r_mlir_3A_3Alinalg_3A_3APackResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackResult.html">mlir::linalg::PackResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <span class="tt">pack</span> call.  <a href="structmlir_1_1linalg_1_1PackResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3APackTransposeResult" id="r_mlir_3A_3Alinalg_3A_3APackTransposeResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">mlir::linalg::PackTransposeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <span class="tt">packTranspose</span> call.  <a href="structmlir_1_1linalg_1_1PackTransposeResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ABlockPackMatmulOptions" id="r_mlir_3A_3Alinalg_3A_3ABlockPackMatmulOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">mlir::linalg::BlockPackMatmulOptions</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADownscaleSizeOneWindowed2DConvolution_3C_20Conv2DOp_2C_20Conv1DOp_20_3E" id="r_mlir_3A_3Alinalg_3A_3ADownscaleSizeOneWindowed2DConvolution_3C_20Conv2DOp_2C_20Conv1DOp_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D convolution ops with size-1 window dimensions into 1-D convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADownscaleDepthwiseConv2DNhwcHwcOp" id="r_mlir_3A_3Alinalg_3A_3ADownscaleDepthwiseConv2DNhwcHwcOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D depthwise convolution ops with size-1 (w, kw) or (h, kh) dimensions into 1-D depthwise convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADownscaleConv2DOp" id="r_mlir_3A_3Alinalg_3A_3ADownscaleConv2DOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleConv2DOp.html">mlir::linalg::DownscaleConv2DOp</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgGeneralizationPattern" id="r_mlir_3A_3Alinalg_3A_3ALinalgGeneralizationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">mlir::linalg::LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgSpecializationPattern" id="r_mlir_3A_3Alinalg_3A_3ALinalgSpecializationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgSpecializationPattern.html">mlir::linalg::LinalgSpecializationPattern</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ACopyVectorizationPattern" id="r_mlir_3A_3Alinalg_3A_3ACopyVectorizationPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html">mlir::linalg::CopyVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization pattern for memref::CopyOp.  <a href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADecomposePadOpPattern" id="r_mlir_3A_3Alinalg_3A_3ADecomposePadOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html">mlir::linalg::DecomposePadOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADecomposeOuterUnitDimsPackOpPattern" id="r_mlir_3A_3Alinalg_3A_3ADecomposeOuterUnitDimsPackOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html">mlir::linalg::DecomposeOuterUnitDimsPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::PackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ADecomposeOuterUnitDimsUnPackOpPattern" id="r_mlir_3A_3Alinalg_3A_3ADecomposeOuterUnitDimsUnPackOpPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::UnPackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgCopyVTRForwardingPattern" id="r_mlir_3A_3Alinalg_3A_3ALinalgCopyVTRForwardingPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">mlir::linalg::LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3ALinalgCopyVTWForwardingPattern" id="r_mlir_3A_3Alinalg_3A_3ALinalgCopyVTWForwardingPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">mlir::linalg::LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3AExtractSliceOfPadTensorSwapPattern" id="r_mlir_3A_3Alinalg_3A_3AExtractSliceOfPadTensorSwapPattern"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">mlir::linalg::ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(tensor.pad(x)) into tensor.pad(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Abufferization" id="r_mlir_3A_3Abufferization"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">mlir::bufferization</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg" id="r_mlir_3A_3Alinalg"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">mlir::linalg</a></td></tr>
<tr class="memitem:mlir_3A_3Alinalg_3A_3Adetail" id="r_mlir_3A_3Alinalg_3A_3Adetail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">mlir::linalg::detail</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a71a7fe9b3e7ece0cd20b6d4d11e08f6c" id="r_a71a7fe9b3e7ece0cd20b6d4d11e08f6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a71a7fe9b3e7ece0cd20b6d4d11e08f6c">mlir::linalg::TileSizeComputationFunction</a></td></tr>
<tr class="memitem:a9ada278f74ee670af18b6bfd04271e3b" id="r_a9ada278f74ee670af18b6bfd04271e3b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9ada278f74ee670af18b6bfd04271e3b">mlir::linalg::AllocBufferCallbackFn</a></td></tr>
<tr class="memdesc:a9ada278f74ee670af18b6bfd04271e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <span class="tt">subView</span>.  <br /></td></tr>
<tr class="memitem:abaf9a66d9ea1e1ccf22b88fd5f1446dc" id="r_abaf9a66d9ea1e1ccf22b88fd5f1446dc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abaf9a66d9ea1e1ccf22b88fd5f1446dc">mlir::linalg::DeallocBufferCallbackFn</a></td></tr>
<tr class="memdesc:abaf9a66d9ea1e1ccf22b88fd5f1446dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <br /></td></tr>
<tr class="memitem:ae5b803f6d2ca1c42dc889264b80b690e" id="r_ae5b803f6d2ca1c42dc889264b80b690e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae5b803f6d2ca1c42dc889264b80b690e">mlir::linalg::CopyCallbackFn</a></td></tr>
<tr class="memdesc:ae5b803f6d2ca1c42dc889264b80b690e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <br /></td></tr>
<tr class="memitem:a505f71c7a182531357360cb2151dc1f3" id="r_a505f71c7a182531357360cb2151dc1f3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a505f71c7a182531357360cb2151dc1f3">mlir::linalg::ControlSplitReductionFn</a></td></tr>
<tr class="memdesc:a505f71c7a182531357360cb2151dc1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature to control reduction splitting.  <br /></td></tr>
<tr class="memitem:a193831e3afcf32c859a980c17c8c276b" id="r_a193831e3afcf32c859a980c17c8c276b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a193831e3afcf32c859a980c17c8c276b">mlir::linalg::LinalgLoops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, 4&gt;</td></tr>
<tr class="memitem:a0752c7523022c2c98068a86865e35096" id="r_a0752c7523022c2c98068a86865e35096"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0752c7523022c2c98068a86865e35096">mlir::linalg::DroppedUnitDimsBuilder</a></td></tr>
<tr class="memitem:a1f5ce0fcb27f388f81435ec80109e7c6" id="r_a1f5ce0fcb27f388f81435ec80109e7c6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1f5ce0fcb27f388f81435ec80109e7c6">mlir::linalg::PadSizeComputationFunction</a></td></tr>
<tr class="memitem:ac63ef3b10f63a46b5d07ad3cbf2ed19d" id="r_ac63ef3b10f63a46b5d07ad3cbf2ed19d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac63ef3b10f63a46b5d07ad3cbf2ed19d">mlir::linalg::LoopIndexToRangeIndexMap</a> = <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;int, int&gt;</td></tr>
<tr class="memdesc:ac63ef3b10f63a46b5d07ad3cbf2ed19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a number of ranges equal to the number of non-zero in <span class="tt">tileSizes</span>.  <br /></td></tr>
<tr class="memitem:a41903a6655e9be09920ce399e3e71865" id="r_a41903a6655e9be09920ce399e3e71865"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a41903a6655e9be09920ce399e3e71865">mlir::linalg::ControlBlockPackMatmulFn</a></td></tr>
<tr class="memdesc:a41903a6655e9be09920ce399e3e71865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control matmul packing.  <br /></td></tr>
<tr class="memitem:aa58f7a4c578e94b49e8c3f62f968d7b4" id="r_aa58f7a4c578e94b49e8c3f62f968d7b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa58f7a4c578e94b49e8c3f62f968d7b4">mlir::linalg::OptimizeCopyFn</a></td></tr>
<tr class="memitem:a9f4136d97cdab12f0760756f1adc1721" id="r_a9f4136d97cdab12f0760756f1adc1721"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9f4136d97cdab12f0760756f1adc1721">mlir::linalg::ControlFusionFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)&gt;</td></tr>
<tr class="memdesc:a9f4136d97cdab12f0760756f1adc1721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <br /></td></tr>
<tr class="memitem:ac7e80c46fd448c104f6709b43c315755" id="r_ac7e80c46fd448c104f6709b43c315755"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac7e80c46fd448c104f6709b43c315755">mlir::linalg::ControlPropagationFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:ac7e80c46fd448c104f6709b43c315755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control propagation of <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <br /></td></tr>
<tr class="memitem:a56475069e4631a3e7e54964a3fc576bb" id="r_a56475069e4631a3e7e54964a3fc576bb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a56475069e4631a3e7e54964a3fc576bb">mlir::linalg::GetCollapsableDimensionsFn</a></td></tr>
<tr class="memdesc:a56475069e4631a3e7e54964a3fc576bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type to control generic op dimension collapsing.  <br /></td></tr>
<tr class="memitem:abf9a441fc28af495ff61ceedd25694d2" id="r_abf9a441fc28af495ff61ceedd25694d2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abf9a441fc28af495ff61ceedd25694d2">mlir::linalg::ControlFoldIntoPackUnpackFn</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *opOperand)&gt;</td></tr>
<tr class="memdesc:abf9a441fc28af495ff61ceedd25694d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control folding operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae27267a4634c46beba8c9f55c14cdfa1" id="r_ae27267a4634c46beba8c9f55c14cdfa1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; vector::CombiningKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">mlir::linalg::getCombinerOpKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *combinerOp)</td></tr>
<tr class="memdesc:ae27267a4634c46beba8c9f55c14cdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector::CombiningKind for the given op.  <br /></td></tr>
<tr class="memitem:a300387e92135ddafe3e8fcb45a1d0f4c" id="r_a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, tensor::PadOp padOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination.  <br /></td></tr>
<tr class="memitem:a2b6184483164da0417ac58d1d5086bbc" id="r_a2b6184483164da0417ac58d1d5086bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2b6184483164da0417ac58d1d5086bbc">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, vector::MaskOp maskOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a2b6184483164da0417ac58d1d5086bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region.  <br /></td></tr>
<tr class="memitem:a73274fcc2e8e228f5f44c6336b96e7b7" id="r_a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a73274fcc2e8e228f5f44c6336b96e7b7">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, bufferization::AllocTensorOp allocTensorOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store.  <br /></td></tr>
<tr class="memitem:a72d0ebe64f6077953145c8111cc3d955" id="r_a72d0ebe64f6077953145c8111cc3d955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72d0ebe64f6077953145c8111cc3d955">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const <a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">BufferizeToAllocationOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a72d0ebe64f6077953145c8111cc3d955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer.  <br /></td></tr>
<tr class="memitem:a7b7f777c5538e35bbdd3aaabdb07e6f7" id="r_a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7b7f777c5538e35bbdd3aaabdb07e6f7">mlir::linalg::linalgOpAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <span class="tt">op</span> that are anchored on a LinalgOp.  <br /></td></tr>
<tr class="memitem:a8fa220da60546acce7c4a8b3635d5b21" id="r_a8fa220da60546acce7c4a8b3635d5b21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">mlir::linalg::areElementwiseOpsFusable</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a8fa220da60546acce7c4a8b3635d5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <span class="tt">linalg.generic</span> operations with producer/consumer relationship through <span class="tt">fusedOperand</span> can be fused using elementwise op fusion.  <br /></td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88" id="r_a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">mlir::linalg::promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote memref.subviews feeding linalg-on-buffers operations.  <br /></td></tr>
<tr class="memitem:a8d0310adee4f127279f9147a71db0181" id="r_a8d0310adee4f127279f9147a71db0181"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8d0310adee4f127279f9147a71db0181">mlir::linalg::vectorizeOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputScalableVecDims={}, <a class="el" href="classbool.html">bool</a> vectorizeNDExtract=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> flatten1DDepthwiseConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a8d0310adee4f127279f9147a71db0181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return success if the operation can be vectorized.  <br /></td></tr>
<tr class="memitem:ac980878e4ea40184d0a2183288fd0f61" id="r_ac980878e4ea40184d0a2183288fd0f61"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac980878e4ea40184d0a2183288fd0f61">mlir::linalg::dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, IndexingMapOpInterface op, const <a class="el" href="namespacemlir_1_1linalg.html#a0752c7523022c2c98068a86865e35096">DroppedUnitDimsBuilder</a> &amp;droppedUnitDimsBuilder, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a5b6d6c0f10b756281634aebb9f69d5dd" id="r_a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5b6d6c0f10b756281634aebb9f69d5dd">mlir::linalg::dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a4ceec493e0b40673125a0402c3cf78e4" id="r_a4ceec493e0b40673125a0402c3cf78e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ceec493e0b40673125a0402c3cf78e4">mlir::linalg::fuseElementwiseOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memitem:a4f70173e3ee102c2077ef5cdf5908001" id="r_a4f70173e3ee102c2077ef5cdf5908001"><td class="memItemLeft" align="right" valign="top">llvm::SmallDenseSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f70173e3ee102c2077ef5cdf5908001">mlir::linalg::getPreservedProducerResults</a> (GenericOp producer, GenericOp consumer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a4f70173e3ee102c2077ef5cdf5908001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of indices of the producer's results which would be preserved after the fusion.  <br /></td></tr>
<tr class="memitem:ae273bd1d7e48f4503eefba4f1487fa56" id="r_ae273bd1d7e48f4503eefba4f1487fa56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">mlir::linalg::peelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae273bd1d7e48f4503eefba4f1487fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to peel and canonicalize loop <span class="tt">op</span> and return the new result.  <br /></td></tr>
<tr class="memitem:a5faa18744febf8ff36b38176ca04d8fc" id="r_a5faa18744febf8ff36b38176ca04d8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">mlir::linalg::peelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5faa18744febf8ff36b38176ca04d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant.  <br /></td></tr>
<tr class="memitem:a08d1dafbd1447fdcbad0e11434292563" id="r_a08d1dafbd1447fdcbad0e11434292563"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08d1dafbd1447fdcbad0e11434292563">mlir::linalg::rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp opToPad, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, LinalgOp &amp;paddedOp, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;replacements, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps)</td></tr>
<tr class="memdesc:a08d1dafbd1447fdcbad0e11434292563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <span class="tt">options.paddingDimensions</span> of all <span class="tt">opToPad</span> operands to a static bounding box.  <br /></td></tr>
<tr class="memitem:a629d4548e517e8d9bfcdadacbc4d91fe" id="r_a629d4548e517e8d9bfcdadacbc4d91fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a629d4548e517e8d9bfcdadacbc4d91fe">mlir::linalg::computePaddedShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="namespacemlir.html#a864cb5eb1fea4a548c28cda535ba7213">TypedValue</a>&lt; RankedTensorType &gt; v, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indexingSizes, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a629d4548e517e8d9bfcdadacbc4d91fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the padded shape of the given value <span class="tt">v</span> of <span class="tt">RankedTensorType</span> given:  <br /></td></tr>
<tr class="memitem:aa357f78e61caac5bae1dad723393734a" id="r_aa357f78e61caac5bae1dad723393734a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa357f78e61caac5bae1dad723393734a">mlir::linalg::computeIndexingMapOpInterfacePaddedShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operandToPad, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;)</td></tr>
<tr class="memdesc:aa357f78e61caac5bae1dad723393734a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific helper for Linalg ops.  <br /></td></tr>
<tr class="memitem:a402b2b94588021b9d4c088f351c35c69" id="r_a402b2b94588021b9d4c088f351c35c69"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceResult.html">PadTilingInterfaceResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a402b2b94588021b9d4c088f351c35c69">mlir::linalg::rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, TilingInterface toPad, <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a1f5ce0fcb27f388f81435ec80109e7c6">PadSizeComputationFunction</a> &amp;=&amp;<a class="el" href="namespacemlir_1_1linalg.html#aa357f78e61caac5bae1dad723393734a">computeIndexingMapOpInterfacePaddedShape</a>)</td></tr>
<tr class="memdesc:a402b2b94588021b9d4c088f351c35c69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions of <span class="tt">toPad</span>.  <br /></td></tr>
<tr class="memitem:a856aa97fd05237472be94700af2b3312" id="r_a856aa97fd05237472be94700af2b3312"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html">PackingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a856aa97fd05237472be94700af2b3312">mlir::linalg::detail::buildPackingLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, scf::ForOp outermostEnclosingForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector)</td></tr>
<tr class="memdesc:a856aa97fd05237472be94700af2b3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the packing loop nest required to hoist <span class="tt">opToHoist</span> above <span class="tt">outermostEnclosingForOp</span>.  <br /></td></tr>
<tr class="memitem:a344a0fa8893af22df90d795e19c1a713" id="r_a344a0fa8893af22df90d795e19c1a713"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a344a0fa8893af22df90d795e19c1a713">mlir::linalg::hoistPaddingOnTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, <a class="el" href="classint64__t.html">int64_t</a> numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:a344a0fa8893af22df90d795e19c1a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <span class="tt">numLoops</span> into a new, generally larger tensor.  <br /></td></tr>
<tr class="memitem:ac1d7ae638195a0c07357a33d4b8cfec0" id="r_ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1d7ae638195a0c07357a33d4b8cfec0">mlir::linalg::hoistPaddingOnTensors</a> (tensor::PadOp opToHoist, <a class="el" href="classint64__t.html">int64_t</a> numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <span class="tt">hoistPaddingOnTensors</span> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <br /></td></tr>
<tr class="memitem:aad04f1a354ddbbdec275dd9afd45bdce" id="r_aad04f1a354ddbbdec275dd9afd45bdce"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad04f1a354ddbbdec275dd9afd45bdce">mlir::linalg::padAndHoistLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:aad04f1a354ddbbdec275dd9afd45bdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply padding and hoisting to <span class="tt">linalgOp</span> according to the configuration specified in <span class="tt">options</span>.  <br /></td></tr>
<tr class="memitem:af025e45095e64f984901c4f65fa3c72f" id="r_af025e45095e64f984901c4f65fa3c72f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; TilingInterface, TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">mlir::linalg::splitOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> splitPoint)</td></tr>
<tr class="memdesc:af025e45095e64f984901c4f65fa3c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given <span class="tt">op</span> into two parts along the given iteration space <span class="tt">dimension</span> at the specified <span class="tt">splitPoint</span>, and return the two parts.  <br /></td></tr>
<tr class="memitem:ac13050e75a64a26bf82a80b19006d0e9" id="r_ac13050e75a64a26bf82a80b19006d0e9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac13050e75a64a26bf82a80b19006d0e9">mlir::linalg::tileLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a8dcc62e199cdb1863a3d6f30e4dc317a" id="r_a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">mlir::linalg::interchangeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; interchangeVector)</td></tr>
<tr class="memdesc:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange the <span class="tt">iterator_types</span> and <span class="tt">iterator_maps</span> dimensions and adapts the index accesses of <span class="tt">op</span>.  <br /></td></tr>
<tr class="memitem:a7fc28f76b6a2798611e0008260ae388d" id="r_a7fc28f76b6a2798611e0008260ae388d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7fc28f76b6a2798611e0008260ae388d">mlir::linalg::generalizeNamedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7fc28f76b6a2798611e0008260ae388d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GenericOp from the given named operation <span class="tt">linalgOp</span> and replace the given <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a3be344205769eaea42d412b4c0fae11a" id="r_a3be344205769eaea42d412b4c0fae11a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3be344205769eaea42d412b4c0fae11a">mlir::linalg::specializeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp)</td></tr>
<tr class="memdesc:a3be344205769eaea42d412b4c0fae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namedOp from the given GenericOp and replace the GenericOp.  <br /></td></tr>
<tr class="memitem:a4ed54a24fbd0044060290027188db5c0" id="r_a4ed54a24fbd0044060290027188db5c0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ed54a24fbd0044060290027188db5c0">mlir::linalg::promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, <a class="el" href="classbool.html">bool</a> useOriginalSubviewSize, const <a class="el" href="namespacemlir_1_1linalg.html#a9ada278f74ee670af18b6bfd04271e3b">AllocBufferCallbackFn</a> &amp;allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="memitem:acd639dc165f0ab64ec7afbac992c4d65" id="r_acd639dc165f0ab64ec7afbac992c4d65"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">mlir::linalg::promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:acd639dc165f0ab64ec7afbac992c4d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <span class="tt">subViews</span> into a new buffer allocated at the insertion point <span class="tt">b</span>.  <br /></td></tr>
<tr class="memitem:a266200755192d09deb827c799e59277b" id="r_a266200755192d09deb827c799e59277b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">mlir::linalg::allocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a266200755192d09deb827c799e59277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU workgroup memory.  <br /></td></tr>
<tr class="memitem:ad6babd80190e8df26f441fca7d2fbe31" id="r_ad6babd80190e8df26f441fca7d2fbe31"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">mlir::linalg::deallocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:ad6babd80190e8df26f441fca7d2fbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU group memory there is no need to deallocate.  <br /></td></tr>
<tr class="memitem:a72fb3984f986840e0dc914c1ab90dc3b" id="r_a72fb3984f986840e0dc914c1ab90dc3b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">mlir::linalg::copyToWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a72fb3984f986840e0dc914c1ab90dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity.  <br /></td></tr>
<tr class="memitem:a5606dfca8a9078fc6bc9b74972f15fdc" id="r_a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">mlir::linalg::allocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU private memory.  <br /></td></tr>
<tr class="memitem:a88359f69353831d971485ff6b6b86dc1" id="r_a88359f69353831d971485ff6b6b86dc1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">mlir::linalg::copyToGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a88359f69353831d971485ff6b6b86dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal copy to between src and dst.  <br /></td></tr>
<tr class="memitem:a487d4430e8217b1dabc50cb28bb93342" id="r_a487d4430e8217b1dabc50cb28bb93342"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">mlir::linalg::deallocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a487d4430e8217b1dabc50cb28bb93342"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope.  <br /></td></tr>
<tr class="memitem:a142a09c03dbaa0d795e44f62d4b6b395" id="r_a142a09c03dbaa0d795e44f62d4b6b395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a142a09c03dbaa0d795e44f62d4b6b395">mlir::linalg::hasVectorizationImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)</td></tr>
<tr class="memdesc:a142a09c03dbaa0d795e44f62d4b6b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise.  <br /></td></tr>
<tr class="memitem:a303bb59c046a82276569e6b906002997" id="r_a303bb59c046a82276569e6b906002997"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a303bb59c046a82276569e6b906002997">mlir::linalg::vectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classbool.html">bool</a> &gt; inputScalableVecDims={}, <a class="el" href="classbool.html">bool</a> vectorizeNDExtract=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> flatten1DDepthwiseConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> assumeDynamicDimsMatchVecSizes=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classbool.html">bool</a> createNamedContraction=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a303bb59c046a82276569e6b906002997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <span class="tt"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></span> containing the results of the vectorized op, or failure if the transformation fails.  <br /></td></tr>
<tr class="memitem:a8c63bc9239511b70751c238a12f5b1da" id="r_a8c63bc9239511b70751c238a12f5b1da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">mlir::linalg::vectorizeCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, memref::CopyOp copyOp)</td></tr>
<tr class="memdesc:a8c63bc9239511b70751c238a12f5b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Copy op with fully static shape.  <br /></td></tr>
<tr class="memitem:a7edd4be30bfb8af9bc8e486f8368c1e2" id="r_a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">mlir::linalg::linalgOpToLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">scf.for</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:aff809877c1d119dae06d06a8bad953e4" id="r_aff809877c1d119dae06d06a8bad953e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">mlir::linalg::linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aff809877c1d119dae06d06a8bad953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">scf.parallel</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a95f289e066dcbb7844bd444c0880fc36" id="r_a95f289e066dcbb7844bd444c0880fc36"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a193831e3afcf32c859a980c17c8c276b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">mlir::linalg::linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a95f289e066dcbb7844bd444c0880fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <span class="tt">affine.for</span> with the proper body for <span class="tt">linalgOp</span>.  <br /></td></tr>
<tr class="memitem:a8144efefcad502e511c24aa5ce5b36e8" id="r_a8144efefcad502e511c24aa5ce5b36e8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8144efefcad502e511c24aa5ce5b36e8">mlir::linalg::makeTiledLoopRanges</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allShapeSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allTileSizes)</td></tr>
<tr class="memitem:af8ef5fd09c3c79a47b8c4732ace79928" id="r_af8ef5fd09c3c79a47b8c4732ace79928"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">mlir::linalg::computeMultiTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> divisor, <a class="el" href="classbool.html">bool</a> emitAssertions=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:af8ef5fd09c3c79a47b8c4732ace79928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <span class="tt">targetSize</span>, each divisible by <span class="tt">sizeDivisor</span>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <span class="tt">dimension</span> of the structured <span class="tt">op</span>.  <br /></td></tr>
<tr class="memitem:a91c1fb37672289a396df9c95a9b1dd0b" id="r_a91c1fb37672289a396df9c95a9b1dd0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a91c1fb37672289a396df9c95a9b1dd0b">mlir::linalg::computeStaticMultiTileSizes</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classint64__t.html">int64_t</a> targetSize, <a class="el" href="classint64__t.html">int64_t</a> divisor)</td></tr>
<tr class="memitem:aa3cdafc77c113c1fa2db8782dc0bdb29" id="r_aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa3cdafc77c113c1fa2db8782dc0bdb29">mlir::linalg::computeStaticContinuousTileSizes</a> (LinalgOp op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classunsigned.html">unsigned</a> targetSize)</td></tr>
<tr class="memitem:aa18c5afa193d9ff81a24877f1087fec4" id="r_aa18c5afa193d9ff81a24877f1087fec4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa18c5afa193d9ff81a24877f1087fec4">mlir::linalg::computeContinuousTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, TilingInterface op, <a class="el" href="classunsigned.html">unsigned</a> dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classbool.html">bool</a> emitAssertions)</td></tr>
<tr class="memitem:ab3085a8dbbf3c572b3279bdcc53dbe72" id="r_ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">mlir::linalg::tileReductionUsingForall</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes={}, std::optional&lt; <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> &gt; mapping=std::nullopt)</td></tr>
<tr class="memdesc:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction to parallel iterations computing partial reductions.  <br /></td></tr>
<tr class="memitem:a1b2368f6f815597fcf395106e8978e44" id="r_a1b2368f6f815597fcf395106e8978e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">mlir::linalg::transformIndexOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs, const <a class="el" href="namespacemlir_1_1linalg.html#ac63ef3b10f63a46b5d07ad3cbf2ed19d">LoopIndexToRangeIndexMap</a> &amp;loopIndexToRangeIndex)</td></tr>
<tr class="memdesc:a1b2368f6f815597fcf395106e8978e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">All indices returned by IndexOp should be invariant with respect to tiling.  <br /></td></tr>
<tr class="memitem:aaa4f58f6a18fb7c9af60fb15122e0994" id="r_aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaa4f58f6a18fb7c9af60fb15122e0994">mlir::linalg::splitReduction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:af87c3f5c965b8e271579136775d51ffc" id="r_af87c3f5c965b8e271579136775d51ffc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">mlir::linalg::splitReductionByScaling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:af87c3f5c965b8e271579136775d51ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling-based implementation of the split reduction transformation.  <br /></td></tr>
<tr class="memitem:a31426a6a1dc69e5819138ba53c6e7ef9" id="r_a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a31426a6a1dc69e5819138ba53c6e7ef9">mlir::linalg::isDimSequencePreserved</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a> dimSequence)</td></tr>
<tr class="memdesc:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <span class="tt">true</span> if a given sequence of dimensions are contiguous in the range of the specified indexing map.  <br /></td></tr>
<tr class="memitem:a133a3ec0d7cd50a886d2cd558fdc9030" id="r_a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a133a3ec0d7cd50a886d2cd558fdc9030">mlir::linalg::areDimSequencesPreserved</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; dimSequences)</td></tr>
<tr class="memdesc:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <span class="tt">true</span> if all sequences of dimensions specified in <span class="tt">dimSequences</span> are contiguous in all the ranges of the <span class="tt">maps</span>.  <br /></td></tr>
<tr class="memitem:ae6a3be2f9306a873810377797b78bfc6" id="r_ae6a3be2f9306a873810377797b78bfc6"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae6a3be2f9306a873810377797b78bfc6">mlir::linalg::collapseOpIterationDims</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; foldedIterationDims, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ae6a3be2f9306a873810377797b78bfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses dimensions of linalg.generic/linalg.copy operation.  <br /></td></tr>
<tr class="memitem:afebe4a9f3b87bb8f196bf2d577511a05" id="r_afebe4a9f3b87bb8f196bf2d577511a05"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afebe4a9f3b87bb8f196bf2d577511a05">mlir::linalg::lowerPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, <a class="el" href="classbool.html">bool</a> lowerPadLikeWithInsertSlice=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:afebe4a9f3b87bb8f196bf2d577511a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as pad + reshape + transpose.  <br /></td></tr>
<tr class="memitem:a3cea34f55211c79271dff09bb07c3279" id="r_a3cea34f55211c79271dff09bb07c3279"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cea34f55211c79271dff09bb07c3279">mlir::linalg::lowerUnPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::UnPackOp unPackOp, <a class="el" href="classbool.html">bool</a> lowerUnpadLikeWithExtractSlice=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a3cea34f55211c79271dff09bb07c3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as empty + transpose + reshape + extract_slice.  <br /></td></tr>
<tr class="memitem:abd29d6299d2891ae1d092974bc1c4e30" id="r_abd29d6299d2891ae1d092974bc1c4e30"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">mlir::linalg::pack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; packedSizes)</td></tr>
<tr class="memdesc:abd29d6299d2891ae1d092974bc1c4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement packing of a single LinalgOp by <span class="tt">packedSizes</span>.  <br /></td></tr>
<tr class="memitem:a26e3825819b0563bb199218baf11ca73" id="r_a26e3825819b0563bb199218baf11ca73"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a26e3825819b0563bb199218baf11ca73">mlir::linalg::packTranspose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, linalg::LinalgOp linalgOp, linalg::UnPackOp maybeUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; outerPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; innerPerm)</td></tr>
<tr class="memdesc:a26e3825819b0563bb199218baf11ca73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements.  <br /></td></tr>
<tr class="memitem:ab3567489d885b34059aa8286957de564" id="r_ab3567489d885b34059aa8286957de564"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3567489d885b34059aa8286957de564">mlir::linalg::packMatmulGreedily</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mnkPackedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mnkPaddedSizesNextMultipleOf, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mnkOrder)</td></tr>
<tr class="memdesc:ab3567489d885b34059aa8286957de564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension.  <br /></td></tr>
<tr class="memitem:a5ca967d8e0b6ff895d26faaf60a79263" id="r_a5ca967d8e0b6ff895d26faaf60a79263"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5ca967d8e0b6ff895d26faaf60a79263">mlir::linalg::blockPackMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, const <a class="el" href="namespacemlir_1_1linalg.html#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;controlPackMatmul)</td></tr>
<tr class="memdesc:a5ca967d8e0b6ff895d26faaf60a79263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a matmul operation into blocked 4D layout.  <br /></td></tr>
<tr class="memitem:a5a579fdd0e468c7aec96f84d016c829e" id="r_a5a579fdd0e468c7aec96f84d016c829e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::FromElementsOp fromElementsOp)</td></tr>
<tr class="memdesc:a5a579fdd0e468c7aec96f84d016c829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.from_elements to linalg.generic.  <br /></td></tr>
<tr class="memitem:ab2e500c4bf906d65572af9b3d2982852" id="r_ab2e500c4bf906d65572af9b3d2982852"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::GenerateOp generateOp)</td></tr>
<tr class="memdesc:ab2e500c4bf906d65572af9b3d2982852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.generate to linalg.generic.  <br /></td></tr>
<tr class="memitem:acf3e743297fd7a20a30c7c4e39608fbc" id="r_acf3e743297fd7a20a30c7c4e39608fbc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp)</td></tr>
<tr class="memdesc:acf3e743297fd7a20a30c7c4e39608fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.pad to linalg.generic + tensor.insert_slice.  <br /></td></tr>
<tr class="memitem:a0e2c1f265ce47a53398eab6e8f18b30c" id="r_a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">mlir::linalg::rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcHwcfOp convOp)</td></tr>
<tr class="memdesc:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul.  <br /></td></tr>
<tr class="memitem:a7efbd1a00187259d6074a842842175c2" id="r_a7efbd1a00187259d6074a842842175c2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7efbd1a00187259d6074a842842175c2">mlir::linalg::rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp convOp)</td></tr>
<tr class="memdesc:a7efbd1a00187259d6074a842842175c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the above but for Fhwc channel orderings in the filter.  <br /></td></tr>
<tr class="memitem:a49f61511bb9ed963c3eeb360bfdb1a6a" id="r_a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">mlir::linalg::rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::DepthwiseConv2DNhwcHwcOp convOp)</td></tr>
<tr class="memdesc:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product.  <br /></td></tr>
<tr class="memitem:ad43dfb86d76bed86ecd1117849e5b6f4" id="r_ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">mlir::linalg::rewriteInIm2Col</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNchwFchwOp convOp)</td></tr>
<tr class="memdesc:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed.  <br /></td></tr>
<tr class="memitem:a6ea35f9b824fbdf551b76ddf974fc418" id="r_a6ea35f9b824fbdf551b76ddf974fc418"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ea35f9b824fbdf551b76ddf974fc418">mlir::linalg::transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op)</td></tr>
<tr class="memdesc:a6ea35f9b824fbdf551b76ddf974fc418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose.  <br /></td></tr>
<tr class="memitem:ada14eab9218f7ff7f15f695a980fb717" id="r_ada14eab9218f7ff7f15f695a980fb717"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada14eab9218f7ff7f15f695a980fb717">mlir::linalg::transposeConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcQOp op)</td></tr>
<tr class="memitem:ad8836bfb07ad8fc4f7bda9aa174da988" id="r_ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad8836bfb07ad8fc4f7bda9aa174da988">mlir::linalg::transposeMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::MatmulOp op, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Linalg matmul ops to transposed variants.  <br /></td></tr>
<tr class="memitem:a816f67d5546592d18de9ec5de0e791f3" id="r_a816f67d5546592d18de9ec5de0e791f3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a816f67d5546592d18de9ec5de0e791f3">mlir::linalg::transposeBatchMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::BatchMatmulOp op, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a816f67d5546592d18de9ec5de0e791f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.  <br /></td></tr>
<tr class="memitem:a6e047772994b241ad2de48dfc28d7340" id="r_a6e047772994b241ad2de48dfc28d7340"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6e047772994b241ad2de48dfc28d7340">mlir::linalg::winogradConv2D</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a6e047772994b241ad2de48dfc28d7340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r).  <br /></td></tr>
<tr class="memitem:a22cf4ae6a6c9f8d82a3d3f13e55100c3" id="r_a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a22cf4ae6a6c9f8d82a3d3f13e55100c3">mlir::linalg::decomposeWinogradFilterTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradFilterTransformOp op)</td></tr>
<tr class="memdesc:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_filter_transform.  <br /></td></tr>
<tr class="memitem:ae75908ded36f97719f77c8b56ed859ef" id="r_ae75908ded36f97719f77c8b56ed859ef"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae75908ded36f97719f77c8b56ed859ef">mlir::linalg::decomposeWinogradInputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradInputTransformOp op)</td></tr>
<tr class="memdesc:ae75908ded36f97719f77c8b56ed859ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_input_transform.  <br /></td></tr>
<tr class="memitem:a49f2f00a0e17dbbec5198127ee3151ba" id="r_a49f2f00a0e17dbbec5198127ee3151ba"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f2f00a0e17dbbec5198127ee3151ba">mlir::linalg::decomposeWinogradOutputTransformOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::WinogradOutputTransformOp op)</td></tr>
<tr class="memdesc:a49f2f00a0e17dbbec5198127ee3151ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_output_transform.  <br /></td></tr>
<tr class="memitem:a88467664ee2ebeb70bc1a2c3d5876a9c" id="r_a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; linalg::GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88467664ee2ebeb70bc1a2c3d5876a9c">mlir::linalg::deduplicateOperandsAndRemoveDeadResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::GenericOp genericOp, <a class="el" href="classbool.html">bool</a> removeOutputs)</td></tr>
<tr class="memdesc:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to deduplicate operands and remove dead results of <span class="tt">linalg.generic</span> operations.  <br /></td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e" id="r_ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">mlir::linalg::getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <br /></td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e" id="r_a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">mlir::linalg::populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memitem:ada9bb5c9c8ef1aadbbc563431443b5e2" id="r_ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <br /></td></tr>
<tr class="memitem:adc9ad663f56317f953958cb9434bd8fc" id="r_adc9ad663f56317f953958cb9434bd8fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#adc9ad663f56317f953958cb9434bd8fc">mlir::linalg::populateLinalgGenericOpsSpecializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:adc9ad663f56317f953958cb9434bd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns to convert linalg.generic ops to named ops where possible.  <br /></td></tr>
<tr class="memitem:ae12537adb2614537d3d6d5db2612629f" id="r_ae12537adb2614537d3d6d5db2612629f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae12537adb2614537d3d6d5db2612629f">mlir::linalg::populateLinalgNamedToElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae12537adb2614537d3d6d5db2612629f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> that convert linalg named ops e.g.  <br /></td></tr>
<tr class="memitem:a479c320b2d7a71b7d9c50d04047eba8f" id="r_a479c320b2d7a71b7d9c50d04047eba8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a479c320b2d7a71b7d9c50d04047eba8f">mlir::linalg::populateLinalgFoldIntoElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a479c320b2d7a71b7d9c50d04047eba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">linalg.transform</span> into elementwise op map.  <br /></td></tr>
<tr class="memitem:a887c3b461640ae2783747a1c89726203" id="r_a887c3b461640ae2783747a1c89726203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">mlir::linalg::populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a887c3b461640ae2783747a1c89726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <br /></td></tr>
<tr class="memitem:a96851c32371159549c91211e266f3f0e" id="r_a96851c32371159549c91211e266f3f0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a96851c32371159549c91211e266f3f0e">mlir::linalg::populateDecomposePackUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a96851c32371159549c91211e266f3f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g.  <br /></td></tr>
<tr class="memitem:ae93e7e4b8d10bb895e935d0b4799f3a9" id="r_ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae93e7e4b8d10bb895e935d0b4799f3a9">mlir::linalg::populateDecomposePadPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose tensor.pad into e.g.  <br /></td></tr>
<tr class="memitem:a1e349c4f7a13b98a31f89dec948c5533" id="r_a1e349c4f7a13b98a31f89dec948c5533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">mlir::linalg::populateConvertConv2DToImg2ColPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a1e349c4f7a13b98a31f89dec948c5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul.  <br /></td></tr>
<tr class="memitem:a43c2ef8a778a33a17885475c11b50bdd" id="r_a43c2ef8a778a33a17885475c11b50bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">mlir::linalg::populatePadOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a43c2ef8a778a33a17885475c11b50bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that vectorize tensor.pad.  <br /></td></tr>
<tr class="memitem:aad6f59ca20a1e8ce21c3c29916aec917" id="r_aad6f59ca20a1e8ce21c3c29916aec917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">mlir::linalg::populateDecomposeLinalgOpsPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> removeDeadArgsAndResults=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:aad6f59ca20a1e8ce21c3c29916aec917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for splitting a <span class="tt">LinalgOp</span> with multiple statements within its payload into multiple <span class="tt">GenericOp</span> that have a single statement.  <br /></td></tr>
<tr class="memitem:a68f8e903a075470f95fa853892083469" id="r_a68f8e903a075470f95fa853892083469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">mlir::linalg::populateConvertToDestinationStylePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a68f8e903a075470f95fa853892083469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert non-destination-style ops to destination style ops.  <br /></td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4" id="r_a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">mlir::linalg::populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for vectorizing low-D convolution ops.  <br /></td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47" id="r_a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">mlir::linalg::populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <span class="tt">ElementwiseMappable</span> ops to linalg parallel loops.  <br /></td></tr>
<tr class="memitem:a49366865f5ce183ae19888eceb6667e5" id="r_a49366865f5ce183ae19888eceb6667e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">mlir::linalg::populateSparseTensorRewriting</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a49366865f5ce183ae19888eceb6667e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that are only useful in the context of sparse tensors.  <br /></td></tr>
<tr class="memitem:af537f75332b531f2f627083684c201e4" id="r_af537f75332b531f2f627083684c201e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">mlir::linalg::populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlElementwiseOpFusion)</td></tr>
<tr class="memdesc:af537f75332b531f2f627083684c201e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <br /></td></tr>
<tr class="memitem:a01a1d26266bdb81ec39619dde149ceda" id="r_a01a1d26266bdb81ec39619dde149ceda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a01a1d26266bdb81ec39619dde149ceda">mlir::linalg::populateDataLayoutPropagationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;controlPackUnPackPropagation, <a class="el" href="classbool.html">bool</a> PoisonPaddingOk=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a01a1d26266bdb81ec39619dde149ceda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to bubble up or down data layout ops across other operations.  <br /></td></tr>
<tr class="memitem:a170a7562074760f0aa1786f1d3d1db3b" id="r_a170a7562074760f0aa1786f1d3d1db3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a170a7562074760f0aa1786f1d3d1db3b">mlir::linalg::populateExtractSliceSinkingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#ac7e80c46fd448c104f6709b43c315755">ControlPropagationFn</a> &amp;controlPackUnPackPropagation)</td></tr>
<tr class="memdesc:a170a7562074760f0aa1786f1d3d1db3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to sink extract slice across other operations.  <br /></td></tr>
<tr class="memitem:a9cbdbb9ec2d0ed200d6a679ffd803c7e" id="r_a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <span class="tt">linalg.generic</span> operations.  <br /></td></tr>
<tr class="memitem:abe6e2c64c65b1a22b1794d731be0c612" id="r_abe6e2c64c65b1a22b1794d731be0c612"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">mlir::linalg::populateEraseUnnecessaryInputsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:abe6e2c64c65b1a22b1794d731be0c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to promote inputs to outputs and remove unused inputs of <span class="tt">linalg.generic</span> ops.  <br /></td></tr>
<tr class="memitem:a8ef1d681922add4fcf065a64d713c3b5" id="r_a8ef1d681922add4fcf065a64d713c3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">mlir::linalg::populateCollapseDimensions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a56475069e4631a3e7e54964a3fc576bb">GetCollapsableDimensionsFn</a> &amp;controlCollapseDimensions)</td></tr>
<tr class="memdesc:a8ef1d681922add4fcf065a64d713c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op.  <br /></td></tr>
<tr class="memitem:ac73f0e4d33b9691f06d722f2146c4a66" id="r_ac73f0e4d33b9691f06d722f2146c4a66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">mlir::linalg::populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:ac73f0e4d33b9691f06d722f2146c4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <br /></td></tr>
<tr class="memitem:a3c8bdabd42dfb2f3617cc87eccfa4199" id="r_a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op.  <br /></td></tr>
<tr class="memitem:ad0b142daa69f3f2b8986960b726ba2eb" id="r_ad0b142daa69f3f2b8986960b726ba2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">mlir::linalg::populateConstantFoldLinalgOperations</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a9f4136d97cdab12f0760756f1adc1721">ControlFusionFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ad0b142daa69f3f2b8986960b726ba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to constant fold Linalg operations.  <br /></td></tr>
<tr class="memitem:aeb6bcda20dbb76f4b453abfc31adcc98" id="r_aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb6bcda20dbb76f4b453abfc31adcc98">mlir::linalg::populateFoldAddIntoDestPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <span class="tt">linalg.add</span> when destination passing on a contraction op suffices for achieving the sum.  <br /></td></tr>
<tr class="memitem:a0e0b4c454598e4be0bd0fcde89783a20" id="r_a0e0b4c454598e4be0bd0fcde89783a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a0e0b4c454598e4be0bd0fcde89783a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <span class="tt">tensor.pad</span> operation with the producer of its source, if the producer is a <span class="tt">linalg</span> operation with all parallel iterator types.  <br /></td></tr>
<tr class="memitem:a588c1b33d58eb56f528112cfef47bffb" id="r_a588c1b33d58eb56f528112cfef47bffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a588c1b33d58eb56f528112cfef47bffb">mlir::linalg::populateSimplifyDepthwiseConvPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a588c1b33d58eb56f528112cfef47bffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to simplify depthwise convolutions.  <br /></td></tr>
<tr class="memitem:a7134894ce50357a7e8fefe7c379acac7" id="r_a7134894ce50357a7e8fefe7c379acac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7134894ce50357a7e8fefe7c379acac7">mlir::linalg::populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memdesc:a7134894ce50357a7e8fefe7c379acac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops.  <br /></td></tr>
<tr class="memitem:a042bb54cd9155ed1ca8818a16ab5110a" id="r_a042bb54cd9155ed1ca8818a16ab5110a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">mlir::linalg::populateMoveInitOperandsToInputPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a042bb54cd9155ed1ca8818a16ab5110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that converts init operands to input operands.  <br /></td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2" id="r_acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">mlir::linalg::populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <br /></td></tr>
<tr class="memitem:a18fce962e3d12d2dfc3b467076c71f39" id="r_a18fce962e3d12d2dfc3b467076c71f39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">mlir::linalg::populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a18fce962e3d12d2dfc3b467076c71f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to bubble up extract slice op above linalg op.  <br /></td></tr>
<tr class="memitem:ac8003a713f74f7a32cc681c245ae9708" id="r_ac8003a713f74f7a32cc681c245ae9708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">mlir::linalg::populateSwapExtractSliceWithFillPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ac8003a713f74f7a32cc681c245ae9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)).  <br /></td></tr>
<tr class="memitem:a3a1d8a95a9bec4041581a35ce791a503" id="r_a3a1d8a95a9bec4041581a35ce791a503"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3a1d8a95a9bec4041581a35ce791a503">mlir::linalg::populateDecomposeProjectedPermutationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a3a1d8a95a9bec4041581a35ce791a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp.  <br /></td></tr>
<tr class="memitem:a0c26bb1f203c97b9d5bcf9b8ae6ea102" id="r_a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">mlir::linalg::populateSplitReductionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a505f71c7a182531357360cb2151dc1f3">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, <a class="el" href="classbool.html">bool</a> useAlloc=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply <span class="tt">splitReduction</span> below.  <br /></td></tr>
<tr class="memitem:a0786aed514452424d437b02ff9816dce" id="r_a0786aed514452424d437b02ff9816dce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0786aed514452424d437b02ff9816dce">mlir::linalg::populateTransposeMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, <a class="el" href="classbool.html">bool</a> transposeLHS=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:a0786aed514452424d437b02ff9816dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert Linalg matmul ops to transposed variants.  <br /></td></tr>
<tr class="memitem:a1bf177055be0ddc8558b82cfbf4f8df7" id="r_a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bf177055be0ddc8558b82cfbf4f8df7">mlir::linalg::populateBlockPackMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#a41903a6655e9be09920ce399e3e71865">ControlBlockPackMatmulFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to block pack Linalg matmul ops.  <br /></td></tr>
<tr class="memitem:a4a5263d91b36edf98bda8c609f486214" id="r_a4a5263d91b36edf98bda8c609f486214"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a5263d91b36edf98bda8c609f486214">mlir::linalg::populateWinogradConv2DPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a4a5263d91b36edf98bda8c609f486214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply Winograd Conv2D algorithm F(m x m, r x r).  <br /></td></tr>
<tr class="memitem:a88f5ef52c3bd7a0c67503bb7b5f97ae7" id="r_a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88f5ef52c3bd7a0c67503bb7b5f97ae7">mlir::linalg::populateDecomposeWinogradOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to decompose Winograd operators.  <br /></td></tr>
<tr class="memitem:a08373cf12e45f28268db4e84f038f6ca" id="r_a08373cf12e45f28268db4e84f038f6ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08373cf12e45f28268db4e84f038f6ca">mlir::linalg::populateContractionOpRankReducingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:a08373cf12e45f28268db4e84f038f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <span class="tt">collapse_shape</span>, <span class="tt">&lt;corresponding linalg named op&gt;</span>, <span class="tt">expand_shape</span> (if on tensors).  <br /></td></tr>
<tr class="memitem:ab23b572eea62b16b1020bd964dc67d36" id="r_ab23b572eea62b16b1020bd964dc67d36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab23b572eea62b16b1020bd964dc67d36">mlir::linalg::populateFoldIntoPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>, const <a class="el" href="namespacemlir_1_1linalg.html#abf9a441fc28af495ff61ceedd25694d2">ControlFoldIntoPackUnpackFn</a> &amp;controlFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ab23b572eea62b16b1020bd964dc67d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt">tensor.pad</span> and <span class="tt">tensor.extract_slice</span> into <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations respectively.  <br /></td></tr>
<tr class="memitem:aac248e317eae5124cbaad8bbb832a806" id="r_aac248e317eae5124cbaad8bbb832a806"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aac248e317eae5124cbaad8bbb832a806">mlir::linalg::populateFoldPackUnpackIntoTensorEmptyPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aac248e317eae5124cbaad8bbb832a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that fold operations like <span class="tt"><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></span> and <span class="tt">linalg.unpack</span> into <span class="tt">tensor.empty</span>.  <br /></td></tr>
<tr class="memitem:aab3e6438bd84e7e76e5352c0c54fb5b7" id="r_aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aab3e6438bd84e7e76e5352c0c54fb5b7">mlir::linalg::populateSimplifyPackAndUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <span class="tt">patterns</span> with patterns that simplify <span class="tt">tensor.pack</span> and <span class="tt">tensor.unpack</span> operations.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
