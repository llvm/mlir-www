<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/Dialect/Linalg/Transforms/Transforms.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a class="el" href="dir_d07a6fac82475a065a3b2953573f00a0.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_7d4534fbf0715cf3ed7975990f2820c5.html">Linalg</a></li><li class="navelem"><a class="el" href="dir_2bf7b27484b15c8c863e85164c5e8ee5.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Transforms.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;utility&gt;</code><br />
<code>#include &quot;<a class="el" href="VectorToSCF_8h_source.html">mlir/Conversion/VectorToSCF/VectorToSCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Bufferization_8h_source.html">mlir/Dialect/Bufferization/IR/Bufferization.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Linalg_2Utils_2Utils_8h_source.html">mlir/Dialect/Linalg/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2SCF_2Utils_2Utils_8h_source.html">mlir/Dialect/SCF/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2IR_2Tensor_8h_source.html">mlir/Dialect/Tensor/IR/Tensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorTransforms_8h_source.html">mlir/Dialect/Vector/Transforms/VectorTransforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2X86Vector_2Transforms_8h_source.html">mlir/Dialect/X86Vector/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="OpDefinition_8h_source.html">mlir/IR/OpDefinition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TilingInterface_8h_source.html">mlir/Interfaces/TilingInterface.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DialectConversion_8h_source.html">mlir/Transforms/DialectConversion.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallBitVector.h&quot;</code><br />
<code>#include &quot;llvm/ADT/SmallSet.h&quot;</code><br />
</div>
<p><a href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BufferizeToAllocationOptions.html">mlir::linalg::BufferizeToAllocationOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">mlir::linalg::LinalgTilingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgTilingAndFusionOptions.html">mlir::linalg::LinalgTilingAndFusionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">mlir::linalg::LinalgPaddingOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">mlir::linalg::PadTilingInterfaceOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">mlir::linalg::LinalgPromotionOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionOptions.html">mlir::linalg::SplitReductionOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split Reduction options.  <a href="structmlir_1_1linalg_1_1SplitReductionOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">mlir::linalg::ControlDropUnitDims</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation to drop unit-extent dimensions from <code>linalg.generic</code> operations.  <a href="structmlir_1_1linalg_1_1ControlDropUnitDims.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">mlir::linalg::DropUnitDimsResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">mlir::linalg::ElementwiseOpFusionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuse two <code>linalg.generic</code> operations that have a producer-consumer relationship captured through <code>fusedOperand</code>.  <a href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html">mlir::linalg::detail::PackingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to hold the results of building a packing loop nest.  <a href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">mlir::linalg::TiledLinalgOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform standalone tiling of a single LinalgOp by <code>tileSizes</code>.  <a href="structmlir_1_1linalg_1_1TiledLinalgOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">mlir::linalg::PromotionInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new buffer using the <code>allocationFn</code> provided.  <a href="structmlir_1_1linalg_1_1PromotionInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">mlir::linalg::VectorizationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after vectorizing.  <a href="structmlir_1_1linalg_1_1VectorizationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1MultiSizeSpecificationBase.html">mlir::linalg::detail::MultiSizeSpecificationBase&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1detail_1_1ContinuousTileSizeSpecificationBase.html">mlir::linalg::detail::ContinuousTileSizeSpecificationBase&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">mlir::linalg::MultiSizeSpecification</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a multi-size tiling comprising tile sizes and numbers of tiles, expressed as Values which may or may not be constant.  <a href="structmlir_1_1linalg_1_1MultiSizeSpecification.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">mlir::linalg::StaticMultiSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">mlir::linalg::ContinuousTileSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">mlir::linalg::StaticContinuousTileSizeSpecification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">mlir::linalg::ForallReductionTilingResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation information returned after reduction tiling.  <a href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">mlir::linalg::SplitReductionResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply transformation to split the single linalg op reduction into a parallel and reduction dimension.  <a href="structmlir_1_1linalg_1_1SplitReductionResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">mlir::linalg::CollapseResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">mlir::linalg::LowerPackResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">mlir::linalg::LowerUnPackOpResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackResult.html">mlir::linalg::PackResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>pack</code> call.  <a href="structmlir_1_1linalg_1_1PackResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">mlir::linalg::PackTransposeResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct to hold the result of a <code>packTranspose</code> call.  <a href="structmlir_1_1linalg_1_1PackTransposeResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1BlockPackMatmulOptions.html">mlir::linalg::BlockPackMatmulOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html">mlir::linalg::DownscaleSizeOneWindowed2DConvolution&lt; Conv2DOp, Conv1DOp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D convolution ops with size-1 window dimensions into 1-D convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleSizeOneWindowed2DConvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html">mlir::linalg::DownscaleDepthwiseConv2DNhwcHwcOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites 2-D depthwise convolution ops with size-1 (w, kw) or (h, kh) dimensions into 1-D depthwise convolution ops.  <a href="structmlir_1_1linalg_1_1DownscaleDepthwiseConv2DNhwcHwcOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DownscaleConv2DOp.html">mlir::linalg::DownscaleConv2DOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html">mlir::linalg::LinalgGeneralizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization pattern.  <a href="structmlir_1_1linalg_1_1LinalgGeneralizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgSpecializationPattern.html">mlir::linalg::LinalgSpecializationPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html">mlir::linalg::CopyVectorizationPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorization pattern for memref::CopyOp.  <a href="structmlir_1_1linalg_1_1CopyVectorizationPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html">mlir::linalg::DecomposePadOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite a tensor::PadOp into a sequence of EmptyOp, FillOp and InsertSliceOp.  <a href="structmlir_1_1linalg_1_1DecomposePadOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html">mlir::linalg::DecomposeOuterUnitDimsPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::PackOp into a sequence of:  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html">mlir::linalg::DecomposeOuterUnitDimsUnPackOpPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites a linalg::UnPackOp into a sequence of rank-reduced.  <a href="structmlir_1_1linalg_1_1DecomposeOuterUnitDimsUnPackOpPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html">mlir::linalg::LinalgCopyVTRForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTRForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html">mlir::linalg::LinalgCopyVTWForwardingPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Match and rewrite for the pattern:  <a href="structmlir_1_1linalg_1_1LinalgCopyVTWForwardingPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html">mlir::linalg::ExtractSliceOfPadTensorSwapPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite extract_slice(tensor.pad(x)) into tensor.pad(extract_slice(x)).  <a href="structmlir_1_1linalg_1_1ExtractSliceOfPadTensorSwapPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1bufferization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1bufferization.html">mlir::bufferization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">mlir::linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html">mlir::linalg::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a730df0415b8172eb93f8f7b346e04440"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a730df0415b8172eb93f8f7b346e04440">mlir::linalg::TileSizeComputationFunction</a> = std::function&lt; SmallVector&lt; Value, 4 &gt;(OpBuilder &amp;, Operation *)&gt;</td></tr>
<tr class="separator:a730df0415b8172eb93f8f7b346e04440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcbad447f843c9b98886ad6f49469a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">mlir::linalg::AllocBufferCallbackFn</a> = std::function&lt; std::optional&lt; Value &gt;(OpBuilder &amp;b, memref::SubViewOp subView, ArrayRef&lt; Value &gt; boundingSubViewSize, DataLayout &amp;layout)&gt;</td></tr>
<tr class="memdesc:a1bcbad447f843c9b98886ad6f49469a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to perform the allocation for the promoted <code>subView</code>.  <a href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">More...</a><br /></td></tr>
<tr class="separator:a1bcbad447f843c9b98886ad6f49469a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7afb284c4be072a74a24eeb71cc985"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">mlir::linalg::DeallocBufferCallbackFn</a> = std::function&lt; LogicalResult(OpBuilder &amp;b, Value buffer)&gt;</td></tr>
<tr class="memdesc:a3d7afb284c4be072a74a24eeb71cc985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to deallocate the buffers used to hold the promoted subview.  <a href="namespacemlir_1_1linalg.html#a3d7afb284c4be072a74a24eeb71cc985">More...</a><br /></td></tr>
<tr class="separator:a3d7afb284c4be072a74a24eeb71cc985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49994e2aab61b35167972384684cf24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">mlir::linalg::CopyCallbackFn</a> = std::function&lt; LogicalResult(OpBuilder &amp;b, Value src, Value dst)&gt;</td></tr>
<tr class="memdesc:aa49994e2aab61b35167972384684cf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function type used to insert copy from original subview to subview of the promoted region for the read operands/subview of promoted region to original subview for the results.  <a href="namespacemlir_1_1linalg.html#aa49994e2aab61b35167972384684cf24">More...</a><br /></td></tr>
<tr class="separator:aa49994e2aab61b35167972384684cf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16099880d7579f488dd714c6273ea4c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">mlir::linalg::ControlSplitReductionFn</a> = std::function&lt; SplitReductionOptions(LinalgOp op)&gt;</td></tr>
<tr class="memdesc:ad16099880d7579f488dd714c6273ea4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function signature to control reduction splitting.  <a href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">More...</a><br /></td></tr>
<tr class="separator:ad16099880d7579f488dd714c6273ea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">mlir::linalg::LinalgLoops</a> = SmallVector&lt; Operation *, 4 &gt;</td></tr>
<tr class="separator:a4a9ca79033211e3e53e0eb25a8e9551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f38324ff992b8ceebc6e3f0c01a57d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">mlir::linalg::DroppedUnitDimsBuilder</a> = std::function&lt; IndexingMapOpInterface(Location loc, OpBuilder &amp;, IndexingMapOpInterface, ArrayRef&lt; Value &gt; newOperands, ArrayRef&lt; AffineMap &gt; newIndexingMaps, const llvm::SmallDenseSet&lt; unsigned &gt; &amp;droppedDims)&gt;</td></tr>
<tr class="separator:a2f38324ff992b8ceebc6e3f0c01a57d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac636a02565dd1c1bdcb8eb5982bd07c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">mlir::linalg::PadSizeComputationFunction</a> = std::function&lt; FailureOr&lt; SmallVector&lt; OpFoldResult &gt; &gt;(RewriterBase &amp;, OpOperand &amp;, ArrayRef&lt; Range &gt;, const PadTilingInterfaceOptions &amp;)&gt;</td></tr>
<tr class="separator:ac636a02565dd1c1bdcb8eb5982bd07c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2363d9b68019db04dbf0c710afe7f224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">mlir::linalg::LoopIndexToRangeIndexMap</a> = DenseMap&lt; int, int &gt;</td></tr>
<tr class="memdesc:a2363d9b68019db04dbf0c710afe7f224"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a number of ranges equal to the number of non-zero in <code>tileSizes</code>.  <a href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">More...</a><br /></td></tr>
<tr class="separator:a2363d9b68019db04dbf0c710afe7f224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae020263d273fb7b7f80c4970556da5f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">mlir::linalg::ControlBlockPackMatmulFn</a> = std::function&lt; std::optional&lt; BlockPackMatmulOptions &gt;(linalg::LinalgOp)&gt;</td></tr>
<tr class="memdesc:ae020263d273fb7b7f80c4970556da5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control matmul packing.  <a href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">More...</a><br /></td></tr>
<tr class="separator:ae020263d273fb7b7f80c4970556da5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7326883dfd3172d344f305860482e9ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7326883dfd3172d344f305860482e9ff">mlir::linalg::OptimizeCopyFn</a> = std::function&lt; LogicalResult(RewriterBase &amp;, tensor::PadOp, Value)&gt;</td></tr>
<tr class="separator:a7326883dfd3172d344f305860482e9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">mlir::linalg::ControlFusionFn</a> = std::function&lt; bool(OpOperand *fusedOperand)&gt;</td></tr>
<tr class="memdesc:a3115e251fd057529cff9b2d44a0ba1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control when to stop fusion.  <a href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">More...</a><br /></td></tr>
<tr class="separator:a3115e251fd057529cff9b2d44a0ba1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab145fd297a4850ad34e09aab2f669e65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">mlir::linalg::ControlPropagationFn</a> = std::function&lt; bool(OpOperand *opOperand)&gt;</td></tr>
<tr class="memdesc:ab145fd297a4850ad34e09aab2f669e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control propagation of <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <a href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">More...</a><br /></td></tr>
<tr class="separator:ab145fd297a4850ad34e09aab2f669e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d01335b6fc341e4b908d9ea5df7482"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">mlir::linalg::GetCollapsableDimensionsFn</a> = std::function&lt; SmallVector&lt; ReassociationIndices &gt;(linalg::LinalgOp)&gt;</td></tr>
<tr class="memdesc:ac1d01335b6fc341e4b908d9ea5df7482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type to control generic op dimension collapsing.  <a href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">More...</a><br /></td></tr>
<tr class="separator:ac1d01335b6fc341e4b908d9ea5df7482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8978399adc7b5ab6a4574123f59d1f52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">mlir::linalg::ControlFoldIntoPackUnpackFn</a> = std::function&lt; bool(OpOperand *opOperand)&gt;</td></tr>
<tr class="memdesc:a8978399adc7b5ab6a4574123f59d1f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type which is used to control folding operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a>/unpack ops.  <a href="namespacemlir_1_1linalg.html#a8978399adc7b5ab6a4574123f59d1f52">More...</a><br /></td></tr>
<tr class="separator:a8978399adc7b5ab6a4574123f59d1f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memItemLeft" align="right" valign="top">enum WinogradConv2DFmr uint32_t std::optional&lt; vector::CombiningKind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">mlir::linalg::getCombinerOpKind</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *combinerOp)</td></tr>
<tr class="memdesc:ae27267a4634c46beba8c9f55c14cdfa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return vector::CombiningKind for the given op.  <a href="namespacemlir_1_1linalg.html#ae27267a4634c46beba8c9f55c14cdfa1">More...</a><br /></td></tr>
<tr class="separator:ae27267a4634c46beba8c9f55c14cdfa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">mlir::linalg::bufferizeToAllocation</a> (RewriterBase &amp;rewriter, const BufferizeToAllocationOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, tensor::PadOp padOp, Attribute memorySpace={}, Operation *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given tensor.pad op and lower the op to linalg.fill/linalg.generic + bufferization.materialize_in_destination.  <a href="namespacemlir_1_1linalg.html#a300387e92135ddafe3e8fcb45a1d0f4c">More...</a><br /></td></tr>
<tr class="separator:a300387e92135ddafe3e8fcb45a1d0f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b6184483164da0417ac58d1d5086bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a2b6184483164da0417ac58d1d5086bbc">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const BufferizeToAllocationOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, vector::MaskOp maskOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a2b6184483164da0417ac58d1d5086bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given vector.mask op and bufferize the op, including its region.  <a href="namespacemlir_1_1linalg.html#a2b6184483164da0417ac58d1d5086bbc">More...</a><br /></td></tr>
<tr class="separator:a2b6184483164da0417ac58d1d5086bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a73274fcc2e8e228f5f44c6336b96e7b7">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const BufferizeToAllocationOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, bufferization::AllocTensorOp allocTensorOp, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a buffer allocation for the given bufferization.alloc_tensor op and lower the op to memref.alloc + memref.tensor_store.  <a href="namespacemlir_1_1linalg.html#a73274fcc2e8e228f5f44c6336b96e7b7">More...</a><br /></td></tr>
<tr class="separator:a73274fcc2e8e228f5f44c6336b96e7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d0ebe64f6077953145c8111cc3d955"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72d0ebe64f6077953145c8111cc3d955">mlir::linalg::bufferizeToAllocation</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, const BufferizeToAllocationOptions &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> memorySpace={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *insertionPoint=nullptr)</td></tr>
<tr class="memdesc:a72d0ebe64f6077953145c8111cc3d955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bufferize the given op with tensor semantics and materialize the result in a newly allocated buffer.  <a href="namespacemlir_1_1linalg.html#a72d0ebe64f6077953145c8111cc3d955">More...</a><br /></td></tr>
<tr class="separator:a72d0ebe64f6077953145c8111cc3d955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7b7f777c5538e35bbdd3aaabdb07e6f7">mlir::linalg::linalgOpAnchoredEmptyTensorEliminationStep</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1bufferization_1_1OneShotAnalysisState.html">bufferization::OneShotAnalysisState</a> &amp;state)</td></tr>
<tr class="memdesc:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to eliminate tensor::EmptyOps inside <code>op</code> that are anchored on a LinalgOp.  <a href="namespacemlir_1_1linalg.html#a7b7f777c5538e35bbdd3aaabdb07e6f7">More...</a><br /></td></tr>
<tr class="separator:a7b7f777c5538e35bbdd3aaabdb07e6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa220da60546acce7c4a8b3635d5b21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">mlir::linalg::areElementwiseOpsFusable</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a8fa220da60546acce7c4a8b3635d5b21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two <code>linalg.generic</code> operations with producer/consumer relationship through <code>fusedOperand</code> can be fused using elementwise op fusion.  <a href="namespacemlir_1_1linalg.html#a8fa220da60546acce7c4a8b3635d5b21">More...</a><br /></td></tr>
<tr class="separator:a8fa220da60546acce7c4a8b3635d5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850b9fd11404efe17bca02011aff2e88"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">mlir::linalg::promoteSubviewsPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> <a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a850b9fd11404efe17bca02011aff2e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote memref.subviews feeding linalg-on-buffers operations.  <a href="namespacemlir_1_1linalg.html#a850b9fd11404efe17bca02011aff2e88">More...</a><br /></td></tr>
<tr class="separator:a850b9fd11404efe17bca02011aff2e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0310adee4f127279f9147a71db0181"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8d0310adee4f127279f9147a71db0181">mlir::linalg::vectorizeOpPrecondition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputScalableVecDims={}, bool vectorizeNDExtract=false, bool flatten1DDepthwiseConv=false)</td></tr>
<tr class="memdesc:a8d0310adee4f127279f9147a71db0181"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return success if the operation can be vectorized.  <a href="namespacemlir_1_1linalg.html#a8d0310adee4f127279f9147a71db0181">More...</a><br /></td></tr>
<tr class="separator:a8d0310adee4f127279f9147a71db0181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980878e4ea40184d0a2183288fd0f61"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac980878e4ea40184d0a2183288fd0f61">mlir::linalg::dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, IndexingMapOpInterface op, const <a class="el" href="namespacemlir_1_1linalg.html#a2f38324ff992b8ceebc6e3f0c01a57d1">DroppedUnitDimsBuilder</a> &amp;droppedUnitDimsBuilder, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ac980878e4ea40184d0a2183288fd0f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1DropUnitDimsResult.html">DropUnitDimsResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5b6d6c0f10b756281634aebb9f69d5dd">mlir::linalg::dropUnitDims</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, const <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:a5b6d6c0f10b756281634aebb9f69d5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceec493e0b40673125a0402c3cf78e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ElementwiseOpFusionResult.html">ElementwiseOpFusionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ceec493e0b40673125a0402c3cf78e4">mlir::linalg::fuseElementwiseOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="separator:a4ceec493e0b40673125a0402c3cf78e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f70173e3ee102c2077ef5cdf5908001"><td class="memItemLeft" align="right" valign="top">llvm::SmallDenseSet&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4f70173e3ee102c2077ef5cdf5908001">mlir::linalg::getPreservedProducerResults</a> (GenericOp producer, GenericOp consumer, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand)</td></tr>
<tr class="memdesc:a4f70173e3ee102c2077ef5cdf5908001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a set of indices of the producer's results which would be preserved after the fusion.  <a href="namespacemlir_1_1linalg.html#a4f70173e3ee102c2077ef5cdf5908001">More...</a><br /></td></tr>
<tr class="separator:a4f70173e3ee102c2077ef5cdf5908001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">mlir::linalg::peelLoop</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ae273bd1d7e48f4503eefba4f1487fa56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to peel and canonicalize loop <code>op</code> and return the new result.  <a href="namespacemlir_1_1linalg.html#ae273bd1d7e48f4503eefba4f1487fa56">More...</a><br /></td></tr>
<tr class="separator:ae273bd1d7e48f4503eefba4f1487fa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa18744febf8ff36b38176ca04d8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">mlir::linalg::peelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; scf::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5faa18744febf8ff36b38176ca04d8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Peel 'loops' and applies affine_min/max bounds simplification on the fly where relevant.  <a href="namespacemlir_1_1linalg.html#a5faa18744febf8ff36b38176ca04d8fc">More...</a><br /></td></tr>
<tr class="separator:a5faa18744febf8ff36b38176ca04d8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d1dafbd1447fdcbad0e11434292563"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08d1dafbd1447fdcbad0e11434292563">mlir::linalg::rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp opToPad, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>, LinalgOp &amp;paddedOp, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;replacements, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps)</td></tr>
<tr class="memdesc:a08d1dafbd1447fdcbad0e11434292563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <code>options.paddingDimensions</code> of all <code>opToPad</code> operands to a static bounding box.  <a href="namespacemlir_1_1linalg.html#a08d1dafbd1447fdcbad0e11434292563">More...</a><br /></td></tr>
<tr class="separator:a08d1dafbd1447fdcbad0e11434292563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a372334d0c7a18ff500631d618d77c495"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a372334d0c7a18ff500631d618d77c495">mlir::linalg::computePaddedShape</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt; RankedTensorType &gt; v, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; indexingSizes, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a372334d0c7a18ff500631d618d77c495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to compute the padded shape of the given value <code>v</code> of <code>RankedTensorType</code> given:  <a href="namespacemlir_1_1linalg.html#a372334d0c7a18ff500631d618d77c495">More...</a><br /></td></tr>
<tr class="separator:a372334d0c7a18ff500631d618d77c495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">mlir::linalg::computeIndexingMapOpInterfacePaddedShape</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operandToPad, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a> &gt; iterationDomain, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific helper for Linalg ops.  <a href="namespacemlir_1_1linalg.html#a8cf886d8eb4668c4b2ad34db3a2d4bad">More...</a><br /></td></tr>
<tr class="separator:a8cf886d8eb4668c4b2ad34db3a2d4bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae0bb7dd79e2a9d97a336bbd51ac947a4">mlir::linalg::rewriteAsPaddedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface opToPad, const <a class="el" href="structmlir_1_1linalg_1_1PadTilingInterfaceOptions.html">PadTilingInterfaceOptions</a> &amp;constOptions, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; tensor::PadOp &gt; &amp;padOps, <a class="el" href="namespacemlir_1_1linalg.html#ac636a02565dd1c1bdcb8eb5982bd07c1">PadSizeComputationFunction</a> computePaddingSizeFun=&amp;computeIndexingMapOpInterfacePaddedShape)</td></tr>
<tr class="memdesc:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pad the iterator dimensions <code>options.paddingDimensions</code> of <code>opToPad</code>.  <a href="namespacemlir_1_1linalg.html#ae0bb7dd79e2a9d97a336bbd51ac947a4">More...</a><br /></td></tr>
<tr class="separator:ae0bb7dd79e2a9d97a336bbd51ac947a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856aa97fd05237472be94700af2b3312"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1detail_1_1PackingResult.html">PackingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg_1_1detail.html#a856aa97fd05237472be94700af2b3312">mlir::linalg::detail::buildPackingLoopNest</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, scf::ForOp outermostEnclosingForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector)</td></tr>
<tr class="memdesc:a856aa97fd05237472be94700af2b3312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the packing loop nest required to hoist <code>opToHoist</code> above <code>outermostEnclosingForOp</code>.  <a href="namespacemlir_1_1linalg_1_1detail.html#a856aa97fd05237472be94700af2b3312">More...</a><br /></td></tr>
<tr class="separator:a856aa97fd05237472be94700af2b3312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344a0fa8893af22df90d795e19c1a713"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a344a0fa8893af22df90d795e19c1a713">mlir::linalg::hoistPaddingOnTensors</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:a344a0fa8893af22df90d795e19c1a713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mechanically hoist padding operations on tensors by <code>numLoops</code> into a new, generally larger tensor.  <a href="namespacemlir_1_1linalg.html#a344a0fa8893af22df90d795e19c1a713">More...</a><br /></td></tr>
<tr class="separator:a344a0fa8893af22df90d795e19c1a713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac1d7ae638195a0c07357a33d4b8cfec0">mlir::linalg::hoistPaddingOnTensors</a> (tensor::PadOp opToHoist, int64_t numLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; transposeVector, tensor::PadOp &amp;hoistedOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; TransposeOp &gt; &amp;transposeOps)</td></tr>
<tr class="memdesc:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <code>hoistPaddingOnTensors</code> with a local <a class="el" href="classmlir_1_1IRRewriter.html" title="This class coordinates rewriting a piece of IR outside of a pattern rewrite, providing a way to keep ...">IRRewriter</a>.  <a href="namespacemlir_1_1linalg.html#ac1d7ae638195a0c07357a33d4b8cfec0">More...</a><br /></td></tr>
<tr class="separator:ac1d7ae638195a0c07357a33d4b8cfec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad04f1a354ddbbdec275dd9afd45bdce"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad04f1a354ddbbdec275dd9afd45bdce">mlir::linalg::padAndHoistLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPaddingOptions.html">LinalgPaddingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:aad04f1a354ddbbdec275dd9afd45bdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply padding and hoisting to <code>linalgOp</code> according to the configuration specified in <code>options</code>.  <a href="namespacemlir_1_1linalg.html#aad04f1a354ddbbdec275dd9afd45bdce">More...</a><br /></td></tr>
<tr class="separator:aad04f1a354ddbbdec275dd9afd45bdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af025e45095e64f984901c4f65fa3c72f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; TilingInterface, TilingInterface &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">mlir::linalg::splitOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, TilingInterface op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> splitPoint)</td></tr>
<tr class="memdesc:af025e45095e64f984901c4f65fa3c72f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given <code>op</code> into two parts along the given iteration space <code>dimension</code> at the specified <code>splitPoint</code>, and return the two parts.  <a href="namespacemlir_1_1linalg.html#af025e45095e64f984901c4f65fa3c72f">More...</a><br /></td></tr>
<tr class="separator:af025e45095e64f984901c4f65fa3c72f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13050e75a64a26bf82a80b19006d0e9"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1TiledLinalgOp.html">TiledLinalgOp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac13050e75a64a26bf82a80b19006d0e9">mlir::linalg::tileLinalgOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgTilingOptions.html">LinalgTilingOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="separator:ac13050e75a64a26bf82a80b19006d0e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">mlir::linalg::interchangeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; interchangeVector)</td></tr>
<tr class="memdesc:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interchange the <code>iterator_types</code> and <code>iterator_maps</code> dimensions and adapts the index accesses of <code>op</code>.  <a href="namespacemlir_1_1linalg.html#a8dcc62e199cdb1863a3d6f30e4dc317a">More...</a><br /></td></tr>
<tr class="separator:a8dcc62e199cdb1863a3d6f30e4dc317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc28f76b6a2798611e0008260ae388d"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7fc28f76b6a2798611e0008260ae388d">mlir::linalg::generalizeNamedOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7fc28f76b6a2798611e0008260ae388d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a GenericOp from the given named operation <code>linalgOp</code> and replace the given <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a7fc28f76b6a2798611e0008260ae388d">More...</a><br /></td></tr>
<tr class="separator:a7fc28f76b6a2798611e0008260ae388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be344205769eaea42d412b4c0fae11a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3be344205769eaea42d412b4c0fae11a">mlir::linalg::specializeGenericOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp genericOp)</td></tr>
<tr class="memdesc:a3be344205769eaea42d412b4c0fae11a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a namedOp from the given GenericOp and replace the GenericOp.  <a href="namespacemlir_1_1linalg.html#a3be344205769eaea42d412b4c0fae11a">More...</a><br /></td></tr>
<tr class="separator:a3be344205769eaea42d412b4c0fae11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed54a24fbd0044060290027188db5c0"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PromotionInfo.html">PromotionInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4ed54a24fbd0044060290027188db5c0">mlir::linalg::promoteSubviewAsNewBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, memref::SubViewOp subView, bool useOriginalSubviewSize, const <a class="el" href="namespacemlir_1_1linalg.html#a1bcbad447f843c9b98886ad6f49469a9">AllocBufferCallbackFn</a> &amp;allocationFn, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout)</td></tr>
<tr class="separator:a4ed54a24fbd0044060290027188db5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd639dc165f0ab64ec7afbac992c4d65"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; LinalgOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">mlir::linalg::promoteSubViews</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, LinalgOp op, const <a class="el" href="structmlir_1_1linalg_1_1LinalgPromotionOptions.html">LinalgPromotionOptions</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:acd639dc165f0ab64ec7afbac992c4d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <code>subViews</code> into a new buffer allocated at the insertion point <code>b</code>.  <a href="namespacemlir_1_1linalg.html#acd639dc165f0ab64ec7afbac992c4d65">More...</a><br /></td></tr>
<tr class="separator:acd639dc165f0ab64ec7afbac992c4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266200755192d09deb827c799e59277b"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">mlir::linalg::allocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a266200755192d09deb827c799e59277b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU workgroup memory.  <a href="namespacemlir_1_1linalg.html#a266200755192d09deb827c799e59277b">More...</a><br /></td></tr>
<tr class="separator:a266200755192d09deb827c799e59277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6babd80190e8df26f441fca7d2fbe31"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">mlir::linalg::deallocateWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:ad6babd80190e8df26f441fca7d2fbe31"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU group memory there is no need to deallocate.  <a href="namespacemlir_1_1linalg.html#ad6babd80190e8df26f441fca7d2fbe31">More...</a><br /></td></tr>
<tr class="separator:ad6babd80190e8df26f441fca7d2fbe31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">mlir::linalg::copyToWorkgroupMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a72fb3984f986840e0dc914c1ab90dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Memref copy operations and add gpu barrier guards before and after the copy operation to ensure data integrity.  <a href="namespacemlir_1_1linalg.html#a72fb3984f986840e0dc914c1ab90dc3b">More...</a><br /></td></tr>
<tr class="separator:a72fb3984f986840e0dc914c1ab90dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">mlir::linalg::allocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, memref::SubViewOp subview, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizeBounds, <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;)</td></tr>
<tr class="memdesc:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the subview in the GPU private memory.  <a href="namespacemlir_1_1linalg.html#a5606dfca8a9078fc6bc9b74972f15fdc">More...</a><br /></td></tr>
<tr class="separator:a5606dfca8a9078fc6bc9b74972f15fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88359f69353831d971485ff6b6b86dc1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">mlir::linalg::copyToGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Value.html">Value</a> src, <a class="el" href="classmlir_1_1Value.html">Value</a> dst)</td></tr>
<tr class="memdesc:a88359f69353831d971485ff6b6b86dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normal copy to between src and dst.  <a href="namespacemlir_1_1linalg.html#a88359f69353831d971485ff6b6b86dc1">More...</a><br /></td></tr>
<tr class="separator:a88359f69353831d971485ff6b6b86dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487d4430e8217b1dabc50cb28bb93342"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">mlir::linalg::deallocateGPUPrivateMemory</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Value.html">Value</a>)</td></tr>
<tr class="memdesc:a487d4430e8217b1dabc50cb28bb93342"><td class="mdescLeft">&#160;</td><td class="mdescRight">In case of GPU private memory there is no need to deallocate since the memory is freed when going outside of the scope.  <a href="namespacemlir_1_1linalg.html#a487d4430e8217b1dabc50cb28bb93342">More...</a><br /></td></tr>
<tr class="separator:a487d4430e8217b1dabc50cb28bb93342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142a09c03dbaa0d795e44f62d4b6b395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a142a09c03dbaa0d795e44f62d4b6b395">mlir::linalg::hasVectorizationImpl</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)</td></tr>
<tr class="memdesc:a142a09c03dbaa0d795e44f62d4b6b395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there's dedicated logic in the Linalg Vectorizer to vectorize this <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>, false otherwise.  <a href="namespacemlir_1_1linalg.html#a142a09c03dbaa0d795e44f62d4b6b395">More...</a><br /></td></tr>
<tr class="separator:a142a09c03dbaa0d795e44f62d4b6b395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303bb59c046a82276569e6b906002997"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html">VectorizationResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a303bb59c046a82276569e6b906002997">mlir::linalg::vectorize</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; inputVectorSizes={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; bool &gt; inputScalableVecDims={}, bool vectorizeNDExtract=false, bool flatten1DDepthwiseConv=false, bool assumeDynamicDimsMatchVecSizes=false, bool createNamedContraction=false)</td></tr>
<tr class="memdesc:a303bb59c046a82276569e6b906002997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <code><a class="el" href="structmlir_1_1linalg_1_1VectorizationResult.html" title="Transformation information returned after vectorizing.">VectorizationResult</a></code> containing the results of the vectorized op, or failure if the transformation fails.  <a href="namespacemlir_1_1linalg.html#a303bb59c046a82276569e6b906002997">More...</a><br /></td></tr>
<tr class="separator:a303bb59c046a82276569e6b906002997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c63bc9239511b70751c238a12f5b1da"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">mlir::linalg::vectorizeCopy</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;builder, memref::CopyOp copyOp)</td></tr>
<tr class="memdesc:a8c63bc9239511b70751c238a12f5b1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a suitable vector form for a Copy op with fully static shape.  <a href="namespacemlir_1_1linalg.html#a8c63bc9239511b70751c238a12f5b1da">More...</a><br /></td></tr>
<tr class="separator:a8c63bc9239511b70751c238a12f5b1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">mlir::linalg::linalgOpToLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a7edd4be30bfb8af9bc8e486f8368c1e2">More...</a><br /></td></tr>
<tr class="separator:a7edd4be30bfb8af9bc8e486f8368c1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff809877c1d119dae06d06a8bad953e4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">mlir::linalg::linalgOpToParallelLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:aff809877c1d119dae06d06a8bad953e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>scf.parallel</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#aff809877c1d119dae06d06a8bad953e4">More...</a><br /></td></tr>
<tr class="separator:aff809877c1d119dae06d06a8bad953e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f289e066dcbb7844bd444c0880fc36"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="namespacemlir_1_1linalg.html#a4a9ca79033211e3e53e0eb25a8e9551b">LinalgLoops</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">mlir::linalg::linalgOpToAffineLoops</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp)</td></tr>
<tr class="memdesc:a95f289e066dcbb7844bd444c0880fc36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a loop nest of <code>affine.for</code> with the proper body for <code>linalgOp</code>.  <a href="namespacemlir_1_1linalg.html#a95f289e066dcbb7844bd444c0880fc36">More...</a><br /></td></tr>
<tr class="separator:a95f289e066dcbb7844bd444c0880fc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8144efefcad502e511c24aa5ce5b36e8"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1Range.html">Range</a>, 4 &gt;, <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8144efefcad502e511c24aa5ce5b36e8">mlir::linalg::makeTiledLoopRanges</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allShapeSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; allTileSizes)</td></tr>
<tr class="separator:a8144efefcad502e511c24aa5ce5b36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1MultiSizeSpecification.html">MultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">mlir::linalg::computeMultiTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, LinalgOp op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> divisor, bool emitAssertions=true)</td></tr>
<tr class="memdesc:af8ef5fd09c3c79a47b8c4732ace79928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the IR computing the multi-sized tiling specification with two tile sizes not exceeding <code>targetSize</code>, each divisible by <code>sizeDivisor</code>, such that there exist numbers of tiles with these sizes that fully cover the given iteration space <code>dimension</code> of the structured <code>op</code>.  <a href="namespacemlir_1_1linalg.html#af8ef5fd09c3c79a47b8c4732ace79928">More...</a><br /></td></tr>
<tr class="separator:af8ef5fd09c3c79a47b8c4732ace79928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticMultiSizeSpecification.html">StaticMultiSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a91c1fb37672289a396df9c95a9b1dd0b">mlir::linalg::computeStaticMultiTileSizes</a> (LinalgOp op, unsigned dimension, int64_t targetSize, int64_t divisor)</td></tr>
<tr class="separator:a91c1fb37672289a396df9c95a9b1dd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1StaticContinuousTileSizeSpecification.html">StaticContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa3cdafc77c113c1fa2db8782dc0bdb29">mlir::linalg::computeStaticContinuousTileSizes</a> (LinalgOp op, unsigned dimension, unsigned targetSize)</td></tr>
<tr class="separator:aa3cdafc77c113c1fa2db8782dc0bdb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18c5afa193d9ff81a24877f1087fec4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ContinuousTileSizeSpecification.html">ContinuousTileSizeSpecification</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aa18c5afa193d9ff81a24877f1087fec4">mlir::linalg::computeContinuousTileSizes</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, TilingInterface op, unsigned dimension, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> targetSize, bool emitAssertions)</td></tr>
<tr class="separator:aa18c5afa193d9ff81a24877f1087fec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1ForallReductionTilingResult.html">ForallReductionTilingResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">mlir::linalg::tileReductionUsingForall</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, PartialReductionOpInterface op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; numThreads, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; tileSizes={}, std::optional&lt; ArrayAttr &gt; mapping=std::nullopt)</td></tr>
<tr class="memdesc:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to tile a reduction to parallel iterations computing partial reductions.  <a href="namespacemlir_1_1linalg.html#ab3085a8dbbf3c572b3279bdcc53dbe72">More...</a><br /></td></tr>
<tr class="separator:ab3085a8dbbf3c572b3279bdcc53dbe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2368f6f815597fcf395106e8978e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">mlir::linalg::transformIndexOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs, const <a class="el" href="namespacemlir_1_1linalg.html#a2363d9b68019db04dbf0c710afe7f224">LoopIndexToRangeIndexMap</a> &amp;loopIndexToRangeIndex)</td></tr>
<tr class="memdesc:a1b2368f6f815597fcf395106e8978e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">All indices returned by IndexOp should be invariant with respect to tiling.  <a href="namespacemlir_1_1linalg.html#a1b2368f6f815597fcf395106e8978e44">More...</a><br /></td></tr>
<tr class="separator:a1b2368f6f815597fcf395106e8978e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aaa4f58f6a18fb7c9af60fb15122e0994">mlir::linalg::splitReduction</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="separator:aaa4f58f6a18fb7c9af60fb15122e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87c3f5c965b8e271579136775d51ffc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1SplitReductionResult.html">SplitReductionResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">mlir::linalg::splitReductionByScaling</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;b, LinalgOp op, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:af87c3f5c965b8e271579136775d51ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling-based implementation of the split reduction transformation.  <a href="namespacemlir_1_1linalg.html#af87c3f5c965b8e271579136775d51ffc">More...</a><br /></td></tr>
<tr class="separator:af87c3f5c965b8e271579136775d51ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a31426a6a1dc69e5819138ba53c6e7ef9">mlir::linalg::isDimSequencePreserved</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="namespacemlir.html#a7ed845b40509fa999492a04654211321">ReassociationIndicesRef</a> dimSequence)</td></tr>
<tr class="memdesc:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if a given sequence of dimensions are contiguous in the range of the specified indexing map.  <a href="namespacemlir_1_1linalg.html#a31426a6a1dc69e5819138ba53c6e7ef9">More...</a><br /></td></tr>
<tr class="separator:a31426a6a1dc69e5819138ba53c6e7ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a133a3ec0d7cd50a886d2cd558fdc9030">mlir::linalg::areDimSequencesPreserved</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; dimSequences)</td></tr>
<tr class="memdesc:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if all sequences of dimensions specified in <code>dimSequences</code> are contiguous in all the ranges of the <code>maps</code>.  <a href="namespacemlir_1_1linalg.html#a133a3ec0d7cd50a886d2cd558fdc9030">More...</a><br /></td></tr>
<tr class="separator:a133a3ec0d7cd50a886d2cd558fdc9030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a3be2f9306a873810377797b78bfc6"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1CollapseResult.html">CollapseResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae6a3be2f9306a873810377797b78bfc6">mlir::linalg::collapseOpIterationDims</a> (LinalgOp op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; foldedIterationDims, <a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter)</td></tr>
<tr class="memdesc:ae6a3be2f9306a873810377797b78bfc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapses dimensions of linalg.generic/linalg.copy operation.  <a href="namespacemlir_1_1linalg.html#ae6a3be2f9306a873810377797b78bfc6">More...</a><br /></td></tr>
<tr class="separator:ae6a3be2f9306a873810377797b78bfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebe4a9f3b87bb8f196bf2d577511a05"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerPackResult.html">LowerPackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#afebe4a9f3b87bb8f196bf2d577511a05">mlir::linalg::lowerPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, bool lowerPadLikeWithInsertSlice=true)</td></tr>
<tr class="memdesc:afebe4a9f3b87bb8f196bf2d577511a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as pad + reshape + transpose.  <a href="namespacemlir_1_1linalg.html#afebe4a9f3b87bb8f196bf2d577511a05">More...</a><br /></td></tr>
<tr class="separator:afebe4a9f3b87bb8f196bf2d577511a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cea34f55211c79271dff09bb07c3279"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1LowerUnPackOpResult.html">LowerUnPackOpResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3cea34f55211c79271dff09bb07c3279">mlir::linalg::lowerUnPack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::UnPackOp unPackOp, bool lowerUnpadLikeWithExtractSlice=true)</td></tr>
<tr class="memdesc:a3cea34f55211c79271dff09bb07c3279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite pack as empty + transpose + reshape + extract_slice.  <a href="namespacemlir_1_1linalg.html#a3cea34f55211c79271dff09bb07c3279">More...</a><br /></td></tr>
<tr class="separator:a3cea34f55211c79271dff09bb07c3279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd29d6299d2891ae1d092974bc1c4e30"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">mlir::linalg::pack</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; packedSizes)</td></tr>
<tr class="memdesc:abd29d6299d2891ae1d092974bc1c4e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement packing of a single LinalgOp by <code>packedSizes</code>.  <a href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30">More...</a><br /></td></tr>
<tr class="separator:abd29d6299d2891ae1d092974bc1c4e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e3825819b0563bb199218baf11ca73"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackTransposeResult.html">PackTransposeResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a26e3825819b0563bb199218baf11ca73">mlir::linalg::packTranspose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::PackOp packOp, linalg::LinalgOp linalgOp, linalg::UnPackOp maybeUnPackOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; outerPerm, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; innerPerm)</td></tr>
<tr class="memdesc:a26e3825819b0563bb199218baf11ca73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transpose a single PackOp -&gt; LinalgOp -&gt; UnPackOp chain and return the transposed PackOp -&gt; LinalgOp -&gt; UnPackOp chain after replacements.  <a href="namespacemlir_1_1linalg.html#a26e3825819b0563bb199218baf11ca73">More...</a><br /></td></tr>
<tr class="separator:a26e3825819b0563bb199218baf11ca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3567489d885b34059aa8286957de564"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab3567489d885b34059aa8286957de564">mlir::linalg::packMatmulGreedily</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mnkPackedSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; mnkPaddedSizesNextMultipleOf, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; mnkOrder)</td></tr>
<tr class="memdesc:ab3567489d885b34059aa8286957de564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a LinalgOp by greedily inferring matmul dimensions (m, n, k) where m and n are proper parallel dimensions and k is a proper reduction dimension.  <a href="namespacemlir_1_1linalg.html#ab3567489d885b34059aa8286957de564">More...</a><br /></td></tr>
<tr class="separator:ab3567489d885b34059aa8286957de564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca967d8e0b6ff895d26faaf60a79263"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="structmlir_1_1linalg_1_1PackResult.html">PackResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5ca967d8e0b6ff895d26faaf60a79263">mlir::linalg::blockPackMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::LinalgOp linalgOp, const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;controlPackMatmul)</td></tr>
<tr class="memdesc:a5ca967d8e0b6ff895d26faaf60a79263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pack a matmul operation into blocked 4D layout.  <a href="namespacemlir_1_1linalg.html#a5ca967d8e0b6ff895d26faaf60a79263">More...</a><br /></td></tr>
<tr class="separator:a5ca967d8e0b6ff895d26faaf60a79263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a579fdd0e468c7aec96f84d016c829e"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::FromElementsOp fromElementsOp)</td></tr>
<tr class="memdesc:a5a579fdd0e468c7aec96f84d016c829e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.from_elements to linalg.generic.  <a href="namespacemlir_1_1linalg.html#a5a579fdd0e468c7aec96f84d016c829e">More...</a><br /></td></tr>
<tr class="separator:a5a579fdd0e468c7aec96f84d016c829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e500c4bf906d65572af9b3d2982852"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::GenerateOp generateOp)</td></tr>
<tr class="memdesc:ab2e500c4bf906d65572af9b3d2982852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.generate to linalg.generic.  <a href="namespacemlir_1_1linalg.html#ab2e500c4bf906d65572af9b3d2982852">More...</a><br /></td></tr>
<tr class="separator:ab2e500c4bf906d65572af9b3d2982852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">mlir::linalg::rewriteInDestinationPassingStyle</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, tensor::PadOp padOp)</td></tr>
<tr class="memdesc:acf3e743297fd7a20a30c7c4e39608fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite tensor.pad to linalg.generic + tensor.insert_slice.  <a href="namespacemlir_1_1linalg.html#acf3e743297fd7a20a30c7c4e39608fbc">More...</a><br /></td></tr>
<tr class="separator:acf3e743297fd7a20a30c7c4e39608fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; Operation *, Operation * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">mlir::linalg::rewriteInIm2Col</a> (RewriterBase &amp;rewriter, linalg::Conv2DNhwcHwcfOp convOp)</td></tr>
<tr class="memdesc:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_hwcf into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a0e2c1f265ce47a53398eab6e8f18b30c">More...</a><br /></td></tr>
<tr class="separator:a0e2c1f265ce47a53398eab6e8f18b30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efbd1a00187259d6074a842842175c2"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; Operation *, Operation * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7efbd1a00187259d6074a842842175c2">mlir::linalg::rewriteInIm2Col</a> (RewriterBase &amp;rewriter, linalg::Conv2DNhwcFhwcOp convOp)</td></tr>
<tr class="memdesc:a7efbd1a00187259d6074a842842175c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the above but for Fhwc channel orderings in the filter.  <a href="namespacemlir_1_1linalg.html#a7efbd1a00187259d6074a842842175c2">More...</a><br /></td></tr>
<tr class="separator:a7efbd1a00187259d6074a842842175c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; Operation *, Operation * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">mlir::linalg::rewriteInIm2Col</a> (RewriterBase &amp;rewriter, linalg::DepthwiseConv2DNhwcHwcOp convOp)</td></tr>
<tr class="memdesc:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except there is no reduction among the input channels so each convolution can be a matrix-vector product and by transposing both input filter so channels are outer most the computation is a batched matrix-vector product.  <a href="namespacemlir_1_1linalg.html#a49f61511bb9ed963c3eeb360bfdb1a6a">More...</a><br /></td></tr>
<tr class="separator:a49f61511bb9ed963c3eeb360bfdb1a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; std::pair&lt; Operation *, Operation * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">mlir::linalg::rewriteInIm2Col</a> (RewriterBase &amp;rewriter, linalg::Conv2DNchwFchwOp convOp)</td></tr>
<tr class="memdesc:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to rewriteInIm2Col with linalg::Conv2DNhwcHwcfOp except because the channels are to the left of the image shape dimensions, the position of the contraction dimension in the resulting matmul is reversed.  <a href="namespacemlir_1_1linalg.html#ad43dfb86d76bed86ecd1117849e5b6f4">More...</a><br /></td></tr>
<tr class="separator:ad43dfb86d76bed86ecd1117849e5b6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea35f9b824fbdf551b76ddf974fc418"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a6ea35f9b824fbdf551b76ddf974fc418">mlir::linalg::transposeConv2D</a> (RewriterBase &amp;rewriter, linalg::Conv2DNhwcFhwcOp op)</td></tr>
<tr class="memdesc:a6ea35f9b824fbdf551b76ddf974fc418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc(_q) to linalg.conv_2d_nhwc_hwcf(_q) by materializing transpose.  <a href="namespacemlir_1_1linalg.html#a6ea35f9b824fbdf551b76ddf974fc418">More...</a><br /></td></tr>
<tr class="separator:a6ea35f9b824fbdf551b76ddf974fc418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada14eab9218f7ff7f15f695a980fb717"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada14eab9218f7ff7f15f695a980fb717">mlir::linalg::transposeConv2D</a> (RewriterBase &amp;rewriter, linalg::Conv2DNhwcFhwcQOp op)</td></tr>
<tr class="separator:ada14eab9218f7ff7f15f695a980fb717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad8836bfb07ad8fc4f7bda9aa174da988">mlir::linalg::transposeMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::MatmulOp op, bool transposeLHS=true)</td></tr>
<tr class="memdesc:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert Linalg matmul ops to transposed variants.  <a href="namespacemlir_1_1linalg.html#ad8836bfb07ad8fc4f7bda9aa174da988">More...</a><br /></td></tr>
<tr class="separator:ad8836bfb07ad8fc4f7bda9aa174da988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816f67d5546592d18de9ec5de0e791f3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a816f67d5546592d18de9ec5de0e791f3">mlir::linalg::transposeBatchMatmul</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::BatchMatmulOp op, bool transposeLHS=true)</td></tr>
<tr class="memdesc:a816f67d5546592d18de9ec5de0e791f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace.  <a href="namespacemlir_1_1linalg.html#a816f67d5546592d18de9ec5de0e791f3">More...</a><br /></td></tr>
<tr class="separator:a816f67d5546592d18de9ec5de0e791f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c00031d476aa3ea451687f117fabde7"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8c00031d476aa3ea451687f117fabde7">mlir::linalg::winogradConv2D</a> (RewriterBase &amp;rewriter, linalg::Conv2DNhwcFhwcOp op, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a8c00031d476aa3ea451687f117fabde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert linalg.conv_2d_nhwc_fhwc to Winograd Conv2D algorithm F(m x m, r x r).  <a href="namespacemlir_1_1linalg.html#a8c00031d476aa3ea451687f117fabde7">More...</a><br /></td></tr>
<tr class="separator:a8c00031d476aa3ea451687f117fabde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a22cf4ae6a6c9f8d82a3d3f13e55100c3">mlir::linalg::decomposeWinogradFilterTransformOp</a> (RewriterBase &amp;rewriter, linalg::WinogradFilterTransformOp op)</td></tr>
<tr class="memdesc:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_filter_transform.  <a href="namespacemlir_1_1linalg.html#a22cf4ae6a6c9f8d82a3d3f13e55100c3">More...</a><br /></td></tr>
<tr class="separator:a22cf4ae6a6c9f8d82a3d3f13e55100c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75908ded36f97719f77c8b56ed859ef"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae75908ded36f97719f77c8b56ed859ef">mlir::linalg::decomposeWinogradInputTransformOp</a> (RewriterBase &amp;rewriter, linalg::WinogradInputTransformOp op)</td></tr>
<tr class="memdesc:ae75908ded36f97719f77c8b56ed859ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_input_transform.  <a href="namespacemlir_1_1linalg.html#ae75908ded36f97719f77c8b56ed859ef">More...</a><br /></td></tr>
<tr class="separator:ae75908ded36f97719f77c8b56ed859ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2f00a0e17dbbec5198127ee3151ba"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; Operation * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49f2f00a0e17dbbec5198127ee3151ba">mlir::linalg::decomposeWinogradOutputTransformOp</a> (RewriterBase &amp;rewriter, linalg::WinogradOutputTransformOp op)</td></tr>
<tr class="memdesc:a49f2f00a0e17dbbec5198127ee3151ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite linalg.winograd_output_transform.  <a href="namespacemlir_1_1linalg.html#a49f2f00a0e17dbbec5198127ee3151ba">More...</a><br /></td></tr>
<tr class="separator:a49f2f00a0e17dbbec5198127ee3151ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; linalg::GenericOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88467664ee2ebeb70bc1a2c3d5876a9c">mlir::linalg::deduplicateOperandsAndRemoveDeadResults</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, linalg::GenericOp genericOp, bool removeOutputs)</td></tr>
<tr class="memdesc:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to deduplicate operands and remove dead results of <code>linalg.generic</code> operations.  <a href="namespacemlir_1_1linalg.html#a88467664ee2ebeb70bc1a2c3d5876a9c">More...</a><br /></td></tr>
<tr class="separator:a88467664ee2ebeb70bc1a2c3d5876a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">mlir::linalg::getLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization patterns relevant to apply after tiling patterns.  <a href="namespacemlir_1_1linalg.html#ae61503376ad6b88f0c35f8ce358dbc9e">More...</a><br /></td></tr>
<tr class="separator:ae61503376ad6b88f0c35f8ce358dbc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4701ad0fa2e34da0089a80135935f02e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4701ad0fa2e34da0089a80135935f02e">mlir::linalg::populateLinalgTilingCanonicalizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="separator:a4701ad0fa2e34da0089a80135935f02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">mlir::linalg::populateLinalgNamedOpsGeneralizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg generalization patterns.  <a href="namespacemlir_1_1linalg.html#ada9bb5c9c8ef1aadbbc563431443b5e2">More...</a><br /></td></tr>
<tr class="separator:ada9bb5c9c8ef1aadbbc563431443b5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9ad663f56317f953958cb9434bd8fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#adc9ad663f56317f953958cb9434bd8fc">mlir::linalg::populateLinalgGenericOpsSpecializationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:adc9ad663f56317f953958cb9434bd8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns to convert linalg.generic ops to named ops where possible.  <a href="namespacemlir_1_1linalg.html#adc9ad663f56317f953958cb9434bd8fc">More...</a><br /></td></tr>
<tr class="separator:adc9ad663f56317f953958cb9434bd8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479c320b2d7a71b7d9c50d04047eba8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a479c320b2d7a71b7d9c50d04047eba8f">mlir::linalg::populateLinalgFoldIntoElementwisePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a479c320b2d7a71b7d9c50d04047eba8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code>linalg.transform</code> into elementwise op map.  <a href="namespacemlir_1_1linalg.html#a479c320b2d7a71b7d9c50d04047eba8f">More...</a><br /></td></tr>
<tr class="separator:a479c320b2d7a71b7d9c50d04047eba8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c3b461640ae2783747a1c89726203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">mlir::linalg::populateDecomposeConvolutionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a887c3b461640ae2783747a1c89726203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linalg decompose convolutions patterns.  <a href="namespacemlir_1_1linalg.html#a887c3b461640ae2783747a1c89726203">More...</a><br /></td></tr>
<tr class="separator:a887c3b461640ae2783747a1c89726203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96851c32371159549c91211e266f3f0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a96851c32371159549c91211e266f3f0e">mlir::linalg::populateDecomposePackUnpackPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a96851c32371159549c91211e266f3f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose <a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a> and linalg.unpack Ops into e.g.  <a href="namespacemlir_1_1linalg.html#a96851c32371159549c91211e266f3f0e">More...</a><br /></td></tr>
<tr class="separator:a96851c32371159549c91211e266f3f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ae93e7e4b8d10bb895e935d0b4799f3a9">mlir::linalg::populateDecomposePadPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to decompose tensor.pad into e.g.  <a href="namespacemlir_1_1linalg.html#ae93e7e4b8d10bb895e935d0b4799f3a9">More...</a><br /></td></tr>
<tr class="separator:ae93e7e4b8d10bb895e935d0b4799f3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e349c4f7a13b98a31f89dec948c5533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">mlir::linalg::populateConvertConv2DToImg2ColPatterns</a> (RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a1e349c4f7a13b98a31f89dec948c5533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates patterns to transform linalg.conv_2d_xxx operations into linalg.generic (for img2col packing) and linalg.matmul.  <a href="namespacemlir_1_1linalg.html#a1e349c4f7a13b98a31f89dec948c5533">More...</a><br /></td></tr>
<tr class="separator:a1e349c4f7a13b98a31f89dec948c5533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2ef8a778a33a17885475c11b50bdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">mlir::linalg::populatePadOpVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> baseBenefit=1)</td></tr>
<tr class="memdesc:a43c2ef8a778a33a17885475c11b50bdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that vectorize tensor.pad.  <a href="namespacemlir_1_1linalg.html#a43c2ef8a778a33a17885475c11b50bdd">More...</a><br /></td></tr>
<tr class="separator:a43c2ef8a778a33a17885475c11b50bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">mlir::linalg::populateDecomposeLinalgOpsPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool removeDeadArgsAndResults=true)</td></tr>
<tr class="memdesc:aad6f59ca20a1e8ce21c3c29916aec917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for splitting a <code>LinalgOp</code> with multiple statements within its payload into multiple <code>GenericOp</code> that have a single statement.  <a href="namespacemlir_1_1linalg.html#aad6f59ca20a1e8ce21c3c29916aec917">More...</a><br /></td></tr>
<tr class="separator:aad6f59ca20a1e8ce21c3c29916aec917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8e903a075470f95fa853892083469"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">mlir::linalg::populateConvertToDestinationStylePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a68f8e903a075470f95fa853892083469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert non-destination-style ops to destination style ops.  <a href="namespacemlir_1_1linalg.html#a68f8e903a075470f95fa853892083469">More...</a><br /></td></tr>
<tr class="separator:a68f8e903a075470f95fa853892083469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">mlir::linalg::populateConvolutionVectorizationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a> benefit=1)</td></tr>
<tr class="memdesc:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns for vectorizing low-D convolution ops.  <a href="namespacemlir_1_1linalg.html#a891b8f2d145dcc3327ba55c7a49d44e4">More...</a><br /></td></tr>
<tr class="separator:a891b8f2d145dcc3327ba55c7a49d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a49133ef595966377878adc42196f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">mlir::linalg::populateElementwiseToLinalgConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7a49133ef595966377878adc42196f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that convert <code>ElementwiseMappable</code> ops to linalg parallel loops.  <a href="namespacemlir_1_1linalg.html#a7a49133ef595966377878adc42196f47">More...</a><br /></td></tr>
<tr class="separator:a7a49133ef595966377878adc42196f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49366865f5ce183ae19888eceb6667e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">mlir::linalg::populateSparseTensorRewriting</a> (RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a49366865f5ce183ae19888eceb6667e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that are only useful in the context of sparse tensors.  <a href="namespacemlir_1_1linalg.html#a49366865f5ce183ae19888eceb6667e5">More...</a><br /></td></tr>
<tr class="separator:a49366865f5ce183ae19888eceb6667e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af537f75332b531f2f627083684c201e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">mlir::linalg::populateElementwiseOpsFusionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlElementwiseOpFusion)</td></tr>
<tr class="memdesc:af537f75332b531f2f627083684c201e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns for fusing linalg operation on tensors.  <a href="namespacemlir_1_1linalg.html#af537f75332b531f2f627083684c201e4">More...</a><br /></td></tr>
<tr class="separator:af537f75332b531f2f627083684c201e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">mlir::linalg::populateDataLayoutPropagationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#ab145fd297a4850ad34e09aab2f669e65">ControlPropagationFn</a> &amp;controlPackUnPackPropagation)</td></tr>
<tr class="memdesc:a3e0c4216814c93fb83b999f3f4923f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to bubble up or down data layout ops across other operations.  <a href="namespacemlir_1_1linalg.html#a3e0c4216814c93fb83b999f3f4923f7d">More...</a><br /></td></tr>
<tr class="separator:a3e0c4216814c93fb83b999f3f4923f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">mlir::linalg::populateEraseUnusedOperandsAndResultsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to remove dead operands and results of <code>linalg.generic</code> operations.  <a href="namespacemlir_1_1linalg.html#a9cbdbb9ec2d0ed200d6a679ffd803c7e">More...</a><br /></td></tr>
<tr class="separator:a9cbdbb9ec2d0ed200d6a679ffd803c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6e2c64c65b1a22b1794d731be0c612"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">mlir::linalg::populateEraseUnnecessaryInputsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:abe6e2c64c65b1a22b1794d731be0c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to promote inputs to outputs and remove unused inputs of <code>linalg.generic</code> ops.  <a href="namespacemlir_1_1linalg.html#abe6e2c64c65b1a22b1794d731be0c612">More...</a><br /></td></tr>
<tr class="separator:abe6e2c64c65b1a22b1794d731be0c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef1d681922add4fcf065a64d713c3b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">mlir::linalg::populateCollapseDimensions</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#ac1d01335b6fc341e4b908d9ea5df7482">GetCollapsableDimensionsFn</a> &amp;controlCollapseDimensions)</td></tr>
<tr class="memdesc:a8ef1d681922add4fcf065a64d713c3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to collapse dimensions in a linalg.generic op.  <a href="namespacemlir_1_1linalg.html#a8ef1d681922add4fcf065a64d713c3b5">More...</a><br /></td></tr>
<tr class="separator:a8ef1d681922add4fcf065a64d713c3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">mlir::linalg::populateFoldReshapeOpsByExpansionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:ac73f0e4d33b9691f06d722f2146c4a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding (collapsing) tensor_reshape operation with its producer (consumer) generic operation by expanding the dimensionality of the loop in the generic op.  <a href="namespacemlir_1_1linalg.html#ac73f0e4d33b9691f06d722f2146c4a66">More...</a><br /></td></tr>
<tr class="separator:ac73f0e4d33b9691f06d722f2146c4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">mlir::linalg::populateFoldReshapeOpsByCollapsingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFoldingReshapes)</td></tr>
<tr class="memdesc:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold an expanding tensor.expand_shape operation with its producer generic operation by collapsing the dimensions of the generic op.  <a href="namespacemlir_1_1linalg.html#a3c8bdabd42dfb2f3617cc87eccfa4199">More...</a><br /></td></tr>
<tr class="separator:a3c8bdabd42dfb2f3617cc87eccfa4199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">mlir::linalg::populateConstantFoldLinalgOperations</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#a3115e251fd057529cff9b2d44a0ba1c0">ControlFusionFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:ad0b142daa69f3f2b8986960b726ba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to constant fold Linalg operations.  <a href="namespacemlir_1_1linalg.html#ad0b142daa69f3f2b8986960b726ba2eb">More...</a><br /></td></tr>
<tr class="separator:ad0b142daa69f3f2b8986960b726ba2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aeb6bcda20dbb76f4b453abfc31adcc98">mlir::linalg::populateFoldAddIntoDestPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to replace <code>linalg.add</code> when destination passing on a contraction op suffices for achieving the sum.  <a href="namespacemlir_1_1linalg.html#aeb6bcda20dbb76f4b453abfc31adcc98">More...</a><br /></td></tr>
<tr class="separator:aeb6bcda20dbb76f4b453abfc31adcc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">mlir::linalg::populateFuseTensorPadWithProducerLinalgOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0e0b4c454598e4be0bd0fcde89783a20"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fuse a <code>tensor.pad</code> operation with the producer of its source, if the producer is a <code>linalg</code> operation with all parallel iterator types.  <a href="namespacemlir_1_1linalg.html#a0e0b4c454598e4be0bd0fcde89783a20">More...</a><br /></td></tr>
<tr class="separator:a0e0b4c454598e4be0bd0fcde89783a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419b15db70f16465aec05d8f86f6e4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">mlir::linalg::populateLinalgNamedOpConversionPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a0419b15db70f16465aec05d8f86f6e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert from one named op to another.  <a href="namespacemlir_1_1linalg.html#a0419b15db70f16465aec05d8f86f6e4e">More...</a><br /></td></tr>
<tr class="separator:a0419b15db70f16465aec05d8f86f6e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7134894ce50357a7e8fefe7c379acac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a7134894ce50357a7e8fefe7c379acac7">mlir::linalg::populateFoldUnitExtentDimsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, <a class="el" href="structmlir_1_1linalg_1_1ControlDropUnitDims.html">ControlDropUnitDims</a> &amp;<a class="el" href="Timing_8cpp.html#a52c68f021b2e559b78bed0c973d80848">options</a>)</td></tr>
<tr class="memdesc:a7134894ce50357a7e8fefe7c379acac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to fold unit-extent dimensions in operands/results of linalg ops on tensors via reassociative reshape ops.  <a href="namespacemlir_1_1linalg.html#a7134894ce50357a7e8fefe7c379acac7">More...</a><br /></td></tr>
<tr class="separator:a7134894ce50357a7e8fefe7c379acac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">mlir::linalg::populateMoveInitOperandsToInputPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a042bb54cd9155ed1ca8818a16ab5110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern that converts init operands to input operands.  <a href="namespacemlir_1_1linalg.html#a042bb54cd9155ed1ca8818a16ab5110a">More...</a><br /></td></tr>
<tr class="separator:a042bb54cd9155ed1ca8818a16ab5110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">mlir::linalg::populateInlineConstantOperandsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to inline constant operands into linalg generic ops.  <a href="namespacemlir_1_1linalg.html#acc64a8c8a9ecf3de84383893d8e4ddc2">More...</a><br /></td></tr>
<tr class="separator:acc64a8c8a9ecf3de84383893d8e4ddc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fce962e3d12d2dfc3b467076c71f39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">mlir::linalg::populateBubbleUpExtractSliceOpPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a18fce962e3d12d2dfc3b467076c71f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns that are used to bubble up extract slice op above linalg op.  <a href="namespacemlir_1_1linalg.html#a18fce962e3d12d2dfc3b467076c71f39">More...</a><br /></td></tr>
<tr class="separator:a18fce962e3d12d2dfc3b467076c71f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8003a713f74f7a32cc681c245ae9708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">mlir::linalg::populateSwapExtractSliceWithFillPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac8003a713f74f7a32cc681c245ae9708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that waps tensor.extract_slice(linalg.fill(cst, init)) into linalg.fill(cst, tensor.extract_slice(init)).  <a href="namespacemlir_1_1linalg.html#ac8003a713f74f7a32cc681c245ae9708">More...</a><br /></td></tr>
<tr class="separator:ac8003a713f74f7a32cc681c245ae9708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1d8a95a9bec4041581a35ce791a503"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a3a1d8a95a9bec4041581a35ce791a503">mlir::linalg::populateDecomposeProjectedPermutationPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a3a1d8a95a9bec4041581a35ce791a503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add patterns to make explicit broadcasts and transforms in the input operands of a genericOp.  <a href="namespacemlir_1_1linalg.html#a3a1d8a95a9bec4041581a35ce791a503">More...</a><br /></td></tr>
<tr class="separator:a3a1d8a95a9bec4041581a35ce791a503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">mlir::linalg::populateSplitReductionPattern</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#ad16099880d7579f488dd714c6273ea4c">ControlSplitReductionFn</a> &amp;controlSplitReductionFn, bool useAlloc=false)</td></tr>
<tr class="memdesc:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply <code>splitReduction</code> below.  <a href="namespacemlir_1_1linalg.html#a0c26bb1f203c97b9d5bcf9b8ae6ea102">More...</a><br /></td></tr>
<tr class="separator:a0c26bb1f203c97b9d5bcf9b8ae6ea102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0786aed514452424d437b02ff9816dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a0786aed514452424d437b02ff9816dce">mlir::linalg::populateTransposeMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, bool transposeLHS=true)</td></tr>
<tr class="memdesc:a0786aed514452424d437b02ff9816dce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to convert Linalg matmul ops to transposed variants.  <a href="namespacemlir_1_1linalg.html#a0786aed514452424d437b02ff9816dce">More...</a><br /></td></tr>
<tr class="separator:a0786aed514452424d437b02ff9816dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a1bf177055be0ddc8558b82cfbf4f8df7">mlir::linalg::populateBlockPackMatmulPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns, const <a class="el" href="namespacemlir_1_1linalg.html#ae020263d273fb7b7f80c4970556da5f8">ControlBlockPackMatmulFn</a> &amp;controlFn)</td></tr>
<tr class="memdesc:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to block pack Linalg matmul ops.  <a href="namespacemlir_1_1linalg.html#a1bf177055be0ddc8558b82cfbf4f8df7">More...</a><br /></td></tr>
<tr class="separator:a1bf177055be0ddc8558b82cfbf4f8df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5263d91b36edf98bda8c609f486214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a4a5263d91b36edf98bda8c609f486214">mlir::linalg::populateWinogradConv2DPatterns</a> (RewritePatternSet &amp;patterns, WinogradConv2DFmr fmr)</td></tr>
<tr class="memdesc:a4a5263d91b36edf98bda8c609f486214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to apply Winograd Conv2D algorithm F(m x m, r x r).  <a href="namespacemlir_1_1linalg.html#a4a5263d91b36edf98bda8c609f486214">More...</a><br /></td></tr>
<tr class="separator:a4a5263d91b36edf98bda8c609f486214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a88f5ef52c3bd7a0c67503bb7b5f97ae7">mlir::linalg::populateDecomposeWinogradOpsPatterns</a> (RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patterns to decompose Winograd operators.  <a href="namespacemlir_1_1linalg.html#a88f5ef52c3bd7a0c67503bb7b5f97ae7">More...</a><br /></td></tr>
<tr class="separator:a88f5ef52c3bd7a0c67503bb7b5f97ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08373cf12e45f28268db4e84f038f6ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#a08373cf12e45f28268db4e84f038f6ca">mlir::linalg::populateContractionOpRankReducingPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;patterns)</td></tr>
<tr class="memdesc:a08373cf12e45f28268db4e84f038f6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds patterns that reduce the rank of named contraction ops that have unit dimensions in the operand(s) by converting to a sequence of <code>collapse_shape</code>, <code>&lt;corresponding linalg named op&gt;</code>, <code>expand_shape</code> (if on tensors).  <a href="namespacemlir_1_1linalg.html#a08373cf12e45f28268db4e84f038f6ca">More...</a><br /></td></tr>
<tr class="separator:a08373cf12e45f28268db4e84f038f6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23b572eea62b16b1020bd964dc67d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#ab23b572eea62b16b1020bd964dc67d36">mlir::linalg::populateFoldIntoPackAndUnpackPatterns</a> (RewritePatternSet &amp;patterns, const ControlFoldIntoPackUnpackFn &amp;controlFn=nullptr)</td></tr>
<tr class="memdesc:ab23b572eea62b16b1020bd964dc67d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code>tensor.pad</code> and <code>tensor.extract_slice</code> into <code>tensor.pack</code> and <code>tensor.unpack</code> operations respectively.  <a href="namespacemlir_1_1linalg.html#ab23b572eea62b16b1020bd964dc67d36">More...</a><br /></td></tr>
<tr class="separator:ab23b572eea62b16b1020bd964dc67d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac248e317eae5124cbaad8bbb832a806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aac248e317eae5124cbaad8bbb832a806">mlir::linalg::populateFoldPackUnpackIntoTensorEmptyPatterns</a> (RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:aac248e317eae5124cbaad8bbb832a806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that fold operations like <code><a class="el" href="namespacemlir_1_1linalg.html#abd29d6299d2891ae1d092974bc1c4e30" title="Implement packing of a single LinalgOp by packedSizes.">linalg.pack</a></code> and <code>linalg.unpack</code> into <code>tensor.empty</code>.  <a href="namespacemlir_1_1linalg.html#aac248e317eae5124cbaad8bbb832a806">More...</a><br /></td></tr>
<tr class="separator:aac248e317eae5124cbaad8bbb832a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html#aab3e6438bd84e7e76e5352c0c54fb5b7">mlir::linalg::populateSimplifyPackAndUnpackPatterns</a> (RewritePatternSet &amp;patterns)</td></tr>
<tr class="memdesc:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates <code>patterns</code> with patterns that simplify <code>tensor.pack</code> and <code>tensor.unpack</code> operations.  <a href="namespacemlir_1_1linalg.html#aab3e6438bd84e7e76e5352c0c54fb5b7">More...</a><br /></td></tr>
<tr class="separator:aab3e6438bd84e7e76e5352c0c54fb5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:27 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
