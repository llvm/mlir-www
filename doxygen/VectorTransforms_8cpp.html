<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Vector/Transforms/VectorTransforms.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_84ad971b6ccc87b19bc57b4cf8f3f79f.html">Vector</a></li><li class="navelem"><a href="dir_7b47e7ae615a7c9f8246c22d2b9965e5.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">VectorTransforms.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="VectorTransforms_8h_source.html">mlir/Dialect/Vector/Transforms/VectorTransforms.h</a>&quot;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;functional&gt;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2SCF_2IR_2SCF_8h_source.html">mlir/Dialect/SCF/IR/SCF.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StructuredOpsUtils_8h_source.html">mlir/Dialect/Utils/StructuredOpsUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorOps_8h_source.html">mlir/Dialect/Vector/IR/VectorOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorRewritePatterns_8h_source.html">mlir/Dialect/Vector/Transforms/VectorRewritePatterns.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="VectorUtils_8h_source.html">mlir/Dialect/Vector/Utils/VectorUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html">mlir/IR/BuiltinTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Location_8h_source.html">mlir/IR/Location.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="TypeUtilities_8h_source.html">mlir/IR/TypeUtilities.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/STLExtras.h&quot;</code><br />
<code>#include &quot;llvm/Support/FormatVariadic.h&quot;</code><br />
<code>#include &quot;mlir/Dialect/Vector/Transforms/VectorTransformsEnums.cpp.inc&quot;</code><br />
</div>
<p><a href="VectorTransforms_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:DropInnerMostUnitDimsTransferRead" id="r_DropInnerMostUnitDimsTransferRead"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDropInnerMostUnitDimsTransferRead.html">DropInnerMostUnitDimsTransferRead</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop inner most contiguous unit dimensions from transfer_read operand.  <a href="classDropInnerMostUnitDimsTransferRead.html#details">More...</a><br /></td></tr>
<tr class="memitem:DropInnerMostUnitDimsTransferWrite" id="r_DropInnerMostUnitDimsTransferWrite"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDropInnerMostUnitDimsTransferWrite.html">DropInnerMostUnitDimsTransferWrite</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop inner most contiguous unit dimensions from transfer_write operand. E.g., vector.transfer_write arg1, arg0[c0, arg2, c0, c0, c0] {in_bounds = [true, true, true, true, true]} : <a class="el" href="namespacemlir_1_1vector.html">vector&lt;1x16x16x1x1xf32&gt;</a>, <a class="el" href="namespacemlir_1_1memref.html">memref&lt;1x512x16x1x1xf32&gt;</a>  <a href="classDropInnerMostUnitDimsTransferWrite.html#details">More...</a><br /></td></tr>
<tr class="memitem:CanonicalizeContractMatmulToMMT" id="r_CanonicalizeContractMatmulToMMT"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCanonicalizeContractMatmulToMMT.html">CanonicalizeContractMatmulToMMT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalization of a <span class="tt">vector.contraction a, b, c</span> with row-major matmul semantics to a contraction suitable for MMT (matrix matrix multiplication with the RHS transposed) lowering.  <a href="structCanonicalizeContractMatmulToMMT.html#details">More...</a><br /></td></tr>
<tr class="memitem:FoldArithExtIntoContractionOp_3C_20ExtOp_20_3E" id="r_FoldArithExtIntoContractionOp_3C_20ExtOp_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFoldArithExtIntoContractionOp.html">FoldArithExtIntoContractionOp&lt; ExtOp &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fold arithmetic extensions on floating point data types into vector contraction operations. linalg.matmul introduces arithmetic extensions on its operands. Please mlir snippets below for more details.  <a href="structFoldArithExtIntoContractionOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:ChainedReduction" id="r_ChainedReduction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structChainedReduction.html">ChainedReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to fold chained reduction to a series of vector additions and a final reduction. This form should require fewer subgroup operations.  <a href="structChainedReduction.html#details">More...</a><br /></td></tr>
<tr class="memitem:DropUnitDimFromElementwiseOps" id="r_DropUnitDimFromElementwiseOps"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDropUnitDimFromElementwiseOps.html">DropUnitDimFromElementwiseOps</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For vectors with at least one unit dim, replaces: elementwise(a, b) with: sc_a = shape_cast(a) sc_b = shape_cast(b) res = elementwise(sc_a, sc_b) return shape_cast(res) The newly inserted shape_cast Ops fold (before elementwise <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>) and then restore (after elementwise <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have.">Op</a>) the unit dim. Vectors <span class="tt">a</span> and <span class="tt">b</span> are required to be rank &gt; 1.  <a href="structDropUnitDimFromElementwiseOps.html#details">More...</a><br /></td></tr>
<tr class="memitem:DropUnitDimsFromTransposeOp" id="r_DropUnitDimsFromTransposeOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDropUnitDimsFromTransposeOp.html">DropUnitDimsFromTransposeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to drop unit dims from vector.transpose.  <a href="structDropUnitDimsFromTransposeOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:DropUnitDimsFromScfForOp" id="r_DropUnitDimsFromScfForOp"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDropUnitDimsFromScfForOp.html">DropUnitDimsFromScfForOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pattern to drop unit dims from the iter_args of an scf.for.  <a href="structDropUnitDimsFromScfForOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReduceRedundantZero" id="r_ReduceRedundantZero"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structReduceRedundantZero.html">ReduceRedundantZero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="This class contains all of the data related to a pattern, but does not contain any methods or logic f...">Pattern</a> to eliminate redundant zero-constants added to reduction operands. It's enough for there to be one initial zero value, so we can eliminate the extra ones that feed into <span class="tt">vector.reduction &lt;add&gt;</span>. These get created by the <span class="tt"><a class="el" href="structChainedReduction.html" title="Pattern to fold chained reduction to a series of vector additions and a final reduction....">ChainedReduction</a></span> pattern.  <a href="structReduceRedundantZero.html#details">More...</a><br /></td></tr>
<tr class="memitem:BreakDownVectorReduction" id="r_BreakDownVectorReduction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structBreakDownVectorReduction.html">BreakDownVectorReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Example:  <a href="structBreakDownVectorReduction.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;vector-to-vector&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac93b7ef538f133f7826fd2982c56010a" id="r_ac93b7ef538f133f7826fd2982c56010a"><td class="memTemplParams" colspan="2">template&lt;typename IntType&gt; </td></tr>
<tr class="memitem:ac93b7ef538f133f7826fd2982c56010a template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; IntType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac93b7ef538f133f7826fd2982c56010a">extractVector</a> (<a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a> arrayAttr)</td></tr>
<tr class="memitem:a1092ea58a7991c4a7bd0bec2e2d4954b" id="r_a1092ea58a7991c4a7bd0bec2e2d4954b"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1092ea58a7991c4a7bd0bec2e2d4954b">getResultIndex</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classint64__t.html">int64_t</a> index)</td></tr>
<tr class="memitem:af2bc348f013e93923ce7baeeb7616719" id="r_af2bc348f013e93923ce7baeeb7616719"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2bc348f013e93923ce7baeeb7616719">getTransferFoldableInnerUnitDims</a> (MemRefType srcType, VectorType vectorType)</td></tr>
<tr class="memdesc:af2bc348f013e93923ce7baeeb7616719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of dims can be folded away from transfer ops. It returns a failure if it can not determine the number of dims to be folded.  <br /></td></tr>
<tr class="memitem:ab38283a038d147fcc982698f4792dc52" id="r_ab38283a038d147fcc982698f4792dc52"><td class="memItemLeft" align="right" valign="top">static VectorType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab38283a038d147fcc982698f4792dc52">dropNonScalableUnitDimFromType</a> (VectorType inVecTy)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9284bc20084c3c496ef82b87e495c1b1" id="r_a9284bc20084c3c496ef82b87e495c1b1"><td class="memItemLeft" align="right" valign="top">*B *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9284bc20084c3c496ef82b87e495c1b1">Example</a></td></tr>
<tr class="memdesc:a9284bc20084c3c496ef82b87e495c1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold <span class="tt">mulf(tr(broadcast(A)), broadcast(B))</span> into `vector.outerproduct(A,.  <br /></td></tr>
<tr class="memitem:aa816ee744e158291cc7abe613735fbfd" id="r_aa816ee744e158291cc7abe613735fbfd"><td class="memItemLeft" align="right" valign="top">*B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa816ee744e158291cc7abe613735fbfd">rhsBcast</a></td></tr>
<tr class="memitem:a611c177776150f2e11f15c1cec5764c1" id="r_a611c177776150f2e11f15c1cec5764c1"><td class="memItemLeft" align="right" valign="top">*B&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611c177776150f2e11f15c1cec5764c1">rhs</a></td></tr>
<tr class="memitem:ad9add153e9bd7798ae26960fb18999df" id="r_ad9add153e9bd7798ae26960fb18999df"><td class="memItemLeft" align="right" valign="top">*B vector&lt; 4xi32 &gt; **Supports only to broadcasts The following cases are not supported *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9add153e9bd7798ae26960fb18999df">ex1</a></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;vector-to-vector&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l00038">38</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ab38283a038d147fcc982698f4792dc52" name="ab38283a038d147fcc982698f4792dc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38283a038d147fcc982698f4792dc52">&#9670;&#160;</a></span>dropNonScalableUnitDimFromType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorType dropNonScalableUnitDimFromType </td>
          <td>(</td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>inVecTy</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l01916">1916</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l01965">DropUnitDimFromElementwiseOps::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02110">DropUnitDimsFromScfForOp::matchAndRewrite()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02033">DropUnitDimsFromTransposeOp::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ac93b7ef538f133f7826fd2982c56010a" name="ac93b7ef538f133f7826fd2982c56010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93b7ef538f133f7826fd2982c56010a">&#9670;&#160;</a></span>extractVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; IntType &gt; extractVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr</a></td>          <td class="paramname"><span class="paramname"><em>arrayAttr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l00044">44</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp.html#a779742dd6f87d76525a94f72bd2effc6">ArrayAttr()</a>.</p>

</div>
</div>
<a id="a1092ea58a7991c4a7bd0bec2e2d4954b" name="a1092ea58a7991c4a7bd0bec2e2d4954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1092ea58a7991c4a7bd0bec2e2d4954b">&#9670;&#160;</a></span>getResultIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getResultIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l00051">51</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">mlir::AffineMap::getDimPosition()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>.</p>

</div>
</div>
<a id="af2bc348f013e93923ce7baeeb7616719" name="af2bc348f013e93923ce7baeeb7616719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bc348f013e93923ce7baeeb7616719">&#9670;&#160;</a></span>getTransferFoldableInnerUnitDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; size_t &gt; getTransferFoldableInnerUnitDims </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>srcType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorType</td>          <td class="paramname"><span class="paramname"><em>vectorType</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of dims can be folded away from transfer ops. It returns a failure if it can not determine the number of dims to be folded. </p>
<p>Ex 1: returns "2" if <span class="tt">srcType</span> is <a class="el" href="namespacemlir_1_1memref.html">memref&lt;512x16x1x1xf32&gt;</a> and <span class="tt">vectorType</span> is <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x16x1x1xf32&gt;</a> (there two inner most dims can be dropped by memref.subview ops)</p>
<p>Ex 2: returns "1" if <span class="tt">srcType</span> is <a class="el" href="namespacemlir_1_1memref.html">memref&lt;512x16x1x1xf32&gt;</a> with [8192, 16, 8, 1] strides and <span class="tt">vectorType</span> is <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x16x1x1xf32&gt;</a> (only the inner most unit dim of <span class="tt">srcType</span> can be dropped)</p>
<p>Ex 3: return "0" if <span class="tt">srcType</span> is <a class="el" href="namespacemlir_1_1memref.html">memref&lt;512x16x1x1xf32&gt;</a> and <span class="tt">vectorType</span> is <a class="el" href="namespacemlir_1_1vector.html">vector&lt;16x16x1x[1]xf32&gt;</a> (the most inner dim in <span class="tt">vectorType</span> is not a unit dim (it's a "scalable
unit") </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l01528">1528</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ad9add153e9bd7798ae26960fb18999df" name="ad9add153e9bd7798ae26960fb18999df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9add153e9bd7798ae26960fb18999df">&#9670;&#160;</a></span>ex1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* B vector&lt;4xi32&gt;* * Supports only to broadcasts The following cases are not supported* ex1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02252">2252</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

</div>
</div>
<a id="a9284bc20084c3c496ef82b87e495c1b1" name="a9284bc20084c3c496ef82b87e495c1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9284bc20084c3c496ef82b87e495c1b1">&#9670;&#160;</a></span>Example</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* B* Example</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fold <span class="tt">mulf(tr(broadcast(A)), broadcast(B))</span> into `vector.outerproduct(A,. </p>

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02241">2241</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

</div>
</div>
<a id="a611c177776150f2e11f15c1cec5764c1" name="a611c177776150f2e11f15c1cec5764c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611c177776150f2e11f15c1cec5764c1">&#9670;&#160;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* B rhs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02249">2249</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00311">mlir::ArithBuilder::_and()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00374">mlir::affine::AffineBuilder::add()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00314">mlir::ArithBuilder::add()</a>, <a class="el" href="Var_8cpp_source.html#l00103">mlir::sparse_tensor::ir_detail::VarSet::add()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearValueConstraints::addBound()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00520">mlir::xegpu::addElementwise()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00051">addIntegerAttrs()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01594">mlir::SimpleAffineExprFlattener::addLocalIdSemiAffine()</a>, <a class="el" href="XeGPUUtils_8cpp_source.html#l00545">mlir::xegpu::addWithRightAligned()</a>, <a class="el" href="AliasAnalysis_8cpp_source.html#l00080">mlir::AliasAnalysis::alias()</a>, <a class="el" href="classmlir_1_1detail_1_1AliasAnalysisTraits_1_1Concept.html#a83f50cc4bbe59ecf0e96b7f492ca8a1d">mlir::detail::AliasAnalysisTraits::Concept::alias()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00203">mlir::detail::AliasAnalysisTraits::Model&lt; ImplT &gt;::alias()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00440">mlir::LocalAliasAnalysis::alias()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00342">mlir::LocalAliasAnalysis::aliasImpl()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02082">mlir::arith::applyCmpPredicate()</a>, <a class="el" href="ArithOps_8cpp_source.html#l01939">mlir::arith::applyCmpPredicate()</a>, <a class="el" href="PatternApplicator_8cpp_source.html#l00058">mlir::PatternApplicator::applyCostModel()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00042">applyToIntegerAttrs()</a>, <a class="el" href="TosaCanonicalizations_8cpp_source.html#l00893">binaryFolder()</a>, <a class="el" href="Merger_8cpp_source.html#l00940">mlir::sparse_tensor::Merger::buildLattices()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00772">MmaSyncBuilder::buildMmaSync()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00387">mlir::affine::AffineBuilder::ceil()</a>, <a class="el" href="LocalAliasAnalysis_8cpp_source.html#l00320">checkDistinctObjects()</a>, <a class="el" href="ArithmeticUtils_8h_source.html#l00123">mlir::sparse_tensor::detail::checkedMul()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00036">checkOperandAffineExprRecursively()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00056">mlir::func::impl::DuplicateFunctionEliminationPassBase&lt; DerivedT &gt;::clonePass()</a>, <a class="el" href="PassOptions_8h_source.html#l00498">mlir::OptionValue&lt; mlir::OpPassManager &gt;::compare()</a>, <a class="el" href="structmlir_1_1OptionValue_3_01mlir_1_1OpPassManager_01_4.html#a834ac0244ba744375fcfacfcef914c09">mlir::OptionValue&lt; mlir::OpPassManager &gt;::compare()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00782">mlir::ValueBoundsConstraintSet::compare()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00586">compareIndices()</a>, <a class="el" href="OperationSupport_8h_source.html#l00448">mlir::OperationName::compareOpProperties()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00036">comparePosDepth()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00930">mlir::OperationName::UnregisteredOpModel::compareProperties()</a>, <a class="el" href="OperationSupport_8h_source.html#l00653">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::compareProperties()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01954">composedAffineMultiply()</a>, <a class="el" href="InlinerInterfaceImpl_8cpp_source.html#l00217">concatArrayAttr()</a>, <a class="el" href="CommonFolders_8h_source.html#l00046">mlir::constFoldBinaryOpConditional()</a>, <a class="el" href="OperationSupport_8h_source.html#l00444">mlir::OperationName::copyOpProperties()</a>, <a class="el" href="ExtensibleDialect_8h_source.html#l00496">mlir::DynamicOpDefinition::copyProperties()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00366">mlir::Operation::copyProperties()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00926">mlir::OperationName::UnregisteredOpModel::copyProperties()</a>, <a class="el" href="OperationSupport_8h_source.html#l00660">mlir::RegisteredOperationName::Model&lt; ConcreteOp &gt;::copyProperties()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00079">mlir::func::createDuplicateFunctionEliminationPass()</a>, <a class="el" href="TosaValidation_8cpp_source.html#l00872">mlir::tosa::createTosaValidation()</a>, <a class="el" href="OpImplementation_8h_source.html#l01430">mlir::AsmParser::CyclicParseReset::CyclicParseReset()</a>, <a class="el" href="OpImplementation_8h_source.html#l00284">mlir::AsmPrinter::CyclicPrintReset::CyclicPrintReset()</a>, <a class="el" href="classmlir_1_1DefaultTimingManager.html#ae94d4eac8ce614e27395c8325be3cfa4">mlir::DefaultTimingManager::DefaultTimingManager()</a>, <a class="el" href="classmlir_1_1DefaultTimingManager.html#aa7a8d458de607c058fcc1463de793994">mlir::DefaultTimingManager::DefaultTimingManager()</a>, <a class="el" href="mlir-c_2AffineExpr_8h.html#acef8f06738133e9c8680f649b997c7d4">DEFINE_C_API_STRUCT()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00313">deriveStaticUpperBound()</a>, <a class="el" href="Mem2Reg_8cpp_source.html#l00543">dominanceSort()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00044">mlir::detail::ElementsAttrIndexer::ElementsAttrIndexer()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00037">mlir::detail::ElementsAttrIndexer::ElementsAttrIndexer()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00707">mlir::shard::Sharding::equalHaloAndShardSizes()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00727">mlir::shard::Sharding::equalHaloSizes()</a>, <a class="el" href="ParallelLoopFusion_8cpp_source.html#l00041">equalIterationSpaces()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00711">mlir::shard::Sharding::equalShardSizes()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00688">mlir::shard::Sharding::equalSplitAxes()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00719">mlir::intrange::evaluatePred()</a>, <a class="el" href="OperationSupport_8h_source.html#l01405">mlir::OperationEquivalence::exactValueMatch()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00113">findDepIdxSet()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00383">mlir::affine::AffineBuilder::floor()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00094">foldBinaryOpChecked()</a>, <a class="el" href="IndexOps_8cpp_source.html#l00068">foldBinaryOpUnchecked()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00672">foldDivMul()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00430">mlir::sparse_tensor::foreachInSparseConstant()</a>, <a class="el" href="PredicateTree_8cpp_source.html#l00935">mlir::pdl_to_pdl_interp::MatcherNode::generateMatcherTree()</a>, <a class="el" href="ReductionNode_8cpp_source.html#l00051">mlir::ReductionNode::generateNewVariants()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00061">mlir::quant::detail::AnyQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00388">mlir::quant::detail::CalibratedQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00193">mlir::quant::detail::UniformQuantizedPerAxisTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00289">mlir::quant::detail::UniformQuantizedSubChannelTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Dialect_2Quant_2IR_2TypeDetail_8h_source.html#l00120">mlir::quant::detail::UniformQuantizedTypeStorage::KeyTy::genericIsEqual()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00420">genInsertionStore()</a>, <a class="el" href="Sparsification_8cpp_source.html#l01267">genStmt()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00526">genTensorStore()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="namespacemlir.html#ace395202c24e4dc75013296cf46ed692">mlir::getAffineConstantExprs()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00601">getAffineExprOfType()</a>, <a class="el" href="IntRangeOptimizations_8cpp_source.html#l00431">mlir::arith::impl::ArithIntRangeOptsBase&lt; DerivedT &gt;::getArgumentName()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00385">mlir::vector::getConstantVscaleMultiplier()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00176">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="DuplicateFunctionElimination_8cpp_source.html#l00061">mlir::func::impl::DuplicateFunctionEliminationPassBase&lt; DerivedT &gt;::getDependentDialects()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00241">mlir::AffineExpr::getLargestKnownDivisor()</a>, <a class="el" href="classmlir_1_1dataflow_1_1AbstractSparseBackwardDataFlowAnalysis.html#a67bf1550637f0af439412e69dc7fb2c3">mlir::dataflow::AbstractSparseBackwardDataFlowAnalysis::getLatticeElement()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00434">mlir::MLIRContext::getLoadedDialects()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00163">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getName()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00160">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::getPassName()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02786">mlir::arith::getReductionOp()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00711">mlir::MLIRContext::getRegisteredOperationsByDialect()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00341">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01133">getSemiAffineExprFromFlatForm()</a>, <a class="el" href="ScalableValueBoundsConstraintSet_8cpp_source.html#l00014">mlir::vector::ScalableValueBoundsConstraintSet::ConstantOrScalableBound::getSize()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00081">groupByDialectPerByte()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00905">hasSizeMismatch()</a>, <a class="el" href="TosaOps_8cpp_source.html#l00557">idivCheck()</a>, <a class="el" href="OperationSupport_8h_source.html#l01400">mlir::OperationEquivalence::ignoreValueEquivalence()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00184">mlir::intrange::inferAdd()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00367">mlir::intrange::inferCeilDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00319">mlir::intrange::inferCeilDivU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00360">mlir::intrange::inferDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00339">inferDivSRange()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00312">mlir::intrange::inferDivU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00288">inferDivURange()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00401">mlir::intrange::inferFloorDivS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00492">mlir::intrange::inferMaxS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00501">mlir::intrange::inferMaxU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00510">mlir::intrange::inferMinS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00519">mlir::intrange::inferMinU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00249">mlir::intrange::inferMul()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00422">mlir::intrange::inferRemS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00461">mlir::intrange::inferRemU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00593">mlir::intrange::inferShl()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00627">mlir::intrange::inferShrS()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00639">mlir::intrange::inferShrU()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00217">mlir::intrange::inferSub()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00577">mlir::intrange::inferXor()</a>, <a class="el" href="include_2mlir_2IR_2Diagnostics_8h_source.html#l00319">mlir::InFlightDiagnostic::InFlightDiagnostic()</a>, <a class="el" href="Diagnostic_8h_source.html#l00086">mlir::pdll::ast::InFlightDiagnostic::InFlightDiagnostic()</a>, <a class="el" href="LowerVectorShapeCast_8cpp_source.html#l00048">inplaceAdd()</a>, <a class="el" href="mlir_2TableGen_2Interfaces_8h_source.html#l00083">mlir::tblgen::Interface::Interface()</a>, <a class="el" href="IRNumbering_8cpp_source.html#l00130">mlir::bytecode::detail::IRNumberingState::IRNumberingState()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00412">mlir::linalg::isDimTimesConstantOrDimOnly()</a>, <a class="el" href="OpImplementation_8h_source.html#l01871">llvm::DenseMapInfo&lt; mlir::AsmDialectResourceHandle &gt;::isEqual()</a>, <a class="el" href="Block_8h_source.html#l00444">llvm::DenseMapInfo&lt; mlir::Block::iterator &gt;::isEqual()</a>, <a class="el" href="Attributes_8h_source.html#l00361">llvm::DenseMapInfo&lt; mlir::NamedAttribute &gt;::isEqual()</a>, <a class="el" href="OperationSupport_8h_source.html#l01452">llvm::DenseMapInfo&lt; mlir::OperationName &gt;::isEqual()</a>, <a class="el" href="PassInstrumentation_8h_source.html#l00149">llvm::DenseMapInfo&lt; mlir::PassInstrumentation::PipelineParentInfo &gt;::isEqual()</a>, <a class="el" href="Tools_2PDLL_2AST_2Types_8h_source.html#l00409">llvm::DenseMapInfo&lt; mlir::pdll::ast::Type &gt;::isEqual()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00805">llvm::DenseMapInfo&lt; mlir::ProgramPoint &gt;::isEqual()</a>, <a class="el" href="Remarks_8h_source.html#l00641">llvm::DenseMapInfo&lt; mlir::remark::detail::Remark &gt;::isEqual()</a>, <a class="el" href="BlockSupport_8h_source.html#l00190">llvm::DenseMapInfo&lt; mlir::SuccessorRange &gt;::isEqual()</a>, <a class="el" href="structllvm_1_1DenseMapInfo_3_01mlir_1_1tblgen_1_1Constraint_01_4.html#a8e243a7aa8b6febee70910bb7fe13f7c">llvm::DenseMapInfo&lt; mlir::tblgen::Constraint &gt;::isEqual()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00704">llvm::DenseMapInfo&lt; mlir::tblgen::DagLeaf &gt;::isEqual()</a>, <a class="el" href="include_2mlir_2TableGen_2Pattern_8h_source.html#l00686">llvm::DenseMapInfo&lt; mlir::tblgen::DagNode &gt;::isEqual()</a>, <a class="el" href="TypeID_8h_source.html#l00408">llvm::DenseMapInfo&lt; mlir::TypeID &gt;::isEqual()</a>, <a class="el" href="TypeRange_8h_source.html#l00206">llvm::DenseMapInfo&lt; mlir::TypeRange &gt;::isEqual()</a>, <a class="el" href="Value_8h_source.html#l00517">llvm::DenseMapInfo&lt; mlir::Value &gt;::isEqual()</a>, <a class="el" href="NanobindUtils_8h_source.html#l00430">llvm::DenseMapInfo&lt; MlirTypeID &gt;::isEqual()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00298">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;::isEqual()</a>, <a class="el" href="OpDefinition_8h_source.html#l02151">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &amp;&amp;!mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;::isEqual()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00756">mlir::DataFlowSolver::isEquivalent()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00897">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00829">mlir::OperationEquivalence::isEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00709">mlir::OperationEquivalence::isRegionEquivalentTo()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00812">mlir::OperationEquivalence::isRegionEquivalentTo()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00679">isStaticallyTrue()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00320">mlir::DialectRegistry::isSubsetOf()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00115">mlir::dataflow::AbstractDenseForwardDataFlowAnalysis::join()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00047">mlir::dataflow::AbstractDenseLattice::join()</a>, <a class="el" href="SparseAnalysis_8cpp_source.html#l00350">mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::join()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00044">mlir::dataflow::AbstractSparseLattice::join()</a>, <a class="el" href="ConstantPropagationAnalysis_8h_source.html#l00073">mlir::dataflow::ConstantValue::join()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00103">mlir::dataflow::Lattice&lt; ValueT &gt;::join()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00115">mlir::dataflow::Lattice&lt; ValueT &gt;::join()</a>, <a class="el" href="InferIntRangeInterface_8h_source.html#l00140">mlir::IntegerValueRange::join()</a>, <a class="el" href="InferStridedMetadataInterface_8h_source.html#l00085">mlir::StridedMetadataRange::join()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00081">mlir::tosa::ValueKnowledge::join()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00981">makeAtomicReductionGen()</a>, <a class="el" href="OpenMPToLLVMIRTranslation_8cpp_source.html#l00951">makeReductionGen()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00735">makeVectorShapes()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00171">BinaryArithOpToAPFloatConversion&lt; OpTy &gt;::matchAndRewrite()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02176">CmpFIntToFPConst::matchAndRewrite()</a>, <a class="el" href="ArithToAPFloat_8cpp_source.html#l00413">CmpFOpToAPFloatConversion::matchAndRewrite()</a>, <a class="el" href="FoldAddIntoDest_8cpp_source.html#l00058">FoldAddIntoDest::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00133">IAddCarryFold::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00213">MulExtendedFold&lt; spirv::SMulExtendedOp, true &gt;::matchAndRewrite()</a>, <a class="el" href="SPIRVCanonicalization_8cpp_source.html#l00289">UMulExtendedOpXOne::matchAndRewrite()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00061">materializeBinaryNanCheckIfRequired()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00412">mlir::dataflow::AbstractDenseBackwardDataFlowAnalysis::meet()</a>, <a class="el" href="DenseAnalysis_8h_source.html#l00051">mlir::dataflow::AbstractDenseLattice::meet()</a>, <a class="el" href="SparseAnalysis_8cpp_source.html#l00668">mlir::dataflow::AbstractSparseBackwardDataFlowAnalysis::meet()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00050">mlir::dataflow::AbstractSparseLattice::meet()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00109">mlir::dataflow::Lattice&lt; ValueT &gt;::meet()</a>, <a class="el" href="SparseAnalysis_8h_source.html#l00143">mlir::dataflow::Lattice&lt; ValueT &gt;::meet()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00136">mlir::tosa::ValueKnowledge::meet()</a>, <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html#afcf51296504b5089513d8734b71ecd19">mlir::affine::MemRefAccess::MemRefAccess()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00207">mlir::detail::OpPassManagerImpl::mergeInto()</a>, <a class="el" href="InferIntRangeCommon_8cpp_source.html#l00057">minMaxBy()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00137">mlirAffineAddExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00190">mlirAffineCeilDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00024">mlirAffineExprEqual()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00176">mlirAffineFloorDivExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00163">mlirAffineModExprGet()</a>, <a class="el" href="CAPI_2IR_2AffineExpr_8cpp_source.html#l00150">mlirAffineMulExprGet()</a>, <a class="el" href="IR_8cpp_source.html#l00468">mlirModuleEqual()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00380">mlir::affine::AffineBuilder::mul()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00324">mlir::ArithBuilder::mul()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00061">mulIntegerAttrs()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00132">mlir::affine::MemRefAccess::operator!=()</a>, <a class="el" href="Location_8h_source.html#l00094">mlir::Location::operator!=()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00107">mlir::ModRefResult::operator!=()</a>, <a class="el" href="Attributes_8h_source.html#l00198">mlir::NamedAttribute::operator!=()</a>, <a class="el" href="OperationSupport_8h_source.html#l00490">mlir::OperationName::operator!=()</a>, <a class="el" href="OpDefinition_8h_source.html#l00265">mlir::operator!=()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00270">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01066">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01072">mlir::operator!=()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01076">mlir::operator!=()</a>, <a class="el" href="PatternMatch_8h_source.html#l00053">mlir::PatternBenefit::operator!=()</a>, <a class="el" href="IR_2Region_8h_source.html#l00150">mlir::Region::OpIterator::operator!=()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00222">mlir::RegionSuccessor::operator!=</a>, <a class="el" href="ValueRange_8h_source.html#l00363">mlir::ResultRange::UseIterator::operator!=()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00749">mlir::shard::Sharding::operator!=()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00743">mlir::shard::Sharding::operator!=()</a>, <a class="el" href="WalkResult_8h_source.html#l00044">mlir::WalkResult::operator!=()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00048">mlir::operator&amp;()</a>, <a class="el" href="BufferDeallocationOpInterface_8cpp_source.html#l00222">mlir::bufferization::ValueComparator::operator()()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00891">mlir::AffineExpr::operator*()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00069">operator*()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00207">mlir::detail::ElementsAttrIterator&lt; T &gt;::operator-()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00062">operator/()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00213">mlir::detail::ElementsAttrIterator&lt; T &gt;::operator&lt;()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00943">mlir::detail::ParallelDiagnosticHandlerImpl::ThreadDiagnostic::operator&lt;()</a>, <a class="el" href="Attributes_8cpp_source.html#l00068">mlir::NamedAttribute::operator&lt;()</a>, <a class="el" href="Attributes_8cpp_source.html#l00072">mlir::NamedAttribute::operator&lt;()</a>, <a class="el" href="PatternMatch_8h_source.html#l00054">mlir::PatternBenefit::operator&lt;()</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00280">mlir::spirv::StructType::MemberDecorationInfo::operator&lt;</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00303">mlir::spirv::StructType::StructDecorationInfo::operator&lt;</a>, <a class="el" href="PatternMatch_8h_source.html#l00058">mlir::PatternBenefit::operator&lt;=()</a>, <a class="el" href="OpImplementation_8h_source.html#l01432">mlir::AsmParser::CyclicParseReset::operator=()</a>, <a class="el" href="OpImplementation_8h_source.html#l00287">mlir::AsmPrinter::CyclicPrintReset::operator=()</a>, <a class="el" href="AsmState_8h_source.html#l00118">mlir::AsmResourceBlob::operator=()</a>, <a class="el" href="classmlir_1_1DefaultTimingManager.html#aee772d43eb0a231e02ff5a26ba8aa2b9">mlir::DefaultTimingManager::operator=()</a>, <a class="el" href="InterfaceSupport_8h_source.html#l00177">mlir::detail::InterfaceMap::operator=()</a>, <a class="el" href="OperationSupport_8cpp_source.html#l00152">mlir::NamedAttrList::operator=()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00355">mlir::OpPassManager::operator=()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00359">mlir::OpPassManager::operator=()</a>, <a class="el" href="structmlir_1_1OptionValue_3_01mlir_1_1OpPassManager_01_4.html#aeaf0e5d7f76505c91c37fc52030444ba">mlir::OptionValue&lt; mlir::OpPassManager &gt;::operator=()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">mlir::affine::MemRefAccess::operator==()</a>, <a class="el" href="ConstantPropagationAnalysis_8h_source.html#l00052">mlir::dataflow::ConstantValue::operator==()</a>, <a class="el" href="BuiltinAttributeInterfaces_8h_source.html#l00210">mlir::detail::ElementsAttrIterator&lt; T &gt;::operator==()</a>, <a class="el" href="InferIntRangeInterface_8h_source.html#l00135">mlir::IntegerValueRange::operator==()</a>, <a class="el" href="LLVMDialect_8h_source.html#l00183">mlir::LLVM::GEPIndicesAdaptor&lt; DynamicRange &gt;::iterator::operator==()</a>, <a class="el" href="Location_8h_source.html#l00093">mlir::Location::operator==()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00106">mlir::ModRefResult::operator==()</a>, <a class="el" href="Attributes_8h_source.html#l00195">mlir::NamedAttribute::operator==()</a>, <a class="el" href="OperationSupport_8h_source.html#l00489">mlir::OperationName::operator==()</a>, <a class="el" href="TypeRange_8h_source.html#l00167">mlir::operator==()</a>, <a class="el" href="OpDefinition_8h_source.html#l00262">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01063">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01069">mlir::operator==()</a>, <a class="el" href="mlir_2IR_2BuiltinAttributes_8h_source.html#l01073">mlir::operator==()</a>, <a class="el" href="PatternMatch_8h_source.html#l00050">mlir::PatternBenefit::operator==()</a>, <a class="el" href="IR_2Region_8h_source.html#l00147">mlir::Region::OpIterator::operator==()</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00257">mlir::RegionBranchPoint::operator==</a>, <a class="el" href="ControlFlowInterfaces_8h_source.html#l00218">mlir::RegionSuccessor::operator==()</a>, <a class="el" href="ValueRange_8h_source.html#l00362">mlir::ResultRange::UseIterator::operator==()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00745">mlir::shard::Sharding::operator==()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00739">mlir::shard::Sharding::operator==()</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00273">mlir::spirv::StructType::MemberDecorationInfo::operator==</a>, <a class="el" href="SPIRVTypes_8h_source.html#l00297">mlir::spirv::StructType::StructDecorationInfo::operator==</a>, <a class="el" href="TargetEnv_8h_source.html#l00032">mlir::tosa::TosaLevel::operator==()</a>, <a class="el" href="ShapeUtils_8h_source.html#l00075">mlir::tosa::ValueKnowledge::operator==()</a>, <a class="el" href="UseDefLists_8h_source.html#l00326">mlir::ValueUseIterator&lt; OpOperand &gt;::operator==()</a>, <a class="el" href="WalkResult_8h_source.html#l00043">mlir::WalkResult::operator==()</a>, <a class="el" href="PatternMatch_8h_source.html#l00057">mlir::PatternBenefit::operator&gt;()</a>, <a class="el" href="PatternMatch_8h_source.html#l00059">mlir::PatternBenefit::operator&gt;=()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00041">mlir::operator|()</a>, <a class="el" href="Class_8h_source.html#l00490">operator|()</a>, <a class="el" href="DataFlowFramework_8h_source.html#l00044">mlir::operator|=()</a>, <a class="el" href="Class_8h_source.html#l00497">operator|=()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00354">mlir::OpPassManager::OpPassManager()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00353">mlir::OpPassManager::OpPassManager()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00124">mlir::detail::OpPassManagerImpl::OpPassManagerImpl()</a>, <a class="el" href="structmlir_1_1OptionValue_3_01mlir_1_1OpPassManager_01_4.html#ade63ca1af65b2359d7518f878c1b30ae">mlir::OptionValue&lt; mlir::OpPassManager &gt;::OptionValue()</a>, <a class="el" href="classmlir_1_1detail_1_1OpToOpPassAdaptor.html#a65e7b6c5c5748baa8e6339ba58a8be2b">mlir::detail::OpToOpPassAdaptor::OpToOpPassAdaptor()</a>, <a class="el" href="OuterProductFusion_8cpp_source.html#l00144">mlir::arm_sme::impl::OuterProductFusionBase&lt; DerivedT &gt;::OuterProductFusionBase()</a>, <a class="el" href="OpImplementation_8h_source.html#l01767">mlir::OpAsmParser::parseAssignmentList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00294">parseCmpOp()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a13e2984db44d0a267a04a3daa6d4f89d">mlir::OpAsmParser::parseOptionalAssignmentList()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00774">mlir::ValueBoundsConstraintSet::populateAndCompare()</a>, <a class="el" href="DebugCounter_8cpp_source.html#l00091">mlir::tracing::DebugCounter::print()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03039">mlir::AsmPrinter::Impl::printAffineExprInternal()</a>, <a class="el" href="Translation_8cpp_source.html#l00166">mlir::TranslationParser::printOptionInfo()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00072">mlir::printRegisteredPasses()</a>, <a class="el" href="PassStatistics_8cpp_source.html#l00059">printResultsAsList()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00155">mlir::AffineExpr::replace()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00339">mlir::ArithBuilder::select()</a>, <a class="el" href="OperationSupport_8h_source.html#l00495">mlir::OperationName::setImpl()</a>, <a class="el" href="classmlir_1_1dataflow_1_1AbstractSparseForwardDataFlowAnalysis.html#a4c7bfb6ffb519d4f8d9606ce5f37dab5">mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setToEntryState()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00329">mlir::ArithBuilder::sgt()</a>, <a class="el" href="ShardOps_8cpp_source.html#l00753">mlir::shard::Sharding::Sharding()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01133">shortenAddChainsContainingAll()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00972">simplifyCeilDiv()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00822">simplifyExprAndOperands()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00913">simplifyFloorDiv()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01019">simplifyMod()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00836">simplifyMul()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00334">mlir::ArithBuilder::slt()</a>, <a class="el" href="Storage_8h_source.html#l00356">mlir::sparse_tensor::SparseTensorStorage&lt; P, C, V &gt;::sortInPlace()</a>, <a class="el" href="ODS_2Context_8cpp_source.html#l00081">sortMapByName()</a>, <a class="el" href="File_8cpp_source.html#l00109">streq()</a>, <a class="el" href="File_8cpp_source.html#l00114">strne()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00801">mlir::ValueBoundsConstraintSet::strongCompare()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00377">mlir::affine::AffineBuilder::sub()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00319">mlir::ArithBuilder::sub()</a>, <a class="el" href="ArithOps_8cpp_source.html#l00056">subIntegerAttrs()</a>, <a class="el" href="Class_8cpp_source.html#l00054">mlir::tblgen::MethodParameters::subsumes()</a>, <a class="el" href="Pass_2Pass_8cpp_source.html#l00754">mlir::detail::OpToOpPassAdaptor::tryMergeInto()</a>, <a class="el" href="DimLvlMap_8cpp_source.html#l00040">mlir::sparse_tensor::ir_detail::DimLvlExpr::unpackBinop()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01347">mlir::SimpleAffineExprFlattener::visitAddExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01371">mlir::SimpleAffineExprFlattener::visitModExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01320">mlir::SimpleAffineExprFlattener::visitMulExpr()</a>, <a class="el" href="classmlir_1_1LocalAliasAnalysis.html#a68468af8b42038a15f857b5f229e2c44">mlir::LocalAliasAnalysis::~LocalAliasAnalysis()</a>, <a class="el" href="classmlir_1_1OpPassManager.html#a1e1778ef419bb18b79b63624b3e0f5fa">mlir::OpPassManager::~OpPassManager()</a>, and <a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html#a87c4398e4b523c2f51f8e19e85b8a56c">mlir::SimpleAffineExprFlattener::~SimpleAffineExprFlattener()</a>.</p>

</div>
</div>
<a id="aa816ee744e158291cc7abe613735fbfd" name="aa816ee744e158291cc7abe613735fbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa816ee744e158291cc7abe613735fbfd">&#9670;&#160;</a></span>rhsBcast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* B rhsBcast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="VectorTransforms_8cpp_source.html#l02245">2245</a> of file <a class="el" href="VectorTransforms_8cpp_source.html">VectorTransforms.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
