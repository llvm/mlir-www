<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::AffineMap Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1AffineMap.html">AffineMap</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classmlir_1_1AffineMap-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::AffineMap Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a491f21c36efbd2ad2e664d16948c016c" id="r_a491f21c36efbd2ad2e664d16948c016c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> = <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5605b1cc86aac352486868fa9a66e7a9" id="r_a5605b1cc86aac352486868fa9a66e7a9"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap</a> ()=default</td></tr>
<tr class="memitem:a6cd0836d686d1e4e23f9da8ff0cd54e0" id="r_a6cd0836d686d1e4e23f9da8ff0cd54e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cd0836d686d1e4e23f9da8ff0cd54e0">AffineMap</a> (<a class="el" href="#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *map)</td></tr>
<tr class="memitem:a07ce6ee55edc21c008a3bf8d10a2d726" id="r_a07ce6ee55edc21c008a3bf8d10a2d726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07ce6ee55edc21c008a3bf8d10a2d726">getContext</a> () const</td></tr>
<tr class="memitem:a4db87d862458ead8c492e1a05ce18e33" id="r_a4db87d862458ead8c492e1a05ce18e33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4db87d862458ead8c492e1a05ce18e33">operator bool</a> () const</td></tr>
<tr class="memitem:a7381857cac60752009640964e99172c2" id="r_a7381857cac60752009640964e99172c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7381857cac60752009640964e99172c2">operator==</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="memitem:ad066a62bd10ed01423748bdd913565be" id="r_ad066a62bd10ed01423748bdd913565be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad066a62bd10ed01423748bdd913565be">operator!=</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> other) const</td></tr>
<tr class="memitem:af33ea095c58804447510ad5ff023975c" id="r_af33ea095c58804447510ad5ff023975c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33ea095c58804447510ad5ff023975c">isIdentity</a> () const</td></tr>
<tr class="memdesc:af33ea095c58804447510ad5ff023975c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an identity affine map.  <br /></td></tr>
<tr class="memitem:a93371aad5ea3f31f48e132f8c7cbb302" id="r_a93371aad5ea3f31f48e132f8c7cbb302"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93371aad5ea3f31f48e132f8c7cbb302">isSymbolIdentity</a> () const</td></tr>
<tr class="memdesc:a93371aad5ea3f31f48e132f8c7cbb302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an identity affine map on the symbol identifiers.  <br /></td></tr>
<tr class="memitem:a1ccbe714fa69ce8426190f88b7854a98" id="r_a1ccbe714fa69ce8426190f88b7854a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ccbe714fa69ce8426190f88b7854a98">isMinorIdentity</a> () const</td></tr>
<tr class="memdesc:a1ccbe714fa69ce8426190f88b7854a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a minor identity, i.e.  <br /></td></tr>
<tr class="memitem:acf141c61521d9a40ba68c0b350a31836" id="r_acf141c61521d9a40ba68c0b350a31836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf141c61521d9a40ba68c0b350a31836">getBroadcastDims</a> () const</td></tr>
<tr class="memdesc:acf141c61521d9a40ba68c0b350a31836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of broadcast dimensions (i.e.  <br /></td></tr>
<tr class="memitem:a753daf697958f1aa999c10c163d3c35b" id="r_a753daf697958f1aa999c10c163d3c35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a753daf697958f1aa999c10c163d3c35b">isMinorIdentityWithBroadcasting</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *broadcastedDims=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>) const</td></tr>
<tr class="memdesc:a753daf697958f1aa999c10c163d3c35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a minor identity up to broadcasted dimensions which are indicated by value 0 in the result.  <br /></td></tr>
<tr class="memitem:a819c4c0117656eae56b72348e469c01e" id="r_a819c4c0117656eae56b72348e469c01e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a819c4c0117656eae56b72348e469c01e">isPermutationOfMinorIdentityWithBroadcasting</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;permutedDims) const</td></tr>
<tr class="memdesc:a819c4c0117656eae56b72348e469c01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this affine map can be converted to a minor identity with broadcast by doing a permute.  <br /></td></tr>
<tr class="memitem:a5752e3927fef1c67c276e3aa956e9cfe" id="r_a5752e3927fef1c67c276e3aa956e9cfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5752e3927fef1c67c276e3aa956e9cfe">isEmpty</a> () const</td></tr>
<tr class="memdesc:a5752e3927fef1c67c276e3aa956e9cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is an empty map, i.e., () -&gt; ().  <br /></td></tr>
<tr class="memitem:a4197b91018d6d6badaccdcb0ce6c1e12" id="r_a4197b91018d6d6badaccdcb0ce6c1e12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4197b91018d6d6badaccdcb0ce6c1e12">isSingleConstant</a> () const</td></tr>
<tr class="memdesc:a4197b91018d6d6badaccdcb0ce6c1e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map is a single result constant function.  <br /></td></tr>
<tr class="memitem:a359c688633fed9ca27c7fdf4fdad9487" id="r_a359c688633fed9ca27c7fdf4fdad9487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a359c688633fed9ca27c7fdf4fdad9487">isConstant</a> () const</td></tr>
<tr class="memdesc:a359c688633fed9ca27c7fdf4fdad9487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this affine map has only constant results.  <br /></td></tr>
<tr class="memitem:a029344fc35377bfa5b59b51edaf304d9" id="r_a029344fc35377bfa5b59b51edaf304d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a029344fc35377bfa5b59b51edaf304d9">getSingleConstantResult</a> () const</td></tr>
<tr class="memdesc:a029344fc35377bfa5b59b51edaf304d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant result of this map.  <br /></td></tr>
<tr class="memitem:a7b5a032d678f6c17893836f3ce8a107c" id="r_a7b5a032d678f6c17893836f3ce8a107c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b5a032d678f6c17893836f3ce8a107c">getConstantResults</a> () const</td></tr>
<tr class="memdesc:a7b5a032d678f6c17893836f3ce8a107c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the constant results of this map.  <br /></td></tr>
<tr class="memitem:ae0ecd6ef18c3c3fa94c053f5fba67bdf" id="r_ae0ecd6ef18c3c3fa94c053f5fba67bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0ecd6ef18c3c3fa94c053f5fba67bdf">print</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os) const</td></tr>
<tr class="memitem:ac981930c6d7e6b46b46c4c678d9b5f17" id="r_ac981930c6d7e6b46b46c4c678d9b5f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac981930c6d7e6b46b46c4c678d9b5f17">dump</a> () const</td></tr>
<tr class="memitem:a75bef7af11cc1451c2e440718c5a5933" id="r_a75bef7af11cc1451c2e440718c5a5933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75bef7af11cc1451c2e440718c5a5933">getNumDims</a> () const</td></tr>
<tr class="memitem:a750b299a4842c7965de35bd2cb1479a0" id="r_a750b299a4842c7965de35bd2cb1479a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a750b299a4842c7965de35bd2cb1479a0">getNumSymbols</a> () const</td></tr>
<tr class="memitem:a96f194ae3b4baf33c67b10c9f795b564" id="r_a96f194ae3b4baf33c67b10c9f795b564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a96f194ae3b4baf33c67b10c9f795b564">getNumResults</a> () const</td></tr>
<tr class="memitem:aa821f07143bcad97d6df532c232129a3" id="r_aa821f07143bcad97d6df532c232129a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa821f07143bcad97d6df532c232129a3">getNumInputs</a> () const</td></tr>
<tr class="memitem:a79007ce78cfccb064390c22a4af6037c" id="r_a79007ce78cfccb064390c22a4af6037c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79007ce78cfccb064390c22a4af6037c">getResults</a> () const</td></tr>
<tr class="memitem:ac60458b2cba87d765341cd6b2d41ed12" id="r_ac60458b2cba87d765341cd6b2d41ed12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac60458b2cba87d765341cd6b2d41ed12">getResult</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="memitem:a1ff49306f1f5459448db5f41c55daa3e" id="r_a1ff49306f1f5459448db5f41c55daa3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff49306f1f5459448db5f41c55daa3e">getDimPosition</a> (<a class="el" href="classunsigned.html">unsigned</a> idx) const</td></tr>
<tr class="memdesc:a1ff49306f1f5459448db5f41c55daa3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the position of the dimensional expression at the given result, when the caller knows it is safe to do so.  <br /></td></tr>
<tr class="memitem:a6d5de865f8ff094af37d1990af727c2e" id="r_a6d5de865f8ff094af37d1990af727c2e"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d5de865f8ff094af37d1990af727c2e">getResultPosition</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> input) const</td></tr>
<tr class="memdesc:a6d5de865f8ff094af37d1990af727c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the first result position where <span class="tt">input</span> dimension resides.  <br /></td></tr>
<tr class="memitem:a173d3fd01950f75a2285a872b22e2c48" id="r_a173d3fd01950f75a2285a872b22e2c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a173d3fd01950f75a2285a872b22e2c48">isFunctionOfDim</a> (<a class="el" href="classunsigned.html">unsigned</a> position) const</td></tr>
<tr class="memdesc:a173d3fd01950f75a2285a872b22e2c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> <span class="tt">position</span>.  <br /></td></tr>
<tr class="memitem:a7df13ef25920c15d07c7bc9686b26be7" id="r_a7df13ef25920c15d07c7bc9686b26be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7df13ef25920c15d07c7bc9686b26be7">isFunctionOfSymbol</a> (<a class="el" href="classunsigned.html">unsigned</a> position) const</td></tr>
<tr class="memdesc:a7df13ef25920c15d07c7bc9686b26be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression.">AffineSymbolExpr</a> <span class="tt">position</span>.  <br /></td></tr>
<tr class="memitem:ad9311cb0642ba9e548c9773afada69d8" id="r_ad9311cb0642ba9e548c9773afada69d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9311cb0642ba9e548c9773afada69d8">walkExprs</a> (<a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt; callback) const</td></tr>
<tr class="memdesc:ad9311cb0642ba9e548c9773afada69d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk all of the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>'s in this mapping.  <br /></td></tr>
<tr class="memitem:aa1fdca78f9d7bde157d251892dd99fa8" id="r_aa1fdca78f9d7bde157d251892dd99fa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1fdca78f9d7bde157d251892dd99fa8">replaceDimsAndSymbols</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; dimReplacements, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; symReplacements, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:aa1fdca78f9d7bde157d251892dd99fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method substitutes any uses of dimensions and symbols (e.g.  <br /></td></tr>
<tr class="memitem:ac7d5c7e20f021aac37fcb4e65cbfca8c" id="r_ac7d5c7e20f021aac37fcb4e65cbfca8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7d5c7e20f021aac37fcb4e65cbfca8c">replace</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement</a>, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:ac7d5c7e20f021aac37fcb4e65cbfca8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse replace method.  <br /></td></tr>
<tr class="memitem:a33e5fc7ddb3f04679b3563a1525274ae" id="r_a33e5fc7ddb3f04679b3563a1525274ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e5fc7ddb3f04679b3563a1525274ae">replace</a> (const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;map) const</td></tr>
<tr class="memdesc:a33e5fc7ddb3f04679b3563a1525274ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse replace method.  <br /></td></tr>
<tr class="memitem:a4822614b5ae9d1f80e0b3da7b3ce664d" id="r_a4822614b5ae9d1f80e0b3da7b3ce664d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4822614b5ae9d1f80e0b3da7b3ce664d">replace</a> (const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;map, <a class="el" href="classunsigned.html">unsigned</a> numResultDims, <a class="el" href="classunsigned.html">unsigned</a> numResultSyms) const</td></tr>
<tr class="memdesc:a4822614b5ae9d1f80e0b3da7b3ce664d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse replace method.  <br /></td></tr>
<tr class="memitem:a3e72052d4b3c5ebbabbcc56d786901af" id="r_a3e72052d4b3c5ebbabbcc56d786901af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e72052d4b3c5ebbabbcc56d786901af">shiftDims</a> (<a class="el" href="classunsigned.html">unsigned</a> shift, <a class="el" href="classunsigned.html">unsigned</a> offset=0) const</td></tr>
<tr class="memdesc:a3e72052d4b3c5ebbabbcc56d786901af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace dims[offset ... numDims) by dims[offset + shift ... shift + numDims).  <br /></td></tr>
<tr class="memitem:aab2febbfaf719c1e16ba071663244b8b" id="r_aab2febbfaf719c1e16ba071663244b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab2febbfaf719c1e16ba071663244b8b">shiftSymbols</a> (<a class="el" href="classunsigned.html">unsigned</a> shift, <a class="el" href="classunsigned.html">unsigned</a> offset=0) const</td></tr>
<tr class="memdesc:aab2febbfaf719c1e16ba071663244b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace symbols[offset ... numSymbols) by symbols[offset + shift ... shift + numSymbols).  <br /></td></tr>
<tr class="memitem:a6192ae9c7bae0a08642d8c37d0c74182" id="r_a6192ae9c7bae0a08642d8c37d0c74182"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6192ae9c7bae0a08642d8c37d0c74182">dropResult</a> (<a class="el" href="classint64__t.html">int64_t</a> pos) const</td></tr>
<tr class="memdesc:a6192ae9c7bae0a08642d8c37d0c74182"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the same number of dims and symbols and one less result at <span class="tt">pos</span>, dropped.  <br /></td></tr>
<tr class="memitem:a0517cd0d6664663cbf004873030538c9" id="r_a0517cd0d6664663cbf004873030538c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0517cd0d6664663cbf004873030538c9">dropResults</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; positions) const</td></tr>
<tr class="memitem:abab7113ad70691bafd354aa8b19b83c5" id="r_abab7113ad70691bafd354aa8b19b83c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abab7113ad70691bafd354aa8b19b83c5">dropResults</a> (const llvm::SmallBitVector &amp;positions) const</td></tr>
<tr class="memitem:a42368d516e602b0d263039fc82b1aa7b" id="r_a42368d516e602b0d263039fc82b1aa7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42368d516e602b0d263039fc82b1aa7b">insertResult</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classunsigned.html">unsigned</a> pos) const</td></tr>
<tr class="memdesc:a42368d516e602b0d263039fc82b1aa7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the same number of dims and symbols and an extra result inserted at <span class="tt">pos</span>.  <br /></td></tr>
<tr class="memitem:ae066f1e53d4d5a7f469874e221abf3f6" id="r_ae066f1e53d4d5a7f469874e221abf3f6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae066f1e53d4d5a7f469874e221abf3f6">constantFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operandConstants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;results, <a class="el" href="classbool.html">bool</a> *hasPoison=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>) const</td></tr>
<tr class="memdesc:ae066f1e53d4d5a7f469874e221abf3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Folds the results of the application of an affine map on the provided operands to a constant if possible.  <br /></td></tr>
<tr class="memitem:ad979cffb85eaeda752bd53688165d2d2" id="r_ad979cffb85eaeda752bd53688165d2d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad979cffb85eaeda752bd53688165d2d2">partialConstantFold</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operandConstants, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *results=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> *hasPoison=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>) const</td></tr>
<tr class="memdesc:ad979cffb85eaeda752bd53688165d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagates the constant operands into this affine map.  <br /></td></tr>
<tr class="memitem:af2baf4561cf7d74a9959fd9e875c9a82" id="r_af2baf4561cf7d74a9959fd9e875c9a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2baf4561cf7d74a9959fd9e875c9a82">compose</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map) const</td></tr>
<tr class="memdesc:af2baf4561cf7d74a9959fd9e875c9a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> resulting from composing <span class="tt">this</span> with <span class="tt">map</span>.  <br /></td></tr>
<tr class="memitem:a7c205e3ff1701beab13d721c11031ed2" id="r_a7c205e3ff1701beab13d721c11031ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c205e3ff1701beab13d721c11031ed2">compose</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; values) const</td></tr>
<tr class="memdesc:a7c205e3ff1701beab13d721c11031ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies composition by the dims of <span class="tt">this</span> to the integer <span class="tt">values</span> and returns the resulting values.  <br /></td></tr>
<tr class="memitem:a8b4d79d68fb5c4e34706143bffb1a420" id="r_a8b4d79d68fb5c4e34706143bffb1a420"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b4d79d68fb5c4e34706143bffb1a420">getNumOfZeroResults</a> () const</td></tr>
<tr class="memdesc:a8b4d79d68fb5c4e34706143bffb1a420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of "zero" results (constant values == 0) in this map.  <br /></td></tr>
<tr class="memitem:ac8532830efc67348905fd1e414beaebb" id="r_ac8532830efc67348905fd1e414beaebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8532830efc67348905fd1e414beaebb">dropZeroResults</a> ()</td></tr>
<tr class="memdesc:ac8532830efc67348905fd1e414beaebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> resulting from removing "zero" results (constant values == 0) from this map.  <br /></td></tr>
<tr class="memitem:a457a8530ceb03d15e3b171ea3a9fc4a6" id="r_a457a8530ceb03d15e3b171ea3a9fc4a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a457a8530ceb03d15e3b171ea3a9fc4a6">isProjectedPermutation</a> (<a class="el" href="classbool.html">bool</a> allowZeroInResults=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>) const</td></tr>
<tr class="memdesc:a457a8530ceb03d15e3b171ea3a9fc4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> represents a subset (i.e.  <br /></td></tr>
<tr class="memitem:af6e665372add0df0668e1ebd231488b4" id="r_af6e665372add0df0668e1ebd231488b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6e665372add0df0668e1ebd231488b4">isPermutation</a> () const</td></tr>
<tr class="memdesc:af6e665372add0df0668e1ebd231488b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> represents a symbol-less permutation map.  <br /></td></tr>
<tr class="memitem:add23e0ad557890ca7113d38e96c4c870" id="r_add23e0ad557890ca7113d38e96c4c870"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add23e0ad557890ca7113d38e96c4c870">getSubMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; resultPos) const</td></tr>
<tr class="memdesc:add23e0ad557890ca7113d38e96c4c870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the <span class="tt">resultPos</span> subset.  <br /></td></tr>
<tr class="memitem:a054f395f1fc7a1db524caa616e460bed" id="r_a054f395f1fc7a1db524caa616e460bed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a054f395f1fc7a1db524caa616e460bed">getSliceMap</a> (<a class="el" href="classunsigned.html">unsigned</a> start, <a class="el" href="classunsigned.html">unsigned</a> length) const</td></tr>
<tr class="memdesc:a054f395f1fc7a1db524caa616e460bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of <span class="tt">length</span> expressions starting from <span class="tt">start</span>.  <br /></td></tr>
<tr class="memitem:a06383d6033de3ed99168e650abaaf66d" id="r_a06383d6033de3ed99168e650abaaf66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06383d6033de3ed99168e650abaaf66d">getMajorSubMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numResults) const</td></tr>
<tr class="memdesc:a06383d6033de3ed99168e650abaaf66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the most major <span class="tt">numResults</span> results.  <br /></td></tr>
<tr class="memitem:a481ad498d786f3c6e9b17965ea1d83a8" id="r_a481ad498d786f3c6e9b17965ea1d83a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a481ad498d786f3c6e9b17965ea1d83a8">getMinorSubMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numResults) const</td></tr>
<tr class="memdesc:a481ad498d786f3c6e9b17965ea1d83a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the map consisting of the most minor <span class="tt">numResults</span> results.  <br /></td></tr>
<tr class="memitem:a4e88fa7c055d33c1eae5a72f1084fcbc" id="r_a4e88fa7c055d33c1eae5a72f1084fcbc"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e88fa7c055d33c1eae5a72f1084fcbc">getLargestKnownDivisorOfMapExprs</a> ()</td></tr>
<tr class="memdesc:a4e88fa7c055d33c1eae5a72f1084fcbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the largest known divisor of all map expressions.  <br /></td></tr>
<tr class="memitem:acd80590df09c086f3800c7aebf110809" id="r_acd80590df09c086f3800c7aebf110809"><td class="memItemLeft" align="right" valign="top">friend::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd80590df09c086f3800c7aebf110809">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="memitem:a43659699b095f0e0f85fb2efb35bc9b8" id="r_a43659699b095f0e0f85fb2efb35bc9b8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvoid.html">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43659699b095f0e0f85fb2efb35bc9b8">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a43659699b095f0e0f85fb2efb35bc9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods supporting C API.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3cfca2eb29fddf3c4bda714cccaa53f9" id="r_a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3cfca2eb29fddf3c4bda714cccaa53f9">get</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a3cfca2eb29fddf3c4bda714cccaa53f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with no dimensions or symbols: () -&gt; ().  <br /></td></tr>
<tr class="memitem:ad0742d98deb42f72abc9a7b2fa232dc8" id="r_ad0742d98deb42f72abc9a7b2fa232dc8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0742d98deb42f72abc9a7b2fa232dc8">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad0742d98deb42f72abc9a7b2fa232dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a zero result affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> symbols, e.g.: <span class="tt">(...) -&gt; ()</span>.  <br /></td></tr>
<tr class="memitem:aeb27ba563698d7152eced09f1c5a99c6" id="r_aeb27ba563698d7152eced09f1c5a99c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb27ba563698d7152eced09f1c5a99c6">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:aeb27ba563698d7152eced09f1c5a99c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> mapping to a single output dimension.  <br /></td></tr>
<tr class="memitem:aa05f70527f322fb8d381e416a96db44d" id="r_aa05f70527f322fb8d381e416a96db44d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa05f70527f322fb8d381e416a96db44d">get</a> (<a class="el" href="classunsigned.html">unsigned</a> dimCount, <a class="el" href="classunsigned.html">unsigned</a> symbolCount, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aa05f70527f322fb8d381e416a96db44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> mapping to the given results.  <br /></td></tr>
<tr class="memitem:ad98c7861efe6542d1e99c8172cc6061a" id="r_ad98c7861efe6542d1e99c8172cc6061a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad98c7861efe6542d1e99c8172cc6061a">getConstantMap</a> (<a class="el" href="classint64__t.html">int64_t</a> val, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ad98c7861efe6542d1e99c8172cc6061a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a single constant result affine map.  <br /></td></tr>
<tr class="memitem:a39ed2c2a4c743450a4a999fa6db1bf84" id="r_a39ed2c2a4c743450a4a999fa6db1bf84"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39ed2c2a4c743450a4a999fa6db1bf84">getMultiDimIdentityMap</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a39ed2c2a4c743450a4a999fa6db1bf84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with 'numDims' identity result dim exprs.  <br /></td></tr>
<tr class="memitem:a035fc7c93286e3aa0354f522f2cd885a" id="r_a035fc7c93286e3aa0354f522f2cd885a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a035fc7c93286e3aa0354f522f2cd885a">getMinorIdentityMap</a> (<a class="el" href="classunsigned.html">unsigned</a> dims, <a class="el" href="classunsigned.html">unsigned</a> results, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a035fc7c93286e3aa0354f522f2cd885a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions.  <br /></td></tr>
<tr class="memitem:ac64464574634cca5ffcd023227260414" id="r_ac64464574634cca5ffcd023227260414"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac64464574634cca5ffcd023227260414">getFilteredIdentityMap</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a>)&gt; keepDimFilter)</td></tr>
<tr class="memdesc:ac64464574634cca5ffcd023227260414"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an identity affine map with <span class="tt">numDims</span> input dimensions and filtered results using <span class="tt">keepDimFilter</span>.  <br /></td></tr>
<tr class="memitem:acd08312b1039c20f008d2f6785c47816" id="r_acd08312b1039c20f008d2f6785c47816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd08312b1039c20f008d2f6785c47816">getPermutationMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permutation, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:acd08312b1039c20f008d2f6785c47816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> representing a permutation.  <br /></td></tr>
<tr class="memitem:a2b4411050d640c3148ee52c97e7dc52c" id="r_a2b4411050d640c3148ee52c97e7dc52c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b4411050d640c3148ee52c97e7dc52c">getPermutationMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; permutation, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:ada21d48618f194b336889ce9a549925e" id="r_ada21d48618f194b336889ce9a549925e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada21d48618f194b336889ce9a549925e">getMultiDimMapWithTargets</a> (<a class="el" href="classunsigned.html">unsigned</a> numDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; targets, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ada21d48618f194b336889ce9a549925e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an affine map with <span class="tt">numDims</span> input dimensions and results specified by <span class="tt">targets</span>.  <br /></td></tr>
<tr class="memitem:aa0cd273aeeb176dd6af9d98ec0756c34" id="r_aa0cd273aeeb176dd6af9d98ec0756c34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0cd273aeeb176dd6af9d98ec0756c34">inferFromExprList</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt; exprsList, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:aa0cd273aeeb176dd6af9d98ec0756c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of AffineMaps; each with as many results as <span class="tt">exprs.size()</span>, as many dims as the largest dim in <span class="tt">exprs</span> and as many symbols as the largest symbol in <span class="tt">exprs</span>.  <br /></td></tr>
<tr class="memitem:a646001b9034dc42ea6822081c56f53da" id="r_a646001b9034dc42ea6822081c56f53da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a646001b9034dc42ea6822081c56f53da">inferFromExprList</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; &gt; exprsList, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memitem:aacdf41a0f3fee3a701ee651d40306a1c" id="r_aacdf41a0f3fee3a701ee651d40306a1c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacdf41a0f3fee3a701ee651d40306a1c">getFromOpaquePointer</a> (const <a class="el" href="classvoid.html">void</a> *pointer)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a>'s, and they are uniqued. </p>
<p>Eg: (d0, d1) -&gt; (d0/128, d0 mod 128, d1) The names used (d0, d1) don't matter - it's the mathematical function that is unique to this affine map. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00046">46</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Member Typedef Documentation</h2>
<a id="a491f21c36efbd2ad2e664d16948c016c" name="a491f21c36efbd2ad2e664d16948c016c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491f21c36efbd2ad2e664d16948c016c">&#9670;&#160;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a491f21c36efbd2ad2e664d16948c016c">mlir::AffineMap::ImplType</a> = <a class="el" href="structmlir_1_1detail_1_1AffineMapStorage.html">detail::AffineMapStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00048">48</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5605b1cc86aac352486868fa9a66e7a9" name="a5605b1cc86aac352486868fa9a66e7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5605b1cc86aac352486868fa9a66e7a9">&#9670;&#160;</a></span>AffineMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel constexpr">constexpr</span><span class="mlabel default">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00293">dropResult()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01233">get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01239">get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01228">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">getConstantMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00138">getFilteredIdentityMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00413">getFromOpaquePointer()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00660">getMajorSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">getMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00668">getMinorSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00276">getMultiDimMapWithTargets()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00269">getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">getPermutationMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="#acd80590df09c086f3800c7aebf110809">hash_value()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00134">operator!=()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00133">operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">replaceDimsAndSymbols()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>.</p>

</div>
</div>
<a id="a6cd0836d686d1e4e23f9da8ff0cd54e0" name="a6cd0836d686d1e4e23f9da8ff0cd54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd0836d686d1e4e23f9da8ff0cd54e0">&#9670;&#160;</a></span>AffineMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::AffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a491f21c36efbd2ad2e664d16948c016c">ImplType</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00051">51</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="af2baf4561cf7d74a9959fd9e875c9a82" name="af2baf4561cf7d74a9959fd9e875c9a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2baf4561cf7d74a9959fd9e875c9a82">&#9670;&#160;</a></span>compose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> resulting from composing <span class="tt">this</span> with <span class="tt">map</span>. </p>
<p>The resulting <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> has as many <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> as <span class="tt">map</span> and as many <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression.">AffineSymbolExpr</a> as the concatenation of <span class="tt">this</span> and <span class="tt">map</span> (in which case the symbols of <span class="tt">this</span> map come first).</p>
<p>Prerequisites: The maps are composable, i.e. that the number of <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> of <span class="tt">this</span> matches the number of results of <span class="tt">map</span>.</p>
<p>Example: map1: <span class="tt">(d0, d1)[s0, s1] -&gt; (d0 + 1 + s1, d1 - 1 - s0)</span> map2: <span class="tt">(d0)[s0] -&gt; (d0 + s0, d0 - s0)</span> map1.compose(map2): <span class="tt">(d0)[s0, s1, s2] -&gt; (d0 + s1 + s2 + 1, d0 - s0 - s2 - 1)</span> </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">552</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01076">mlir::AffineExpr::compose()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00948">mlir::expandDimsToRank()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00430">mlir::sparse_tensor::foreachInSparseConstant()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04823">mlir::vector::inferTransferOpMaskType()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00611">transposeOneLinalgOperandAndReplace()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01452">vectorizeAsLinalgGeneric()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="a7c205e3ff1701beab13d721c11031ed2" name="a7c205e3ff1701beab13d721c11031ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c205e3ff1701beab13d721c11031ed2">&#9670;&#160;</a></span>compose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a>, 4 &gt; AffineMap::compose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>values</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies composition by the dims of <span class="tt">this</span> to the integer <span class="tt">values</span> and returns the resulting values. </p>
<p><span class="tt">this</span> must be symbol-less. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">576</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="ae066f1e53d4d5a7f469874e221abf3f6" name="ae066f1e53d4d5a7f469874e221abf3f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae066f1e53d4d5a7f469874e221abf3f6">&#9670;&#160;</a></span>constantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult AffineMap::constantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operandConstants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>hasPoison</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Folds the results of the application of an affine map on the provided operands to a constant if possible. </p>
<p>Returns false if the folding happens, true otherwise. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00430">430</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02558">foldLoopBounds()</a>.</p>

</div>
</div>
<a id="a6192ae9c7bae0a08642d8c37d0c74182" name="a6192ae9c7bae0a08642d8c37d0c74182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6192ae9c7bae0a08642d8c37d0c74182">&#9670;&#160;</a></span>dropResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::dropResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the same number of dims and symbols and one less result at <span class="tt">pos</span>, dropped. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00293">293</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>.</p>

</div>
</div>
<a id="a0517cd0d6664663cbf004873030538c9" name="a0517cd0d6664663cbf004873030538c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0517cd0d6664663cbf004873030538c9">&#9670;&#160;</a></span>dropResults() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::dropResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">299</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00293">dropResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00948">mlir::expandDimsToRank()</a>.</p>

</div>
</div>
<a id="abab7113ad70691bafd354aa8b19b83c5" name="abab7113ad70691bafd354aa8b19b83c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7113ad70691bafd354aa8b19b83c5">&#9670;&#160;</a></span>dropResults() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::dropResults </td>
          <td>(</td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">543</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="ac8532830efc67348905fd1e414beaebb" name="ac8532830efc67348905fd1e414beaebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8532830efc67348905fd1e414beaebb">&#9670;&#160;</a></span>dropZeroResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::dropZeroResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> resulting from removing "zero" results (constant values == 0) from this map. </p>
<p>Example:</p><ul>
<li>For <span class="tt">(d0, d1) -&gt; (d0, d1, 0)</span> returns <span class="tt">(d0, d1) -&gt; (d0, d1)</span></li>
<li>For <span class="tt">(d0, d1, d2) -&gt; (d0, d1)</span> returns <span class="tt">(d0, d1, d2) -&gt; (d0, d1)</span></li>
<li>For <span class="tt">(d0, d1, d2) -&gt; (d0, 0, d1, 0, d2)</span> returns <span class="tt">(d0, d1, d2) -&gt; (d0, d1, d2)</span> </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">600</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="ac981930c6d7e6b46b46c4c678d9b5f17" name="ac981930c6d7e6b46b46c4c678d9b5f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac981930c6d7e6b46b46c4c678d9b5f17">&#9670;&#160;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::dump </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04003">4003</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="SPIRVAttributes_8cpp_source.html#l00624">print()</a>.</p>

</div>
</div>
<a id="a3cfca2eb29fddf3c4bda714cccaa53f9" name="a3cfca2eb29fddf3c4bda714cccaa53f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfca2eb29fddf3c4bda714cccaa53f9">&#9670;&#160;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero result affine map with no dimensions or symbols: () -&gt; (). </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01224">1224</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00494">mlir::OperationName::getImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00180">mlir::ValueBoundsConstraintSet::addBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00077">mlir::scf::addLoopRangeConstraints()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00058">adjustMap()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00826">mlir::ValueBoundsConstraintSet::areOverlappingSlices()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00818">broadcastDynamicDimension()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="VectorDistribute_8cpp_source.html#l00042">calculateImplicitMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03311">composeSetAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">mlir::ValueBoundsConstraintSet::computeBound()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00676">mlir::ValueBoundsConstraintSet::computeConstantDelta()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02944">computeIteratorTypesAndIndexingMaps()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">mlir::concatAffineMaps()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01024">createMask()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00075">doubleBuffer()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00334">dropUnitExtentFromOperandMetadata()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="TosaToLinalg_8cpp_source.html#l00943">emitElementwiseComputation()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02454">mlir::linalg::extractOrIdentityMap()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00129">forEachIJPairInAllBuffers()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">mlir::affine::fullyComposeAndComputeConstantDelta()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00985">mlir::MutableAffineMap::getAffineMap()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="TosaToLinalgNamed_8cpp_source.html#l00086">getBroadcastingMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00022">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="Builders_8cpp_source.html#l00378">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01160">mlir::affine::MemRefRegion::getConstantBoundingSizeAndShape()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00947">mlir::FlatLinearConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">getConstantMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00383">mlir::Builder::getDimIdentityMap()</a>, <a class="el" href="DimLvlMap_8cpp_source.html#l00118">mlir::sparse_tensor::ir_detail::DimLvlMap::getDimToLvlMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00376">mlir::Builder::getEmptyAffineMap()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00668">getIndexingMapInExpandedOp()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00040">getIndicesForAccess()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00319">mlir::affine::FlatAffineValueConstraints::getIneqAsAffineValueMap()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00499">mlir::FlatLinearConstraints::getLowerAndUpperBound()</a>, <a class="el" href="DimLvlMap_8cpp_source.html#l00127">mlir::sparse_tensor::ir_detail::DimLvlMap::getLvlToDimMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">getMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">getMultiDimIdentityMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00387">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00276">getMultiDimMapWithTargets()</a>, <a class="el" href="MMAUtils_8cpp_source.html#l00148">getRegisterIndexToTileOffsetMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00407">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00401">mlir::Builder::getSingleDimShiftAffineMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00396">mlir::Builder::getSymbolIdentityMap()</a>, <a class="el" href="ReshapeOpsUtils_8cpp_source.html#l00447">mlir::getSymbolLessAffineMaps()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00189">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">mlir::affine::getTripCountMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00293">inferFromExprList()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01056">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">mlir::isBatchMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">mlir::isBatchVecmat()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">mlir::isColumnMajorMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">mlir::isMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">mlir::isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">mlir::isRowMajorMatmul()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00100">isTransposeMatrixLoadMap()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">mlir::isVecmat()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">mlir::affine::loopUnrollJamByFactor()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>, <a class="el" href="IR_2BuiltinAttributes_8cpp_source.html#l01808">mlir::makeStridedLinearLayoutMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03669">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03712">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00037">mlirAffineMapEmptyGet()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00046">mlirAffineMapGet()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00041">mlirAffineMapZeroResultGet()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="SCFToGPU_8cpp_source.html#l00401">processParallelLoop()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">replaceDimsAndSymbols()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00030">sliceTransferIndices()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00241">mlir::linalg::splitReductionByScaling()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00088">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>, <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>.</p>

</div>
</div>
<a id="aeb27ba563698d7152eced09f1c5a99c6" name="aeb27ba563698d7152eced09f1c5a99c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb27ba563698d7152eced09f1c5a99c6">&#9670;&#160;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>symbolCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> mapping to a single output dimension. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01233">1233</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="OperationSupport_8h_source.html#l00494">mlir::OperationName::getImpl()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01208">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="aa05f70527f322fb8d381e416a96db44d" name="aa05f70527f322fb8d381e416a96db44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05f70527f322fb8d381e416a96db44d">&#9670;&#160;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>symbolCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> mapping to the given results. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01239">1239</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="OperationSupport_8h_source.html#l00494">mlir::OperationName::getImpl()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01208">willBeValidAffineMap()</a>.</p>

</div>
</div>
<a id="ad0742d98deb42f72abc9a7b2fa232dc8" name="ad0742d98deb42f72abc9a7b2fa232dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0742d98deb42f72abc9a7b2fa232dc8">&#9670;&#160;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dimCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>symbolCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a zero result affine map with <span class="tt">dimCount</span> dimensions and <span class="tt">symbolCount</span> symbols, e.g.: <span class="tt">(...) -&gt; ()</span>. </p>

<p class="definition">Definition at line <a class="el" href="MLIRContext_8cpp_source.html#l01228">1228</a> of file <a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="OperationSupport_8h_source.html#l00494">mlir::OperationName::getImpl()</a>.</p>

</div>
</div>
<a id="a43659699b095f0e0f85fb2efb35bc9b8" name="a43659699b095f0e0f85fb2efb35bc9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43659699b095f0e0f85fb2efb35bc9b8">&#9670;&#160;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvoid.html">void</a> * mlir::AffineMap::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods supporting C API. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00410">410</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="acf141c61521d9a40ba68c0b350a31836" name="acf141c61521d9a40ba68c0b350a31836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf141c61521d9a40ba68c0b350a31836">&#9670;&#160;</a></span>getBroadcastDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; AffineMap::getBroadcastDims </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of broadcast dimensions (i.e. </p>
<p>dims indicated by value 0 in the result). Ex:</p><ul>
<li>(d0, d1, d2) -&gt; (0, d1) gives [0]</li>
<li>(d0, d1, d2) -&gt; (d2, d1) gives []</li>
<li>(d0, d1, d2, d4) -&gt; (d0, 0, d1, 0) gives [1, 3] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00157">157</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l04995">foldTransferInBoundsAttribute()</a>.</p>

</div>
</div>
<a id="ad98c7861efe6542d1e99c8172cc6061a" name="ad98c7861efe6542d1e99c8172cc6061a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98c7861efe6542d1e99c8172cc6061a">&#9670;&#160;</a></span>getConstantMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getConstantMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a single constant result affine map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">124</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, and <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">mlir::affine::getTripCountMapAndOperands()</a>, and <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00054">mlirAffineMapConstantGet()</a>.</p>

</div>
</div>
<a id="a7b5a032d678f6c17893836f3ce8a107c" name="a7b5a032d678f6c17893836f3ce8a107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a032d678f6c17893836f3ce8a107c">&#9670;&#160;</a></span>getConstantResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; AffineMap::getConstantResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant results of this map. </p>
<p>This method asserts that the map has all constant results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00382">382</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00373">isConstant()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a07ce6ee55edc21c008a3bf8d10a2d726" name="a07ce6ee55edc21c008a3bf8d10a2d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ce6ee55edc21c008a3bf8d10a2d726">&#9670;&#160;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * AffineMap::getContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">339</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00430">constantFold()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00948">mlir::expandDimsToRank()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04823">mlir::vector::inferTransferOpMaskType()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00151">isMinorIdentity()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01591">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00100">isTransposeMatrixLoadMap()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00535">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00963">mlir::MutableAffineMap::reset()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>.</p>

</div>
</div>
<a id="a1ff49306f1f5459448db5f41c55daa3e" name="a1ff49306f1f5459448db5f41c55daa3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff49306f1f5459448db5f41c55daa3e">&#9670;&#160;</a></span>getDimPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getDimPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the position of the dimensional expression at the given result, when the caller knows it is safe to do so. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">411</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerVectorContract_8cpp_source.html#l00058">adjustMap()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00704">extractLoadCoordsForComposite()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00176">getDimPosition()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00164">getReductionIndex()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00035">getResultIndex()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00051">getResultIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00756">ContractOpToElementwise::matchAndRewriteMaskableOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01181">mlir::sparse_tensor::toDim()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01190">mlir::sparse_tensor::toLvl()</a>, and <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>.</p>

</div>
</div>
<a id="ac64464574634cca5ffcd023227260414" name="ac64464574634cca5ffcd023227260414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64464574634cca5ffcd023227260414">&#9670;&#160;</a></span>getFilteredIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getFilteredIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>keepDimFilter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity affine map with <span class="tt">numDims</span> input dimensions and filtered results using <span class="tt">keepDimFilter</span>. </p>
<p>If <span class="tt">keepDimFilter</span> returns true for a dimension, the dimension is kept in the affine map results. Otherwise, the dimension is dropped from the results.</p>
<p>Examples:</p><ul>
<li>getFilteredIdentityMap(4, [false, true, false, true]) -&gt; affine_map&lt;(d0, d1, d2, d3) -&gt; (d1, d3)&gt;</li>
<li>getFilteredIdentityMap(3, [false, false, true]) -&gt; affine_map&lt;(d0, d1, d2) -&gt; (d2)&gt; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00138">138</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">getMultiDimIdentityMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>.</p>

</div>
</div>
<a id="aacdf41a0f3fee3a701ee651d40306a1c" name="aacdf41a0f3fee3a701ee651d40306a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf41a0f3fee3a701ee651d40306a1c">&#9670;&#160;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvoid.html">void</a> *</td>          <td class="paramname"><span class="paramname"><em>pointer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00413">413</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>.</p>

</div>
</div>
<a id="a4e88fa7c055d33c1eae5a72f1084fcbc" name="a4e88fa7c055d33c1eae5a72f1084fcbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e88fa7c055d33c1eae5a72f1084fcbc">&#9670;&#160;</a></span>getLargestKnownDivisorOfMapExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t AffineMap::getLargestKnownDivisorOfMapExprs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the largest known divisor of all map expressions. </p>
<p>For eg: for (d0, d1) -&gt; (8*d0 + 4, 4*d1 + 2), the result is 2. In the case of maps with no expressions or all zero constant expressions, the largest known divisor is trivially the max uint64_t value. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">319</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="a06383d6033de3ed99168e650abaaf66d" name="a06383d6033de3ed99168e650abaaf66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06383d6033de3ed99168e650abaaf66d">&#9670;&#160;</a></span>getMajorSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMajorSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResults</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the most major <span class="tt">numResults</span> results. </p>
<p>Returns the null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> if <span class="tt">numResults</span> == 0. Returns <span class="tt">*this</span> if <span class="tt">numResults</span> &gt;= <span class="tt">this-&gt;<a class="el" href="#a96f194ae3b4baf33c67b10c9f795b564">getNumResults()</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00660">660</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>.</p>

</div>
</div>
<a id="a035fc7c93286e3aa0354f522f2cd885a" name="a035fc7c93286e3aa0354f522f2cd885a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035fc7c93286e3aa0354f522f2cd885a">&#9670;&#160;</a></span>getMinorIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMinorIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">131</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">getMultiDimIdentityMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00189">mlir::vector::getTransferMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00151">isMinorIdentity()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00063">mlirAffineMapMinorIdentityGet()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l01166">vectorizeTensorExtract()</a>.</p>

</div>
</div>
<a id="a481ad498d786f3c6e9b17965ea1d83a8" name="a481ad498d786f3c6e9b17965ea1d83a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481ad498d786f3c6e9b17965ea1d83a8">&#9670;&#160;</a></span>getMinorSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMinorSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResults</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the most minor <span class="tt">numResults</span> results. </p>
<p>Returns the null <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> if <span class="tt">numResults</span> == 0. Returns <span class="tt">*this</span> if <span class="tt">numResults</span> &gt;= <span class="tt">this-&gt;<a class="el" href="#a96f194ae3b4baf33c67b10c9f795b564">getNumResults()</a></span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00668">668</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>.</p>

</div>
</div>
<a id="a39ed2c2a4c743450a4a999fa6db1bf84" name="a39ed2c2a4c743450a4a999fa6db1bf84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ed2c2a4c743450a4a999fa6db1bf84">&#9670;&#160;</a></span>getMultiDimIdentityMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMultiDimIdentityMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with 'numDims' identity result dim exprs. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">330</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, and <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00345">buildMax()</a>, <a class="el" href="Tiling_8cpp_source.html#l00353">buildMin()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02944">computeIteratorTypesAndIndexingMaps()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00948">mlir::expandDimsToRank()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l02454">mlir::linalg::extractOrIdentityMap()</a>, <a class="el" href="SparseTensorType_8h_source.html#l00221">mlir::sparse_tensor::SparseTensorType::getExpandedDimToLvl()</a>, <a class="el" href="AMDGPUDialect_8cpp_source.html#l00102">getFatRawBufferTypeLike()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00138">getFilteredIdentityMap()</a>, <a class="el" href="Shard_2Interfaces_2ShardingInterfaceImpl_8h_source.html#l00118">mlir::shard::ElementwiseShardingInterface&lt; ElemwiseOp &gt;::getIndexingMaps()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">getMinorIdentityMap()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00282">isAccessIndexInvariant()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01578">mlir::linalg::makeMemRefCopyOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00396">mlir::affine::AffineBuilder::max()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00391">mlir::affine::AffineBuilder::min()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00058">mlirAffineMapMultiDimIdentityGet()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00260">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ada21d48618f194b336889ce9a549925e" name="ada21d48618f194b336889ce9a549925e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada21d48618f194b336889ce9a549925e">&#9670;&#160;</a></span>getMultiDimMapWithTargets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getMultiDimMapWithTargets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an affine map with <span class="tt">numDims</span> input dimensions and results specified by <span class="tt">targets</span>. </p>
<p>Examples:</p><ul>
<li>getMultiDimMapWithTargets(3, [0, 2, 1]) -&gt; affine_map&lt;(d0, d1, d2) -&gt; (d0, d2, d1)&gt;</li>
<li>getMultiDimMapWithTargets(3, [2, 1]) -&gt; affine_map&lt;(d0, d1, d2) -&gt; (d2, d1)&gt; </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00276">276</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">getPermutationMap()</a>.</p>

</div>
</div>
<a id="a75bef7af11cc1451c2e440718c5a5933" name="a75bef7af11cc1451c2e440718c5a5933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bef7af11cc1451c2e440718c5a5933">&#9670;&#160;</a></span>getNumDims()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumDims </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">390</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00058">adjustMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00022">buildArithValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00105">collectInadmissInfo()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03311">composeSetAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00259">mlir::shard::detail::defaultGetShardingOption()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00704">extractLoadCoordsForComposite()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00392">findPermutationsIndexingOperand()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00040">getIndicesForAccess()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">mlir::getMultiAffineFunctionFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00498">mlir::affine::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00538">mlir::affine::getRelationFromMap()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00384">getSharding()</a>, <a class="el" href="Builders_8cpp_source.html#l00407">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00052">getXferIndices()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00419">inferIteratorsFromOutMap()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">mlir::ValueBoundsConstraintSet::insert()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">isEmpty()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">isIdentity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00151">isMinorIdentity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00172">isMinorIdentityWithBroadcasting()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">isPermutation()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00100">isTransposeMatrixLoadMap()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03669">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03712">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">mlir::affine::materializeComputedBound()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03177">mlir::AsmPrinter::Impl::printAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02468">printBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04377">printMinMaxBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00963">mlir::MutableAffineMap::reset()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00077">mlir::detail::verifyAffineMapAsLayout()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03419">verifyMemoryOpIndexing()</a>, and <a class="el" href="LinalgInterfaces_8cpp_source.html#l01261">mlir::linalg::detail::verifyStructuredOpInterface()</a>.</p>

</div>
</div>
<a id="aa821f07143bcad97d6df532c232129a3" name="aa821f07143bcad97d6df532c232129a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa821f07143bcad97d6df532c232129a3">&#9670;&#160;</a></span>getNumInputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumInputs </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">399</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00730">buildVectorWrite()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01397">mlir::FlatLinearValueConstraints::computeAlignedMap()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00175">generateShiftedLoop()</a>, <a class="el" href="AffineOps_8h_source.html#l00198">mlir::affine::AffineDmaStartOp::getDstIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00167">mlir::affine::AffineDmaStartOp::getDstMemRefOperandIndex()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01216">mlir::affine::MemRefRegion::getLowerAndUpperBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">mlir::getMultiAffineFunctionFromMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00155">mlir::affine::AffineDmaStartOp::getSrcIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00231">mlir::affine::AffineDmaStartOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00361">mlir::affine::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00205">mlir::affine::AffineDmaStartOp::getTagMemRefOperandIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">mlir::isBatchMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">mlir::isBatchVecmat()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">mlir::isColumnMajorMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">mlir::isMatvec()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">isProjectedPermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">mlir::isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">mlir::isRowMajorMatmul()</a>, <a class="el" href="AffineOps_8h_source.html#l00294">mlir::affine::AffineDmaStartOp::isStrided()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">mlir::isVecmat()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02012">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03419">verifyMemoryOpIndexing()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04696">verifyPermutationMap()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l04725">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="a8b4d79d68fb5c4e34706143bffb1a420" name="a8b4d79d68fb5c4e34706143bffb1a420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4d79d68fb5c4e34706143bffb1a420">&#9670;&#160;</a></span>getNumOfZeroResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t AffineMap::getNumOfZeroResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of "zero" results (constant values == 0) in this map. </p>
<p>Example:</p><ul>
<li>For <span class="tt">(d0, d1) -&gt; (d0, d1, 0)</span> returns 1</li>
<li>For <span class="tt">(d0, d1, d2) -&gt; (d0, d1)</span> returns 0</li>
<li>For <span class="tt">(d0, d1, d2) -&gt; (d0, 0, d1, 0, d2)</span> returns 2 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00589">589</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="a96f194ae3b4baf33c67b10c9f795b564" name="a96f194ae3b4baf33c67b10c9f795b564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f194ae3b4baf33c67b10c9f795b564">&#9670;&#160;</a></span>getNumResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">398</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00058">adjustMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">mlir::linalg::areElementwiseOpsFusable()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00022">buildArithValue()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">mlir::affine::buildSliceTripCountMap()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00105">collectInadmissInfo()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00179">createInlinedCompareImplementation()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01024">createMask()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02558">foldLoopBounds()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00129">forEachIJPairInAllBuffers()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00109">forEachIJPairInXs()</a>, <a class="el" href="CodegenUtils_8cpp_source.html#l00430">mlir::sparse_tensor::foreachInSparseConstant()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00176">getDimPosition()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00100">getFirstResultIndexFunctionOf()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00040">getIndicesForAccess()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">mlir::affine::getLargestDivisorOfTripCount()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00660">getMajorSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00668">getMinorSubMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">mlir::getMultiAffineFunctionFromMap()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00164">getReductionIndex()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00498">mlir::affine::getRelationFromMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00538">mlir::affine::getRelationFromMap()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01145">getResultIndex()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00035">getResultIndex()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00051">getResultIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00415">getResultPosition()</a>, <a class="el" href="Builders_8cpp_source.html#l00407">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">mlir::ValueBoundsConstraintSet::insert()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01056">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">mlir::isBatchMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">mlir::isBatchVecmat()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l03605">isBroadcasted()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">mlir::isColumnMajorMatmul()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">mlir::linalg::isDimSequencePreserved()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">isEmpty()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">isIdentity()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">mlir::isMatvec()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00151">isMinorIdentity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00172">isMinorIdentityWithBroadcasting()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">isPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">isProjectedPermutation()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">mlir::isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">mlir::isRowMajorMatmul()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">isSingleConstant()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00353">isSymbolIdentity()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00083">isTiled()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00678">isTransposed()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">mlir::isVecmat()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01514">mlir::affine::makeComposedFoldedMultiResultAffineApply()</a>, <a class="el" href="Tiling_8cpp_source.html#l00044">mlir::linalg::makeTiledLoopRanges()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03669">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="LowerVectorContract_8cpp_source.html#l00756">ContractOpToElementwise::matchAndRewriteMaskableOp()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02468">printBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00535">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">replaceDimsAndSymbols()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00030">mlir::linalg::splitReduction()</a>, <a class="el" href="BlockPackMatmul_8cpp_source.html#l00089">transposePackedMatmul()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l03638">verifyInputMaps()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03419">verifyMemoryOpIndexing()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l03676">verifyOutputMap()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l04725">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="a750b299a4842c7965de35bd2cb1479a0" name="a750b299a4842c7965de35bd2cb1479a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750b299a4842c7965de35bd2cb1479a0">&#9670;&#160;</a></span>getNumSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> AffineMap::getNumSymbols </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">394</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00814">mlir::FlatLinearConstraints::addBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">compose()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03311">composeSetAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00334">dropUnitExtentFromOperandMetadata()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00668">getIndexingMapInExpandedOp()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00040">getIndicesForAccess()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01563">mlir::getMultiAffineFunctionFromMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00407">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01041">mlir::sparse_tensor::inferLvlToDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">isEmpty()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">isProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00353">isSymbolIdentity()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03669">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03712">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03177">mlir::AsmPrinter::Impl::printAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02468">printBound()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00963">mlir::MutableAffineMap::reset()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l04725">verifyTransferOp()</a>.</p>

</div>
</div>
<a id="a2b4411050d640c3148ee52c97e7dc52c" name="a2b4411050d640c3148ee52c97e7dc52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b4411050d640c3148ee52c97e7dc52c">&#9670;&#160;</a></span>getPermutationMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00269">269</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">getPermutationMap()</a>.</p>

</div>
</div>
<a id="acd08312b1039c20f008d2f6785c47816" name="acd08312b1039c20f008d2f6785c47816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd08312b1039c20f008d2f6785c47816">&#9670;&#160;</a></span>getPermutationMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getPermutationMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permutation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> representing a permutation. </p>
<p>The permutation is expressed as a non-empty vector of integers. E.g. the permutation <span class="tt">(i,j,k) -&gt; (j,k,i)</span> will be expressed with <span class="tt">permutation = [1,2,0]</span>. All values in <span class="tt">permutation</span> must be integers, in the range 0..<span class="tt">permutation.size()-1</span> without duplications (i.e. <span class="tt">[1,1,2]</span> is an invalid permutation). </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00260">260</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00276">getMultiDimMapWithTargets()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00541">convertTransferReadOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04995">foldTransferInBoundsAttribute()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00269">getPermutationMap()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="Interchange_8cpp_source.html#l00031">interchangeGenericOpPrecondition()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00678">isTransposed()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00512">VectorizationState::maskOperation()</a>, <a class="el" href="CAPI_2IR_2AffineMap_8cpp_source.html#l00068">mlirAffineMapPermutationGet()</a>, <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00611">transposeOneLinalgOperandAndReplace()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00828">vectorizeLinalgIndex()</a>.</p>

</div>
</div>
<a id="ac60458b2cba87d765341cd6b2d41ed12" name="ac60458b2cba87d765341cd6b2d41ed12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60458b2cba87d765341cd6b2d41ed12">&#9670;&#160;</a></span>getResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> AffineMap::getResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>idx</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">407</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00022">buildArithValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00105">collectInadmissInfo()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00541">convertTransferReadOp()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">mlir::affine::decompose()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04995">foldTransferInBoundsAttribute()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00109">forEachIJPairInXs()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00411">getDimPosition()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00100">getFirstResultIndexFunctionOf()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01145">getResultIndex()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00415">getResultPosition()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00377">getSingleConstantResult()</a>, <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">getSubMap()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00052">getXferIndices()</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00305">mlir::ValueBoundsConstraintSet::insert()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01056">mlir::sparse_tensor::inverseBlockSparsity()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00172">mlir::isBatchMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00123">mlir::isBatchVecmat()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00046">mlir::isColumnMajorMatmul()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">mlir::linalg::isDimSequencePreserved()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00091">mlir::affine::AffineValueMap::isFunctionOf()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00148">mlir::isMatvec()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00072">mlir::isRowMajorBatchMatmul()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00020">mlir::isRowMajorMatmul()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">isSingleConstant()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00083">isTiled()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00678">isTransposed()</a>, <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00099">mlir::isVecmat()</a>, <a class="el" href="Vectorization_8cpp_source.html#l00512">VectorizationState::maskOperation()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">mlir::affine::materializeComputedBound()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02468">printBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04377">printMinMaxBound()</a>, <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l03638">verifyInputMaps()</a>.</p>

</div>
</div>
<a id="a6d5de865f8ff094af37d1990af727c2e" name="a6d5de865f8ff094af37d1990af727c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5de865f8ff094af37d1990af727c2e">&#9670;&#160;</a></span>getResultPosition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; AffineMap::getResultPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>input</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the first result position where <span class="tt">input</span> dimension resides. </p>
<p>Returns <span class="tt">std::nullopt</span> if <span class="tt">input</span> is not a dimension expression or cannot be found in results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00415">415</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>.</p>

</div>
</div>
<a id="a79007ce78cfccb064390c22a4af6037c" name="a79007ce78cfccb064390c22a4af6037c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79007ce78cfccb064390c22a4af6037c">&#9670;&#160;</a></span>getResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; AffineMap::getResults </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">403</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l03590">areResultExprsSubsetOf()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03796">canonicalizeMapExprAndTermOrder()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01076">mlir::AffineExpr::compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">compose()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00576">compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03311">composeSetAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00680">compressUnusedListImpl()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l00901">computeMemoryOpIndices()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00259">mlir::shard::detail::defaultGetShardingOption()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00299">dropResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00543">dropResults()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00334">dropUnitExtentFromOperandMetadata()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00600">dropZeroResults()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00392">findPermutationsIndexingOperand()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00129">forEachIJPairInAllBuffers()</a>, <a class="el" href="Fusion_8cpp_source.html#l00173">fuse()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00151">genReplaceDimToLvlMap()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01109">mlir::sparse_tensor::getBlockSize()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00157">getBroadcastDims()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00022">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00382">getConstantResults()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">mlir::affine::getConstantTripCount()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01289">getDomainReassociation()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00687">getExpandedShapeAndType()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00668">getIndexingMapInExpandedOp()</a>, <a class="el" href="TilingInterfaceImpl_8cpp_source.html#l00040">getIndicesForAccess()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">mlir::affine::getLargestDivisorOfTripCount()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00319">getLargestKnownDivisorOfMapExprs()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00054">getMangledSortHelperFuncName()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">getMinorIdentityMap()</a>, <a class="el" href="Sparsification_8cpp_source.html#l00191">getNumNonTrivialIdxExpOnSparseLvls()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00589">getNumOfZeroResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00713">getPreservedDims()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00710">getReassociationForExpansion()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>, <a class="el" href="Fusion_8cpp_source.html#l00058">getShapeDefiningLoopRange()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00384">getSharding()</a>, <a class="el" href="ShardingInterface_8cpp_source.html#l00362">getSharding()</a>, <a class="el" href="Builders_8cpp_source.html#l00407">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">getSliceMap()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01492">getTileSizePos()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00081">hasAtMostOneResultFunctionOfDim()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00419">inferIteratorsFromOutMap()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">insertResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01126">mlir::sparse_tensor::isBlockSparsity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00373">isConstant()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">mlir::linalg::isDimSequencePreserved()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00221">isFunctionOfDim()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00228">isFunctionOfSymbol()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">isIdentity()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00172">isMinorIdentityWithBroadcasting()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01591">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">isPermutationOfMinorIdentityWithBroadcasting()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">isProjectedPermutation()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00353">isSymbolIdentity()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03669">DeduplicateAffineMinMaxExpressions&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineOps_8cpp_source.html#l03712">MergeAffineMinMaxOp&lt; T &gt;::matchAndRewrite()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00112">mlir::affine::AffineValueMap::operator==()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">partialConstantFold()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00119">permuteValues()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l03177">mlir::AsmPrinter::Impl::printAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00853">projectCommonImpl()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00535">replace()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">replace()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00963">mlir::MutableAffineMap::reset()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">setInterTileBoundsParametric()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00464">setIntraTileBoundsParametric()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">shiftDims()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">shiftSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01035">simplifyMapWithOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00925">simplifyMinOrMaxExprWithOperands()</a>, <a class="el" href="VectorUnroll_8cpp_source.html#l00030">sliceTransferIndices()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00945">verifyOutputShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l04696">verifyPermutationMap()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00486">walkExprs()</a>.</p>

</div>
</div>
<a id="a029344fc35377bfa5b59b51edaf304d9" name="a029344fc35377bfa5b59b51edaf304d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029344fc35377bfa5b59b51edaf304d9">&#9670;&#160;</a></span>getSingleConstantResult()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> AffineMap::getSingleConstantResult </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the constant result of this map. </p>
<p>This methods asserts that the map has a single constant result. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00377">377</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">isSingleConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00125">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">mlir::affine::materializeComputedBound()</a>, and <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>.</p>

</div>
</div>
<a id="a054f395f1fc7a1db524caa616e460bed" name="a054f395f1fc7a1db524caa616e460bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054f395f1fc7a1db524caa616e460bed">&#9670;&#160;</a></span>getSliceMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getSliceMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>length</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of <span class="tt">length</span> expressions starting from <span class="tt">start</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00655">655</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00660">getMajorSubMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00668">getMinorSubMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l04377">printMinMaxBound()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>.</p>

</div>
</div>
<a id="add23e0ad557890ca7113d38e96c4c870" name="add23e0ad557890ca7113d38e96c4c870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add23e0ad557890ca7113d38e96c4c870">&#9670;&#160;</a></span>getSubMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::getSubMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>resultPos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the map consisting of the <span class="tt">resultPos</span> subset. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">647</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">generateFusedElementwiseOpRegion()</a>, <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="acd80590df09c086f3800c7aebf110809" name="acd80590df09c086f3800c7aebf110809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd80590df09c086f3800c7aebf110809">&#9670;&#160;</a></span>hash_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend::llvm::hash_code mlir::AffineMap::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>arg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>.</p>

</div>
</div>
<a id="aa0cd273aeeb176dd6af9d98ec0756c34" name="aa0cd273aeeb176dd6af9d98ec0756c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0cd273aeeb176dd6af9d98ec0756c34">&#9670;&#160;</a></span>inferFromExprList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; AffineMap::inferFromExprList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>exprsList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of AffineMaps; each with as many results as <span class="tt">exprs.size()</span>, as many dims as the largest dim in <span class="tt">exprs</span> and as many symbols as the largest symbol in <span class="tt">exprs</span>. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">308</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00072">contractSupportsMMAMatrixType()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00488">mlir::linalg::convLayoutMatches()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00097">mlir::linalg::getIm2ColInputExpressions()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00123">mlir::StructuredGenerator&lt; StructuredOpInterface, IteratorTypeT &gt;::layout()</a>, <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00855">mlir::makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01427">mlir::affine::makeComposedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01503">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l01736">CanonicalizeContractMatmulToMMT::matchAndRewrite()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00535">replace()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00416">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00550">mlir::linalg::rewriteInIm2Col()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00123">mlir::linalg::rewriteInIm2Col()</a>, and <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>.</p>

</div>
</div>
<a id="a646001b9034dc42ea6822081c56f53da" name="a646001b9034dc42ea6822081c56f53da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a646001b9034dc42ea6822081c56f53da">&#9670;&#160;</a></span>inferFromExprList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>, 4 &gt; AffineMap::inferFromExprList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, 4 &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>exprsList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>context</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00314">314</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

</div>
</div>
<a id="a42368d516e602b0d263039fc82b1aa7b" name="a42368d516e602b0d263039fc82b1aa7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42368d516e602b0d263039fc82b1aa7b">&#9670;&#160;</a></span>insertResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::insertResult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the same number of dims and symbols and an extra result inserted at <span class="tt">pos</span>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00315">315</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, and <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>.</p>

</div>
</div>
<a id="a359c688633fed9ca27c7fdf4fdad9487" name="a359c688633fed9ca27c7fdf4fdad9487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359c688633fed9ca27c7fdf4fdad9487">&#9670;&#160;</a></span>isConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isConstant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map has only constant results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00373">373</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00125">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00382">getConstantResults()</a>.</p>

</div>
</div>
<a id="a5752e3927fef1c67c276e3aa956e9cfe" name="a5752e3927fef1c67c276e3aa956e9cfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5752e3927fef1c67c276e3aa956e9cfe">&#9670;&#160;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isEmpty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an empty map, i.e., () -&gt; (). </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00365">365</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Interchange_8cpp_source.html#l00045">mlir::linalg::interchangeGenericOp()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>, and <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>.</p>

</div>
</div>
<a id="a173d3fd01950f75a2285a872b22e2c48" name="a173d3fd01950f75a2285a872b22e2c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173d3fd01950f75a2285a872b22e2c48">&#9670;&#160;</a></span>isFunctionOfDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::AffineMap::isFunctionOfDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineDimExpr.html" title="A dimensional identifier appearing in an affine expression.">AffineDimExpr</a> <span class="tt">position</span>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00221">221</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00314">mlir::AffineExpr::isFunctionOfDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>.</p>

</div>
</div>
<a id="a7df13ef25920c15d07c7bc9686b26be7" name="a7df13ef25920c15d07c7bc9686b26be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df13ef25920c15d07c7bc9686b26be7">&#9670;&#160;</a></span>isFunctionOfSymbol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::AffineMap::isFunctionOfSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if any affine expression involves <a class="el" href="classmlir_1_1AffineSymbolExpr.html" title="A symbolic identifier appearing in an affine expression.">AffineSymbolExpr</a> <span class="tt">position</span>. </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00228">228</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00325">mlir::AffineExpr::isFunctionOfSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>.</p>

</div>
</div>
<a id="af33ea095c58804447510ad5ff023975c" name="af33ea095c58804447510ad5ff023975c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33ea095c58804447510ad5ff023975c">&#9670;&#160;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an identity affine map. </p>
<p>An identity affine map corresponds to an identity affine function on the dimensional identifiers. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">341</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="BuiltinAttributeInterfaces_8cpp_source.html#l00161">getStridesAndOffset()</a>.</p>

</div>
</div>
<a id="a1ccbe714fa69ce8426190f88b7854a98" name="a1ccbe714fa69ce8426190f88b7854a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ccbe714fa69ce8426190f88b7854a98">&#9670;&#160;</a></span>isMinorIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isMinorIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a minor identity, i.e. </p>
<p>an identity affine map (d0, ..., dn) -&gt; (dp, ..., dn) on the most minor dimensions. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00151">151</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00131">getMinorIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorToGPU_8cpp_source.html#l00140">transferReadSupportsMMAMatrixType()</a>.</p>

</div>
</div>
<a id="a753daf697958f1aa999c10c163d3c35b" name="a753daf697958f1aa999c10c163d3c35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753daf697958f1aa999c10c163d3c35b">&#9670;&#160;</a></span>isMinorIdentityWithBroadcasting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isMinorIdentityWithBroadcasting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>broadcastedDims</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a minor identity up to broadcasted dimensions which are indicated by value 0 in the result. </p>
<p>If <span class="tt">broadcastedDims</span> is not null, it will be populated with the indices of the broadcasted dimensions in the result array. Example: affine_map&lt;(d0, d1, d2, d3, d4) -&gt; (0, d2, 0, d4)&gt; (<span class="tt">broadcastedDims</span> will contain [0, 2]) </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00172">172</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="af6e665372add0df0668e1ebd231488b4" name="af6e665372add0df0668e1ebd231488b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e665372add0df0668e1ebd231488b4">&#9670;&#160;</a></span>isPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isPermutation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> represents a symbol-less permutation map. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">641</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">mlir::linalg::areElementwiseOpsFusable()</a>, <a class="el" href="MemRefToSPIRV_8cpp_source.html#l00704">extractLoadCoordsForComposite()</a>, <a class="el" href="SparseBufferRewriting_8cpp_source.html#l00129">forEachIJPairInAllBuffers()</a>, <a class="el" href="SparseTensorDialect_8cpp_source.html#l01041">mlir::sparse_tensor::inferLvlToDim()</a>, and <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00119">permuteValues()</a>.</p>

</div>
</div>
<a id="a819c4c0117656eae56b72348e469c01e" name="a819c4c0117656eae56b72348e469c01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a819c4c0117656eae56b72348e469c01e">&#9670;&#160;</a></span>isPermutationOfMinorIdentityWithBroadcasting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isPermutationOfMinorIdentityWithBroadcasting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>permutedDims</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this affine map can be converted to a minor identity with broadcast by doing a permute. </p>
<p>Return a permutation (there may be several) to apply to get to a minor identity with broadcasts. Ex:</p><ul>
<li>(d0, d1, d2) -&gt; (0, d1) maps to minor identity (d1, 0 = d2) with perm = [1, 0] and broadcast d2</li>
<li>(d0, d1, d2) -&gt; (d0, 0) cannot be mapped to a minor identity by permutation + broadcast</li>
<li>(d0, d1, d2, d3) -&gt; (0, d1, d3) maps to minor identity (d1, 0 = d2, d3) with perm = [1, 0, 2] and broadcast d2</li>
<li>(d0, d1) -&gt; (d1, 0, 0, d0) maps to minor identity (d0, d1) with extra leading broadcat dimensions. The map returned would be (0, 0, d0, d1) with perm = [3, 0, 1, 2] </li>
</ul>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00212">212</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="a457a8530ceb03d15e3b171ea3a9fc4a6" name="a457a8530ceb03d15e3b171ea3a9fc4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457a8530ceb03d15e3b171ea3a9fc4a6">&#9670;&#160;</a></span>isProjectedPermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isProjectedPermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowZeroInResults</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> represents a subset (i.e. </p>
<p>a projection) of a symbol-less permutation map. <span class="tt">allowZeroInResults</span> allows projected permutation maps with constant zero result expressions. TODO: Remove <span class="tt">allowZeroInResults</span> when constant zero result expressions are broadly supported. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">611</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00675">mlir::applyPermutationMap()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01289">getDomainReassociation()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00713">getPreservedDims()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00419">inferIteratorsFromOutMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00808">mlir::inverseAndBroadcastProjectedPermutation()</a>, <a class="el" href="LinalgInterfaces_8cpp_source.html#l00513">mlir::linalg::detail::isContractionInterfaceImpl()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01306">mlir::linalg::isDimSequencePreserved()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00641">isPermutation()</a>, and <a class="el" href="Vectorization_8cpp_source.html#l00595">reindexIndexingMap()</a>.</p>

</div>
</div>
<a id="a4197b91018d6d6badaccdcb0ce6c1e12" name="a4197b91018d6d6badaccdcb0ce6c1e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4197b91018d6d6badaccdcb0ce6c1e12">&#9670;&#160;</a></span>isSingleConstant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isSingleConstant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is a single result constant function. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">369</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">getResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00377">getSingleConstantResult()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">mlir::affine::materializeComputedBound()</a>, and <a class="el" href="Arith_2Transforms_2ReifyValueBounds_8cpp_source.html#l00066">mlir::arith::reifyValueBound()</a>.</p>

</div>
</div>
<a id="a93371aad5ea3f31f48e132f8c7cbb302" name="a93371aad5ea3f31f48e132f8c7cbb302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93371aad5ea3f31f48e132f8c7cbb302">&#9670;&#160;</a></span>isSymbolIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> AffineMap::isSymbolIdentity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this affine map is an identity affine map on the symbol identifiers. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00353">353</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="a4db87d862458ead8c492e1a05ce18e33" name="a4db87d862458ead8c492e1a05ce18e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db87d862458ead8c492e1a05ce18e33">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::AffineMap::operator <a class="el" href="classbool.html">bool</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel explicit">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00132">132</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

</div>
</div>
<a id="ad066a62bd10ed01423748bdd913565be" name="ad066a62bd10ed01423748bdd913565be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad066a62bd10ed01423748bdd913565be">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::AffineMap::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00134">134</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>.</p>

</div>
</div>
<a id="a7381857cac60752009640964e99172c2" name="a7381857cac60752009640964e99172c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7381857cac60752009640964e99172c2">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::AffineMap::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00133">133</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>.</p>

</div>
</div>
<a id="ad979cffb85eaeda752bd53688165d2d2" name="ad979cffb85eaeda752bd53688165d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad979cffb85eaeda752bd53688165d2d2">&#9670;&#160;</a></span>partialConstantFold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::partialConstantFold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operandConstants</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>results</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>hasPoison</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Propagates the constant operands into this affine map. </p>
<p>Operands are allowed to be null, at which point they are treated as non-constant. This does not change the number of symbols and dimensions. Returns a new map, which may be equal to the old map if no folding happened. If <span class="tt">results</span> is provided and if all expressions in the map were folded to constants, <span class="tt">results</span> will contain the values of these constants. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00449">449</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2AffineMap_8cpp_source.html#l00430">constantFold()</a>.</p>

</div>
</div>
<a id="ae0ecd6ef18c3c3fa94c053f5fba67bdf" name="ae0ecd6ef18c3c3fa94c053f5fba67bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ecd6ef18c3c3fa94c053f5fba67bdf">&#9670;&#160;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l04027">4027</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, <a class="el" href="AsmState_8h_source.html#l00568">mlir::AsmState::getImpl()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l03177">mlir::AsmPrinter::Impl::printAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00664">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="ac7d5c7e20f021aac37fcb4e65cbfca8c" name="ac7d5c7e20f021aac37fcb4e65cbfca8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d5c7e20f021aac37fcb4e65cbfca8c">&#9670;&#160;</a></span>replace() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>replacement</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultSyms</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse replace method. </p>
<p>Apply <a class="el" href="classmlir_1_1AffineExpr.html#ac62de85207ad0444e6f82d4e74595e79" title="Sparse replace method.">AffineExpr::replace</a>(<span class="tt">expr</span>, <span class="tt">replacement</span>) to each of the results and return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the new results and with the specified number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">511</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01190">replaceAffineDelinearizeIndexInverseExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01061">replaceAffineMinBoundingBoxExpression()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>, <a class="el" href="SparseReinterpretMap_8cpp_source.html#l00242">translateMap()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00110">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>.</p>

</div>
</div>
<a id="a33e5fc7ddb3f04679b3563a1525274ae" name="a33e5fc7ddb3f04679b3563a1525274ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e5fc7ddb3f04679b3563a1525274ae">&#9670;&#160;</a></span>replace() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse replace method. </p>
<p>Apply <a class="el" href="classmlir_1_1AffineExpr.html#ac62de85207ad0444e6f82d4e74595e79" title="Sparse replace method.">AffineExpr::replace</a>(<span class="tt">map</span>) to each of the results and return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the new results and with inferred number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00535">535</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">inferFromExprList()</a>.</p>

</div>
</div>
<a id="a4822614b5ae9d1f80e0b3da7b3ce664d" name="a4822614b5ae9d1f80e0b3da7b3ce664d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4822614b5ae9d1f80e0b3da7b3ce664d">&#9670;&#160;</a></span>replace() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultSyms</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sparse replace method. </p>
<p>Apply <a class="el" href="classmlir_1_1AffineExpr.html#ac62de85207ad0444e6f82d4e74595e79" title="Sparse replace method.">AffineExpr::replace</a>(<span class="tt">map</span>) to each of the results and return a new <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> with the new results and with the specified number of dims and symbols. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00524">524</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>.</p>

</div>
</div>
<a id="aa1fdca78f9d7bde157d251892dd99fa8" name="aa1fdca78f9d7bde157d251892dd99fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fdca78f9d7bde157d251892dd99fa8">&#9670;&#160;</a></span>replaceDimsAndSymbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> AffineMap::replaceDimsAndSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>dimReplacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>symReplacements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numResultSyms</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method substitutes any uses of dimensions and symbols (e.g. </p>
<p>dim#0 with dimReplacements[0]) in subexpressions and returns the modified expression mapping. Because this can be used to eliminate dims and symbols, the client needs to specify the number of dims and symbols in the result. The returned map always has the same number of results. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">496</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00087">mlir::AffineExpr::replaceDimsAndSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="DropUnitDims_8cpp_source.html#l00384">mlir::linalg::dropUnitDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">mlir::affine::reorderOperandsByHoistability()</a>, and <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00110">mlir::ValueBoundsConstraintSet::Variable::Variable()</a>.</p>

</div>
</div>
<a id="a3e72052d4b3c5ebbabbcc56d786901af" name="a3e72052d4b3c5ebbabbcc56d786901af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e72052d4b3c5ebbabbcc56d786901af">&#9670;&#160;</a></span>shiftDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::shiftDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace dims[offset ... numDims) by dims[offset + shift ... shift + numDims). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">267</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00131">mlir::AffineExpr::shiftDims()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00230">insertParallelDim()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00147">packLinalgMetadataOnce()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, <a class="el" href="SplitReduction_8cpp_source.html#l00215">scaleReductionDim()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="aab2febbfaf719c1e16ba071663244b8b" name="aab2febbfaf719c1e16ba071663244b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2febbfaf719c1e16ba071663244b8b">&#9670;&#160;</a></span>shiftSymbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::AffineMap::shiftSymbols </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>shift</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>offset</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace symbols[offset ... numSymbols) by symbols[offset + shift ... shift + numSymbols). </p>

<p class="definition">Definition at line <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00280">280</a> of file <a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="#a5605b1cc86aac352486868fa9a66e7a9">AffineMap()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00143">mlir::AffineExpr::shiftSymbols()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>.</p>

</div>
</div>
<a id="ad9311cb0642ba9e548c9773afada69d8" name="ad9311cb0642ba9e548c9773afada69d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9311cb0642ba9e548c9773afada69d8">&#9670;&#160;</a></span>walkExprs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> AffineMap::walkExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk all of the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a>'s in this mapping. </p>
<p>Each node in an expression tree is visited in postorder. </p>

<p class="definition">Definition at line <a class="el" href="IR_2AffineMap_8cpp_source.html#l00486">486</a> of file <a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">getResults()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00117">mlir::AffineExpr::walk()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">AffineMap.h</a></li>
<li>lib/IR/<a class="el" href="IR_2AffineMap_8cpp_source.html">AffineMap.cpp</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="MLIRContext_8cpp_source.html">MLIRContext.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
