<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1affine.html">affine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::affine Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1affine_1_1matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a (parallelizable) reduction in an affine loop.  <a href="structmlir_1_1affine_1_1LoopReduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a memref load or store access information.  <a href="structmlir_1_1affine_1_1MemRefAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two accesses to the same memref access the same element.  <a href="structmlir_1_1affine_1_1DependenceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> is an extension of <a class="el" href="classmlir_1_1FlatLinearValueConstraints.html" title="FlatLinearValueConstraints represents an extension of FlatLinearConstraints where each non-local vari...">FlatLinearValueConstraints</a> with helper functions for Affine dialect ops.  <a href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FlatAffineRelation.html">FlatAffineRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1affine_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain -&gt; range) where &quot;domain&quot; and &quot;range&quot; a...">FlatAffineRelation</a> represents a set of ordered pairs (domain -&gt; range) where "domain" and "range" are tuples of variables.  <a href="classmlir_1_1affine_1_1FlatAffineRelation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> captures nested patterns in the IR.  <a href="classmlir_1_1affine_1_1NestedMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedPatternContext.html">NestedPatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII structure to transparently manage the bump allocator for <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> and <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html" title="An NestedPattern captures nested patterns in the IR.">NestedMatch</a> classes.  <a href="classmlir_1_1affine_1_1NestedPatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">LoopNestStateCollector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different result statuses of slice computation by <code>computeSliceUnion</code>  <a href="structmlir_1_1affine_1_1SliceComputationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaWaitOp.html">AffineDmaWaitOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> blocks until the completion of a DMA operation associated with the tag element 'tag[index]'.  <a href="classmlir_1_1affine_1_1AffineDmaWaitOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineBound.html">AffineBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineBound.html" title="AffineBound represents a lower or upper bound in the for operation.">AffineBound</a> represents a lower or upper bound in the for operation.  <a href="classmlir_1_1affine_1_1AffineBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a> is an affine map plus its ML value operands and results for analysis purposes.  <a href="classmlir_1_1affine_1_1AffineValueMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the fusion strategy to be used in the Affine loop fusion utilities.  <a href="classmlir_1_1affine_1_1FusionStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html" title="LoopNestStats aggregates various per-loop statistics (eg.">LoopNestStats</a> aggregates various per-loop statistics (eg.  <a href="structmlir_1_1affine_1_1LoopNestStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy / DMA generation options for mlir::affineDataCopyGenerate.  <a href="structmlir_1_1affine_1_1AffineCopyOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1CopyGenerateResult.html">CopyGenerateResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result for calling generateCopyForMemRegion.  <a href="structmlir_1_1affine_1_1CopyGenerateResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html">VectorizationStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds parameters to perform n-D vectorization on a single loop nest.  <a href="structmlir_1_1affine_1_1VectorizationStrategy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DivModValue.html">DivModValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the result of (div a, b) and (mod a, b).  <a href="structmlir_1_1affine_1_1DivModValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineValueExpr.html">AffineValueExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineBuilder.html">AffineBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple AffineValueExprs with minimal type inference support.  <a href="structmlir_1_1affine_1_1AffineBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a989bf28765adddf1a6b818d6c36acc07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a989bf28765adddf1a6b818d6c36acc07">VectorizableLoopFun</a> = std::function&lt; bool(AffineForOp)&gt;</td></tr>
<tr class="separator:a989bf28765adddf1a6b818d6c36acc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6784a37545fc5cbc1395a1fffc2f2cb4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a6784a37545fc5cbc1395a1fffc2f2cb4">FilterFunctionType</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a6784a37545fc5cbc1395a1fffc2f2cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that:  <a href="namespacemlir_1_1affine.html#a6784a37545fc5cbc1395a1fffc2f2cb4">More...</a><br /></td></tr>
<tr class="separator:a6784a37545fc5cbc1395a1fffc2f2cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a9af2e4bb4c811ad5329293609224"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">ReductionLoopMap</a> = <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a>, 2 &gt; &gt;</td></tr>
<tr class="separator:ac58a9af2e4bb4c811ad5329293609224"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a955654b005f9ba55cfe8948a18593a1d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a> { <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6">Greedy</a>
, <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1dad17c9ca2b9301ef3d0cccfa9b6baf7ad">ProducerConsumer</a>
, <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1da0293acfd01e25304d05b1a7379cf3eb1">Sibling</a>
 }</td></tr>
<tr class="memdesc:a955654b005f9ba55cfe8948a18593a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusion mode to attempt.  <a href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1d">More...</a><br /></td></tr>
<tr class="separator:a955654b005f9ba55cfe8948a18593a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d5e2d802af8800beea28156d1604091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a5d5e2d802af8800beea28156d1604091">getSupportedReductions</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;supportedReductions)</td></tr>
<tr class="memdesc:a5d5e2d802af8800beea28156d1604091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <code>supportedReductions</code> with descriptors of the supported reductions.  <a href="namespacemlir_1_1affine.html#a5d5e2d802af8800beea28156d1604091">More...</a><br /></td></tr>
<tr class="separator:a5d5e2d802af8800beea28156d1604091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f70963668d2bfc0c3befc39fd1f250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad0f70963668d2bfc0c3befc39fd1f250">isLoopParallel</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; *parallelReductions=nullptr)</td></tr>
<tr class="memdesc:ad0f70963668d2bfc0c3befc39fd1f250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if &lsquo;forOp&rsquo; is a parallel loop.  <a href="namespacemlir_1_1affine.html#ad0f70963668d2bfc0c3befc39fd1f250">More...</a><br /></td></tr>
<tr class="separator:ad0f70963668d2bfc0c3befc39fd1f250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c415a3c0be0bdd484b55efb8d4f5e18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a7c415a3c0be0bdd484b55efb8d4f5e18">isLoopMemoryParallel</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a7c415a3c0be0bdd484b55efb8d4f5e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if &lsquo;forOp&rsquo; doesn't have memory dependences preventing parallelization.  <a href="namespacemlir_1_1affine.html#a7c415a3c0be0bdd484b55efb8d4f5e18">More...</a><br /></td></tr>
<tr class="separator:a7c415a3c0be0bdd484b55efb8d4f5e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77346d5ef6933117f2eeb04d320b1745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a77346d5ef6933117f2eeb04d320b1745">getReachableAffineApplyOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;affineApplyOps)</td></tr>
<tr class="memdesc:a77346d5ef6933117f2eeb04d320b1745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp.  <a href="namespacemlir_1_1affine.html#a77346d5ef6933117f2eeb04d320b1745">More...</a><br /></td></tr>
<tr class="separator:a77346d5ef6933117f2eeb04d320b1745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320102486b693e875ebb36f63c3bfc51"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a320102486b693e875ebb36f63c3bfc51">getIndexSet</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *domain)</td></tr>
<tr class="memdesc:a320102486b693e875ebb36f63c3bfc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a system of constraints with dimensional variables corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order.  <a href="namespacemlir_1_1affine.html#a320102486b693e875ebb36f63c3bfc51">More...</a><br /></td></tr>
<tr class="separator:a320102486b693e875ebb36f63c3bfc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f529204bbf5826df07986dc54aa5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a627f529204bbf5826df07986dc54aa5c">checkMemrefAccessDependence</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;dstAccess, unsigned loopDepth, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *dependenceConstraints=nullptr, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *dependenceComponents=nullptr, bool allowRAR=false)</td></tr>
<tr class="separator:a627f529204bbf5826df07986dc54aa5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d96430280537a906b65fe1e2184447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab2d96430280537a906b65fe1e2184447">hasDependence</a> (<a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> result)</td></tr>
<tr class="memdesc:ab2d96430280537a906b65fe1e2184447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to a dependence result.  <a href="namespacemlir_1_1affine.html#ab2d96430280537a906b65fe1e2184447">More...</a><br /></td></tr>
<tr class="separator:ab2d96430280537a906b65fe1e2184447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee44441a5ada09f5106e1a52ea905f2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aee44441a5ada09f5106e1a52ea905f2d">noDependence</a> (<a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> result)</td></tr>
<tr class="memdesc:aee44441a5ada09f5106e1a52ea905f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to the absence of a dependence.  <a href="namespacemlir_1_1affine.html#aee44441a5ada09f5106e1a52ea905f2d">More...</a><br /></td></tr>
<tr class="separator:aee44441a5ada09f5106e1a52ea905f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0909c720d16373cdd1209de6475a5055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0909c720d16373cdd1209de6475a5055">getDependenceComponents</a> (AffineForOp forOp, unsigned maxLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *depCompsVec)</td></tr>
<tr class="memdesc:a0909c720d16373cdd1209de6475a5055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth].  <a href="namespacemlir_1_1affine.html#a0909c720d16373cdd1209de6475a5055">More...</a><br /></td></tr>
<tr class="separator:a0909c720d16373cdd1209de6475a5055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9722cddbbf47c30fa4f5f4d0ed39f7ab"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9722cddbbf47c30fa4f5f4d0ed39f7ab">getRelationFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a9722cddbbf47c30fa4f5f4d0ed39f7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a relation from the given AffineMap/AffineValueMap <code>map</code>, containing all pairs of the form <code>operands -&gt; result</code> that satisfy <code>map</code>.  <a href="namespacemlir_1_1affine.html#a9722cddbbf47c30fa4f5f4d0ed39f7ab">More...</a><br /></td></tr>
<tr class="separator:a9722cddbbf47c30fa4f5f4d0ed39f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab216bbb57cc8cdf47c2cd1e4670adbc2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab216bbb57cc8cdf47c2cd1e4670adbc2">getRelationFromMap</a> (const <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &amp;map, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;rel)</td></tr>
<tr class="separator:ab216bbb57cc8cdf47c2cd1e4670adbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544bc2c1d4dc4d79bac4cb89321cbe09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a544bc2c1d4dc4d79bac4cb89321cbe09">getTripCountMapAndOperands</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a544bc2c1d4dc4d79bac4cb89321cbe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise.  <a href="namespacemlir_1_1affine.html#a544bc2c1d4dc4d79bac4cb89321cbe09">More...</a><br /></td></tr>
<tr class="separator:a544bc2c1d4dc4d79bac4cb89321cbe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03531487e4feec545babe224a2f9b671"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a03531487e4feec545babe224a2f9b671">getConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a03531487e4feec545babe224a2f9b671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop if it's a constant, std::nullopt otherwise.  <a href="namespacemlir_1_1affine.html#a03531487e4feec545babe224a2f9b671">More...</a><br /></td></tr>
<tr class="separator:a03531487e4feec545babe224a2f9b671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2752858f86e707624c0702a16d2d2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a93c2752858f86e707624c0702a16d2d2">getLargestDivisorOfTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a93c2752858f86e707624c0702a16d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest known integral divisor of the trip count.  <a href="namespacemlir_1_1affine.html#a93c2752858f86e707624c0702a16d2d2">More...</a><br /></td></tr>
<tr class="separator:a93c2752858f86e707624c0702a16d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623d044442600d97d7a7b5ecb597a166"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOp &gt; </td></tr>
<tr class="memitem:a623d044442600d97d7a7b5ecb597a166"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a623d044442600d97d7a7b5ecb597a166">isInvariantAccess</a> (LoadOrStoreOp memOp, AffineForOp forOp)</td></tr>
<tr class="memdesc:a623d044442600d97d7a7b5ecb597a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine read or write operation depends on <code>forOp</code>'s IV, i.e., if the memory access is invariant on <code>forOp</code>.  <a href="namespacemlir_1_1affine.html#a623d044442600d97d7a7b5ecb597a166">More...</a><br /></td></tr>
<tr class="separator:a623d044442600d97d7a7b5ecb597a166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4225805ce5c9b30cced3e7ca2adc8d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a4225805ce5c9b30cced3e7ca2adc8d55">getInvariantAccesses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; indices)</td></tr>
<tr class="memdesc:a4225805ce5c9b30cced3e7ca2adc8d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>.  <a href="namespacemlir_1_1affine.html#a4225805ce5c9b30cced3e7ca2adc8d55">More...</a><br /></td></tr>
<tr class="separator:a4225805ce5c9b30cced3e7ca2adc8d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971420849a0dcea8b985c4aae2c1a419"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOp &gt; </td></tr>
<tr class="memitem:a971420849a0dcea8b985c4aae2c1a419"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a971420849a0dcea8b985c4aae2c1a419">isContiguousAccess</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, LoadOrStoreOp memoryOp, int *memRefDim)</td></tr>
<tr class="memdesc:a971420849a0dcea8b985c4aae2c1a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given:  <a href="namespacemlir_1_1affine.html#a971420849a0dcea8b985c4aae2c1a419">More...</a><br /></td></tr>
<tr class="separator:a971420849a0dcea8b985c4aae2c1a419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ee6f64e3efdd85b5f35ca0b7e4acec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a14ee6f64e3efdd85b5f35ca0b7e4acec">isVectorizableLoopBody</a> (AffineForOp loop, <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a14ee6f64e3efdd85b5f35ca0b7e4acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable; i.e.  <a href="namespacemlir_1_1affine.html#a14ee6f64e3efdd85b5f35ca0b7e4acec">More...</a><br /></td></tr>
<tr class="separator:a14ee6f64e3efdd85b5f35ca0b7e4acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8739b5a311c3583c17ae8802a491f2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a8739b5a311c3583c17ae8802a491f2be">isVectorizableLoopBody</a> (AffineForOp loop, int *memRefDim, <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a8739b5a311c3583c17ae8802a491f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are either:  <a href="namespacemlir_1_1affine.html#a8739b5a311c3583c17ae8802a491f2be">More...</a><br /></td></tr>
<tr class="separator:a8739b5a311c3583c17ae8802a491f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9ac00d2450032a64d31d68d1c82408"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#acf9ac00d2450032a64d31d68d1c82408">isOpwiseShiftValid</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts)</td></tr>
<tr class="memdesc:acf9ac00d2450032a64d31d68d1c82408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.  <a href="namespacemlir_1_1affine.html#acf9ac00d2450032a64d31d68d1c82408">More...</a><br /></td></tr>
<tr class="separator:acf9ac00d2450032a64d31d68d1c82408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114e1e8e803cf90761ffc5a667f3c0c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a114e1e8e803cf90761ffc5a667f3c0c7">isTilingValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:a114e1e8e803cf90761ffc5a667f3c0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether hyper-rectangular loop tiling of the nest represented by <code>loops</code> is valid.  <a href="namespacemlir_1_1affine.html#a114e1e8e803cf90761ffc5a667f3c0c7">More...</a><br /></td></tr>
<tr class="separator:a114e1e8e803cf90761ffc5a667f3c0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20aaeff227a5723102c54a6a88bedd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae20aaeff227a5723102c54a6a88bedd5">hasCyclicDependence</a> (AffineForOp root)</td></tr>
<tr class="memdesc:ae20aaeff227a5723102c54a6a88bedd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine nest rooted at <code>root</code> has a cyclic dependence among its affine memory accesses.  <a href="namespacemlir_1_1affine.html#ae20aaeff227a5723102c54a6a88bedd5">More...</a><br /></td></tr>
<tr class="separator:ae20aaeff227a5723102c54a6a88bedd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b53bee9c367aacba5fc65c40c8477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aa7b53bee9c367aacba5fc65c40c8477c">defaultFilterFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)</td></tr>
<tr class="separator:aa7b53bee9c367aacba5fc65c40c8477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">getAffineForIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one while not traversing outside of the surrounding affine scope.  <a href="namespacemlir_1_1affine.html#a9085efe05b8bc0b7c3b4f643d70eb1e7">More...</a><br /></td></tr>
<tr class="separator:a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b5b72a6baee24bfab9faebd198fe9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">getAffineIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs)</td></tr>
<tr class="memdesc:a50b5b72a6baee24bfab9faebd198fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outermost one to the innermost while not traversing outside of the surrounding affine scope.  <a href="namespacemlir_1_1affine.html#a50b5b72a6baee24bfab9faebd198fe9b">More...</a><br /></td></tr>
<tr class="separator:a50b5b72a6baee24bfab9faebd198fe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e59ec9faff34b64ebb0411a383c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">getEnclosingAffineOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *ops)</td></tr>
<tr class="memdesc:a1f8e59ec9faff34b64ebb0411a383c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with affine operations enclosing <code>op</code> ordered from outermost to innermost while stopping at the boundary of the affine scope.  <a href="namespacemlir_1_1affine.html#a1f8e59ec9faff34b64ebb0411a383c3a">More...</a><br /></td></tr>
<tr class="separator:a1f8e59ec9faff34b64ebb0411a383c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <a href="namespacemlir_1_1affine.html#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">More...</a><br /></td></tr>
<tr class="separator:ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c1ca39d435d06366058d16b5fe4225"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">isLoopParallelAndContainsReduction</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a34c1ca39d435d06366058d16b5fe4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a loop is a parallel loop and contains a reduction loop.  <a href="namespacemlir_1_1affine.html#a34c1ca39d435d06366058d16b5fe4225">More...</a><br /></td></tr>
<tr class="separator:a34c1ca39d435d06366058d16b5fe4225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad383995f97dc30a0d6891e33fd499a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a5ad383995f97dc30a0d6891e33fd499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <a href="namespacemlir_1_1affine.html#a5ad383995f97dc30a0d6891e33fd499a">More...</a><br /></td></tr>
<tr class="separator:a5ad383995f97dc30a0d6891e33fd499a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;dependenceConstraints, unsigned loopDepth, bool isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <a href="namespacemlir_1_1affine.html#ab6cceed0c6debb9af0d3bd76c9ed52f4">More...</a><br /></td></tr>
<tr class="separator:ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb5cde2210f8126b02cd84843a0c43b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">getSliceIterationCount</a> (const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</td></tr>
<tr class="memdesc:acfb5cde2210f8126b02cd84843a0c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for the <code>slicetripCountMap</code> provided.  <a href="namespacemlir_1_1affine.html#acfb5cde2210f8126b02cd84843a0c43b">More...</a><br /></td></tr>
<tr class="separator:acfb5cde2210f8126b02cd84843a0c43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">buildSliceTripCountMap</a> (const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *tripCountMap)</td></tr>
<tr class="memdesc:af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'.  <a href="namespacemlir_1_1affine.html#af1b7ee261b2662fe2f0c257c9e04f3b6">More...</a><br /></td></tr>
<tr class="separator:af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29213ed6d6cdad5cdd69bb66c6df863f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsB, unsigned loopDepth, unsigned numCommonLoops, bool isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:a29213ed6d6cdad5cdd69bb66c6df863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid.  <a href="namespacemlir_1_1affine.html#a29213ed6d6cdad5cdd69bb66c6df863f">More...</a><br /></td></tr>
<tr class="separator:a29213ed6d6cdad5cdd69bb66c6df863f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32168fb86ad493527c61d139acee48a"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, unsigned dstLoopDepth, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:af32168fb86ad493527c61d139acee48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <a href="namespacemlir_1_1affine.html#af32168fb86ad493527c61d139acee48a">More...</a><br /></td></tr>
<tr class="separator:af32168fb86ad493527c61d139acee48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">getIntOrFloatMemRefSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a memref with element type int or float in bytes if it's statically shaped, std::nullopt otherwise.  <a href="namespacemlir_1_1affine.html#ac5e109cfdab6f0859fbbc3e0bf08ebac">More...</a><br /></td></tr>
<tr class="separator:ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer &gt; </td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, bool <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=true)</td></tr>
<tr class="memdesc:addef193d35d8d7990addced6bcb731c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <a href="namespacemlir_1_1affine.html#addef193d35d8d7990addced6bcb731c1">More...</a><br /></td></tr>
<tr class="separator:addef193d35d8d7990addced6bcb731c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a39bbf8628440572cdd76a10d58dc53"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;b)</td></tr>
<tr class="memdesc:a3a39bbf8628440572cdd76a10d58dc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <a href="namespacemlir_1_1affine.html#a3a39bbf8628440572cdd76a10d58dc53">More...</a><br /></td></tr>
<tr class="separator:a3a39bbf8628440572cdd76a10d58dc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <a href="namespacemlir_1_1affine.html#a93666d2fb7a3b0598ecf69542f1a5ab7">More...</a><br /></td></tr>
<tr class="separator:a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e0f536b1471778961ba51c2227f07"><td class="memItemLeft" align="right" valign="top">std::optional&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">getMemRefIntOrFloatEltSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:afd9e0f536b1471778961ba51c2227f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memref's element type's size in bytes where the elemental type is an int or float or a vector of such types.  <a href="namespacemlir_1_1affine.html#afd9e0f536b1471778961ba51c2227f07">More...</a><br /></td></tr>
<tr class="separator:afd9e0f536b1471778961ba51c2227f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2e85e904cf88ca63479dad00941e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1f2e85e904cf88ca63479dad00941e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <a href="namespacemlir_1_1affine.html#a1f2e85e904cf88ca63479dad00941e87">More...</a><br /></td></tr>
<tr class="separator:a1f2e85e904cf88ca63479dad00941e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=nullptr)</td></tr>
<tr class="memdesc:a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <a href="namespacemlir_1_1affine.html#a9cc3df9a0cea6ad3bf48958ad2d54128">More...</a><br /></td></tr>
<tr class="separator:a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c9fec2934b9a14a5883e9fabbe3f49"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">simplifyConstrainedMinMaxOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> constraints)</td></tr>
<tr class="memdesc:af4c9fec2934b9a14a5883e9fabbe3f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the given affine.min or affine.max op to an affine map with a single result and operands, taking into account the specified constraint set.  <a href="namespacemlir_1_1affine.html#af4c9fec2934b9a14a5883e9fabbe3f49">More...</a><br /></td></tr>
<tr class="separator:af4c9fec2934b9a14a5883e9fabbe3f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ee1431de2b7e6802c9270b1ff60d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">mlir::Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">findInnermostCommonBlockInScope</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *b)</td></tr>
<tr class="memdesc:ae33ee1431de2b7e6802c9270b1ff60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the innermost common <code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></code> of <code>a</code> and <code>b</code> in the affine scope that <code>a</code> and <code>b</code> are part of.  <a href="namespacemlir_1_1affine.html#ae33ee1431de2b7e6802c9270b1ff60d1">More...</a><br /></td></tr>
<tr class="separator:ae33ee1431de2b7e6802c9270b1ff60d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ac5508d6eb2d2c7c2a2103ca7a1bfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a85ac5508d6eb2d2c7c2a2103ca7a1bfe">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a85ac5508d6eb2d2c7c2a2103ca7a1bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code> or is a region argument for such an op.  <a href="namespacemlir_1_1affine.html#a85ac5508d6eb2d2c7c2a2103ca7a1bfe">More...</a><br /></td></tr>
<tr class="separator:a85ac5508d6eb2d2c7c2a2103ca7a1bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b541bc609cc8c880c998cc99cdd1589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9b541bc609cc8c880c998cc99cdd1589">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a9b541bc609cc8c880c998cc99cdd1589"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code>.  <a href="namespacemlir_1_1affine.html#a9b541bc609cc8c880c998cc99cdd1589">More...</a><br /></td></tr>
<tr class="separator:a9b541bc609cc8c880c998cc99cdd1589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad353c117f0a45543a77ef884704a7ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad353c117f0a45543a77ef884704a7ff0">getAffineScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad353c117f0a45543a77ef884704a7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest region enclosing <code>op</code> that is held by an operation with trait <code>AffineScope</code>; <code>nullptr</code> if there is no such region.  <a href="namespacemlir_1_1affine.html#ad353c117f0a45543a77ef884704a7ff0">More...</a><br /></td></tr>
<tr class="separator:ad353c117f0a45543a77ef884704a7ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8722fd9a0481c2680fd64fcb7fbbb583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a8722fd9a0481c2680fd64fcb7fbbb583">getAffineAnalysisScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8722fd9a0481c2680fd64fcb7fbbb583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest region enclosing <code>op</code> that is held by a non-affine operation; <code>nullptr</code> if there is no such region.  <a href="namespacemlir_1_1affine.html#a8722fd9a0481c2680fd64fcb7fbbb583">More...</a><br /></td></tr>
<tr class="separator:a8722fd9a0481c2680fd64fcb7fbbb583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ded6085da1a665f8c367bea35e77fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a43ded6085da1a665f8c367bea35e77fc">computeProduct</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; terms)</td></tr>
<tr class="memdesc:a43ded6085da1a665f8c367bea35e77fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of <code>terms</code>, creating an <code>affine.apply</code> if any of them are non-constant values.  <a href="namespacemlir_1_1affine.html#a43ded6085da1a665f8c367bea35e77fc">More...</a><br /></td></tr>
<tr class="separator:a43ded6085da1a665f8c367bea35e77fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245751b99c21bbee57456cef1e52bde4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a245751b99c21bbee57456cef1e52bde4">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a245751b99c21bbee57456cef1e52bde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="namespacemlir_1_1affine.html#a245751b99c21bbee57456cef1e52bde4">More...</a><br /></td></tr>
<tr class="separator:a245751b99c21bbee57456cef1e52bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3030c26358d640e751344ee1fc60335"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab3030c26358d640e751344ee1fc60335">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:ab3030c26358d640e751344ee1fc60335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="namespacemlir_1_1affine.html#ab3030c26358d640e751344ee1fc60335">More...</a><br /></td></tr>
<tr class="separator:ab3030c26358d640e751344ee1fc60335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d387ed8b9220b1d4f32d7efe7cf6117"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9d387ed8b9220b1d4f32d7efe7cf6117">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9d387ed8b9220b1d4f32d7efe7cf6117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>.  <a href="namespacemlir_1_1affine.html#a9d387ed8b9220b1d4f32d7efe7cf6117">More...</a><br /></td></tr>
<tr class="separator:a9d387ed8b9220b1d4f32d7efe7cf6117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeeefdd6013aa0720cc45eed32fd8eac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#adeeefdd6013aa0720cc45eed32fd8eac">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:adeeefdd6013aa0720cc45eed32fd8eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>.  <a href="namespacemlir_1_1affine.html#adeeefdd6013aa0720cc45eed32fd8eac">More...</a><br /></td></tr>
<tr class="separator:adeeefdd6013aa0720cc45eed32fd8eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96a1dbba3240e5a725ce9176f832a6f"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad96a1dbba3240e5a725ce9176f832a6f">parseDimAndSymbolList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, unsigned &amp;numDims)</td></tr>
<tr class="memdesc:ad96a1dbba3240e5a725ce9176f832a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses dimension and symbol list.  <a href="namespacemlir_1_1affine.html#ad96a1dbba3240e5a725ce9176f832a6f">More...</a><br /></td></tr>
<tr class="separator:ad96a1dbba3240e5a725ce9176f832a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691ff98dafcd40a555ea1d127b06c9c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a691ff98dafcd40a555ea1d127b06c9c3">canonicalizeMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a691ff98dafcd40a555ea1d127b06c9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies both <code>map</code> and <code>operands</code> in-place so as to:  <a href="namespacemlir_1_1affine.html#a691ff98dafcd40a555ea1d127b06c9c3">More...</a><br /></td></tr>
<tr class="separator:a691ff98dafcd40a555ea1d127b06c9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b47f23151bd884a4ce93312f1499a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a8b47f23151bd884a4ce93312f1499a02">canonicalizeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a8b47f23151bd884a4ce93312f1499a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps.  <a href="namespacemlir_1_1affine.html#a8b47f23151bd884a4ce93312f1499a02">More...</a><br /></td></tr>
<tr class="separator:a8b47f23151bd884a4ce93312f1499a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5cb525632c1a12545d579561c40dcc"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0d5cb525632c1a12545d579561c40dcc">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a0d5cb525632c1a12545d579561c40dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands.  <a href="namespacemlir_1_1affine.html#a0d5cb525632c1a12545d579561c40dcc">More...</a><br /></td></tr>
<tr class="separator:a0d5cb525632c1a12545d579561c40dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c32299c7b12725419a820f4314fa39c"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a4c32299c7b12725419a820f4314fa39c">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, bool composeAffineMin=false)</td></tr>
<tr class="separator:a4c32299c7b12725419a820f4314fa39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790378c2cd10eccca0bfe9fca0f84300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a790378c2cd10eccca0bfe9fca0f84300">makeComposedFoldedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a790378c2cd10eccca0bfe9fca0f84300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineApplyOp that applies <code>map</code> to <code>operands</code> after composing the map with the maps of any other AffineApplyOp supplying the operands, then immediately attempts to fold it.  <a href="namespacemlir_1_1affine.html#a790378c2cd10eccca0bfe9fca0f84300">More...</a><br /></td></tr>
<tr class="separator:a790378c2cd10eccca0bfe9fca0f84300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f23150730054dc540e6470b3bf342e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad9f23150730054dc540e6470b3bf342e">makeComposedFoldedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:ad9f23150730054dc540e6470b3bf342e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>makeComposedFoldedAffineApply</code> that applies to an expression.  <a href="namespacemlir_1_1affine.html#ad9f23150730054dc540e6470b3bf342e">More...</a><br /></td></tr>
<tr class="separator:ad9f23150730054dc540e6470b3bf342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369e8fce67650dea4a3ae344c29b3ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a369e8fce67650dea4a3ae344c29b3ee4">makeComposedFoldedMultiResultAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a369e8fce67650dea4a3ae344c29b3ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <code>makeComposedFoldedAffineApply</code> suitable for multi-result maps.  <a href="namespacemlir_1_1affine.html#a369e8fce67650dea4a3ae344c29b3ee4">More...</a><br /></td></tr>
<tr class="separator:a369e8fce67650dea4a3ae344c29b3ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb27d3d2a62c6db2503c7cc8d62a6bb"><td class="memItemLeft" align="right" valign="top">AffineMinOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aefb27d3d2a62c6db2503c7cc8d62a6bb">makeComposedAffineMin</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:aefb27d3d2a62c6db2503c7cc8d62a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an AffineMinOp obtained by composing <code>map</code> and <code>operands</code> with AffineApplyOps supplying those operands.  <a href="namespacemlir_1_1affine.html#aefb27d3d2a62c6db2503c7cc8d62a6bb">More...</a><br /></td></tr>
<tr class="separator:aefb27d3d2a62c6db2503c7cc8d62a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cf2e698dddd6dc85868bac07a74ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a81cf2e698dddd6dc85868bac07a74ca0">makeComposedFoldedAffineMin</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:a81cf2e698dddd6dc85868bac07a74ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineMinOp that computes a minimum across the results of applying <code>map</code> to <code>operands</code>, then immediately attempts to fold it.  <a href="namespacemlir_1_1affine.html#a81cf2e698dddd6dc85868bac07a74ca0">More...</a><br /></td></tr>
<tr class="separator:a81cf2e698dddd6dc85868bac07a74ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767162cfa21cd3e191f6c2e8f5bc9f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a767162cfa21cd3e191f6c2e8f5bc9f1e">makeComposedFoldedAffineMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:a767162cfa21cd3e191f6c2e8f5bc9f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineMinOp that computes a maximum across the results of applying <code>map</code> to <code>operands</code>, then immediately attempts to fold it.  <a href="namespacemlir_1_1affine.html#a767162cfa21cd3e191f6c2e8f5bc9f1e">More...</a><br /></td></tr>
<tr class="separator:a767162cfa21cd3e191f6c2e8f5bc9f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d2273335462b22fd078a52a6c687e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a89d2273335462b22fd078a52a6c687e7">fullyComposeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands, bool composeAffineMin=false)</td></tr>
<tr class="memdesc:a89d2273335462b22fd078a52a6c687e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp.  <a href="namespacemlir_1_1affine.html#a89d2273335462b22fd078a52a6c687e7">More...</a><br /></td></tr>
<tr class="separator:a89d2273335462b22fd078a52a6c687e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78713c7b03663a8b9c23a4394a714e1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a78713c7b03663a8b9c23a4394a714e1a">isAffineForInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a78713c7b03663a8b9c23a4394a714e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of an AffineForOp.  <a href="namespacemlir_1_1affine.html#a78713c7b03663a8b9c23a4394a714e1a">More...</a><br /></td></tr>
<tr class="separator:a78713c7b03663a8b9c23a4394a714e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae078747217d5df8ac5077cadb329f087"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae078747217d5df8ac5077cadb329f087">isAffineParallelInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ae078747217d5df8ac5077cadb329f087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>val</code> is the induction variable of an AffineParallelOp.  <a href="namespacemlir_1_1affine.html#ae078747217d5df8ac5077cadb329f087">More...</a><br /></td></tr>
<tr class="separator:ae078747217d5df8ac5077cadb329f087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb9a1f410c602d0a0aaf955705a15ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a2fb9a1f410c602d0a0aaf955705a15ac">isAffineInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a2fb9a1f410c602d0a0aaf955705a15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of an AffineForOp or AffineParallelOp.  <a href="namespacemlir_1_1affine.html#a2fb9a1f410c602d0a0aaf955705a15ac">More...</a><br /></td></tr>
<tr class="separator:a2fb9a1f410c602d0a0aaf955705a15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483c308ea389d0ce4b47ef74a252b14e"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a483c308ea389d0ce4b47ef74a252b14e">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a483c308ea389d0ce4b47ef74a252b14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="namespacemlir_1_1affine.html#a483c308ea389d0ce4b47ef74a252b14e">More...</a><br /></td></tr>
<tr class="separator:a483c308ea389d0ce4b47ef74a252b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27d6cea1330a4ac809686a75c43d25"><td class="memItemLeft" align="right" valign="top">AffineParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abf27d6cea1330a4ac809686a75c43d25">getAffineParallelInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:abf27d6cea1330a4ac809686a75c43d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is among the induction variables of an AffineParallelOp.  <a href="namespacemlir_1_1affine.html#abf27d6cea1330a4ac809686a75c43d25">More...</a><br /></td></tr>
<tr class="separator:abf27d6cea1330a4ac809686a75c43d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da42aec5ee59df08774d6d55982b59c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1da42aec5ee59df08774d6d55982b59c">extractForInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forInsts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *ivs)</td></tr>
<tr class="memdesc:a1da42aec5ee59df08774d6d55982b59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>.  <a href="namespacemlir_1_1affine.html#a1da42aec5ee59df08774d6d55982b59c">More...</a><br /></td></tr>
<tr class="separator:a1da42aec5ee59df08774d6d55982b59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a92b58f46c4e921cc3c899423b76a27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9a92b58f46c4e921cc3c899423b76a27">extractInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; affineOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs)</td></tr>
<tr class="memdesc:a9a92b58f46c4e921cc3c899423b76a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of either AffineForOp or AffineParallelOp and places them in the output argument <code>ivs</code>.  <a href="namespacemlir_1_1affine.html#a9a92b58f46c4e921cc3c899423b76a27">More...</a><br /></td></tr>
<tr class="separator:a9a92b58f46c4e921cc3c899423b76a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2fe80f256b34a27f3f9fa0cce088a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0d2fe80f256b34a27f3f9fa0cce088a5">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="memdesc:a0d2fe80f256b34a27f3f9fa0cce088a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator.  <a href="namespacemlir_1_1affine.html#a0d2fe80f256b34a27f3f9fa0cce088a5">More...</a><br /></td></tr>
<tr class="separator:a0d2fe80f256b34a27f3f9fa0cce088a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38de885fc72eb338a5ec53d1ab65630c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a38de885fc72eb338a5ec53d1ab65630c">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; steps, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=nullptr)</td></tr>
<tr class="separator:a38de885fc72eb338a5ec53d1ab65630c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f3eb48860eab1e82710027ceae08f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a861f3eb48860eab1e82710027ceae08f">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a861f3eb48860eab1e82710027ceae08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9717faebcbb497b46d259b26da55635"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab9717faebcbb497b46d259b26da55635">fullyComposeAndComputeConstantDelta</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value1, <a class="el" href="classmlir_1_1Value.html">Value</a> value2)</td></tr>
<tr class="memdesc:ab9717faebcbb497b46d259b26da55635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant delta of the given two values.  <a href="namespacemlir_1_1affine.html#ab9717faebcbb497b46d259b26da55635">More...</a><br /></td></tr>
<tr class="separator:ab9717faebcbb497b46d259b26da55635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ab6f9e710bf9eb63bc8b3488c58631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae3ab6f9e710bf9eb63bc8b3488c58631">canFuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, unsigned dstLoopDepth, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *srcSlice, <a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a> fusionStrategy=<a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html#a996eae93c3d38b2b1f428661df7acc46a1c27f9e3417768eefe1bab13d6de5de6">FusionStrategy::Generic</a>)</td></tr>
<tr class="memdesc:ae3ab6f9e710bf9eb63bc8b3488c58631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'.  <a href="namespacemlir_1_1affine.html#ae3ab6f9e710bf9eb63bc8b3488c58631">More...</a><br /></td></tr>
<tr class="separator:ae3ab6f9e710bf9eb63bc8b3488c58631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87fd816295937f98c409c06f1407d96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a87fd816295937f98c409c06f1407d96e">fuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;srcSlice, bool isInnermostSiblingInsertionFusion=false)</td></tr>
<tr class="memdesc:a87fd816295937f98c409c06f1407d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'.  <a href="namespacemlir_1_1affine.html#a87fd816295937f98c409c06f1407d96e">More...</a><br /></td></tr>
<tr class="separator:a87fd816295937f98c409c06f1407d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7270aca023f828cb4e8893705de7e0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aa7270aca023f828cb4e8893705de7e0b">getLoopNestStats</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> *stats)</td></tr>
<tr class="memdesc:aa7270aca023f828cb4e8893705de7e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect loop nest statistics (eg.  <a href="namespacemlir_1_1affine.html#aa7270aca023f828cb4e8893705de7e0b">More...</a><br /></td></tr>
<tr class="separator:aa7270aca023f828cb4e8893705de7e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e97fc7b7a01938ada405a335e7961a7"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a6e97fc7b7a01938ada405a335e7961a7">getComputeCost</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;stats)</td></tr>
<tr class="memdesc:a6e97fc7b7a01938ada405a335e7961a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.  <a href="namespacemlir_1_1affine.html#a6e97fc7b7a01938ada405a335e7961a7">More...</a><br /></td></tr>
<tr class="separator:a6e97fc7b7a01938ada405a335e7961a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b764a0cf88a53b85f7149423277f12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a27b764a0cf88a53b85f7149423277f12">getFusionComputeCost</a> (AffineForOp srcForOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;srcStats, AffineForOp dstForOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;dstStats, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, int64_t *computeCost)</td></tr>
<tr class="memdesc:a27b764a0cf88a53b85f7149423277f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'.  <a href="namespacemlir_1_1affine.html#a27b764a0cf88a53b85f7149423277f12">More...</a><br /></td></tr>
<tr class="separator:a27b764a0cf88a53b85f7149423277f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c01e230ac0a33fa2370a21e428e833e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3c01e230ac0a33fa2370a21e428e833e">gatherProducerConsumerMemrefs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; srcOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; dstOps, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:a3c01e230ac0a33fa2370a21e428e833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'.  <a href="namespacemlir_1_1affine.html#a3c01e230ac0a33fa2370a21e428e833e">More...</a><br /></td></tr>
<tr class="separator:a3c01e230ac0a33fa2370a21e428e833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1298df47a03112972950004cc449fed3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1298df47a03112972950004cc449fed3">loopUnrollFull</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a1298df47a03112972950004cc449fed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation completely if the trip count is known to be constant.  <a href="namespacemlir_1_1affine.html#a1298df47a03112972950004cc449fed3">More...</a><br /></td></tr>
<tr class="separator:a1298df47a03112972950004cc449fed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e40110d365738e8699594b1d4f27e85"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1e40110d365738e8699594b1d4f27e85">loopUnrollByFactor</a> (AffineForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=nullptr, bool cleanUpUnroll=false)</td></tr>
<tr class="memdesc:a1e40110d365738e8699594b1d4f27e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="namespacemlir_1_1affine.html#a1e40110d365738e8699594b1d4f27e85">More...</a><br /></td></tr>
<tr class="separator:a1e40110d365738e8699594b1d4f27e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6bdc8e2c261d88d25e21d30ab2899d"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a6d6bdc8e2c261d88d25e21d30ab2899d">loopUnrollUpToFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a6d6bdc8e2c261d88d25e21d30ab2899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop by the specified unroll factor or its trip count, whichever is lower.  <a href="namespacemlir_1_1affine.html#a6d6bdc8e2c261d88d25e21d30ab2899d">More...</a><br /></td></tr>
<tr class="separator:a6d6bdc8e2c261d88d25e21d30ab2899d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0fe5f9658cd1c27d0460a91d0f18f"><td class="memItemLeft" align="right" valign="top">bool LLVM_ATTRIBUTE_UNUSED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a25d0fe5f9658cd1c27d0460a91d0f18f">isPerfectlyNested</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:a25d0fe5f9658cd1c27d0460a91d0f18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost.  <a href="namespacemlir_1_1affine.html#a25d0fe5f9658cd1c27d0460a91d0f18f">More...</a><br /></td></tr>
<tr class="separator:a25d0fe5f9658cd1c27d0460a91d0f18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdd1212128e826d76abbe85a61742b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3fdd1212128e826d76abbe85a61742b7">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;nestedLoops, AffineForOp root)</td></tr>
<tr class="memdesc:a3fdd1212128e826d76abbe85a61742b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="namespacemlir_1_1affine.html#a3fdd1212128e826d76abbe85a61742b7">More...</a><br /></td></tr>
<tr class="separator:a3fdd1212128e826d76abbe85a61742b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8208a6014374243c317effcb573395dd"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a8208a6014374243c317effcb573395dd">loopUnrollJamByFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:a8208a6014374243c317effcb573395dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor.  <a href="namespacemlir_1_1affine.html#a8208a6014374243c317effcb573395dd">More...</a><br /></td></tr>
<tr class="separator:a8208a6014374243c317effcb573395dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c569833e90667ba35ace5840ac92307"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1c569833e90667ba35ace5840ac92307">loopUnrollJamUpToFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:a1c569833e90667ba35ace5840ac92307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower.  <a href="namespacemlir_1_1affine.html#a1c569833e90667ba35ace5840ac92307">More...</a><br /></td></tr>
<tr class="separator:a1c569833e90667ba35ace5840ac92307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d92cbba68de00d9a29abd461274661"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a17d92cbba68de00d9a29abd461274661">promoteIfSingleIteration</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a17d92cbba68de00d9a29abd461274661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration.  <a href="namespacemlir_1_1affine.html#a17d92cbba68de00d9a29abd461274661">More...</a><br /></td></tr>
<tr class="separator:a17d92cbba68de00d9a29abd461274661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6177db3daa7c8f6e03b62ec74334fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aa6177db3daa7c8f6e03b62ec74334fdd">promoteSingleIterationLoops</a> (func::FuncOp f)</td></tr>
<tr class="memdesc:aa6177db3daa7c8f6e03b62ec74334fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <a href="namespacemlir_1_1affine.html#aa6177db3daa7c8f6e03b62ec74334fdd">More...</a><br /></td></tr>
<tr class="separator:aa6177db3daa7c8f6e03b62ec74334fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46706cab45d0b917d5acff3ed72756c2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a46706cab45d0b917d5acff3ed72756c2">affineForOpBodySkew</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts, bool unrollPrologueEpilogue=false)</td></tr>
<tr class="memdesc:a46706cab45d0b917d5acff3ed72756c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew the operations in an affine.for's body with the specified operation-wise shifts.  <a href="namespacemlir_1_1affine.html#a46706cab45d0b917d5acff3ed72756c2">More...</a><br /></td></tr>
<tr class="separator:a46706cab45d0b917d5acff3ed72756c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fdfbbfeaedc902c83393747fa2fe7f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad4fdfbbfeaedc902c83393747fa2fe7f">tilePerfectlyNested</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:ad4fdfbbfeaedc902c83393747fa2fe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops.  <a href="namespacemlir_1_1affine.html#ad4fdfbbfeaedc902c83393747fa2fe7f">More...</a><br /></td></tr>
<tr class="separator:ad4fdfbbfeaedc902c83393747fa2fe7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86baa652b01992ec11a10c7de8e2fe54"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a86baa652b01992ec11a10c7de8e2fe54">tilePerfectlyNestedParametric</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=nullptr)</td></tr>
<tr class="memdesc:a86baa652b01992ec11a10c7de8e2fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters.  <a href="namespacemlir_1_1affine.html#a86baa652b01992ec11a10c7de8e2fe54">More...</a><br /></td></tr>
<tr class="separator:a86baa652b01992ec11a10c7de8e2fe54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbefeb28d61a80e2a403eb660deabbe7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#adbefeb28d61a80e2a403eb660deabbe7">interchangeLoops</a> (AffineForOp forOpA, AffineForOp forOpB)</td></tr>
<tr class="memdesc:adbefeb28d61a80e2a403eb660deabbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs loop interchange on 'forOpA' and 'forOpB'.  <a href="namespacemlir_1_1affine.html#adbefeb28d61a80e2a403eb660deabbe7">More...</a><br /></td></tr>
<tr class="separator:adbefeb28d61a80e2a403eb660deabbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aded67ac5853a2bdeff09550e8bb32c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a5aded67ac5853a2bdeff09550e8bb32c">isValidLoopInterchangePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; loopPermMap)</td></tr>
<tr class="memdesc:a5aded67ac5853a2bdeff09550e8bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange).  <a href="namespacemlir_1_1affine.html#a5aded67ac5853a2bdeff09550e8bb32c">More...</a><br /></td></tr>
<tr class="separator:a5aded67ac5853a2bdeff09550e8bb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcd13c7ee29ca2ec5cc65bfc85133fb"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a7bcd13c7ee29ca2ec5cc65bfc85133fb">permuteLoops</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; permMap)</td></tr>
<tr class="memdesc:a7bcd13c7ee29ca2ec5cc65bfc85133fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ...  <a href="namespacemlir_1_1affine.html#a7bcd13c7ee29ca2ec5cc65bfc85133fb">More...</a><br /></td></tr>
<tr class="separator:a7bcd13c7ee29ca2ec5cc65bfc85133fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1cc3f41464ffc9424244b2e3a3f2bd5"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad1cc3f41464ffc9424244b2e3a3f2bd5">sinkSequentialLoops</a> (AffineForOp forOp)</td></tr>
<tr class="separator:ad1cc3f41464ffc9424244b2e3a3f2bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b737fda5e5d83d831e50dcb73d8e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad1b737fda5e5d83d831e50dcb73d8e26">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="memdesc:ad1b737fda5e5d83d831e50dcb73d8e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="namespacemlir_1_1affine.html#ad1b737fda5e5d83d831e50dcb73d8e26">More...</a><br /></td></tr>
<tr class="separator:ad1b737fda5e5d83d831e50dcb73d8e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c5e9321f0d01289b23d98a44b936cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0c5e9321f0d01289b23d98a44b936cd8">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, AffineForOp target)</td></tr>
<tr class="memdesc:a0c5e9321f0d01289b23d98a44b936cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="namespacemlir_1_1affine.html#a0c5e9321f0d01289b23d98a44b936cd8">More...</a><br /></td></tr>
<tr class="separator:a0c5e9321f0d01289b23d98a44b936cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ea5f36f45e2f2ebec58eb519a31132"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a18ea5f36f45e2f2ebec58eb519a31132">affineDataCopyGenerate</a> (<a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;copyNests)</td></tr>
<tr class="memdesc:a18ea5f36f45e2f2ebec58eb519a31132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs explicit copying for the contiguous sequence of operations in the block iterator range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;), where &lsquo;end&rsquo; can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>.  <a href="namespacemlir_1_1affine.html#a18ea5f36f45e2f2ebec58eb519a31132">More...</a><br /></td></tr>
<tr class="separator:a18ea5f36f45e2f2ebec58eb519a31132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3104b8f1e9d611cb3df35198716f6c2e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3104b8f1e9d611cb3df35198716f6c2e">affineDataCopyGenerate</a> (AffineForOp forOp, const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; filterMemRef, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;copyNests)</td></tr>
<tr class="memdesc:a3104b8f1e9d611cb3df35198716f6c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp.  <a href="namespacemlir_1_1affine.html#a3104b8f1e9d611cb3df35198716f6c2e">More...</a><br /></td></tr>
<tr class="separator:a3104b8f1e9d611cb3df35198716f6c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603f6044e2b28d95b05b3bd9f3c9a92f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a603f6044e2b28d95b05b3bd9f3c9a92f">generateCopyForMemRegion</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;memrefRegion, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *analyzedOp, const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="structmlir_1_1affine_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;result)</td></tr>
<tr class="memdesc:a603f6044e2b28d95b05b3bd9f3c9a92f"><td class="mdescLeft">&#160;</td><td class="mdescRight">generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region.  <a href="namespacemlir_1_1affine.html#a603f6044e2b28d95b05b3bd9f3c9a92f">More...</a><br /></td></tr>
<tr class="separator:a603f6044e2b28d95b05b3bd9f3c9a92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfdb1e5e6c995ae96a9ad8cfb5017b2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0cfdb1e5e6c995ae96a9ad8cfb5017b2">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:a0cfdb1e5e6c995ae96a9ad8cfb5017b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="namespacemlir_1_1affine.html#a0cfdb1e5e6c995ae96a9ad8cfb5017b2">More...</a><br /></td></tr>
<tr class="separator:a0cfdb1e5e6c995ae96a9ad8cfb5017b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd8ee5b7c4e685f87b2bd699d97d1a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#acbd8ee5b7c4e685f87b2bd699d97d1a4">mapLoopToProcessorIds</a> (scf::ForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; processorId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; numProcessors)</td></tr>
<tr class="memdesc:acbd8ee5b7c4e685f87b2bd699d97d1a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>.  <a href="namespacemlir_1_1affine.html#acbd8ee5b7c4e685f87b2bd699d97d1a4">More...</a><br /></td></tr>
<tr class="separator:acbd8ee5b7c4e685f87b2bd699d97d1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239797bc019435d740770259b914481b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a239797bc019435d740770259b914481b">gatherLoops</a> (func::FuncOp func, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;depthToLoops)</td></tr>
<tr class="memdesc:a239797bc019435d740770259b914481b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers all AffineForOps in 'func.func' grouped by loop depth.  <a href="namespacemlir_1_1affine.html#a239797bc019435d740770259b914481b">More...</a><br /></td></tr>
<tr class="separator:a239797bc019435d740770259b914481b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc01b3f110fd9d70bda08f55ce385e1"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3dc01b3f110fd9d70bda08f55ce385e1">createCanonicalizedAffineForOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubOperands, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap, int64_t step=1)</td></tr>
<tr class="memdesc:a3dc01b3f110fd9d70bda08f55ce385e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped.  <a href="namespacemlir_1_1affine.html#a3dc01b3f110fd9d70bda08f55ce385e1">More...</a><br /></td></tr>
<tr class="separator:a3dc01b3f110fd9d70bda08f55ce385e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af852add8069b0ed0dcd8280a79042468"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af852add8069b0ed0dcd8280a79042468">separateFullTiles</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; nest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *fullTileNest=nullptr)</td></tr>
<tr class="memdesc:af852add8069b0ed0dcd8280a79042468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp.  <a href="namespacemlir_1_1affine.html#af852add8069b0ed0dcd8280a79042468">More...</a><br /></td></tr>
<tr class="separator:af852add8069b0ed0dcd8280a79042468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0047736d4b77a87e105fc02a3986e05"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af0047736d4b77a87e105fc02a3986e05">coalescePerfectlyNestedAffineLoops</a> (AffineForOp op)</td></tr>
<tr class="memdesc:af0047736d4b77a87e105fc02a3986e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk an affine.for to find a band to coalesce.  <a href="namespacemlir_1_1affine.html#af0047736d4b77a87e105fc02a3986e05">More...</a><br /></td></tr>
<tr class="separator:af0047736d4b77a87e105fc02a3986e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f955e6ef5e73376cf17d57ce91fbd3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac5f955e6ef5e73376cf17d57ce91fbd3">numEnclosingInvariantLoops</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand)</td></tr>
<tr class="memdesc:ac5f955e6ef5e73376cf17d57ce91fbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of loops surrounding <code>operand</code> such that operand could be hoisted above.  <a href="namespacemlir_1_1affine.html#ac5f955e6ef5e73376cf17d57ce91fbd3">More...</a><br /></td></tr>
<tr class="separator:ac5f955e6ef5e73376cf17d57ce91fbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d37c95eae4f6e48b8711d87e482138"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac2d37c95eae4f6e48b8711d87e482138">createSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memdesc:ac2d37c95eae4f6e48b8711d87e482138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simplification pass for affine structures (maps and sets).  <a href="namespacemlir_1_1affine.html#ac2d37c95eae4f6e48b8711d87e482138">More...</a><br /></td></tr>
<tr class="separator:ac2d37c95eae4f6e48b8711d87e482138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e33a259b4d2b2ba16b25214cfd87b90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1e33a259b4d2b2ba16b25214cfd87b90">createAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a1e33a259b4d2b2ba16b25214cfd87b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops.  <a href="namespacemlir_1_1affine.html#a1e33a259b4d2b2ba16b25214cfd87b90">More...</a><br /></td></tr>
<tr class="separator:a1e33a259b4d2b2ba16b25214cfd87b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6f01a5c7212482882c213ecf76c6b3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abb6f01a5c7212482882c213ecf76c6b3">createAffineParallelizePass</a> ()</td></tr>
<tr class="memdesc:abb6f01a5c7212482882c213ecf76c6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops.  <a href="namespacemlir_1_1affine.html#abb6f01a5c7212482882c213ecf76c6b3">More...</a><br /></td></tr>
<tr class="separator:abb6f01a5c7212482882c213ecf76c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960e99ffd0051a74f6ab1007e7b1ced3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a960e99ffd0051a74f6ab1007e7b1ced3">createRaiseMemrefToAffine</a> ()</td></tr>
<tr class="memdesc:a960e99ffd0051a74f6ab1007e7b1ced3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts some memref operators to affine operators.  <a href="namespacemlir_1_1affine.html#a960e99ffd0051a74f6ab1007e7b1ced3">More...</a><br /></td></tr>
<tr class="separator:a960e99ffd0051a74f6ab1007e7b1ced3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e7f7eb4ce92936880206456af175d60"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3e7f7eb4ce92936880206456af175d60">createAffineLoopNormalizePass</a> (bool promoteSingleIter=false)</td></tr>
<tr class="memdesc:a3e7f7eb4ce92936880206456af175d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply normalization transformations to affine loop-like ops.  <a href="namespacemlir_1_1affine.html#a3e7f7eb4ce92936880206456af175d60">More...</a><br /></td></tr>
<tr class="separator:a3e7f7eb4ce92936880206456af175d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab146994c9d7fb84f7647b1c7f69623"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a7ab146994c9d7fb84f7647b1c7f69623">createAffineDataCopyGenerationPass</a> (unsigned slowMemorySpace, unsigned fastMemorySpace, unsigned tagMemorySpace=0, int minDmaTransferSize=1024, uint64_t fastMemCapacityBytes=std::numeric_limits&lt; uint64_t &gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>())</td></tr>
<tr class="memdesc:a7ab146994c9d7fb84f7647b1c7f69623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations.  <a href="namespacemlir_1_1affine.html#a7ab146994c9d7fb84f7647b1c7f69623">More...</a><br /></td></tr>
<tr class="separator:a7ab146994c9d7fb84f7647b1c7f69623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea380e86b89f4c708beac838b978af47"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aea380e86b89f4c708beac838b978af47">createAffineDataCopyGenerationPass</a> ()</td></tr>
<tr class="memdesc:aea380e86b89f4c708beac838b978af47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="namespacemlir_1_1affine.html#aea380e86b89f4c708beac838b978af47">More...</a><br /></td></tr>
<tr class="separator:aea380e86b89f4c708beac838b978af47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1af7c53ffcf2175bed3528a5efd0d1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0f1af7c53ffcf2175bed3528a5efd0d1">createAffineScalarReplacementPass</a> ()</td></tr>
<tr class="memdesc:a0f1af7c53ffcf2175bed3528a5efd0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs.  <a href="namespacemlir_1_1affine.html#a0f1af7c53ffcf2175bed3528a5efd0d1">More...</a><br /></td></tr>
<tr class="separator:a0f1af7c53ffcf2175bed3528a5efd0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f454dd30258cafd177eee0de1562e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a31f454dd30258cafd177eee0de1562e1">createLoopCoalescingPass</a> ()</td></tr>
<tr class="memdesc:a31f454dd30258cafd177eee0de1562e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms perfectly nested loops with independent bounds into a single loop.  <a href="namespacemlir_1_1affine.html#a31f454dd30258cafd177eee0de1562e1">More...</a><br /></td></tr>
<tr class="separator:a31f454dd30258cafd177eee0de1562e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bff65ed7d124cc37d8ef411947a9a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a94bff65ed7d124cc37d8ef411947a9a3">createLoopFusionPass</a> (unsigned fastMemorySpace=0, uint64_t localBufSizeThreshold=0, bool maximalFusion=false, enum <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a> fusionMode=FusionMode::Greedy)</td></tr>
<tr class="memdesc:a94bff65ed7d124cc37d8ef411947a9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses affine loop nests at the top-level of the operation the pass is created on according to the type of fusion specified in <code>fusionMode</code>.  <a href="namespacemlir_1_1affine.html#a94bff65ed7d124cc37d8ef411947a9a3">More...</a><br /></td></tr>
<tr class="separator:a94bff65ed7d124cc37d8ef411947a9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faf839f27abf73616bc2ba7ed28b8d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a9faf839f27abf73616bc2ba7ed28b8d9">createLoopTilingPass</a> (uint64_t cacheSizeBytes)</td></tr>
<tr class="memdesc:a9faf839f27abf73616bc2ba7ed28b8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform tiling on loop nests.  <a href="namespacemlir_1_1affine.html#a9faf839f27abf73616bc2ba7ed28b8d9">More...</a><br /></td></tr>
<tr class="separator:a9faf839f27abf73616bc2ba7ed28b8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9180dd506c0f8b1a612dffadce18a93"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad9180dd506c0f8b1a612dffadce18a93">createLoopTilingPass</a> ()</td></tr>
<tr class="memdesc:ad9180dd506c0f8b1a612dffadce18a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <a href="namespacemlir_1_1affine.html#ad9180dd506c0f8b1a612dffadce18a93">More...</a><br /></td></tr>
<tr class="separator:ad9180dd506c0f8b1a612dffadce18a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51e0f9baa43a9e07476f356779e95d0"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad51e0f9baa43a9e07476f356779e95d0">createLoopUnrollPass</a> (int unrollFactor=-1, bool unrollUpToFactor=false, bool unrollFull=false, const std::function&lt; unsigned(AffineForOp)&gt; &amp;getUnrollFactor=nullptr)</td></tr>
<tr class="memdesc:ad51e0f9baa43a9e07476f356779e95d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unrolling pass with the provided parameters.  <a href="namespacemlir_1_1affine.html#ad51e0f9baa43a9e07476f356779e95d0">More...</a><br /></td></tr>
<tr class="separator:ad51e0f9baa43a9e07476f356779e95d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e439a1d5a4a00345ebea914e51e36"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ace0e439a1d5a4a00345ebea914e51e36">createLoopUnrollAndJamPass</a> (int unrollJamFactor=-1)</td></tr>
<tr class="memdesc:ace0e439a1d5a4a00345ebea914e51e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unroll jam pass to unroll jam by the specified factor.  <a href="namespacemlir_1_1affine.html#ace0e439a1d5a4a00345ebea914e51e36">More...</a><br /></td></tr>
<tr class="separator:ace0e439a1d5a4a00345ebea914e51e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0e21ed1bde4dca79b101c3d0dd7e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac9e0e21ed1bde4dca79b101c3d0dd7e8">createPipelineDataTransferPass</a> ()</td></tr>
<tr class="memdesc:ac9e0e21ed1bde4dca79b101c3d0dd7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy.  <a href="namespacemlir_1_1affine.html#ac9e0e21ed1bde4dca79b101c3d0dd7e8">More...</a><br /></td></tr>
<tr class="separator:ac9e0e21ed1bde4dca79b101c3d0dd7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ffce291badfd37964dea394098ad7c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ab6ffce291badfd37964dea394098ad7c">createAffineExpandIndexOpsPass</a> ()</td></tr>
<tr class="memdesc:ab6ffce291badfd37964dea394098ad7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect).  <a href="namespacemlir_1_1affine.html#ab6ffce291badfd37964dea394098ad7c">More...</a><br /></td></tr>
<tr class="separator:ab6ffce291badfd37964dea394098ad7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3bc5ab2aa37a753081b1abb6ea6534e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad3bc5ab2aa37a753081b1abb6ea6534e">createAffineExpandIndexOpsAsAffinePass</a> ()</td></tr>
<tr class="memdesc:ad3bc5ab2aa37a753081b1abb6ea6534e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to expand affine index operations into affine.apply operations.  <a href="namespacemlir_1_1affine.html#ad3bc5ab2aa37a753081b1abb6ea6534e">More...</a><br /></td></tr>
<tr class="separator:ad3bc5ab2aa37a753081b1abb6ea6534e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131df27a14db6c8a12e643fa2a0a5603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a131df27a14db6c8a12e643fa2a0a5603">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="separator:a131df27a14db6c8a12e643fa2a0a5603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114cd1965e100b6f419e30ca42720f5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a5114cd1965e100b6f419e30ca42720f5">lowerAffineDelinearizeIndexOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineDelinearizeIndexOp op)</td></tr>
<tr class="memdesc:a5114cd1965e100b6f419e30ca42720f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers <code>affine.delinearize_index</code> into a sequence of division and remainder operations.  <a href="namespacemlir_1_1affine.html#a5114cd1965e100b6f419e30ca42720f5">More...</a><br /></td></tr>
<tr class="separator:a5114cd1965e100b6f419e30ca42720f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90391c4033121397ca4cb25888f8acfc"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a90391c4033121397ca4cb25888f8acfc">lowerAffineLinearizeIndexOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineLinearizeIndexOp op)</td></tr>
<tr class="memdesc:a90391c4033121397ca4cb25888f8acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers <code>affine.linearize_index</code> into a sequence of multiplications and additions.  <a href="namespacemlir_1_1affine.html#a90391c4033121397ca4cb25888f8acfc">More...</a><br /></td></tr>
<tr class="separator:a90391c4033121397ca4cb25888f8acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0254031e77bf59bb9352e139ce07540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad0254031e77bf59bb9352e139ce07540">populateAffineExpandIndexOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad0254031e77bf59bb9352e139ce07540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect).  <a href="namespacemlir_1_1affine.html#ad0254031e77bf59bb9352e139ce07540">More...</a><br /></td></tr>
<tr class="separator:ad0254031e77bf59bb9352e139ce07540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb8bb2407dc150a9486edb551538afde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#afb8bb2407dc150a9486edb551538afde">populateAffineExpandIndexOpsAsAffinePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:afb8bb2407dc150a9486edb551538afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that expand affine index operations into their equivalent <code>affine.apply</code> representations.  <a href="namespacemlir_1_1affine.html#afb8bb2407dc150a9486edb551538afde">More...</a><br /></td></tr>
<tr class="separator:afb8bb2407dc150a9486edb551538afde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af183bca84d167ae145cb1eb3cb7ccaee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af183bca84d167ae145cb1eb3cb7ccaee">reorderOperandsByHoistability</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineApplyOp op)</td></tr>
<tr class="memdesc:af183bca84d167ae145cb1eb3cb7ccaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to rewrite <code>op</code>'s affine map and reorder its operands such that they are in increasing order of hoistability (i.e.  <a href="namespacemlir_1_1affine.html#af183bca84d167ae145cb1eb3cb7ccaee">More...</a><br /></td></tr>
<tr class="separator:af183bca84d167ae145cb1eb3cb7ccaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a469c3be86c49c78459dd5cda4bd128"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; AffineApplyOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a7a469c3be86c49c78459dd5cda4bd128">decompose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineApplyOp op)</td></tr>
<tr class="memdesc:a7a469c3be86c49c78459dd5cda4bd128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split an "affine.apply" operation into smaller ops.  <a href="namespacemlir_1_1affine.html#a7a469c3be86c49c78459dd5cda4bd128">More...</a><br /></td></tr>
<tr class="separator:a7a469c3be86c49c78459dd5cda4bd128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c342c069f431842d231d674e90e2541"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3c342c069f431842d231d674e90e2541">reifyValueBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">ValueBoundsConstraintSet::Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition, bool closedUB=false)</td></tr>
<tr class="memdesc:a3c342c069f431842d231d674e90e2541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the given variable in terms of SSA values for which <code>stopCondition</code> is met.  <a href="namespacemlir_1_1affine.html#a3c342c069f431842d231d674e90e2541">More...</a><br /></td></tr>
<tr class="separator:a3c342c069f431842d231d674e90e2541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a2845645fcfad9550c1ac55f33e632"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a51a2845645fcfad9550c1ac55f33e632">reifyIndexValueBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition=nullptr, bool closedUB=false)</td></tr>
<tr class="memdesc:a51a2845645fcfad9550c1ac55f33e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the given index-typed value in terms of SSA values for which <code>stopCondition</code> is met.  <a href="namespacemlir_1_1affine.html#a51a2845645fcfad9550c1ac55f33e632">More...</a><br /></td></tr>
<tr class="separator:a51a2845645fcfad9550c1ac55f33e632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccde276863cb70af4a37c9be4c95f02"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aeccde276863cb70af4a37c9be4c95f02">reifyShapedValueDimBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> value, int64_t dim, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition=nullptr, bool closedUB=false)</td></tr>
<tr class="memdesc:aeccde276863cb70af4a37c9be4c95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the specified dimension of the given shaped value in terms of SSA values for which <code>stopCondition</code> is met.  <a href="namespacemlir_1_1affine.html#aeccde276863cb70af4a37c9be4c95f02">More...</a><br /></td></tr>
<tr class="separator:aeccde276863cb70af4a37c9be4c95f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ab5a8b82f033f307a2a136d93efcab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad9ab5a8b82f033f307a2a136d93efcab">materializeComputedBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; int64_t &gt;&gt;&gt; mapOperands)</td></tr>
<tr class="memdesc:ad9ab5a8b82f033f307a2a136d93efcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize an already computed bound with Affine dialect ops.  <a href="namespacemlir_1_1affine.html#ad9ab5a8b82f033f307a2a136d93efcab">More...</a><br /></td></tr>
<tr class="separator:ad9ab5a8b82f033f307a2a136d93efcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d33a598ceba944409eed9c050cb32a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac3d33a598ceba944409eed9c050cb32a">simplifyAffineMinOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineMinOp op)</td></tr>
<tr class="memdesc:ac3d33a598ceba944409eed9c050cb32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform tries to simplify the affine min operation <code>op</code>, by finding a common lower bound for a set of expressions in the affine map results.  <a href="namespacemlir_1_1affine.html#ac3d33a598ceba944409eed9c050cb32a">More...</a><br /></td></tr>
<tr class="separator:ac3d33a598ceba944409eed9c050cb32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef87e3d47ba2f545f09a0e7c8a05ab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a0ef87e3d47ba2f545f09a0e7c8a05ab6">simplifyAffineMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineMaxOp op)</td></tr>
<tr class="memdesc:a0ef87e3d47ba2f545f09a0e7c8a05ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform tries to simplify the affine max operation <code>op</code>, by finding a common upper bound for a set of expressions in the affine map results.  <a href="namespacemlir_1_1affine.html#a0ef87e3d47ba2f545f09a0e7c8a05ab6">More...</a><br /></td></tr>
<tr class="separator:a0ef87e3d47ba2f545f09a0e7c8a05ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ba5400dd55afc238cc0a85164da986"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac8ba5400dd55afc238cc0a85164da986">simplifyAffineMinMaxOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, bool *modified=nullptr)</td></tr>
<tr class="memdesc:ac8ba5400dd55afc238cc0a85164da986"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform applies <code>simplifyAffineMinOp</code> and <code>simplifyAffineMaxOp</code> to all the <code>affine.min</code> or <code>affine.max</code> operations in <code>ops</code>.  <a href="namespacemlir_1_1affine.html#ac8ba5400dd55afc238cc0a85164da986">More...</a><br /></td></tr>
<tr class="separator:ac8ba5400dd55afc238cc0a85164da986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a65c46d8d3632fed8f99f96ea54bbbc0f">affineParallelize</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; parallelReductions={}, AffineParallelOp *resOp=nullptr)</td></tr>
<tr class="memdesc:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a parallel affine.for op with a 1-d affine.parallel op.  <a href="namespacemlir_1_1affine.html#a65c46d8d3632fed8f99f96ea54bbbc0f">More...</a><br /></td></tr>
<tr class="separator:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee28320f76812321a98b8386c6cce7f8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aee28320f76812321a98b8386c6cce7f8">hoistAffineIfOp</a> (AffineIfOp ifOp, bool *folded=nullptr)</td></tr>
<tr class="memdesc:aee28320f76812321a98b8386c6cce7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's.  <a href="namespacemlir_1_1affine.html#aee28320f76812321a98b8386c6cce7f8">More...</a><br /></td></tr>
<tr class="separator:aee28320f76812321a98b8386c6cce7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135be62a111deaa1433882b8c0e43bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a135be62a111deaa1433882b8c0e43bfd">affineScalarReplace</a> (func::FuncOp f, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDomInfo, <a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a> &amp;analysis)</td></tr>
<tr class="memdesc:a135be62a111deaa1433882b8c0e43bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace affine store and load accesses by scalars by forwarding stores to loads and eliminate invariant affine loads; consequently, eliminate dead allocs.  <a href="namespacemlir_1_1affine.html#a135be62a111deaa1433882b8c0e43bfd">More...</a><br /></td></tr>
<tr class="separator:a135be62a111deaa1433882b8c0e43bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781e38393998e11fee008649817f6ecb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a781e38393998e11fee008649817f6ecb">vectorizeAffineLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *parentOp, <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&gt; &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fastestVaryingPattern, const <a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">ReductionLoopMap</a> &amp;reductionLoops=<a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">ReductionLoopMap</a>())</td></tr>
<tr class="memdesc:a781e38393998e11fee008649817f6ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'.  <a href="namespacemlir_1_1affine.html#a781e38393998e11fee008649817f6ecb">More...</a><br /></td></tr>
<tr class="separator:a781e38393998e11fee008649817f6ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb3d8b25c9ceb8db711a560be0992ff"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#afcb3d8b25c9ceb8db711a560be0992ff">vectorizeAffineLoopNest</a> (std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;loops, const <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;strategy)</td></tr>
<tr class="memdesc:afcb3d8b25c9ceb8db711a560be0992ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest.">VectorizationStrategy</a> definition).  <a href="namespacemlir_1_1affine.html#afcb3d8b25c9ceb8db711a560be0992ff">More...</a><br /></td></tr>
<tr class="separator:afcb3d8b25c9ceb8db711a560be0992ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d95961bad8f337b39d93e8ed8e41280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3d95961bad8f337b39d93e8ed8e41280">normalizeAffineParallel</a> (AffineParallelOp op)</td></tr>
<tr class="memdesc:a3d95961bad8f337b39d93e8ed8e41280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize a affine.parallel op so that lower bounds are 0 and steps are 1.  <a href="namespacemlir_1_1affine.html#a3d95961bad8f337b39d93e8ed8e41280">More...</a><br /></td></tr>
<tr class="separator:a3d95961bad8f337b39d93e8ed8e41280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a79ce32d4cf1dfe2e20a2ca373ef9181f">normalizeAffineFor</a> (AffineForOp op, bool promoteSingleIter=false)</td></tr>
<tr class="memdesc:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalize an affine.for op.  <a href="namespacemlir_1_1affine.html#a79ce32d4cf1dfe2e20a2ca373ef9181f">More...</a><br /></td></tr>
<tr class="separator:a79ce32d4cf1dfe2e20a2ca373ef9181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23447702ca3f9e052eeb1cb2a7311e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#af23447702ca3f9e052eeb1cb2a7311e0">substWithMin</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> dim, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#af7cb11d1121f694b53c0981dc5e8ba9a">min</a>, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> <a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>, bool positivePath=true)</td></tr>
<tr class="memdesc:af23447702ca3f9e052eeb1cb2a7311e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse <code>e</code> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> where all occurrences of <code>dim</code> have been replaced by either:  <a href="namespacemlir_1_1affine.html#af23447702ca3f9e052eeb1cb2a7311e0">More...</a><br /></td></tr>
<tr class="separator:af23447702ca3f9e052eeb1cb2a7311e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6656d7441cf1e9bb27a617d358b939"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aef6656d7441cf1e9bb27a617d358b939">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt; userFilterFn=nullptr, bool allowNonDereferencingOps=false, bool replaceInDeallocOp=false)</td></tr>
<tr class="memdesc:aef6656d7441cf1e9bb27a617d358b939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>.  <a href="namespacemlir_1_1affine.html#aef6656d7441cf1e9bb27a617d358b939">More...</a><br /></td></tr>
<tr class="separator:aef6656d7441cf1e9bb27a617d358b939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8950b81755c5434e4ec0e1c76cd968e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad8950b81755c5434e4ec0e1c76cd968e">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, bool allowNonDereferencingOps=false)</td></tr>
<tr class="memdesc:ad8950b81755c5434e4ec0e1c76cd968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well.  <a href="namespacemlir_1_1affine.html#ad8950b81755c5434e4ec0e1c76cd968e">More...</a><br /></td></tr>
<tr class="separator:ad8950b81755c5434e4ec0e1c76cd968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc13f562d38271c0b1f3de346e6349ad"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp &gt; </td></tr>
<tr class="memitem:abc13f562d38271c0b1f3de346e6349ad"><td class="memTemplItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">normalizeMemRef</a> (AllocLikeOp op)</td></tr>
<tr class="memdesc:abc13f562d38271c0b1f3de346e6349ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the memref defined by alloc or reinterpret_cast op to have an identity layout map and updates all its indexing uses.  <a href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">More...</a><br /></td></tr>
<tr class="separator:abc13f562d38271c0b1f3de346e6349ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b71ec2846f253a33b19eeb84b94cc"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad61b71ec2846f253a33b19eeb84b94cc">normalizeMemRef&lt; memref::AllocaOp &gt;</a> (memref::AllocaOp op)</td></tr>
<tr class="separator:ad61b71ec2846f253a33b19eeb84b94cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e44481392dfe5dec0ff89d8a545e79e"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a3e44481392dfe5dec0ff89d8a545e79e">normalizeMemRef&lt; memref::AllocOp &gt;</a> (memref::AllocOp op)</td></tr>
<tr class="separator:a3e44481392dfe5dec0ff89d8a545e79e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ee1302fe0baab196d176bd1f9c3d44"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a31ee1302fe0baab196d176bd1f9c3d44">normalizeMemRef</a> (memref::ReinterpretCastOp op)</td></tr>
<tr class="separator:a31ee1302fe0baab196d176bd1f9c3d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad958d8023230103fc9fa9632d423ae"><td class="memItemLeft" align="right" valign="top">MemRefType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#abad958d8023230103fc9fa9632d423ae">normalizeMemRefType</a> (MemRefType memrefType)</td></tr>
<tr class="memdesc:abad958d8023230103fc9fa9632d423ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes <code>memrefType</code> so that the affine layout map of the memref is transformed to an identity map with a new shape being computed for the normalized memref type and returns it.  <a href="namespacemlir_1_1affine.html#abad958d8023230103fc9fa9632d423ae">More...</a><br /></td></tr>
<tr class="separator:abad958d8023230103fc9fa9632d423ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2beee19f97f40e2272e413432879ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aea2beee19f97f40e2272e413432879ee">createAffineComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *opInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *sliceOps)</td></tr>
<tr class="memdesc:aea2beee19f97f40e2272e413432879ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation.  <a href="namespacemlir_1_1affine.html#aea2beee19f97f40e2272e413432879ee">More...</a><br /></td></tr>
<tr class="separator:aea2beee19f97f40e2272e413432879ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d426a50bbe0eea58b951870ad90c2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a39d426a50bbe0eea58b951870ad90c2c">expandAffineExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dimValues, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> symbolValues)</td></tr>
<tr class="memdesc:a39d426a50bbe0eea58b951870ad90c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values.  <a href="namespacemlir_1_1affine.html#a39d426a50bbe0eea58b951870ad90c2c">More...</a><br /></td></tr>
<tr class="separator:a39d426a50bbe0eea58b951870ad90c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002c2432c533d69bf56ba15a60176e43"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a002c2432c533d69bf56ba15a60176e43">expandAffineMap</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> affineMap, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:a002c2432c533d69bf56ba15a60176e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp).  <a href="namespacemlir_1_1affine.html#a002c2432c533d69bf56ba15a60176e43">More...</a><br /></td></tr>
<tr class="separator:a002c2432c533d69bf56ba15a60176e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1DivModValue.html">DivModValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae1a9e39e3e6f042f6af0bc8cae9cd7c9">getDivMod</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> lhs, <a class="el" href="classmlir_1_1Value.html">Value</a> rhs)</td></tr>
<tr class="memdesc:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create IR to calculate (div lhs, rhs) and (mod lhs, rhs).  <a href="namespacemlir_1_1affine.html#ae1a9e39e3e6f042f6af0bc8cae9cd7c9">More...</a><br /></td></tr>
<tr class="separator:ae1a9e39e3e6f042f6af0bc8cae9cd7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac812769668034e906e1cceaa828acabe"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ac812769668034e906e1cceaa828acabe">delinearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; basis, bool hasOuterBound=true)</td></tr>
<tr class="memdesc:ac812769668034e906e1cceaa828acabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the IR to delinearize <code>linearIndex</code> given the <code>basis</code> and return the multi-index.  <a href="namespacemlir_1_1affine.html#ac812769668034e906e1cceaa828acabe">More...</a><br /></td></tr>
<tr class="separator:ac812769668034e906e1cceaa828acabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee5c3cc3b2ee66ab738f2b816c4184c"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a1ee5c3cc3b2ee66ab738f2b816c4184c">delinearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis, bool hasOuterBound=true)</td></tr>
<tr class="separator:a1ee5c3cc3b2ee66ab738f2b816c4184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c95c77cd7a7c28c38f17af0343d21f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ad2c95c77cd7a7c28c38f17af0343d21f">linearizeIndex</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; multiIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis, <a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;builder)</td></tr>
<tr class="separator:ad2c95c77cd7a7c28c38f17af0343d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ab039c6166be23a77c5eef5ec886b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a18ab039c6166be23a77c5eef5ec886b7">linearizeIndex</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; multiIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; basis)</td></tr>
<tr class="separator:a18ab039c6166be23a77c5eef5ec886b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d"><td class="memTemplParams" colspan="2">template&lt;typename EffectType , typename T &gt; </td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae989950373589c5cc01381c0febcee4d">hasNoInterveningEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *start, T memOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#ab14db090bfbe8dc17b8754213ae0512b">mayAlias</a>)</td></tr>
<tr class="memdesc:ae989950373589c5cc01381c0febcee4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all operations that could be executed after <code>start</code> (noninclusive) and prior to <code>memOp</code> (e.g.  <a href="namespacemlir_1_1affine.html#ae989950373589c5cc01381c0febcee4d">More...</a><br /></td></tr>
<tr class="separator:ae989950373589c5cc01381c0febcee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9523b9838e2a2f7b23d0f9953558f6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#aab9523b9838e2a2f7b23d0f9953558f6">mergeOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerStrides, const llvm::SmallBitVector &amp;droppedProducerDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerStrides, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedSizes, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedStrides)</td></tr>
<tr class="memdesc:aab9523b9838e2a2f7b23d0f9953558f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <code>combinedOffsets</code>, <code>combinedSizes</code> and <code>combinedStrides</code> to use when combining a producer slice <b>into</b> a consumer slice.  <a href="namespacemlir_1_1affine.html#aab9523b9838e2a2f7b23d0f9953558f6">More...</a><br /></td></tr>
<tr class="separator:aab9523b9838e2a2f7b23d0f9953558f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7752d92fa12e20ac4b6a61942490ec8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#ae7752d92fa12e20ac4b6a61942490ec8">mergeOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, OffsetSizeAndStrideOpInterface producer, OffsetSizeAndStrideOpInterface consumer, const llvm::SmallBitVector &amp;droppedProducerDims, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedSizes, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedStrides)</td></tr>
<tr class="memdesc:ae7752d92fa12e20ac4b6a61942490ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <code>combinedOffsets</code>, <code>combinedSizes</code> and <code>combinedStrides</code> to use when combining a <code>producer</code> slice op <b>into</b> a <code>consumer</code> slice op.  <a href="namespacemlir_1_1affine.html#ae7752d92fa12e20ac4b6a61942490ec8">More...</a><br /></td></tr>
<tr class="separator:ae7752d92fa12e20ac4b6a61942490ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829dd3c66cb0c7fd7fdab2f3a815bac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a829dd3c66cb0c7fd7fdab2f3a815bac2">resolveIndicesIntoOpWithOffsetsAndStrides</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceStrides, const llvm::SmallBitVector &amp;rankReducedDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resolvedIndices)</td></tr>
<tr class="memdesc:a829dd3c66cb0c7fd7fdab2f3a815bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'consumerIndices' of a load/store operation operating on an op with offsets and strides, return the combined indices.  <a href="namespacemlir_1_1affine.html#a829dd3c66cb0c7fd7fdab2f3a815bac2">More...</a><br /></td></tr>
<tr class="separator:a829dd3c66cb0c7fd7fdab2f3a815bac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4081391a1f634fc8180a92f228534b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a8f4081391a1f634fc8180a92f228534b">resolveIndicesIntoOpWithOffsetsAndStrides</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceStrides, const llvm::SmallBitVector &amp;rankReducedDims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> consumerIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resolvedIndices)</td></tr>
<tr class="separator:a8f4081391a1f634fc8180a92f228534b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077878ca8c3dd66d2989e3fbd1ad93a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine.html#a077878ca8c3dd66d2989e3fbd1ad93a6">resolveSizesIntoOpWithSizes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sourceSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; destSizes, const llvm::SmallBitVector &amp;rankReducedSourceDims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resolvedSizes)</td></tr>
<tr class="memdesc:a077878ca8c3dd66d2989e3fbd1ad93a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <code>sourceSizes</code>, <code>destSizes</code> and information about which dimensions are dropped by the source: <code>rankReducedSourceDims</code>, compute the resolved sizes that correspond to dest_op(source_op).  <a href="namespacemlir_1_1affine.html#a077878ca8c3dd66d2989e3fbd1ad93a6">More...</a><br /></td></tr>
<tr class="separator:a077878ca8c3dd66d2989e3fbd1ad93a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a6784a37545fc5cbc1395a1fffc2f2cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6784a37545fc5cbc1395a1fffc2f2cb4">&#9670;&nbsp;</a></span>FilterFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1affine.html#a6784a37545fc5cbc1395a1fffc2f2cb4">mlir::affine::FilterFunctionType</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that: </p>
<ol type="1">
<li>recursively matches a substructure in the tree;</li>
<li>uses a filter function to refine matches with extra semantic constraints (passed via a lambda of type FilterFunctionType);</li>
<li>TODO: optionally applies actions (lambda).</li>
</ol>
<p>Nested patterns are meant to capture imperfectly nested loops while matching properties over the whole loop nest. For instance, in vectorization we are interested in capturing all the imperfectly nested loops of a certain type and such that all the load and stores have certain access patterns along the loops' induction variables). Such NestedMatches are first captured using the <code>match</code> function and are later processed to analyze properties and apply transformations in a non-greedy way.</p>
<p>The NestedMatches captured in the IR can grow large, especially after aggressive unrolling. As experience has shown, it is generally better to use a plain walk over operations to match flat patterns but the current implementation is competitive nonetheless. </p>

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00091">91</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="ac58a9af2e4bb4c811ad5329293609224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac58a9af2e4bb4c811ad5329293609224">&#9670;&nbsp;</a></span>ReductionLoopMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">mlir::affine::ReductionLoopMap</a> = typedef <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a>, 2&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00043">43</a> of file <a class="el" href="Dialect_2Affine_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a989bf28765adddf1a6b818d6c36acc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a989bf28765adddf1a6b818d6c36acc07">&#9670;&nbsp;</a></span>VectorizableLoopFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1affine.html#a989bf28765adddf1a6b818d6c36acc07">mlir::affine::VectorizableLoopFun</a> = typedef std::function&lt;bool(AffineForOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8h_source.html#l00088">88</a> of file <a class="el" href="LoopAnalysis_8h_source.html">LoopAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a955654b005f9ba55cfe8948a18593a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955654b005f9ba55cfe8948a18593a1d">&#9670;&nbsp;</a></span>FusionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1d">mlir::affine::FusionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fusion mode to attempt. </p>
<p>The default mode <code>Greedy</code> does both producer-consumer and sibling fusion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6"></a>Greedy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1dad17c9ca2b9301ef3d0cccfa9b6baf7ad"></a>ProducerConsumer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1da0293acfd01e25304d05b1a7379cf3eb1"></a>Sibling&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l00035">35</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3104b8f1e9d611cb3df35198716f6c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3104b8f1e9d611cb3df35198716f6c2e">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience version of affineDataCopyGenerate for all ops in the body of an AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02493">2493</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02295">affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a18ea5f36f45e2f2ebec58eb519a31132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ea5f36f45e2f2ebec58eb519a31132">&#9670;&nbsp;</a></span>affineDataCopyGenerate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>filterMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs explicit copying for the contiguous sequence of operations in the block iterator range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;), where &lsquo;end&rsquo; can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>. </p>
<p><code>copyOptions</code> provides various parameters, and the output argument <code>copyNests</code> is the set of all copy nests inserted, each represented by its root affine.for. Since we generate alloc's and dealloc's for all fast buffers (before and after the range of operations resp. or at a hoisted position), all of the fast memory capacity is assumed to be available for processing this block range. When 'filterMemRef' is specified, copies are only generated for the provided MemRef. Returns success if the explicit copying succeeded for all memrefs on which affine load/stores were encountered. For memrefs for whose element types a size in bytes can't be computed (<code>index</code> type), their capacity is not accounted for and the <code>fastMemCapacityBytes</code> copy option would be non-functional in such cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02295">2295</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02253">getFullMemRefAsRegion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">getNestingDepth()</a>, <a class="el" href="Block_8cpp_source.html#l00027">mlir::Block::getParent()</a>, <a class="el" href="Value_8cpp_source.html#l00039">mlir::Value::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, <a class="el" href="LoopUtils_8h_source.html#l00163">mlir::affine::AffineCopyOptions::slowMemorySpace</a>, and <a class="el" href="Block_8h_source.html#l00305">mlir::Block::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02493">affineDataCopyGenerate()</a>.</p>

</div>
</div>
<a id="a46706cab45d0b917d5acff3ed72756c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46706cab45d0b917d5acff3ed72756c2">&#9670;&nbsp;</a></span>affineForOpBodySkew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineForOpBodySkew </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollPrologueEpilogue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skew the operations in an affine.for's body with the specified operation-wise shifts. </p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied. If <code>unrollPrologueEpilogue</code> is set, fully unroll the prologue and epilogue loops when possible. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00228">228</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01015">mlir::applyOpPatternsGreedily()</a>, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120">mlir::ExistingAndNewOps</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00173">generateShiftedLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00402">mlir::Builder::getShiftedAffineMap()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00482">isOpwiseShiftValid()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00113">mlir::GreedyRewriteConfig::setStrictness()</a>.</p>

</div>
</div>
<a id="a65c46d8d3632fed8f99f96ea54bbbc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c46d8d3632fed8f99f96ea54bbbc0f">&#9670;&nbsp;</a></span>affineParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineParallelize </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt;&#160;</td>
          <td class="paramname"><em>parallelReductions</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineParallelOp *&#160;</td>
          <td class="paramname"><em>resOp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a parallel affine.for op with a 1-d affine.parallel op. </p>
<p><code>forOp</code>'s body is taken by the affine.parallel op and the former is erased. (mlir::isLoopParallel can be used to detect a parallel affine.for op.) The reductions specified in <code>parallelReductions</code> are also parallelized. Parallelization will fail in the presence of loop iteration arguments that are not listed in <code>parallelReductions</code>. <code>resOp</code> if non-null is set to the newly created affine.parallel op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00352">352</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8h_source.html#l00440">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00443">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00037">mlir::affine::LoopReduction::kind</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00236">mlir::Operation::setOperands()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00043">mlir::affine::LoopReduction::value</a>.</p>

</div>
</div>
<a id="a135be62a111deaa1433882b8c0e43bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135be62a111deaa1433882b8c0e43bfd">&#9670;&nbsp;</a></span>affineScalarReplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::affineScalarReplace </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>domInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>postDomInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AliasAnalysis.html">AliasAnalysis</a> &amp;&#160;</td>
          <td class="paramname"><em>analysis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace affine store and load accesses by scalars by forwarding stores to loads and eliminate invariant affine loads; consequently, eliminate dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01040">1040</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AliasAnalysis_8cpp_source.html#l00080">mlir::AliasAnalysis::alias()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00538">mlir::Operation::erase()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00912">findUnusedStore()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>, <a class="el" href="AliasAnalysis_8h_source.html#l00059">mlir::AliasResult::isNo()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00959">loadCSE()</a>, and <a class="el" href="EliminateBarriers_8cpp_source.html#l00426">mayAlias()</a>.</p>

</div>
</div>
<a id="addef193d35d8d7990addced6bcb731c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addef193d35d8d7990addced6bcb731c1">&#9670;&nbsp;</a></span>boundCheckLoadOrStoreOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOpPointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::boundCheckLoadOrStoreOp </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOpPointer&#160;</td>
          <td class="paramname"><em>loadOrStoreOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise. </p>
<p>Emits a diagnostic error (with location information) if emitError is true. </p>

</div>
</div>
<a id="a0d2fe80f256b34a27f3f9fa0cce088a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2fe80f256b34a27f3f9fa0cce088a5">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator. </p>
<p>The loops iterate from "lbs" to "ubs" with "steps". The body of the innermost loop is populated by calling "bodyBuilderFn" and providing it with an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a>, a <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> and a list of loop induction variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02909">2909</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02887">buildAffineLoopFromConstants()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02846">buildAffineLoopNestImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00379">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a38de885fc72eb338a5ec53d1ab65630c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38de885fc72eb338a5ec53d1ab65630c">&#9670;&nbsp;</a></span>buildAffineLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;&#160;</td>
          <td class="paramname"><em>bodyBuilderFn</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02917">2917</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02896">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02846">buildAffineLoopNestImpl()</a>.</p>

</div>
</div>
<a id="af1b7ee261b2662fe2f0c257c9e04f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b7ee261b2662fe2f0c257c9e04f3b6">&#9670;&nbsp;</a></span>buildSliceTripCountMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::buildSliceTripCountMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'. </p>
<p>Returns true on success, false otherwise (if a non-constant trip count was encountered). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">1729</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01709">getConstDifference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02799">getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00313">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">mlir::affine::ComputationSliceState::lbs</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">mlir::affine::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00573">getFusionComputeCost()</a>.</p>

</div>
</div>
<a id="ae3ab6f9e710bf9eb63bc8b3488c58631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ab6f9e710bf9eb63bc8b3488c58631">&#9670;&nbsp;</a></span>canFuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> mlir::affine::canFuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>srcSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a>&#160;</td>
          <td class="paramname"><em>fusionStrategy</em> = <code><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html#a996eae93c3d38b2b1f428661df7acc46a1c27f9e3417768eefe1bab13d6de5de6">FusionStrategy::Generic</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'. </p>
<p>Returns <a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> 'Success' if fusion of the src/dst loop nests is feasible (i.e. they are in the same block and dependences would not be violated). Otherwise returns a <a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> explaining why fusion is not feasible. NOTE: This function is not feature complete and should only be used in testing. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00247">247</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00034">mlir::affine::FusionResult::FailBlockDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00035">mlir::affine::FusionResult::FailFusionDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00037">mlir::affine::FusionResult::FailIncorrectSlice</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00033">mlir::affine::FusionResult::FailPrecondition</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00170">gatherLoadsAndStores()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00060">mlir::affine::FusionStrategy::Generic</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00301">mlir::affine::SliceComputationResult::GenericFailure</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00132">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">getNumCommonSurroundingLoops()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00088">mlir::affine::FusionStrategy::getSiblingFusionMemRef()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00085">mlir::affine::FusionStrategy::getStrategy()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00300">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00065">mlir::affine::FusionStrategy::ProducerConsumer</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00071">mlir::affine::FusionStrategy::Sibling</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00032">mlir::affine::FusionResult::Success</a>, and <a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">mlir::affine::SliceComputationResult::value</a>.</p>

</div>
</div>
<a id="a691ff98dafcd40a555ea1d127b06c9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ff98dafcd40a555ea1d127b06c9c3">&#9670;&nbsp;</a></span>canonicalizeMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::canonicalizeMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies both <code>map</code> and <code>operands</code> in-place so as to: </p>
<ol type="1">
<li>drop duplicate operands</li>
<li>drop unused dims and symbols from map</li>
<li>promote valid symbols to symbolic operands in case they appeared as dimensional operands</li>
<li>propagate constant operands and drop them </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01617">1617</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01500">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02462">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01194">composeAffineMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01297">composeMultiResultAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02557">createCanonicalizedAffineForOp()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01843">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00043">getCleanupLoopLowerBound()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">materializeComputedBound()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">reorderOperandsByHoistability()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">replaceAllMemRefUsesWith()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01138">replaceDimOrSym()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02194">simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="a8b47f23151bd884a4ce93312f1499a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b47f23151bd884a4ce93312f1499a02">&#9670;&nbsp;</a></span>canonicalizeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::canonicalizeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01622">1622</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00203">mlir::affine::FlatAffineValueConstraints::addAffineIfOpDomain()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02579">createSeparationCondition()</a>.</p>

</div>
</div>
<a id="a627f529204bbf5826df07986dc54aa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f529204bbf5826df07986dc54aa5c">&#9670;&nbsp;</a></span>checkMemrefAccessDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> mlir::affine::checkMemrefAccessDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>dstAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *&#160;</td>
          <td class="paramname"><em>dependenceComponents</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowRAR</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">608</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00381">addOrderingConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00407">computeDirectionVector()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01451">mlir::presburger::IntegerRelation::convertVarKind()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04121">mlir::Operation::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02638">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00167">mlir::affine::DependenceResult::Failure</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00457">mlir::affine::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00275">getAffineAnalysisScope()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00319">getCommonBlockInAffineScope()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02326">mlir::presburger::IntegerRelation::getDomainSet()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00292">getNumCommonLoops()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00211">mlir::presburger::IntegerRelation::getNumDomainVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00120">mlir::presburger::IntegerRelation::getSpace()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00165">mlir::affine::DependenceResult::HasDependence</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02443">mlir::presburger::IntegerRelation::inverse()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00685">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00284">mlir::presburger::PresburgerSpace::isUsingIds()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02552">mlir::presburger::IntegerRelation::mergeAndCompose()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, <a class="el" href="IntegerRelation_8h_source.html#l00138">mlir::presburger::IntegerRelation::resetIds()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00355">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">computeSliceUnion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00696">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00574">hasCyclicDependence()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00136">isLoopMemoryParallel()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00519">isTilingValid()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a0cfdb1e5e6c995ae96a9ad8cfb5017b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfdb1e5e6c995ae96a9ad8cfb5017b2">&#9670;&nbsp;</a></span>coalesceLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops outermost to innermost that are normalized (step one and lower bound of zero) and with bounds and steps independent of any loop induction variable involved in the nest. Coalescing affine.for loops is not always possible, i.e., the result may not be representable using affine.for. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01596">1596</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8h_source.html#l00553">mlir::affine::AffineBound::getMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00565">mlir::affine::AffineBound::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00032">mlir::replaceAllUsesInRegionWith()</a>, and <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02770">coalescePerfectlyNestedAffineLoops()</a>.</p>

</div>
</div>
<a id="af0047736d4b77a87e105fc02a3986e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0047736d4b77a87e105fc02a3986e05">&#9670;&nbsp;</a></span>coalescePerfectlyNestedAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::coalescePerfectlyNestedAffineLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Walk an affine.for to find a band to coalesce. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02770">2770</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8h_source.html#l00026">mlir::areValuesDefinedAbove()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01596">coalesceLoops()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00856">getPerfectlyNestedLoops()</a>.</p>

</div>
</div>
<a id="a43ded6085da1a665f8c367bea35e77fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ded6085da1a665f8c367bea35e77fc">&#9670;&nbsp;</a></span>computeProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>terms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the product of <code>terms</code>, creating an <code>affine.apply</code> if any of them are non-constant values. </p>
<p>If any of <code>terms</code> is <code>nullptr</code>, return <code>nullptr</code>. </p>

</div>
</div>
<a id="a29213ed6d6cdad5cdd69bb66c6df863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29213ed6d6cdad5cdd69bb66c6df863f">&#9670;&nbsp;</a></span>computeSliceUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a> mlir::affine::computeSliceUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>opsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>opsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numCommonLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceUnion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid. </p>
<p>The parameter 'numCommonLoops' is the number of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice' is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a function of IVs and symbols of loop nest surrounding ops in 'opsB' at 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop nest surrounding ops in 'opsB', as a function of IVs and symbols of loop nest surrounding ops in 'opsA' at 'loopDepth'. Returns '<a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate 'failure' otherwise.</p>
<p>Returns '<a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">1541</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01493">addMissingLoopIVBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01240">mlir::FlatLinearValueConstraints::areVarsAlignedWithOther()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00839">mlir::affine::ComputationSliceState::clearBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00306">mlir::affine::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00167">mlir::affine::DependenceResult::Failure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00301">mlir::affine::SliceComputationResult::GenericFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00803">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>, <a class="el" href="IndexingUtils_8cpp_source.html#l00296">getContext()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01509">getInnermostCommonLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">getNestingDepth()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00214">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00300">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00941">mlir::affine::ComputationSliceState::isSliceValid()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00313">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00319">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01350">mlir::FlatLinearValueConstraints::mergeAndAlignVarsWithOther()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00299">mlir::affine::SliceComputationResult::Success</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ubOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">mlir::affine::ComputationSliceState::ubs</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01489">mlir::FlatLinearValueConstraints::unionBoundingBox()</a>, and <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html#a23b4812923c04bbdfbeacf47aeb579d0">mlir::affine::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00247">canFuseLoops()</a>.</p>

</div>
</div>
<a id="aea2beee19f97f40e2272e413432879ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2beee19f97f40e2272e413432879ee">&#9670;&nbsp;</a></span>createAffineComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::createAffineComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>opInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineApplyOp &gt; *&#160;</td>
          <td class="paramname"><em>sliceOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation. </p>
<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation operation.</p>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... v = "compute"(idx, ...)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) v = "compute"(idx_, ...) This allows the application of different transformations on send and compute (for eg. different shifts/delays)</p>
<p>Fills <code>sliceOps</code> with the list of affine.apply operations. In the following cases, <code>sliceOps</code> remains empty:</p><ol type="1">
<li>If none of opInst's operands were the result of an affine.apply (i.e., there was no affine computation slice to create).</li>
<li>If all the affine.apply op's supplying operands to this opInst did not have any uses other than those in this opInst.</li>
</ol>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) "compute"(idx)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) "compute"(idx_)</p>
<p>This allows applying different transformations on send and compute (for eg. different shifts/delays).</p>
<p>Returns nullptr either if none of opInst's operands were the result of an affine.apply and thus there was no affine computation slice to create, or if all the affine.apply op's supplying operands to this opInst did not have any uses besides this opInst; otherwise returns the list of affine.apply operations created in output argument <code>sliceOps</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01413">1413</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01258">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00346">mlir::Operation::getNumOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00189">getReachableAffineApplyOps()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::setOperand()</a>.</p>

</div>
</div>
<a id="aea380e86b89f4c708beac838b978af47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea380e86b89f4c708beac838b978af47">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00097">97</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="a7ab146994c9d7fb84f7647b1c7f69623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab146994c9d7fb84f7647b1c7f69623">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>slowMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tagMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDmaTransferSize</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fastMemCapacityBytes</em> = <code>std::numeric_limits&lt;uint64_t&gt;::<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">max</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations. </p>
<p>Generates copies for memref's living in 'slowMemorySpace' into newly created buffers in 'fastMemorySpace', and replaces memory operations to the former by the latter. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00089">89</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="ad3bc5ab2aa37a753081b1abb6ea6534e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bc5ab2aa37a753081b1abb6ea6534e">&#9670;&nbsp;</a></span>createAffineExpandIndexOpsAsAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createAffineExpandIndexOpsAsAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to expand affine index operations into affine.apply operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html#l00095">95</a> of file <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html">AffineExpandIndexOpsAsAffine.cpp</a>.</p>

</div>
</div>
<a id="ab6ffce291badfd37964dea394098ad7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ffce291badfd37964dea394098ad7c">&#9670;&nbsp;</a></span>createAffineExpandIndexOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createAffineExpandIndexOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect). </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00235">235</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

</div>
</div>
<a id="a1e33a259b4d2b2ba16b25214cfd87b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e33a259b4d2b2ba16b25214cfd87b90">&#9670;&nbsp;</a></span>createAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00205">205</a> of file <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html">AffineLoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="a3e7f7eb4ce92936880206456af175d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7f7eb4ce92936880206456af175d60">&#9670;&nbsp;</a></span>createAffineLoopNormalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineLoopNormalizePass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>promoteSingleIter</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply normalization transformations to affine loop-like ops. </p>
<p>If <code>promoteSingleIter</code> is true, single iteration loops are promoted (i.e., the loop is replaced by its loop body). </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00053">53</a> of file <a class="el" href="AffineLoopNormalize_8cpp_source.html">AffineLoopNormalize.cpp</a>.</p>

</div>
</div>
<a id="abb6f01a5c7212482882c213ecf76c6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6f01a5c7212482882c213ecf76c6b3">&#9670;&nbsp;</a></span>createAffineParallelizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt;func::FuncOp&gt; &gt; mlir::affine::createAffineParallelizePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops. </p>

</div>
</div>
<a id="a0f1af7c53ffcf2175bed3528a5efd0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1af7c53ffcf2175bed3528a5efd0d1">&#9670;&nbsp;</a></span>createAffineScalarReplacementPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineScalarReplacementPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="AffineScalarReplacement_8cpp_source.html#l00043">43</a> of file <a class="el" href="AffineScalarReplacement_8cpp_source.html">AffineScalarReplacement.cpp</a>.</p>

</div>
</div>
<a id="a3dc01b3f110fd9d70bda08f55ce385e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc01b3f110fd9d70bda08f55ce385e1">&#9670;&nbsp;</a></span>createCanonicalizedAffineForOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::createCanonicalizedAffineForOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>lbOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>lbMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>ubOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>ubMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an AffineForOp while ensuring that the lower and upper bounds are canonicalized, i.e., unused and duplicate operands are removed, any constant operands propagated/folded in, and duplicate bound maps dropped. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02557">2557</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01258">fullyComposeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00776">mlir::removeDuplicateExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02660">createFullTiles()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01843">generatePointWiseCopy()</a>.</p>

</div>
</div>
<a id="a31f454dd30258cafd177eee0de1562e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f454dd30258cafd177eee0de1562e1">&#9670;&nbsp;</a></span>createLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms perfectly nested loops with independent bounds into a single loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopCoalescing_8cpp_source.html#l00048">48</a> of file <a class="el" href="LoopCoalescing_8cpp_source.html">LoopCoalescing.cpp</a>.</p>

</div>
</div>
<a id="a94bff65ed7d124cc37d8ef411947a9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bff65ed7d124cc37d8ef411947a9a3">&#9670;&nbsp;</a></span>createLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createLoopFusionPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximalFusion</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="namespacemlir_1_1affine.html#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a>&#160;</td>
          <td class="paramname"><em>fusionMode</em> = <code>FusionMode::Greedy</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses affine loop nests at the top-level of the operation the pass is created on according to the type of fusion specified in <code>fusionMode</code>. </p>
<p>Buffers of size less than or equal to <code>localBufSizeThreshold</code> are promoted to memory space <code>fastMemorySpace</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l01591">1591</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="ad9180dd506c0f8b1a612dffadce18a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9180dd506c0f8b1a612dffadce18a93">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00083">83</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a9faf839f27abf73616bc2ba7ed28b8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faf839f27abf73616bc2ba7ed28b8d9">&#9670;&nbsp;</a></span>createLoopTilingPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cacheSizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform tiling on loop nests. </p>
<p>Creates a pass to perform loop tiling on all suitable loop nests of a Function. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00079">79</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="ace0e439a1d5a4a00345ebea914e51e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0e439a1d5a4a00345ebea914e51e36">&#9670;&nbsp;</a></span>createLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::affine::createLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unroll jam pass to unroll jam by the specified factor. </p>
<p>A factor of -1 lets the pass use the default factor or the one on the command line if provided. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00073">73</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

</div>
</div>
<a id="ad51e0f9baa43a9e07476f356779e95d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51e0f9baa43a9e07476f356779e95d0">&#9670;&nbsp;</a></span>createLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::affine::createLoopUnrollPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollFactor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollUpToFactor</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollFull</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; unsigned(AffineForOp)&gt; &amp;&#160;</td>
          <td class="paramname"><em>getUnrollFactor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unrolling pass with the provided parameters. </p>
<p>'getUnrollFactor' is a function callback for clients to supply a function that computes an unroll factor - the callback takes precedence over unroll factors supplied through other means. If -1 is passed as the unrollFactor and no callback is provided, anything passed from the command-line (if at all) or the default unroll factor is used (LoopUnroll:kDefaultUnrollFactor). </p>

<p class="definition">Definition at line <a class="el" href="LoopUnroll_8cpp_source.html#l00143">143</a> of file <a class="el" href="LoopUnroll_8cpp_source.html">LoopUnroll.cpp</a>.</p>

</div>
</div>
<a id="ac9e0e21ed1bde4dca79b101c3d0dd7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e0e21ed1bde4dca79b101c3d0dd7e8">&#9670;&nbsp;</a></span>createPipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createPipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00054">54</a> of file <a class="el" href="PipelineDataTransfer_8cpp_source.html">PipelineDataTransfer.cpp</a>.</p>

</div>
</div>
<a id="a960e99ffd0051a74f6ab1007e7b1ced3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960e99ffd0051a74f6ab1007e7b1ced3">&#9670;&nbsp;</a></span>createRaiseMemrefToAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createRaiseMemrefToAffine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts some memref operators to affine operators. </p>

<p class="definition">Definition at line <a class="el" href="RaiseMemrefDialect_8cpp_source.html#l00185">185</a> of file <a class="el" href="RaiseMemrefDialect_8cpp_source.html">RaiseMemrefDialect.cpp</a>.</p>

</div>
</div>
<a id="ac2d37c95eae4f6e48b8711d87e482138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d37c95eae4f6e48b8711d87e482138">&#9670;&nbsp;</a></span>createSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simplification pass for affine structures (maps and sets). </p>
<p>In addition, this pass also normalizes memrefs to have the trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00085">85</a> of file <a class="el" href="SimplifyAffineStructures_8cpp_source.html">SimplifyAffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a7a469c3be86c49c78459dd5cda4bd128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a469c3be86c49c78459dd5cda4bd128">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; AffineApplyOp &gt; mlir::affine::decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineApplyOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split an "affine.apply" operation into smaller ops. </p>
<p>This reassociates a large AffineApplyOp into an ordered list of smaller AffineApplyOps. This can be used right before lowering affine ops to arith to exhibit more opportunities for CSE and LICM. Return the sink AffineApplyOp on success or failure if <code>op</code> does not decompose into smaller AffineApplyOps. Note that this can be undone by canonicalization which tries to maximally compose chains of AffineApplyOps. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">95</a> of file <a class="el" href="DecomposeAffineOps_8cpp_source.html">DecomposeAffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">mlir::Add</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">mlir::Mul</a>, <a class="el" href="PatternMatch_8h_source.html#l00716">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="aa7b53bee9c367aacba5fc65c40c8477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b53bee9c367aacba5fc65c40c8477c">&#9670;&nbsp;</a></span>defaultFilterFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::defaultFilterFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00092">92</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a1ee5c3cc3b2ee66ab738f2b816c4184c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee5c3cc3b2ee66ab738f2b816c4184c">&#9670;&nbsp;</a></span>delinearizeIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::affine::delinearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasOuterBound</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01997">1997</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01957">composedAffineMultiply()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01943">getDivMod()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00310">mlir::affine::DivModValue::quotient</a>, and <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00311">mlir::affine::DivModValue::remainder</a>.</p>

</div>
</div>
<a id="ac812769668034e906e1cceaa828acabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac812769668034e906e1cceaa828acabe">&#9670;&nbsp;</a></span>delinearizeIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; mlir::affine::delinearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>linearIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hasOuterBound</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate the IR to delinearize <code>linearIndex</code> given the <code>basis</code> and return the multi-index. </p>
<p><code>hasOuterBound</code> indicates whether <code>basis</code> has an entry given the size of the first multi-index result - if it is true, the function will return <code>basis.size()</code> values, otherwise, it will return <code>basis.size() + 1</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01967">1967</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01957">composedAffineMultiply()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01943">getDivMod()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00310">mlir::affine::DivModValue::quotient</a>, and <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00311">mlir::affine::DivModValue::remainder</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00054">mlir::linalg::unrollIndex()</a>.</p>

</div>
</div>
<a id="a39d426a50bbe0eea58b951870ad90c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d426a50bbe0eea58b951870ad90c2c">&#9670;&nbsp;</a></span>expandAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">mlir::Value</a> mlir::affine::expandAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>dimValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>symbolValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values. </p>
<p>Create a sequence of operations that implement the <code>expr</code> applied to the given dimension and symbol values. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00218">218</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorization_8cpp_source.html#l02657">convertAffineApply()</a>.</p>

</div>
</div>
<a id="a002c2432c533d69bf56ba15a60176e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002c2432c533d69bf56ba15a60176e43">&#9670;&nbsp;</a></span>expandAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &gt; mlir::affine::expandAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>affineMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a sequence of operations that implement the <code>affineMap</code> applied to the given <code>operands</code> (as it it were an AffineApplyOp). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00228">228</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00063">lowerAffineMapMax()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00073">lowerAffineMapMin()</a>.</p>

</div>
</div>
<a id="a1da42aec5ee59df08774d6d55982b59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da42aec5ee59df08774d6d55982b59c">&#9670;&nbsp;</a></span>extractForInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::extractForInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forInsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>. </p>
<p>Extracts the induction variables from a list of AffineForOps and returns them. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02823">2823</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02253">getFullMemRefAsRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00772">tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00814">tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a9a92b58f46c4e921cc3c899423b76a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92b58f46c4e921cc3c899423b76a27">&#9670;&nbsp;</a></span>extractInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::extractInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>affineOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of either AffineForOp or AffineParallelOp and places them in the output argument <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02830">2830</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00239">getIndexSet()</a>.</p>

</div>
</div>
<a id="ae33ee1431de2b7e6802c9270b1ff60d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33ee1431de2b7e6802c9270b1ff60d1">&#9670;&nbsp;</a></span>findInnermostCommonBlockInScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a> * mlir::affine::findInnermostCommonBlockInScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the innermost common <code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></code> of <code>a</code> and <code>b</code> in the affine scope that <code>a</code> and <code>b</code> are part of. </p>
<p>Return nullptr if they belong to different affine scopes. Also, return nullptr if they do not have a common <code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></code> ancestor (for eg., when they are part of the <code>then</code> and <code>else</code> regions of an op that itself starts an affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02299">2299</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00275">getAffineAnalysisScope()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00243">getDominanceFilterForPrivateMemRefRepl()</a>.</p>

</div>
</div>
<a id="a89d2273335462b22fd078a52a6c687e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d2273335462b22fd078a52a6c687e7">&#9670;&nbsp;</a></span>fullyComposeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::fullyComposeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an AffineApplyOp. </p>
<p>When this function returns, <code>map</code> becomes the composed affine map, and each <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>operands</code> is guaranteed to be either a loop IV or a terminal symbol, i.e., a symbol defined at the top level or a block/function argument. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01258">1258</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01194">composeAffineMapAndOperands()</a>, and <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01297">composeMultiResultAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01413">createAffineComputationSlice()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02557">createCanonicalizedAffineForOp()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">fullyComposeAndComputeConstantDelta()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01935">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01843">generatePointWiseCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00507">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00043">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopSpecialization_8cpp_source.html#l00118">peelForLoop()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">replaceAllMemRefUsesWith()</a>.</p>

</div>
</div>
<a id="ab9717faebcbb497b46d259b26da55635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9717faebcbb497b46d259b26da55635">&#9670;&nbsp;</a></span>fullyComposeAndComputeConstantDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; int64_t &gt; mlir::affine::fullyComposeAndComputeConstantDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a constant delta of the given two values. </p>
<p>Return "failure" if we cannot determine a constant delta. <code>value1</code>/<code>value2</code> must be index-typed.</p>
<p>This function is similar to <code>ValueBoundsConstraintSet::computeConstantDistance</code>. To work around limitations in <code><a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a></code>, this function fully composes <code>value1</code> and <code>value2</code> (if they are the result of affine.apply ops) before populating the constraint set. The folding/composing logic can see opportunities for simplifications that the constraint set implementation cannot see. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">169</a> of file <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00630">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841da2dcbad7477fd40561e8b8198f173bd47">mlir::presburger::EQ</a>, <a class="el" href="AffineOps_8cpp_source.html#l01258">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00250">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="a87fd816295937f98c409c06f1407d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fd816295937f98c409c06f1407d96e">&#9670;&nbsp;</a></span>fuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::fuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>srcSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInnermostSiblingInsertionFusion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'. </p>
<p><code>isInnermostSiblingInsertionFusion</code> enables cleanup of &lsquo;srcForOp that is a single-iteration reduction loop being sibling-fused into a 'dstForOp&rsquo;. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">424</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">buildSliceTripCountMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02799">getForInductionVarOwner()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01767">getSliceIterationCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02090">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00313">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00319">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="IRMapping_8h_source.html#l00058">mlir::IRMapping::lookupOrNull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00356">promoteSingleIterReductionLoop()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">mlir::affine::ComputationSliceState::ubs</a>.</p>

</div>
</div>
<a id="a239797bc019435d740770259b914481b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239797bc019435d740770259b914481b">&#9670;&nbsp;</a></span>gatherLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::gatherLoops </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>depthToLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers all AffineForOps in 'func.func' grouped by loop depth. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02545">2545</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02529">gatherLoopsInBlock()</a>.</p>

</div>
</div>
<a id="a3c01e230ac0a33fa2370a21e428e833e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c01e230ac0a33fa2370a21e428e833e">&#9670;&nbsp;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>srcOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>dstOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>producerConsumerMemrefs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00638">638</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00169">gatherProducerConsumerMemrefs()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="a603f6044e2b28d95b05b3bd9f3c9a92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603f6044e2b28d95b05b3bd9f3c9a92f">&#9670;&nbsp;</a></span>generateCopyForMemRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::generateCopyForMemRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>memrefRegion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>analyzedOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1CopyGenerateResult.html">CopyGenerateResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generateCopyForMemRegion is similar to affineDataCopyGenerate, but works with a single memref region. </p>
<p><code>memrefRegion</code> is supposed to contain analysis information within analyzedOp. The generated prologue and epilogue always surround <code>analyzedOp</code>.</p>
<p>Note that <code>analyzedOp</code> is a single op for API convenience, and the [begin, end) version can be added as needed.</p>
<p>Also note that certain options in <code>copyOptions</code> aren't looked at anymore, like slowMemorySpace. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02501">2501</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8h_source.html#l00204">mlir::affine::CopyGenerateResult::alloc</a>, <a class="el" href="LoopUtils_8h_source.html#l00208">mlir::affine::CopyGenerateResult::copyNest</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01935">generateCopy()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00562">mlir::affine::MemRefRegion::memref</a>, and <a class="el" href="LoopUtils_8h_source.html#l00201">mlir::affine::CopyGenerateResult::sizeInBytes</a>.</p>

</div>
</div>
<a id="a8722fd9a0481c2680fd64fcb7fbbb583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8722fd9a0481c2680fd64fcb7fbbb583">&#9670;&nbsp;</a></span>getAffineAnalysisScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::affine::getAffineAnalysisScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest region enclosing <code>op</code> that is held by a non-affine operation; <code>nullptr</code> if there is no such region. </p>
<p>This method is meant to be used by affine analysis methods (e.g. dependence analysis) which are only meaningful when performed among/between operations from the same analysis scope. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00275">275</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02299">findInnermostCommonBlockInScope()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a9085efe05b8bc0b7c3b4f643d70eb1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9085efe05b8bc0b7c3b4f643d70eb1e7">&#9670;&nbsp;</a></span>getAffineForIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getAffineForIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one while not traversing outside of the surrounding affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">756</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02253">getFullMemRefAsRegion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00573">getFusionComputeCost()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01509">getInnermostCommonLoopDepth()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00087">getLastDependentOpInRange()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00243">mlir::affine::MemRefDependenceGraph::init()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01893">insertBackwardComputationSlice()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00063">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="a50b5b72a6baee24bfab9faebd198fe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b5b72a6baee24bfab9faebd198fe9b">&#9670;&nbsp;</a></span>getAffineIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getAffineIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outermost one to the innermost while not traversing outside of the surrounding affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02002">2002</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">getNumCommonSurroundingLoops()</a>.</p>

</div>
</div>
<a id="abf27d6cea1330a4ac809686a75c43d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27d6cea1330a4ac809686a75c43d25">&#9670;&nbsp;</a></span>getAffineParallelInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineParallelOp mlir::affine::getAffineParallelInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is among the induction variables of an AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02810">2810</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02791">isAffineParallelInductionVar()</a>.</p>

</div>
</div>
<a id="ad353c117f0a45543a77ef884704a7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad353c117f0a45543a77ef884704a7ff0">&#9670;&nbsp;</a></span>getAffineScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::affine::getAffineScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest region enclosing <code>op</code> that is held by an operation with trait <code>AffineScope</code>; <code>nullptr</code> if there is no such region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00265">265</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00527">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01870">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02006">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="ab6cceed0c6debb9af0d3bd76c9ed52f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cceed0c6debb9af0d3bd76c9ed52f4">&#9670;&nbsp;</a></span>getComputationSliceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getComputationSliceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSourceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSinkOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'. </p>
<p>If 'isBackwardSlice' is true, a backwards slice is computed in which the slice bounds of loop nest surrounding 'depSourceAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess' at 'loopDepth'. If 'isBackwardSlice' is false, a forward slice is computed in which the slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at 'loopDepth'. The slice loop bounds and associated operands are returned in 'sliceState'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">1781</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">getAffineForIVs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02099">getSequentialLoops()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01767">getSliceIterationCount()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02090">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01011">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00313">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01776">kSliceFusionBarrierAttrName</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00319">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01481">mlir::FlatLinearValueConstraints::projectOut()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">mlir::affine::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a6e97fc7b7a01938ada405a335e7961a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e97fc7b7a01938ada405a335e7961a7">&#9670;&nbsp;</a></span>getComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::affine::getComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total cost of the loop nest rooted at 'forOp' using 'stats'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00562">562</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00526">getComputeCostHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00278">getAdditionalComputeFraction()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00501">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a03531487e4feec545babe224a2f9b671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03531487e4feec545babe224a2f9b671">&#9670;&nbsp;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::affine::getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop if it's a constant, std::nullopt otherwise. </p>
<p>This uses affine expression analysis and is able to determine constant trip count in non-trivial cases.</p>
<p>This method uses affine expression analysis (in turn using getTripCount) and is able to determine constant trip count in non-trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">215</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00165">getTripCountMapAndOperands()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00089">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00228">affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">buildSliceTripCountMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00473">getLoopNestStats()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01061">loopUnrollJamUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00886">loopUnrollUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00356">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a0909c720d16373cdd1209de6475a5055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0909c720d16373cdd1209de6475a5055">&#9670;&nbsp;</a></span>getDependenceComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getDependenceComponents </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>depCompsVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth]. </p>
<p>Gathers dependence components for dependences between all ops in loop nest rooted at 'forOp' at loop depths in range [1, maxLoopDepth]. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00696">696</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00181">hasDependence()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01336">isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01444">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="ae1a9e39e3e6f042f6af0bc8cae9cd7c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a9e39e3e6f042f6af0bc8cae9cd7c9">&#9670;&nbsp;</a></span>getDivMod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1DivModValue.html">DivModValue</a> mlir::affine::getDivMod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create IR to calculate (div lhs, rhs) and (mod lhs, rhs). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01943">1943</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00959">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01274">makeComposedAffineApply()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00310">mlir::affine::DivModValue::quotient</a>, and <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00311">mlir::affine::DivModValue::remainder</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01967">delinearizeIndex()</a>.</p>

</div>
</div>
<a id="a1f8e59ec9faff34b64ebb0411a383c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e59ec9faff34b64ebb0411a383c3a">&#9670;&nbsp;</a></span>getEnclosingAffineOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getEnclosingAffineOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ops' with affine operations enclosing <code>op</code> ordered from outermost to innermost while stopping at the boundary of the affine scope. </p>
<p>affine.for, affine.if, or affine.parallel ops comprise such surrounding affine ops. <code>ops</code> is guaranteed by design to have a successive chain of affine parent ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00770">770</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01749">findHighestBlockForPlacement()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00282">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a483c308ea389d0ce4b47ef74a252b14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483c308ea389d0ce4b47ef74a252b14e">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02799">2799</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01493">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="HoistPadding_8cpp_source.html#l00545">buildPackingLoopNestImpl()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00306">mlir::affine::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00803">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00657">getLargestKnownDivisor()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00747">getLowerBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00292">getNumCommonLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00787">mlir::affine::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00755">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02787">isAffineForInductionVar()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01011">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00695">isNonNegativeBoundedBy()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01098">isUniformDefinition()</a>, and <a class="el" href="HoistPadding_8cpp_source.html#l00879">replaceByPackingResult()</a>.</p>

</div>
</div>
<a id="a27b764a0cf88a53b85f7149423277f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b764a0cf88a53b85f7149423277f12">&#9670;&nbsp;</a></span>getFusionComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::getFusionComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>srcStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>dstStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>computeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. Returns true on success, failure otherwise (e.g. non-constant trip counts).</p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00573">573</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01729">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">getAffineForIVs()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00526">getComputeCostHelper()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01767">getSliceIterationCount()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::insertPoint</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00278">getAdditionalComputeFraction()</a>.</p>

</div>
</div>
<a id="a320102486b693e875ebb36f63c3bfc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320102486b693e875ebb36f63c3bfc51">&#9670;&nbsp;</a></span>getIndexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getIndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a system of constraints with dimensional variables corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order. </p>
<p>Bounds of the loop are used to add appropriate inequalities. Constraints from the index sets of AffineIfOp are also added. Any symbols founds in the bound operands are added as symbols in the system. Returns failure for the yet unimplemented cases. <code>ops</code> accepts both AffineForOp and AffineIfOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00239">239</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00074">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00203">mlir::affine::FlatAffineValueConstraints::addAffineIfOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00125">mlir::affine::FlatAffineValueConstraints::addAffineParallelOpDomain()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02830">extractInductionVars()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00361">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02660">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02579">createSeparationCondition()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00282">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a9cc3df9a0cea6ad3bf48958ad2d54128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc3df9a0cea6ad3bf48958ad2d54128">&#9670;&nbsp;</a></span>getInnermostCommonLoopDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::getInnermostCommonLoopDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>surroundingLoops</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the innermost common loop depth for the set of operations in 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01509">1509</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">getAffineForIVs()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">computeSliceUnion()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="ac5e109cfdab6f0859fbbc3e0bf08ebac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e109cfdab6f0859fbbc3e0bf08ebac">&#9670;&nbsp;</a></span>getIntOrFloatMemRefSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::affine::getIntOrFloatMemRefSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memRefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of a memref with element type int or float in bytes if it's statically shaped, std::nullopt otherwise. </p>
<p>Returns the size of memref data in bytes if it's statically shaped, std::nullopt otherwise.</p>
<p>If the element of the memref has vector type, takes into account size of the vector as well. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01370">1370</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01326">getMemRefIntOrFloatEltSizeInBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01935">generateCopy()</a>.</p>

</div>
</div>
<a id="a4225805ce5c9b30cced3e7ca2adc8d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4225805ce5c9b30cced3e7ca2adc8d55">&#9670;&nbsp;</a></span>getInvariantAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::affine::getInvariantAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type IndexType, returns the set of <code>indices</code> that are independent of <code>iv</code>. </p>
<p>Prerequisites (inherited from <code>isAccessInvariant</code> above):</p><ol type="1">
<li><code>iv</code> and <code>indices</code> of the proper type;</li>
<li>at most one affine.apply is reachable from each index in <code>indices</code>;</li>
</ol>
<p>Emits a note if it encounters a chain of affine.apply and conservatively those cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00307">307</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00281">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01189">isIVMappedToMultipleIndices()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>.</p>

</div>
</div>
<a id="a93c2752858f86e707624c0702a16d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c2752858f86e707624c0702a16d2d2">&#9670;&nbsp;</a></span>getLargestDivisorOfTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affine::getLargestDivisorOfTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest known integral divisor of the trip count. </p>
<p>Affine expression analysis is used (indirectly through getTripCount), and this method is thus able to determine non-trivial divisors. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00242">242</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00165">getTripCountMapAndOperands()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="aa7270aca023f828cb4e8893705de7e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7270aca023f828cb4e8893705de7e0b">&#9670;&nbsp;</a></span>getLoopNestStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::getLoopNestStats </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect loop nest statistics (eg. </p>
<p>loop trip count and operation count) in 'stats' for loop nest rooted at 'forOp'. Returns true on success, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00473">473</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00127">mlir::affine::LoopNestStats::loopMap</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00129">mlir::affine::LoopNestStats::opCountMap</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00131">mlir::affine::LoopNestStats::tripCountMap</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00278">getAdditionalComputeFraction()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00501">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a93666d2fb7a3b0598ecf69542f1a5ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93666d2fb7a3b0598ecf69542f1a5ab7">&#9670;&nbsp;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::affine::getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02081">2081</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02035">getMemoryFootprintBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00501">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="afd9e0f536b1471778961ba51c2227f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e0f536b1471778961ba51c2227f07">&#9670;&nbsp;</a></span>getMemRefIntOrFloatEltSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; int64_t &gt; mlir::affine::getMemRefIntOrFloatEltSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memRefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memref's element type's size in bytes where the elemental type is an int or float or a vector of such types. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01326">1326</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">mlir::detail::divideCeil()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00332">createPrivateMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01370">getIntOrFloatMemRefSizeInBytes()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01345">mlir::affine::MemRefRegion::getRegionSize()</a>.</p>

</div>
</div>
<a id="ac82ec61d5cae9ebb4489d2ab9ad6e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">&#9670;&nbsp;</a></span>getNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::getNestingDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation. </p>
<p>Returns the nesting depth of this statement, i.e., the number of loops surrounding this statement. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">1974</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02295">affineDataCopyGenerate()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01541">computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02035">getMemoryFootprintBytes()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00574">hasCyclicDependence()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00136">isLoopMemoryParallel()</a>.</p>

</div>
</div>
<a id="a3a39bbf8628440572cdd76a10d58dc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a39bbf8628440572cdd76a10d58dc53">&#9670;&nbsp;</a></span>getNumCommonSurroundingLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::getNumCommonSurroundingLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of surrounding loops common to both A and B. </p>
<p>Returns the number of surrounding loops common to 'loopsA' and 'loopsB', where each lists loops from outer-most to inner-most in loop nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">2019</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02002">getAffineIVs()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00247">canFuseLoops()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00574">hasCyclicDependence()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">hasNoInterveningEffect()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a3fdd1212128e826d76abbe85a61742b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdd1212128e826d76abbe85a61742b7">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00856">856</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02770">coalescePerfectlyNestedAffineLoops()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00064">getTopLevelTileableBands()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01444">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a77346d5ef6933117f2eeb04d320b1745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77346d5ef6933117f2eeb04d320b1745">&#9670;&nbsp;</a></span>getReachableAffineApplyOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getReachableAffineApplyOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <code>affineApplyOps</code>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an AffineApplyOp. </p>
<p>Returns the sequence of AffineApplyOp Operations operation in 'affineApplyOps', which are reachable via a search starting from 'operands', and ending at operands which are not defined by AffineApplyOps. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00189">189</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01413">createAffineComputationSlice()</a>.</p>

</div>
</div>
<a id="a9722cddbbf47c30fa4f5f4d0ed39f7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9722cddbbf47c30fa4f5f4d0ed39f7ab">&#9670;&nbsp;</a></span>getRelationFromMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a relation from the given AffineMap/AffineValueMap <code>map</code>, containing all pairs of the form <code>operands -&gt; result</code> that satisfy <code>map</code>. </p>
<p><code>rel</code> is set to the relation built. For example, give the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>:</p>
<p>(d0, d1)[s0] -&gt; (d0 + s0, d0 - s0)</p>
<p>the resulting relation formed is:</p>
<p>(d0, d1) -&gt; (r1, r2) [d0 d1 r1 r2 s0 const] 1 0 -1 0 1 0 = 0 0 1 0 -1 -1 0 = 0</p>
<p>For <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a>, the domain and symbols have <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> set corresponding to the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>map</code>. Returns failure if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> could not be flattened (i.e., semi-affine is not yet handled). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00499">499</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00362">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00223">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, and <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00435">mlir::FlatLinearValueConstraints::setValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00457">mlir::affine::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00539">getRelationFromMap()</a>.</p>

</div>
</div>
<a id="ab216bbb57cc8cdf47c2cd1e4670adbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab216bbb57cc8cdf47c2cd1e4670adbc2">&#9670;&nbsp;</a></span>getRelationFromMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;&#160;</td>
          <td class="paramname"><em>rel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00539">539</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00216">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00213">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00102">mlir::affine::AffineValueMap::getOperand()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00499">getRelationFromMap()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l00065">mlir::presburger::IntegerRelation::setId()</a>.</p>

</div>
</div>
<a id="a5ad383995f97dc30a0d6891e33fd499a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad383995f97dc30a0d6891e33fd499a">&#9670;&nbsp;</a></span>getSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *&#160;</td>
          <td class="paramname"><em>sequentialLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02099">2099</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00098">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="acfb5cde2210f8126b02cd84843a0c43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb5cde2210f8126b02cd84843a0c43b">&#9670;&nbsp;</a></span>getSliceIterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affine::getSliceIterationCount </td>
          <td>(</td>
          <td class="paramtype">const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>sliceTripCountMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for the <code>slicetripCountMap</code> provided. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01767">1767</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00573">getFusionComputeCost()</a>.</p>

</div>
</div>
<a id="a5d5e2d802af8800beea28156d1604091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5e2d802af8800beea28156d1604091">&#9670;&nbsp;</a></span>getSupportedReductions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getSupportedReductions </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>supportedReductions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <code>supportedReductions</code> with descriptors of the supported reductions. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00082">82</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00040">getSupportedReduction()</a>, and <a class="el" href="LinalgOps_8cpp.html#a28955b1aca39affb65f8316b45796bfa">kind</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00098">isLoopParallel()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a544bc2c1d4dc4d79bac4cb89321cbe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544bc2c1d4dc4d79bac4cb89321cbe09">&#9670;&nbsp;</a></span>getTripCountMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::getTripCountMapAndOperands </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>tripCountOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise. </p>
<p>Returns the trip count of the loop as an affine expression if the latter is expressible as an affine expression, and nullptr otherwise.</p>
<p>This method always succeeds as long as the lower bound is not a multi-result map. The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions</p>
<p>The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00165">165</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00077">mlir::affine::AffineValueMap::getNumResults()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00073">mlir::affine::AffineValueMap::getResult()</a>, and <a class="el" href="AffineValueMap_8h_source.html#l00072">mlir::affine::AffineValueMap::setResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00043">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00242">getLargestDivisorOfTripCount()</a>.</p>

</div>
</div>
<a id="ae20aaeff227a5723102c54a6a88bedd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20aaeff227a5723102c54a6a88bedd5">&#9670;&nbsp;</a></span>hasCyclicDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::hasCyclicDependence </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the affine nest rooted at <code>root</code> has a cyclic dependence among its affine memory accesses. </p>
<p>The dependence could be through any dependences carried by loops contained in <code>root</code> (inclusive of <code>root</code>) and those carried by loop bodies (blocks) contained. Dependences carried by loops outer to <code>root</code> aren't relevant. This method doesn't consider/account for aliases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00574">574</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">getNestingDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">getNumCommonSurroundingLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00187">noDependence()</a>.</p>

</div>
</div>
<a id="ab2d96430280537a906b65fe1e2184447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d96430280537a906b65fe1e2184447">&#9670;&nbsp;</a></span>hasDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::hasDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to a dependence result. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00181">181</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8h_source.html#l00165">mlir::affine::DependenceResult::HasDependence</a>, and <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html#a23b4812923c04bbdfbeacf47aeb579d0">mlir::affine::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00696">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00186">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00519">isTilingValid()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="ae989950373589c5cc01381c0febcee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae989950373589c5cc01381c0febcee4d">&#9670;&nbsp;</a></span>hasNoInterveningEffect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectType , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::hasNoInterveningEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>memOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;&#160;</td>
          <td class="paramname"><em>mayAlias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all operations that could be executed after <code>start</code> (noninclusive) and prior to <code>memOp</code> (e.g. </p>
<p>on a control flow/op path between the operations) do not have the potential memory effect <code>EffectType</code> on <code>memOp</code>. <code>memOp</code> is an operation that reads or writes to a memref. For example, if <code>EffectType</code> is <a class="el" href="structmlir_1_1MemoryEffects_1_1Write.html" title="The following effect indicates that the operation writes to some resource.">MemoryEffects::Write</a>, this method will check if there is no write to the memory between <code>start</code> and <code>memOp</code> that would change the read within <code>memOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">687</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02019">getNumCommonSurroundingLoops()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="Block_8h_source.html#l00267">mlir::Block::getSuccessors()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00263">mlir::Operation::isAncestor()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00426">mayAlias()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>.</p>

</div>
</div>
<a id="aee28320f76812321a98b8386c6cce7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee28320f76812321a98b8386c6cce7f8">&#9670;&nbsp;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp&#160;</td>
          <td class="paramname"><em>ifOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>folded</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's. </p>
<p>Returns success if any hoisting happened; folded` is set to true if the op was folded or erased. This hoisting could lead to significant code expansion in some cases. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00414">414</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01015">mlir::applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00897">mlir::applyPatternsGreedily()</a>, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba475f4ba4004dc37c3764009114b6e69b">mlir::ExistingOps</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00262">getOutermostInvariantForOp()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00113">mlir::GreedyRewriteConfig::setStrictness()</a>.</p>

</div>
</div>
<a id="af32168fb86ad493527c61d139acee48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32168fb86ad493527c61d139acee48a">&#9670;&nbsp;</a></span>insertBackwardComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::insertBackwardComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>dstOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'. </p>
<p>Creates a computation slice of the loop nest surrounding 'srcOpInst', updates the slice loop bounds with any non-null bound maps specified in 'sliceState', and inserts this slice into the loop nest surrounding 'dstOpInst' at loop depth 'dstLoopDepth'.</p>
<p>Returns the top-level loop of the computation slice on success, returns nullptr otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01893">1893</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00267">mlir::Operation::emitError()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01451">findInstPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00756">getAffineForIVs()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01468">getInstAtPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00319">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00315">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00317">mlir::affine::ComputationSliceState::ubs</a>.</p>

</div>
</div>
<a id="adbefeb28d61a80e2a403eb660deabbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbefeb28d61a80e2a403eb660deabbe7">&#9670;&nbsp;</a></span>interchangeLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs loop interchange on 'forOpA' and 'forOpB'. </p>
<p>Performs loop interchange on 'forOpA' and 'forOpB', where 'forOpB' is nested within 'forOpA' as the only non-terminator operation in its block.</p>
<p>Requires that 'forOpA' and 'forOpB' are part of a perfectly nested sequence of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01279">1279</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="a78713c7b03663a8b9c23a4394a714e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78713c7b03663a8b9c23a4394a714e1a">&#9670;&nbsp;</a></span>isAffineForInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isAffineForInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of an AffineForOp. </p>
<p>Returns true if the provided value is the induction variable of a AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02787">2787</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02799">getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01493">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00292">getNumCommonLoops()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00281">isAccessIndexInvariant()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02795">isAffineInductionVar()</a>.</p>

</div>
</div>
<a id="a2fb9a1f410c602d0a0aaf955705a15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb9a1f410c602d0a0aaf955705a15ac">&#9670;&nbsp;</a></span>isAffineInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isAffineInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of an AffineForOp or AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02795">2795</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02787">isAffineForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02791">isAffineParallelInductionVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>.</p>

</div>
</div>
<a id="ae078747217d5df8ac5077cadb329f087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae078747217d5df8ac5077cadb329f087">&#9670;&nbsp;</a></span>isAffineParallelInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isAffineParallelInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>val</code> is the induction variable of an AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02791">2791</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02810">getAffineParallelInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00292">getNumCommonLoops()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02795">isAffineInductionVar()</a>.</p>

</div>
</div>
<a id="a971420849a0dcea8b985c4aae2c1a419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971420849a0dcea8b985c4aae2c1a419">&#9670;&nbsp;</a></span>isContiguousAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isContiguousAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadOrStoreOp&#160;</td>
          <td class="paramname"><em>memoryOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>memRefDim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given: </p>
<ol type="1">
<li>an induction variable <code>iv</code> of type AffineForOp;</li>
<li>a <code>memoryOp</code> of type const LoadOp&amp; or const StoreOp&amp;; determines whether <code>memoryOp</code> has a contiguous access along <code>iv</code>. Contiguous is defined as either invariant or varying only along a unique MemRef dim. Upon success, the unique MemRef dim is written in <code>memRefDim</code> (or -1 to convey the memRef access is invariant along <code>iv</code>).</li>
</ol>
<p>Prerequisites:</p><ol type="1">
<li><code>memRefDim</code> ~= nullptr;</li>
<li><code>iv</code> of the proper type;</li>
<li>the MemRef accessed by <code>memoryOp</code> has no layout map or at most an identity layout map.</li>
</ol>
<p>Currently only supports no layout map or identity layout map in the memref. Returns false if the memref has a non-identity layoutMap. This behavior is conservative. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00319">319</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00281">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00446">isVectorizableLoopBody()</a>.</p>

</div>
</div>
<a id="a623d044442600d97d7a7b5ecb597a166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623d044442600d97d7a7b5ecb597a166">&#9670;&nbsp;</a></span>isInvariantAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isInvariantAccess </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOp&#160;</td>
          <td class="paramname"><em>memOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an affine read or write operation depends on <code>forOp</code>'s IV, i.e., if the memory access is invariant on <code>forOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00293">293</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>.</p>

</div>
</div>
<a id="a7c415a3c0be0bdd484b55efb8d4f5e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c415a3c0be0bdd484b55efb8d4f5e18">&#9670;&nbsp;</a></span>isLoopMemoryParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isLoopMemoryParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if &lsquo;forOp&rsquo; doesn't have memory dependences preventing parallelization. </p>
<p>Memrefs that are allocated inside <code>forOp</code> do not impact its dependences and parallelism. This function does not check iter_args (for values other than memref types) and should be used only as a building block for complete parallelism-checking functions. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00136">136</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01974">getNestingDepth()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00122">isLocallyDefined()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00315">mlir::isMemoryEffectFree()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, and <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html#a23b4812923c04bbdfbeacf47aeb579d0">mlir::affine::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00098">isLoopParallel()</a>.</p>

</div>
</div>
<a id="ad0f70963668d2bfc0c3befc39fd1f250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f70963668d2bfc0c3befc39fd1f250">&#9670;&nbsp;</a></span>isLoopParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isLoopParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; *&#160;</td>
          <td class="paramname"><em>parallelReductions</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if &lsquo;forOp&rsquo; is a parallel loop. </p>
<p>If <code>parallelReductions</code> is provided, populates it with descriptors of the parallelizable reductions and treats them as not preventing parallelization. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00098">98</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00082">getSupportedReductions()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00136">isLoopMemoryParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02099">getSequentialLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02090">isLoopParallelAndContainsReduction()</a>.</p>

</div>
</div>
<a id="a34c1ca39d435d06366058d16b5fe4225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c1ca39d435d06366058d16b5fe4225">&#9670;&nbsp;</a></span>isLoopParallelAndContainsReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isLoopParallelAndContainsReduction </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a loop is a parallel loop and contains a reduction loop. </p>
<p>Returns whether a loop is parallel and contains a reduction loop. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02090">2090</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00098">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01781">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="acf9ac00d2450032a64d31d68d1c82408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9ac00d2450032a64d31d68d1c82408">&#9670;&nbsp;</a></span>isOpwiseShiftValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isOpwiseShiftValid </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts. </p>
<p>Checks whether SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.</p>
<p>This method checks if a 'def' and all its uses have the same shift factor. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00482">482</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00228">affineForOpBodySkew()</a>.</p>

</div>
</div>
<a id="a25d0fe5f9658cd1c27d0460a91d0f18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d0fe5f9658cd1c27d0460a91d0f18f">&#9670;&nbsp;</a></span>isPerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVM_ATTRIBUTE_UNUSED mlir::affine::isPerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <code>loops</code> is a perfectly nested loop nest, where loops appear in it from outermost to innermost. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01352">1352</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00382">performPreTilingChecks()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01374">permuteLoops()</a>.</p>

</div>
</div>
<a id="a114e1e8e803cf90761ffc5a667f3c0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114e1e8e803cf90761ffc5a667f3c0c7">&#9670;&nbsp;</a></span>isTilingValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isTilingValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether hyper-rectangular loop tiling of the nest represented by <code>loops</code> is valid. </p>
<p>The validity condition is from Irigoin and Triolet, which states that two tiles cannot depend on each other. We simplify such condition to just checking whether there is any negative dependence direction, since we have the prior knowledge that the tiling results will be hyper-rectangles, which are scheduled in the lexicographically increasing order on the vector of loop indices. This function will return failure when any dependence component is negative along any of <code>loops</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00519">519</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00608">checkMemrefAccessDependence()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04121">mlir::Operation::dump()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00181">hasDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00064">getTopLevelTileableBands()</a>.</p>

</div>
</div>
<a id="a85ac5508d6eb2d2c7c2a2103ca7a1bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ac5508d6eb2d2c7c2a2103ca7a1bfe">&#9670;&nbsp;</a></span>isTopLevelValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code> or is a region argument for such an op. </p>
<p>A utility function to check if a value is defined at the top level of an op with trait <code>AffineScope</code>.</p>
<p>A value of index type defined at the top level is always a valid symbol for all its uses.</p>
<p>If the value is defined in an unlinked region, conservatively assume it is not top-level. A value of index type defined at the top level is always a valid symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00250">250</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00314">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a9b541bc609cc8c880c998cc99cdd1589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b541bc609cc8c880c998cc99cdd1589">&#9670;&nbsp;</a></span>isTopLevelValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of <code>region</code> or is an argument of <code>region</code>. </p>
<p>A value of index type defined at the top level of a <code>AffineScope</code> region is always a valid symbol for all uses in that region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00050">50</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

</div>
</div>
<a id="a245751b99c21bbee57456cef1e52bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245751b99c21bbee57456cef1e52bde4">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00290">290</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02795">isAffineInductionVar()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00490">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01494">legalizeDemotedDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00527">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="ab3030c26358d640e751344ee1fc60335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3030c26358d640e751344ee1fc60335">&#9670;&nbsp;</a></span>isValidDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <code>region</code>, i.e., for all its uses in <code>region</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00314">314</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02795">isAffineInductionVar()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">isTopLevelValue()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>.</p>

</div>
</div>
<a id="a5aded67ac5853a2bdeff09550e8bb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aded67ac5853a2bdeff09550e8bb32c">&#9670;&nbsp;</a></span>isValidLoopInterchangePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isValidLoopInterchangePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange). </p>
<p>Checks if the loop interchange permutation 'loopPermMap' of the perfectly nested sequence of loops in 'loops' would violate dependences. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01336">1336</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01302">checkLoopInterchangeDependences()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00696">getDependenceComponents()</a>.</p>

</div>
</div>
<a id="a9d387ed8b9220b1d4f32d7efe7cf6117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d387ed8b9220b1d4f32d7efe7cf6117">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <code>AffineScope</code>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00412">412</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00250">isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01446">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01162">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00803">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00349">isMemRefSizeValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00490">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00314">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00442">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01494">legalizeDemotedDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00527">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="adeeefdd6013aa0720cc45eed32fd8eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeeefdd6013aa0720cc45eed32fd8eac">&#9670;&nbsp;</a></span>isValidSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <code>region</code>, i.e., for all its uses in <code>region</code>. </p>
<p>A value can be used as a symbol for <code>region</code> iff it meets one of the following conditions: *) It is a constant.</p>
<p>*) It is a result of a <code>Pure</code> operation whose operands are valid symbolic *) identifiers. *) It is a result of the dim op on a memref whose corresponding size is a valid symbol. *) It is defined at the top level of 'region' or is its argument. *) It dominates <code>region</code>'s parent op. If <code>region</code> is null, conservatively assume the symbol definition scope does not exist and only accept the values that would be symbols regardless of the surrounding region structure, i.e. the first three cases above. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00442">442</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Region_8h_source.html#l00200">mlir::Region::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00398">mlir::isPure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">isTopLevelValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a8739b5a311c3583c17ae8802a491f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8739b5a311c3583c17ae8802a491f2be">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>memRefDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are either: </p>
<ol type="1">
<li>invariant along the loop induction variable created by 'loop';</li>
<li>varying along at most one memory dimension. If such a unique dimension is found, it is written into <code>memRefDim</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00446">446</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00319">isContiguousAccess()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00379">isVectorizableLoopBodyWithOpCond()</a>.</p>

</div>
</div>
<a id="a14ee6f64e3efdd85b5f35ca0b7e4acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ee6f64e3efdd85b5f35ca0b7e4acec">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable; i.e. </p>
<p>:</p><ol type="1">
<li>no conditionals are nested under the loop;</li>
<li>all nested load/stores are to scalar MemRefs. TODO: relax the no-conditionals restriction </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00472">472</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00379">isVectorizableLoopBodyWithOpCond()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l00918">isVectorizableLoopPtrFactory()</a>.</p>

</div>
</div>
<a id="ad2c95c77cd7a7c28c38f17af0343d21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c95c77cd7a7c28c38f17af0343d21f">&#9670;&nbsp;</a></span>linearizeIndex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::linearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>multiIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ImplicitLocOpBuilder.html">ImplicitLocOpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l02027">2027</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00654">mlir::ImplicitLocOpBuilder::getLoc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Shard_2Transforms_2Transforms_8cpp_source.html#l00212">mlir::shard::createProcessLinearIndex()</a>, <a class="el" href="SPIRVConversion_8cpp_source.html#l01307">mlir::spirv::getOpenCLElementPtr()</a>, and <a class="el" href="SPIRVConversion_8cpp_source.html#l01276">mlir::spirv::getVulkanElementPtr()</a>.</p>

</div>
</div>
<a id="a18ab039c6166be23a77c5eef5ec886b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ab039c6166be23a77c5eef5ec886b7">&#9670;&nbsp;</a></span>linearizeIndex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::linearizeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>multiIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l02033">2033</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00305">mlir::computeLinearIndex()</a>, <a class="el" href="IndexingUtils_8h_source.html#l00047">mlir::computeStrides()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00643">mlir::getAffineConstantExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a1e40110d365738e8699594b1d4f27e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e40110d365738e8699594b1d4f27e85">&#9670;&nbsp;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(unsigned, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;&#160;</td>
          <td class="paramname"><em>annotateFn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanUpUnroll</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <code>annotateFn</code>. When <code>cleanUpUnroll</code> is true, we can ensure the cleanup loop is unrolled regardless of the unroll factor.</p>
<p>Returns success if the loop is successfully unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00995">995</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00899">generateUnrolledLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00242">getLargestDivisorOfTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00886">loopUnrollUpToFactor()</a>.</p>

</div>
</div>
<a id="a1298df47a03112972950004cc449fed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1298df47a03112972950004cc449fed3">&#9670;&nbsp;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation completely if the trip count is known to be constant. </p>
<p>Unrolls this loop completely.</p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00871">871</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00228">affineForOpBodySkew()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="a8208a6014374243c317effcb573395dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8208a6014374243c317effcb573395dd">&#9670;&nbsp;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor. </p>
<p><code>forOp</code> can be a loop with iteration arguments performing supported reductions and its inner loops can have iteration arguments. Returns success if the loop is successfully unroll-jammed. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01084">1084</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01072">areInnerBoundsInvariant()</a>, <a class="el" href="Builders_8cpp_source.html#l00548">mlir::OpBuilder::clone()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00242">getLargestDivisorOfTripCount()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02778">mlir::arith::getReductionOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00082">getSupportedReductions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>, <a class="el" href="Builders_8h_source.html#l00410">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="LoopLikeInterface_8h_source.html#l00058">mlir::JamBlockGatherer&lt; OpTy &gt;::subBlocks</a>, <a class="el" href="Value_8h_source.html#l00208">mlir::Value::use_empty()</a>, and <a class="el" href="LoopLikeInterface_8h_source.html#l00061">mlir::JamBlockGatherer&lt; OpTy &gt;::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01061">loopUnrollJamUpToFactor()</a>.</p>

</div>
</div>
<a id="a1c569833e90667ba35ace5840ac92307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c569833e90667ba35ace5840ac92307">&#9670;&nbsp;</a></span>loopUnrollJamUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollJamUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01061">1061</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a6d6bdc8e2c261d88d25e21d30ab2899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6bdc8e2c261d88d25e21d30ab2899d">&#9670;&nbsp;</a></span>loopUnrollUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop by the specified unroll factor or its trip count, whichever is lower. </p>
<p>Unrolls this loop by the specified factor or by the trip count (if constant) whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00886">886</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="a5114cd1965e100b6f419e30ca42720f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114cd1965e100b6f419e30ca42720f5">&#9670;&nbsp;</a></span>lowerAffineDelinearizeIndexOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::lowerAffineDelinearizeIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineDelinearizeIndexOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers <code>affine.delinearize_index</code> into a sequence of division and remainder operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00087">87</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00047">mlir::computeStrides()</a>, <a class="el" href="Builders_8h_source.html#l00517">mlir::OpBuilder::createOrFold()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="a90391c4033121397ca4cb25888f8acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90391c4033121397ca4cb25888f8acfc">&#9670;&nbsp;</a></span>lowerAffineLinearizeIndexOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::lowerAffineLinearizeIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineLinearizeIndexOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers <code>affine.linearize_index</code> into a sequence of multiplications and additions. </p>
<p>Make a best effort to sort the input indices so that the most loop-invariant terms are at the left of the additions to enable loop-invariant code motion. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00145">145</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00047">mlir::computeStrides()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02818">numEnclosingInvariantLoops()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00519">mlir::RewriterBase::replaceOpWithNewOp()</a>.</p>

</div>
</div>
<a id="a4c32299c7b12725419a820f4314fa39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c32299c7b12725419a820f4314fa39c">&#9670;&nbsp;</a></span>makeComposedAffineApply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::affine::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01285">1285</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01274">makeComposedAffineApply()</a>.</p>

</div>
</div>
<a id="a0d5cb525632c1a12545d579561c40dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5cb525632c1a12545d579561c40dcc">&#9670;&nbsp;</a></span>makeComposedAffineApply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::affine::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a composed AffineApplyOp by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands. </p>
<p>The operands of the resulting AffineApplyOp do not change the length of AffineApplyOp chains. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01274">1274</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01194">composeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="Tiling_8cpp_source.html#l00262">mlir::linalg::computeMultiTileSizes()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00101">mlir::gpu::WarpDistributionPattern::delinearizeLaneId()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00022">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="ConvertConv2DToImg2Col_8cpp_source.html#l00069">mlir::linalg::getConvolvedIndex()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01943">getDivMod()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00052">getXferIndices()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01285">makeComposedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01327">makeComposedFoldedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00098">mlir::memref::multiBuffer()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00410">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="aefb27d3d2a62c6db2503c7cc8d62a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb27d3d2a62c6db2503c7cc8d62a6bb">&#9670;&nbsp;</a></span>makeComposedAffineMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineMinOp mlir::affine::makeComposedAffineMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an AffineMinOp obtained by composing <code>map</code> and <code>operands</code> with AffineApplyOps supplying those operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01392">1392</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="ad9f23150730054dc540e6470b3bf342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f23150730054dc540e6470b3bf342e">&#9670;&nbsp;</a></span>makeComposedFoldedAffineApply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>makeComposedFoldedAffineApply</code> that applies to an expression. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01361">1361</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a790378c2cd10eccca0bfe9fca0f84300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790378c2cd10eccca0bfe9fca0f84300">&#9670;&nbsp;</a></span>makeComposedFoldedAffineApply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineApplyOp that applies <code>map</code> to <code>operands</code> after composing the map with the maps of any other AffineApplyOp supplying the operands, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. The <code>map</code> must be a single-result affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01327">1327</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8h_source.html#l00440">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00443">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="Builders_8h_source.html#l00318">mlir::OpBuilder::getListener()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01274">makeComposedAffineApply()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, and <a class="el" href="Builders_8h_source.html#l00396">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00374">mlir::affine::AffineBuilder::add()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01002">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00080">buildLinearId()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00980">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00387">mlir::affine::AffineBuilder::ceil()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00195">common3DIdBuilderFn()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01957">composedAffineMultiply()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00097">mlir::linalg::computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00172">mlir::memref::computeSuffixProductIRBlockImpl()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00757">mlir::linalg::computeTileSizes()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00604">createInitialTensorsForTiling()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00741">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03582">denormalizeIndVar()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00681">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00383">mlir::affine::AffineBuilder::floor()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00522">getCollapsedIndices()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00076">getCompressedMaskOp()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00795">getProductOfIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00672">getSplitReductionIvs()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">getUserTileSizesAndNumThreads()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l02033">linearizeIndex()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00219">mlir::linalg::lowerPack()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01361">makeComposedFoldedAffineApply()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mergeOffsetsSizesAndStrides()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00380">mlir::affine::AffineBuilder::mul()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03565">normalizeUpperBounds()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00890">mlir::linalg::offsetIndices()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00766">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00248">mlir::memref::resolveSourceIndicesCollapseShape()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01044">CopyBuilder::rewrite()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00377">mlir::affine::AffineBuilder::sub()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a767162cfa21cd3e191f6c2e8f5bc9f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767162cfa21cd3e191f6c2e8f5bc9f1e">&#9670;&nbsp;</a></span>makeComposedFoldedAffineMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineMinOp that computes a maximum across the results of applying <code>map</code> to <code>operands</code>, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01437">1437</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00345">buildMax()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, and <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00396">mlir::affine::AffineBuilder::max()</a>.</p>

</div>
</div>
<a id="a81cf2e698dddd6dc85868bac07a74ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cf2e698dddd6dc85868bac07a74ca0">&#9670;&nbsp;</a></span>makeComposedFoldedAffineMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineMinOp that computes a minimum across the results of applying <code>map</code> to <code>operands</code>, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01430">1430</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00353">buildMin()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00626">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00277">getTileOffsetAndSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00391">mlir::affine::AffineBuilder::min()</a>, and <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>.</p>

</div>
</div>
<a id="a369e8fce67650dea4a3ae344c29b3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369e8fce67650dea4a3ae344c29b3ee4">&#9670;&nbsp;</a></span>makeComposedFoldedMultiResultAffineApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::makeComposedFoldedMultiResultAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>composeAffineMin</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <code>makeComposedFoldedAffineApply</code> suitable for multi-result maps. </p>
<p>Note that this may create as many affine.apply operations as the map has results given that affine.apply must be single-result. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01372">1372</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00262">mlir::linalg::computeMultiTileSizes()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00105">getGenericOpLoopRange()</a>, <a class="el" href="Tiling_8cpp_source.html#l00044">mlir::linalg::makeTiledLoopRanges()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="acbd8ee5b7c4e685f87b2bd699d97d1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd8ee5b7c4e685f87b2bd699d97d1a4">&#9670;&nbsp;</a></span>mapLoopToProcessorIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::mapLoopToProcessorIds </td>
          <td>(</td>
          <td class="paramtype">scf::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>processorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>numProcessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>. </p>
<p>This is achieved by embedding the SSA values corresponding to <code>processorIds</code> and <code>numProcessors</code> into the bounds and step of the <code>forOp</code>. No check is performed on the legality of the rewrite, it is the caller's responsibility to ensure legality.</p>
<p>Requires that <code>processorIds</code> and <code>numProcessors</code> have the same size and that for each idx, <code>processorIds</code>[idx] takes, at runtime, all values between 0 and <code>numProcessors</code>[idx] - 1. This corresponds to traditional use cases for:</p><ol type="1">
<li>GPU (threadIdx, get_local_id(), ...)</li>
<li>MPI (MPI_Comm_rank)</li>
<li>OpenMP (omp_get_thread_num)</li>
</ol>
<p>Example: Assuming a 2-d grid with processorIds = [blockIdx.x, threadIdx.x] and numProcessors = [gridDim.x, blockDim.x], the loop:</p>
<div class="fragment"><div class="line">scf.for %i = %lb to %ub step %step {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>is rewritten into a version resembling the following pseudo-IR:</p>
<div class="fragment"><div class="line">scf.for %i = %lb + %step * (threadIdx.x + blockIdx.x * blockDim.x)</div>
<div class="line">   to %ub step %gridDim.x * blockDim.x * %step {</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01709">1709</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00336">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00030">insertCopyLoops()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00589">mlir::linalg::tileReductionUsingForall()</a>.</p>

</div>
</div>
<a id="ad9ab5a8b82f033f307a2a136d93efcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ab5a8b82f033f307a2a136d93efcab">&#9670;&nbsp;</a></span>materializeComputedBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::materializeComputedBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>boundMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; int64_t &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>mapOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize an already computed bound with Affine dialect ops. </p>
<ul>
<li><code>ValueBoundsOpInterface::computeBound</code> computes bounds but does not create IR. It is dialect independent.</li>
<li><code>materializeComputedBound</code> materializes computed bounds with Affine dialect ops.</li>
<li><code>reifyIndexValueBound</code>/<code>reifyShapedValueDimBound</code> are a combination of the two functions mentioned above. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">34</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00377">mlir::AffineMap::getSingleConstantResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">mlir::AffineMap::isSingleConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00019">makeIndependent()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="aab9523b9838e2a2f7b23d0f9953558f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9523b9838e2a2f7b23d0f9953558f6">&#9670;&nbsp;</a></span>mergeOffsetsSizesAndStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::mergeOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>producerOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>producerSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>producerStrides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>droppedProducerDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerStrides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <code>combinedOffsets</code>, <code>combinedSizes</code> and <code>combinedStrides</code> to use when combining a producer slice <b>into</b> a consumer slice. </p>
<p>This function performs the following computation:</p><ul>
<li>Combined offsets = producer_offsets * consumer_strides + consumer_offsets</li>
<li>Combined sizes = consumer_sizes</li>
<li>Combined strides = producer_strides * consumer_strides </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">17</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00061">mergeOffsetsSizesAndStrides()</a>.</p>

</div>
</div>
<a id="ae7752d92fa12e20ac4b6a61942490ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7752d92fa12e20ac4b6a61942490ec8">&#9670;&nbsp;</a></span>mergeOffsetsSizesAndStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::mergeOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>producer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface&#160;</td>
          <td class="paramname"><em>consumer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>droppedProducerDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>combinedStrides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <code>combinedOffsets</code>, <code>combinedSizes</code> and <code>combinedStrides</code> to use when combining a <code>producer</code> slice op <b>into</b> a <code>consumer</code> slice op. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mergeOffsetsSizesAndStrides()</a>.</p>

</div>
</div>
<a id="aee44441a5ada09f5106e1a52ea905f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44441a5ada09f5106e1a52ea905f2d">&#9670;&nbsp;</a></span>noDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::noDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to the absence of a dependence. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00187">187</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, and <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html#a23b4812923c04bbdfbeacf47aeb579d0">mlir::affine::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00574">hasCyclicDependence()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>.</p>

</div>
</div>
<a id="a79ce32d4cf1dfe2e20a2ca373ef9181f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ce32d4cf1dfe2e20a2ca373ef9181f">&#9670;&nbsp;</a></span>normalizeAffineFor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::normalizeAffineFor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>promoteSingleIter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize an affine.for op. </p>
<p>An affine.for op is normalized by converting the lower bound to zero and loop step to one. The upper bound is set to the trip count of the loop. Original loops must have a lower bound with only a single result. There is no such restriction on upper bounds. Returns success if the loop has been normalized (or is already in the normal form). If <code>promoteSingleIter</code> is true, the loop is simply promoted if it has a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00559">559</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l04198">mlir::affine::AffineValueMap::canonicalize()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="Builders_8cpp_source.html#l00373">mlir::Builder::getConstantAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00077">mlir::affine::AffineValueMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00117">promoteIfSingleIteration()</a>, and <a class="el" href="Builders_8h_source.html#l00429">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="a3d95961bad8f337b39d93e8ed8e41280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d95961bad8f337b39d93e8ed8e41280">&#9670;&nbsp;</a></span>normalizeAffineParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::normalizeAffineParallel </td>
          <td>(</td>
          <td class="paramtype">AffineParallelOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalize a affine.parallel op so that lower bounds are 0 and steps are 1. </p>
<p>As currently implemented, this transformation cannot fail and will return early if the op is already in a normalized form. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00494">494</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00238">mlir::OpBuilder::atBlockBegin()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00075">mlir::affine::AffineValueMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00076">mlir::affine::AffineValueMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00073">mlir::affine::AffineValueMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::replaceAllUsesExcept()</a>.</p>

</div>
</div>
<a id="abc13f562d38271c0b1f3de346e6349ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc13f562d38271c0b1f3de346e6349ad">&#9670;&nbsp;</a></span>normalizeMemRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocLikeOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::normalizeMemRef </td>
          <td>(</td>
          <td class="paramtype">AllocLikeOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the memref defined by alloc or reinterpret_cast op to have an identity layout map and updates all its indexing uses. </p>
<p>Returns failure if any of its uses escape (while leaving the IR in a valid state). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01718">1718</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01669">createNewDynamicSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01495">getTileSizePos()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01864">normalizeMemRefType()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01306">replaceAllMemRefUsesWith()</a>, and <a class="el" href="Value_8h_source.html#l00149">mlir::Value::replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="a31ee1302fe0baab196d176bd1f9c3d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ee1302fe0baab196d176bd1f9c3d44">&#9670;&nbsp;</a></span>normalizeMemRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::normalizeMemRef </td>
          <td>(</td>
          <td class="paramtype">memref::ReinterpretCastOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01774">1774</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00304">mlir::getType()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00341">mlir::AffineMap::isIdentity()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01864">normalizeMemRefType()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01306">replaceAllMemRefUsesWith()</a>, and <a class="el" href="Value_8h_source.html#l00149">mlir::Value::replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="ad61b71ec2846f253a33b19eeb84b94cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61b71ec2846f253a33b19eeb84b94cc">&#9670;&nbsp;</a></span>normalizeMemRef&lt; memref::AllocaOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template LogicalResult <a class="el" href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">mlir::affine::normalizeMemRef</a>&lt; memref::AllocaOp &gt; </td>
          <td>(</td>
          <td class="paramtype">memref::AllocaOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e44481392dfe5dec0ff89d8a545e79e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e44481392dfe5dec0ff89d8a545e79e">&#9670;&nbsp;</a></span>normalizeMemRef&lt; memref::AllocOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template LogicalResult <a class="el" href="namespacemlir_1_1affine.html#abc13f562d38271c0b1f3de346e6349ad">mlir::affine::normalizeMemRef</a>&lt; memref::AllocOp &gt; </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abad958d8023230103fc9fa9632d423ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad958d8023230103fc9fa9632d423ae">&#9670;&nbsp;</a></span>normalizeMemRefType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MemRefType mlir::affine::normalizeMemRefType </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>memrefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes <code>memrefType</code> so that the affine layout map of the memref is transformed to an identity map with a new shape being computed for the normalized memref type and returns it. </p>
<p>The old memref type is simplify returned if the normalization failed. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01864">1864</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00226">mlir::FlatLinearConstraints::composeMatchingMap()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00565">mlir::presburger::IntegerRelation::getConstantBound64()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00330">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00214">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00220">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01495">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01594">isNormalizedMemRefDynamicDim()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01481">mlir::FlatLinearValueConstraints::projectOut()</a>, <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00203">mlir::MemRefType::Builder::setLayout()</a>, and <a class="el" href="mlir_2IR_2BuiltinTypes_8h_source.html#l00193">mlir::MemRefType::Builder::setShape()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01718">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="ac5f955e6ef5e73376cf17d57ce91fbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f955e6ef5e73376cf17d57ce91fbd3">&#9670;&nbsp;</a></span>numEnclosingInvariantLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::affine::numEnclosingInvariantLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;&#160;</td>
          <td class="paramname"><em>operand</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of loops surrounding <code>operand</code> such that operand could be hoisted above. </p>
<p>Stop counting at the first loop over which the operand cannot be hoisted. This counts any LoopLikeOpInterface, not just affine.for. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02818">2818</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00145">lowerAffineLinearizeIndexOp()</a>.</p>

</div>
</div>
<a id="ad96a1dbba3240e5a725ce9176f832a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a1dbba3240e5a725ce9176f832a6f">&#9670;&nbsp;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::affine::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses dimension and symbol list. </p>
<p>Parses dimension and symbol list and returns true if parsing failed.</p>
<p><code>numDims</code> is set to the number of dimensions in the list parsed. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00505">505</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a2bf38020e304fa596401f15d1eb30e1d">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00050">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95bae4e85fd5ca8927b9be287e34162aab21">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1AsmParser.html#a0a231d61eec795d5dbdef78d1ec4e95ba3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02151">parseBound()</a>.</p>

</div>
</div>
<a id="a7bcd13c7ee29ca2ec5cc65bfc85133fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcd13c7ee29ca2ec5cc65bfc85133fb">&#9670;&nbsp;</a></span>permuteLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::affine::permuteLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>inputNest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>permMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a loop permutation on a perfectly nested loop nest <code>inputNest</code> (where the contained loops appear from outer to inner) as specified by the permutation <code>permMap</code>: loop 'i' in <code>inputNest</code> is mapped to location 'loopPermMap[i]', where positions 0, 1, ... </p>
<p>are from the outermost position to inner. Returns the position in <code>inputNest</code> of the AffineForOp that becomes the new outermost loop of this nest. This method always succeeds, asserts out on invalid input / specifications. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01374">1374</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01352">isPerfectlyNested()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01444">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="afb8bb2407dc150a9486edb551538afde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8bb2407dc150a9486edb551538afde">&#9670;&nbsp;</a></span>populateAffineExpandIndexOpsAsAffinePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::populateAffineExpandIndexOpsAsAffinePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that expand affine index operations into their equivalent <code>affine.apply</code> representations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html#l00089">89</a> of file <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html">AffineExpandIndexOpsAsAffine.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad0254031e77bf59bb9352e139ce07540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0254031e77bf59bb9352e139ce07540">&#9670;&nbsp;</a></span>populateAffineExpandIndexOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::populateAffineExpandIndexOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect). </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00229">229</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a17d92cbba68de00d9a29abd461274661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d92cbba68de00d9a29abd461274661">&#9670;&nbsp;</a></span>promoteIfSingleIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp was known to have a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00117">117</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00215">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00378">mlir::Builder::getDimIdentityMap()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00101">replaceIterArgsAndYieldResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00424">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00173">generateShiftedLoop()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00559">normalizeAffineFor()</a>.</p>

</div>
</div>
<a id="aa6177db3daa7c8f6e03b62ec74334fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6177db3daa7c8f6e03b62ec74334fdd">&#9670;&nbsp;</a></span>promoteSingleIterationLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::promoteSingleIterationLoops </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>. </p>

</div>
</div>
<a id="a131df27a14db6c8a12e643fa2a0a5603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131df27a14db6c8a12e643fa2a0a5603">&#9670;&nbsp;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::scf::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineTransformOps_8cpp_source.html#l00215">215</a> of file <a class="el" href="AffineTransformOps_8cpp_source.html">AffineTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00067">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a861f3eb48860eab1e82710027ceae08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861f3eb48860eab1e82710027ceae08f">&#9670;&nbsp;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;&#160;</td>
          <td class="paramname"><em>registry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00155">155</a> of file <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AllInterfaces_8cpp_source.html#l00017">mlir::linalg::registerAllDialectInterfaceImplementations()</a>, and <a class="el" href="RegisterAllDialects_8cpp_source.html#l00107">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a51a2845645fcfad9550c1ac55f33e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2845645fcfad9550c1ac55f33e632">&#9670;&nbsp;</a></span>reifyIndexValueBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyIndexValueBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the given index-typed value in terms of SSA values for which <code>stopCondition</code> is met. </p>
<p>If no stop condition is specified, reify in terms of the operands of the owner op.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <code>closedUB</code> is set to "true", upper bounds are also closed.</p>
<p>Example: %0 = arith.addi a, b : index %1 = arith.addi %0, c : index</p>
<ul>
<li>If <code>stopCondition</code> evaluates to "true" for %0 and c, "%0 + %c" is an EQ bound for %1.</li>
<li>If <code>stopCondition</code> evaluates to "true" for a, b and c, "%a + %b + %c" is an EQ bound for %1.</li>
<li>Otherwise, if the owners of a, b or c do not implement the ValueBoundsOpInterface, no bound can be computed. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00100">100</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="aeccde276863cb70af4a37c9be4c95f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccde276863cb70af4a37c9be4c95f02">&#9670;&nbsp;</a></span>reifyShapedValueDimBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyShapedValueDimBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the specified dimension of the given shaped value in terms of SSA values for which <code>stopCondition</code> is met. </p>
<p>If no stop condition is specified, reify in terms of the operands of the owner op.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <code>closedUB</code> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00082">82</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="a3c342c069f431842d231d674e90e2541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c342c069f431842d231d674e90e2541">&#9670;&nbsp;</a></span>reifyValueBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyValueBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">ValueBoundsConstraintSet::Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#ae056756719b121863baa8d395f7280ef">ValueBoundsConstraintSet::StopConditionFn</a>&#160;</td>
          <td class="paramname"><em>stopCondition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>closedUB</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the given variable in terms of SSA values for which <code>stopCondition</code> is met. </p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <code>closedUB</code> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">19</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00464">mlir::ValueBoundsConstraintSet::computeBound()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">materializeComputedBound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00100">reifyIndexValueBound()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00082">reifyShapedValueDimBound()</a>.</p>

</div>
</div>
<a id="af183bca84d167ae145cb1eb3cb7ccaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183bca84d167ae145cb1eb3cb7ccaee">&#9670;&nbsp;</a></span>reorderOperandsByHoistability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::reorderOperandsByHoistability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineApplyOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to rewrite <code>op</code>'s affine map and reorder its operands such that they are in increasing order of hoistability (i.e. </p>
<p>the least hoistable) operands come first in the operand list. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">41</a> of file <a class="el" href="DecomposeAffineOps_8cpp_source.html">DecomposeAffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00247">mlir::RewriterBase::finalizeOpModification()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00629">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00612">mlir::RewriterBase::startOpModification()</a>.</p>

</div>
</div>
<a id="aef6656d7441cf1e9bb27a617d358b939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6656d7441cf1e9bb27a617d358b939">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;&#160;</td>
          <td class="paramname"><em>userFilterFn</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replaceInDeallocOp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>. </p>
<p>The new memref could be of a different shape or rank. <code>extraIndices</code> provides any additional access indices to be added to the start.</p>
<p><code>indexRemap</code> remaps indices of the old memref access to a new set of indices that are used to index the memref. Additional input operands to indexRemap can be optionally provided in <code>extraOperands</code>, and they occupy the start of its input list. <code>indexRemap</code>'s dimensional inputs are expected to correspond to memref's indices, and its symbolic inputs if any should be provided in <code>symbolOperands</code>. If <code>userFilterFn</code> is specified, restrict replacement to only those users that pass the specified filter (i.e., the filter returns true).</p>
<p>'allowNonDereferencingOps', if set, allows replacement of non-dereferencing uses of a memref without any requirement for access index rewrites as long as the user operation has the MemRefsNormalizable trait. The default value of this flag is false.</p>
<p>'replaceInDeallocOp', if set, lets DeallocOp, a non-dereferencing user, to also be a candidate for replacement. The default value of this flag is false.</p>
<p>Returns true on success and false if the replacement is not possible, whenever a memref is used as an operand in a non-dereferencing context and 'allowNonDereferencingOps' is false, except for dealloc's on the memref which are left untouched. See comments at function definition for an example. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01306">1306</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="Value_8h_source.html#l00218">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00332">createPrivateMemRef()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00075">doubleBuffer()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01935">generateCopy()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01718">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="ad8950b81755c5434e4ec0e1c76cd968e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8950b81755c5434e4ec0e1c76cd968e">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowNonDereferencingOps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>, except in cases where 'allowNonDereferencingOps' is set to true where we replace the non-dereferencing uses as well. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01109">1109</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="Matchers_8h_source.html#l00344">mlir::detail::enumerate()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01258">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Builders_8cpp_source.html#l00382">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Attributes_8h_source.html#l00179">mlir::NamedAttribute::getValue()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01104">isDereferencingOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00374">mlir::Operation::operand_begin()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00351">mlir::Operation::setOperand()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00766">mlir::simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a829dd3c66cb0c7fd7fdab2f3a815bac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829dd3c66cb0c7fd7fdab2f3a815bac2">&#9670;&nbsp;</a></span>resolveIndicesIntoOpWithOffsetsAndStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSourceOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSourceStrides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>rankReducedDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>consumerIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resolvedIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'consumerIndices' of a load/store operation operating on an op with offsets and strides, return the combined indices. </p>
<p>For example, using <code>memref.load</code> and <code>memref.subview</code> as an illustration:</p>
<div class="fragment"><div class="line">%0 = ... : memref&lt;12x42xf32&gt;</div>
<div class="line">%1 = memref.subview %0[%arg0, %arg1][...][%stride1, %stride2] :</div>
<div class="line">  memref&lt;12x42xf32&gt; to memref&lt;4x4xf32, offset=?, strides=[?, ?]&gt;</div>
<div class="line">%2 = load %1[%i1, %i2] : memref&lt;4x4xf32, offset=?, strides=[?, ?]&gt;</div>
</div><!-- fragment --><p>could be folded into:</p>
<div class="fragment"><div class="line">%2 = load %0[%arg0 + %i1 * %stride1][%arg1 + %i2 * %stride2] :</div>
<div class="line">     memref&lt;12x42xf32&gt;</div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">80</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01203">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01327">makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00033">mlir::amdgpu::FoldMemRefOpsIntoGatherToLDSOp::matchAndRewrite()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a8f4081391a1f634fc8180a92f228534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4081391a1f634fc8180a92f228534b">&#9670;&nbsp;</a></span>resolveIndicesIntoOpWithOffsetsAndStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSourceOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>mixedSourceStrides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>rankReducedDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>consumerIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resolvedIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">82</a> of file <a class="el" href="ViewLikeInterfaceUtils_8h_source.html">ViewLikeInterfaceUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00079">mlir::getAsOpFoldResult()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a077878ca8c3dd66d2989e3fbd1ad93a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077878ca8c3dd66d2989e3fbd1ad93a6">&#9670;&nbsp;</a></span>resolveSizesIntoOpWithSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::resolveSizesIntoOpWithSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>sourceSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td>
          <td class="paramname"><em>destSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;&#160;</td>
          <td class="paramname"><em>rankReducedSourceDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>resolvedSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <code>sourceSizes</code>, <code>destSizes</code> and information about which dimensions are dropped by the source: <code>rankReducedSourceDims</code>, compute the resolved sizes that correspond to dest_op(source_op). </p>
<p>In practice, this amounts to filtering by <code>rankReducedSourceDims</code> and taking from <code>sourceSizes</code> if a dimension is dropped, otherwise taking from <code>destSizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00112">112</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="af852add8069b0ed0dcd8280a79042468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af852add8069b0ed0dcd8280a79042468">&#9670;&nbsp;</a></span>separateFullTiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::separateFullTiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>nest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>fullTileNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separates full tiles from partial tiles for a perfect nest <code>nest</code> by generating a conditional guard that selects between the full tile version and the partial tile version using an AffineIfOp. </p>
<p>The original loop nest is replaced by this guarded two version form.</p>
<p>affine.if (cond) // full_tile else // partial tile </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02716">2716</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l02660">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02579">createSeparationCondition()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

</div>
</div>
<a id="a0ef87e3d47ba2f545f09a0e7c8a05ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef87e3d47ba2f545f09a0e7c8a05ab6">&#9670;&nbsp;</a></span>simplifyAffineMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::simplifyAffineMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMaxOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform tries to simplify the affine max operation <code>op</code>, by finding a common upper bound for a set of expressions in the affine map results. </p>
<p>It returns whether the transform updated <code>op</code>'s affine map.</p>
<p>In concrete terms, given an operation like: <code>affine.max affine_map&lt;(d0)[s0, s1] -&gt; (d0, s1, s0, 128)&gt;(i)[s0, s1]</code> If <code>d0 &gt; 128</code> and <code>s0 &gt; s1 &gt; 128</code>, the transform will update <code>op</code> to: <code>affine.max affine_map&lt;(d0)[s0, s1] -&gt; (d0, s0)&gt;(i)[s0, s1]</code>. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00145">145</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">simplifyAffineMinMaxOps()</a>.</p>

</div>
</div>
<a id="ac8ba5400dd55afc238cc0a85164da986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba5400dd55afc238cc0a85164da986">&#9670;&nbsp;</a></span>simplifyAffineMinMaxOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::simplifyAffineMinMaxOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>modified</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform applies <code>simplifyAffineMinOp</code> and <code>simplifyAffineMaxOp</code> to all the <code>affine.min</code> or <code>affine.max</code> operations in <code>ops</code>. </p>
<p>After simplification, it invokes the <code>affine.min/max</code> canonicalization patterns on <code>ops</code>.</p>
<p>This transform returns failure if the greedy pattern rewriter failed to converge during canonicalization, otherwise it returns success. If provided, <code>modified</code> is set to <code>true</code> if the IR was modified in any way. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">149</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01015">mlir::applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="namespacemlir.html#acbb0dcd5ae75936e3c6f177223c9d5eba8fc95fc7cfbd316cce7d887ab38f6120">mlir::ExistingAndNewOps</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8h_source.html#l00318">mlir::OpBuilder::getListener()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00113">mlir::GreedyRewriteConfig::setStrictness()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00145">simplifyAffineMaxOp()</a>, and <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00141">simplifyAffineMinOp()</a>.</p>

</div>
</div>
<a id="ac3d33a598ceba944409eed9c050cb32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d33a598ceba944409eed9c050cb32a">&#9670;&nbsp;</a></span>simplifyAffineMinOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::affine::simplifyAffineMinOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMinOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform tries to simplify the affine min operation <code>op</code>, by finding a common lower bound for a set of expressions in the affine map results. </p>
<p>It returns whether the transform updated <code>op</code>'s affine map.</p>
<p>In concrete terms, given an operation like: <code>affine.min affine_map&lt;(d0)[s0, s1] -&gt; (d0, s1, s0, 128)&gt;(i)[s0, s1]</code> If <code>d0 &lt; 128</code> and <code>128 &lt; s1 &lt; s0</code>, the transform will update <code>op</code> to: <code>affine.min affine_map&lt;(d0)[s0, s1] -&gt; (d0, 128)&gt;(i)[s0, s1]</code>. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00141">141</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">simplifyAffineMinMaxOps()</a>.</p>

</div>
</div>
<a id="af4c9fec2934b9a14a5883e9fabbe3f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c9fec2934b9a14a5883e9fabbe3f49">&#9670;&nbsp;</a></span>simplifyConstrainedMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &gt; mlir::affine::simplifyConstrainedMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a>&#160;</td>
          <td class="paramname"><em>constraints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the given affine.min or affine.max op to an affine map with a single result and operands, taking into account the specified constraint set. </p>
<p>Return failure if no simplified version could be found. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02194">2194</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02149">addConstToResults()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00369">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02134">alignAndAddBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01617">canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00367">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00359">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00363">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00565">mlir::presburger::IntegerRelation::getConstantBound64()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00115">mlir::getConstantIntValue()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00374">mlir::FlatLinearValueConstraints::getMaybeValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00223">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00217">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00685">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02120">unpackOptionalValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00065">canonicalizeMinMaxOp()</a>.</p>

</div>
</div>
<a id="a1f2e85e904cf88ca63479dad00941e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2e85e904cf88ca63479dad00941e87">&#9670;&nbsp;</a></span>simplifyIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::affine::simplifyIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference. </p>
<p>Also, drop any duplicate constraints. Returns the simplified integer set. This method runs in time linear in the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">2108</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01087">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00057">mlir::IntegerSet::getContext()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00685">mlir::presburger::IntegerRelation::isEmpty()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l01812">mlir::presburger::IntegerRelation::removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="ad1cc3f41464ffc9424244b2e3a3f2bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cc3f41464ffc9424244b2e3a3f2bd5">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01444">1444</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01302">checkLoopInterchangeDependences()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00696">getDependenceComponents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00856">getPerfectlyNestedLoops()</a>, <a class="el" href="namespacemlir_1_1affine_1_1matcher.html#a29ab3023f926bd16e188b2467d343cc4">mlir::affine::matcher::isParallelLoop()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00147">mlir::affine::DependenceComponent::lb</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01374">permuteLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00149">mlir::affine::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00232">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="af23447702ca3f9e052eeb1cb2a7311e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23447702ca3f9e052eeb1cb2a7311e0">&#9670;&nbsp;</a></span>substWithMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::affine::substWithMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positivePath</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse <code>e</code> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> where all occurrences of <code>dim</code> have been replaced by either: </p>
<ul>
<li><code>min</code> if <code>positivePath</code> is true when we reach an occurrence of <code>dim</code></li>
<li><code>max</code> if <code>positivePath</code> is true when we reach an occurrence of <code>dim</code> <code>positivePath</code> is negated each time we hit a multiplicative or divisive binary op with a constant negative coefficient. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00467">467</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">mlir::Add</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>, and <a class="el" href="PolynomialApproximation_8cpp_source.html#l00204">min()</a>.</p>

</div>
</div>
<a id="a0c5e9321f0d01289b23d98a44b936cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5e9321f0d01289b23d98a44b936cd8">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; mlir::affine::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01587">1587</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01575">tile()</a>.</p>

</div>
</div>
<a id="ad1b737fda5e5d83d831e50dcb73d8e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b737fda5e5d83d831e50dcb73d8e26">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt; mlir::affine::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01575">1575</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01520">stripmineSink()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01320">mlir::extractFixedOuterLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01587">tile()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01295">mlir::tile()</a>, and <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l01303">mlir::tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="ad4fdfbbfeaedc902c83393747fa2fe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fdfbbfeaedc902c83393747fa2fe7f">&#9670;&nbsp;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops. </p>
<p>A band is a contiguous set of loops. This utility doesn't check for the validity of tiling itself, but just performs it. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00772">772</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00423">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02823">extractForInductionVars()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00382">performPreTilingChecks()</a>.</p>

</div>
</div>
<a id="a86baa652b01992ec11a10c7de8e2fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86baa652b01992ec11a10c7de8e2fe54">&#9670;&nbsp;</a></span>tilePerfectlyNestedParametric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::tilePerfectlyNestedParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>tiledNest</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00814">814</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00660">constructParametricallyTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00423">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02823">extractForInductionVars()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00382">performPreTilingChecks()</a>.</p>

</div>
</div>
<a id="afcb3d8b25c9ceb8db711a560be0992ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb3d8b25c9ceb8db711a560be0992ff">&#9670;&nbsp;</a></span>vectorizeAffineLoopNest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::vectorizeAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html">VectorizationStrategy</a> &amp;&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>External utility to vectorize affine loops from a single loop nest using an n-D vectorization strategy (see doc in <a class="el" href="structmlir_1_1affine_1_1VectorizationStrategy.html" title="Holds parameters to perform n-D vectorization on a single loop nest.">VectorizationStrategy</a> definition). </p>
<p>Loops are provided in a 2D vector container. The first dimension represents the nesting level relative to the loops to be vectorized. The second dimension contains the loops. This means that: a) every loop in 'loops[i]' must have a parent loop in 'loops[i-1]', b) a loop in 'loops[i]' may or may not have a child loop in 'loops[i+1]'.</p>
<p>For example, for the following loop nest:</p>
<p>func @vec2d(in0: memref&lt;64x128x512xf32&gt;, in1: memref&lt;64x128x128xf32&gt;, out0: memref&lt;64x128x512xf32&gt;, out1: memref&lt;64x128x128xf32&gt;) { affine.for i0 = 0 to 64 { affine.for i1 = 0 to 128 { affine.for i2 = 0 to 512 { ld = affine.load in0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; affine.store ld, out0[i0, i1, i2] : memref&lt;64x128x512xf32&gt; } affine.for i3 = 0 to 128 { ld = affine.load in1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; affine.store ld, out1[i0, i1, i3] : memref&lt;64x128x128xf32&gt; } } } return }</p>
<p>loops = {{i0}, {i2, i3}}, to vectorize the outermost and the two innermost loops; loops = {{i1}, {i2, i3}}, to vectorize the middle and the two innermost loops; loops = {{i2}}, to vectorize only the first innermost loop; loops = {{i3}}, to vectorize only the second innermost loop; loops = {{i1}}, to vectorize only the middle loop. </p>

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l01921">1921</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="SuperVectorize_8cpp_source.html#l01599">vectorizeLoopNest()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01837">verifyLoopNesting()</a>.</p>

</div>
</div>
<a id="a781e38393998e11fee008649817f6ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781e38393998e11fee008649817f6ecb">&#9670;&nbsp;</a></span>vectorizeAffineLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::affine::vectorizeAffineLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>parentOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="namespacemlir.html#a087da824f0d25f4e19913ab4f2688c7b">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fastestVaryingPattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">ReductionLoopMap</a> &amp;&#160;</td>
          <td class="paramname"><em>reductionLoops</em> = <code><a class="el" href="namespacemlir_1_1affine.html#ac58a9af2e4bb4c811ad5329293609224">ReductionLoopMap</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vectorizes affine loops in 'loops' using the n-D vectorization factors in 'vectorSizes'. </p>
<p>By default, each vectorization factor is applied inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can be optionally used to provide a different loop vectorization order. If <code>reductionLoops</code> is not empty, the given reduction loops may be vectorized along the reduction dimension. TODO: Vectorizing reductions is supported only for 1-D vectorization. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:30 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
