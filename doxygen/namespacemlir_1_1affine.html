<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::affine Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1affine.html">affine</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::affine Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:impl" id="r_impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1impl.html">impl</a></td></tr>
<tr class="memitem:matcher" id="r_matcher"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1affine_1_1matcher.html">matcher</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:AffineBound" id="r_AffineBound"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineBound.html">AffineBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineBound.html" title="AffineBound represents a lower or upper bound in the for operation.">AffineBound</a> represents a lower or upper bound in the for operation.  <a href="classmlir_1_1affine_1_1AffineBound.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineBuilder" id="r_AffineBuilder"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineBuilder.html">AffineBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper struct to build simple AffineValueExprs with minimal type inference support.  <a href="structmlir_1_1affine_1_1AffineBuilder.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineCopyOptions" id="r_AffineCopyOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineCopyOptions.html">AffineCopyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy / DMA generation options for mlir::affineDataCopyGenerate.  <a href="structmlir_1_1affine_1_1AffineCopyOptions.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineDataCopyGenerationOptions" id="r_AffineDataCopyGenerationOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineDataCopyGenerationOptions.html">AffineDataCopyGenerationOptions</a></td></tr>
<tr class="memitem:AffineDmaStartOp" id="r_AffineDmaStartOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  <a href="classmlir_1_1affine_1_1AffineDmaStartOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineDmaWaitOp" id="r_AffineDmaWaitOp"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineDmaWaitOp.html">AffineDmaWaitOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> blocks until the completion of a DMA operation associated with the tag element 'tag[index]'.  <a href="classmlir_1_1affine_1_1AffineDmaWaitOp.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineLoopFusionOptions" id="r_AffineLoopFusionOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineLoopFusionOptions.html">AffineLoopFusionOptions</a></td></tr>
<tr class="memitem:AffineLoopNormalizeOptions" id="r_AffineLoopNormalizeOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineLoopNormalizeOptions.html">AffineLoopNormalizeOptions</a></td></tr>
<tr class="memitem:AffineLoopTilingOptions" id="r_AffineLoopTilingOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineLoopTilingOptions.html">AffineLoopTilingOptions</a></td></tr>
<tr class="memitem:AffineLoopUnrollAndJamOptions" id="r_AffineLoopUnrollAndJamOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineLoopUnrollAndJamOptions.html">AffineLoopUnrollAndJamOptions</a></td></tr>
<tr class="memitem:AffineLoopUnrollOptions" id="r_AffineLoopUnrollOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineLoopUnrollOptions.html">AffineLoopUnrollOptions</a></td></tr>
<tr class="memitem:AffineParallelizeOptions" id="r_AffineParallelizeOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineParallelizeOptions.html">AffineParallelizeOptions</a></td></tr>
<tr class="memitem:AffineValueExpr" id="r_AffineValueExpr"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineValueExpr.html">AffineValueExpr</a></td></tr>
<tr class="memitem:AffineValueMap" id="r_AffineValueMap"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a> is an affine map plus its ML value operands and results for analysis purposes.  <a href="classmlir_1_1affine_1_1AffineValueMap.html#details">More...</a><br /></td></tr>
<tr class="memitem:AffineVectorizeOptions" id="r_AffineVectorizeOptions"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1AffineVectorizeOptions.html">AffineVectorizeOptions</a></td></tr>
<tr class="memitem:ComputationSliceState" id="r_ComputationSliceState"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1affine_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="memitem:DependenceComponent" id="r_DependenceComponent"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a></td></tr>
<tr class="memitem:DependenceResult" id="r_DependenceResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two accesses to the same memref access the same element.  <a href="structmlir_1_1affine_1_1DependenceResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlatAffineRelation" id="r_FlatAffineRelation"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FlatAffineRelation.html">FlatAffineRelation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1affine_1_1FlatAffineRelation.html" title="A FlatAffineRelation represents a set of ordered pairs (domain -&gt; range) where &quot;domain&quot; and &quot;range&quot; a...">FlatAffineRelation</a> represents a set of ordered pairs (domain -&gt; range) where "domain" and "range" are tuples of variables.  <a href="classmlir_1_1affine_1_1FlatAffineRelation.html#details">More...</a><br /></td></tr>
<tr class="memitem:FlatAffineValueConstraints" id="r_FlatAffineValueConstraints"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> is an extension of <a class="el" href="classmlir_1_1FlatLinearValueConstraints.html" title="FlatLinearValueConstraints represents an extension of FlatLinearConstraints where each non-local vari...">FlatLinearValueConstraints</a> with helper functions for Affine dialect ops.  <a href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html#details">More...</a><br /></td></tr>
<tr class="memitem:FusionResult" id="r_FusionResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a></td></tr>
<tr class="memitem:FusionStrategy" id="r_FusionStrategy"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes the fusion strategy to be used in the Affine loop fusion utilities.  <a href="classmlir_1_1affine_1_1FusionStrategy.html#details">More...</a><br /></td></tr>
<tr class="memitem:LoopNestStateCollector" id="r_LoopNestStateCollector"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopNestStateCollector.html">LoopNestStateCollector</a></td></tr>
<tr class="memitem:LoopNestStats" id="r_LoopNestStats"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html" title="LoopNestStats aggregates various per-loop statistics (eg.">LoopNestStats</a> aggregates various per-loop statistics (eg.  <a href="structmlir_1_1affine_1_1LoopNestStats.html#details">More...</a><br /></td></tr>
<tr class="memitem:LoopReduction" id="r_LoopReduction"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A description of a (parallelizable) reduction in an affine loop.  <a href="structmlir_1_1affine_1_1LoopReduction.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefAccess" id="r_MemRefAccess"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a memref load or store access information.  <a href="structmlir_1_1affine_1_1MemRefAccess.html#details">More...</a><br /></td></tr>
<tr class="memitem:MemRefDependenceGraph" id="r_MemRefDependenceGraph"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a></td></tr>
<tr class="memitem:MemRefRegion" id="r_MemRefRegion"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1MemRefRegion.html">MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1affine_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="memitem:NestedMatch" id="r_NestedMatch"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedMatch.html">NestedMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> captures nested patterns in the IR.  <a href="classmlir_1_1affine_1_1NestedMatch.html#details">More...</a><br /></td></tr>
<tr class="memitem:NestedPattern" id="r_NestedPattern"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a></td></tr>
<tr class="memitem:NestedPatternContext" id="r_NestedPatternContext"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1affine_1_1NestedPatternContext.html">NestedPatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII structure to transparently manage the bump allocator for <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> and <a class="el" href="classmlir_1_1affine_1_1NestedMatch.html" title="An NestedPattern captures nested patterns in the IR.">NestedMatch</a> classes.  <a href="classmlir_1_1affine_1_1NestedPatternContext.html#details">More...</a><br /></td></tr>
<tr class="memitem:SliceComputationResult" id="r_SliceComputationResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates different result statuses of slice computation by <span class="tt">computeSliceUnion</span>  <a href="structmlir_1_1affine_1_1SliceComputationResult.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a307b24b11d3236cad28c2a63938a2d38" id="r_a307b24b11d3236cad28c2a63938a2d38"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307b24b11d3236cad28c2a63938a2d38">VectorizableLoopFun</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(AffineForOp)&gt;</td></tr>
<tr class="memitem:a7ac41cc03dea5e719278bacddd8f0829" id="r_a7ac41cc03dea5e719278bacddd8f0829"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac41cc03dea5e719278bacddd8f0829">FilterFunctionType</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a7ac41cc03dea5e719278bacddd8f0829"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that:  <br /></td></tr>
<tr class="memitem:a0e3d2cec8b9f06af928ef8b6fe719bc2" id="r_a0e3d2cec8b9f06af928ef8b6fe719bc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap</a> = <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a>, 2&gt;&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a955654b005f9ba55cfe8948a18593a1d" id="r_a955654b005f9ba55cfe8948a18593a1d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a> { <a class="el" href="#a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6">Greedy</a>
, <a class="el" href="#a955654b005f9ba55cfe8948a18593a1dad17c9ca2b9301ef3d0cccfa9b6baf7ad">ProducerConsumer</a>
, <a class="el" href="#a955654b005f9ba55cfe8948a18593a1da0293acfd01e25304d05b1a7379cf3eb1">Sibling</a>
 }</td></tr>
<tr class="memdesc:a955654b005f9ba55cfe8948a18593a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fusion mode to attempt.  <a href="#a955654b005f9ba55cfe8948a18593a1d">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5d5e2d802af8800beea28156d1604091" id="r_a5d5e2d802af8800beea28156d1604091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d5e2d802af8800beea28156d1604091">getSupportedReductions</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;supportedReductions)</td></tr>
<tr class="memdesc:a5d5e2d802af8800beea28156d1604091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate <span class="tt">supportedReductions</span> with descriptors of the supported reductions.  <br /></td></tr>
<tr class="memitem:a7c415a3c0be0bdd484b55efb8d4f5e18" id="r_a7c415a3c0be0bdd484b55efb8d4f5e18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c415a3c0be0bdd484b55efb8d4f5e18">isLoopMemoryParallel</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a7c415a3c0be0bdd484b55efb8d4f5e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if &lsquo;forOp&rsquo; is a parallel loop.  <br /></td></tr>
<tr class="memitem:a77346d5ef6933117f2eeb04d320b1745" id="r_a77346d5ef6933117f2eeb04d320b1745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77346d5ef6933117f2eeb04d320b1745">getReachableAffineApplyOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;affineApplyOps)</td></tr>
<tr class="memdesc:a77346d5ef6933117f2eeb04d320b1745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <span class="tt">affineApplyOps</span>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <span class="tt">operands</span> and ending at those operands that are not the result of an AffineApplyOp.  <br /></td></tr>
<tr class="memitem:a320102486b693e875ebb36f63c3bfc51" id="r_a320102486b693e875ebb36f63c3bfc51"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a320102486b693e875ebb36f63c3bfc51">getIndexSet</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *domain)</td></tr>
<tr class="memdesc:a320102486b693e875ebb36f63c3bfc51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a system of constraints with dimensional variables corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order.  <br /></td></tr>
<tr class="memitem:a627f529204bbf5826df07986dc54aa5c" id="r_a627f529204bbf5826df07986dc54aa5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a627f529204bbf5826df07986dc54aa5c">checkMemrefAccessDependence</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;dstAccess, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *dependenceConstraints=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *dependenceComponents=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> allowRAR=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:ab2d96430280537a906b65fe1e2184447" id="r_ab2d96430280537a906b65fe1e2184447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d96430280537a906b65fe1e2184447">hasDependence</a> (<a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:ab2d96430280537a906b65fe1e2184447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to a dependence result.  <br /></td></tr>
<tr class="memitem:aee44441a5ada09f5106e1a52ea905f2d" id="r_aee44441a5ada09f5106e1a52ea905f2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee44441a5ada09f5106e1a52ea905f2d">noDependence</a> (<a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> <a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:aee44441a5ada09f5106e1a52ea905f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to the absence of a dependence.  <br /></td></tr>
<tr class="memitem:a79027d97c42b5b7d7f7f06529719117a" id="r_a79027d97c42b5b7d7f7f06529719117a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79027d97c42b5b7d7f7f06529719117a">getDependenceComponents</a> (AffineForOp forOp, <a class="el" href="classunsigned.html">unsigned</a> maxLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; &gt; *depCompsVec)</td></tr>
<tr class="memdesc:a79027d97c42b5b7d7f7f06529719117a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth].  <br /></td></tr>
<tr class="memitem:a9722cddbbf47c30fa4f5f4d0ed39f7ab" id="r_a9722cddbbf47c30fa4f5f4d0ed39f7ab"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9722cddbbf47c30fa4f5f4d0ed39f7ab">getRelationFromMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;map, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memdesc:a9722cddbbf47c30fa4f5f4d0ed39f7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a relation from the given AffineMap/AffineValueMap <span class="tt">map</span>, containing all pairs of the form <span class="tt">operands -&gt; result</span> that satisfy <span class="tt">map</span>.  <br /></td></tr>
<tr class="memitem:ab216bbb57cc8cdf47c2cd1e4670adbc2" id="r_ab216bbb57cc8cdf47c2cd1e4670adbc2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab216bbb57cc8cdf47c2cd1e4670adbc2">getRelationFromMap</a> (const <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &amp;map, <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;rel)</td></tr>
<tr class="memitem:a544bc2c1d4dc4d79bac4cb89321cbe09" id="r_a544bc2c1d4dc4d79bac4cb89321cbe09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a544bc2c1d4dc4d79bac4cb89321cbe09">getTripCountMapAndOperands</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a544bc2c1d4dc4d79bac4cb89321cbe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise.  <br /></td></tr>
<tr class="memitem:a03531487e4feec545babe224a2f9b671" id="r_a03531487e4feec545babe224a2f9b671"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03531487e4feec545babe224a2f9b671">getConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a03531487e4feec545babe224a2f9b671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop if it's a constant, std::nullopt otherwise.  <br /></td></tr>
<tr class="memitem:a93c2752858f86e707624c0702a16d2d2" id="r_a93c2752858f86e707624c0702a16d2d2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93c2752858f86e707624c0702a16d2d2">getLargestDivisorOfTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a93c2752858f86e707624c0702a16d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest known integral divisor of the trip count.  <br /></td></tr>
<tr class="memitem:a623d044442600d97d7a7b5ecb597a166" id="r_a623d044442600d97d7a7b5ecb597a166"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOp&gt; </td></tr>
<tr class="memitem:a623d044442600d97d7a7b5ecb597a166 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a623d044442600d97d7a7b5ecb597a166">isInvariantAccess</a> (LoadOrStoreOp memOp, AffineForOp forOp)</td></tr>
<tr class="memdesc:a623d044442600d97d7a7b5ecb597a166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an affine read or write operation depends on <span class="tt">forOp</span>'s IV, i.e., if the memory access is invariant on <span class="tt">forOp</span>.  <br /></td></tr>
<tr class="memitem:a4225805ce5c9b30cced3e7ca2adc8d55" id="r_a4225805ce5c9b30cced3e7ca2adc8d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="namespacemlir.html#a0fe2f804c3b5ffdbebdae95e127ce987">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4225805ce5c9b30cced3e7ca2adc8d55">getInvariantAccesses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; <a class="el" href="AffineAnalysis_8cpp.html#a7b261d2d5f193015afc3427b0c0951ed">indices</a>)</td></tr>
<tr class="memdesc:a4225805ce5c9b30cced3e7ca2adc8d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an induction variable <span class="tt">iv</span> of type AffineForOp and <span class="tt">indices</span> of type IndexType, returns the set of <span class="tt">indices</span> that are independent of <span class="tt">iv</span>.  <br /></td></tr>
<tr class="memitem:a971420849a0dcea8b985c4aae2c1a419" id="r_a971420849a0dcea8b985c4aae2c1a419"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOp&gt; </td></tr>
<tr class="memitem:a971420849a0dcea8b985c4aae2c1a419 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a971420849a0dcea8b985c4aae2c1a419">isContiguousAccess</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, LoadOrStoreOp memoryOp, int *memRefDim)</td></tr>
<tr class="memdesc:a971420849a0dcea8b985c4aae2c1a419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given:  <br /></td></tr>
<tr class="memitem:a14ee6f64e3efdd85b5f35ca0b7e4acec" id="r_a14ee6f64e3efdd85b5f35ca0b7e4acec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14ee6f64e3efdd85b5f35ca0b7e4acec">isVectorizableLoopBody</a> (AffineForOp loop, <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a14ee6f64e3efdd85b5f35ca0b7e4acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable; i.e.:  <br /></td></tr>
<tr class="memitem:a8739b5a311c3583c17ae8802a491f2be" id="r_a8739b5a311c3583c17ae8802a491f2be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8739b5a311c3583c17ae8802a491f2be">isVectorizableLoopBody</a> (AffineForOp loop, int *memRefDim, <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a8739b5a311c3583c17ae8802a491f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are either:  <br /></td></tr>
<tr class="memitem:acf9ac00d2450032a64d31d68d1c82408" id="r_acf9ac00d2450032a64d31d68d1c82408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf9ac00d2450032a64d31d68d1c82408">isOpwiseShiftValid</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts)</td></tr>
<tr class="memdesc:acf9ac00d2450032a64d31d68d1c82408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.  <br /></td></tr>
<tr class="memitem:a114e1e8e803cf90761ffc5a667f3c0c7" id="r_a114e1e8e803cf90761ffc5a667f3c0c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a114e1e8e803cf90761ffc5a667f3c0c7">isTilingValid</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:a114e1e8e803cf90761ffc5a667f3c0c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether hyper-rectangular loop tiling of the nest represented by <span class="tt">loops</span> is valid.  <br /></td></tr>
<tr class="memitem:ae20aaeff227a5723102c54a6a88bedd5" id="r_ae20aaeff227a5723102c54a6a88bedd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae20aaeff227a5723102c54a6a88bedd5">hasCyclicDependence</a> (AffineForOp root)</td></tr>
<tr class="memdesc:ae20aaeff227a5723102c54a6a88bedd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the affine nest rooted at <span class="tt">root</span> has a cyclic dependence among its affine memory accesses.  <br /></td></tr>
<tr class="memitem:aa7b53bee9c367aacba5fc65c40c8477c" id="r_aa7b53bee9c367aacba5fc65c40c8477c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7b53bee9c367aacba5fc65c40c8477c">defaultFilterFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)</td></tr>
<tr class="memitem:a9085efe05b8bc0b7c3b4f643d70eb1e7" id="r_a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9085efe05b8bc0b7c3b4f643d70eb1e7">getAffineForIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a9085efe05b8bc0b7c3b4f643d70eb1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one while not traversing outside of the surrounding affine scope.  <br /></td></tr>
<tr class="memitem:a50b5b72a6baee24bfab9faebd198fe9b" id="r_a50b5b72a6baee24bfab9faebd198fe9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50b5b72a6baee24bfab9faebd198fe9b">getAffineIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs)</td></tr>
<tr class="memdesc:a50b5b72a6baee24bfab9faebd198fe9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outermost one to the innermost while not traversing outside of the surrounding affine scope.  <br /></td></tr>
<tr class="memitem:a1f8e59ec9faff34b64ebb0411a383c3a" id="r_a1f8e59ec9faff34b64ebb0411a383c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f8e59ec9faff34b64ebb0411a383c3a">getEnclosingAffineOps</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *ops)</td></tr>
<tr class="memdesc:a1f8e59ec9faff34b64ebb0411a383c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'ops' with affine operations enclosing <span class="tt">op</span> ordered from outermost to innermost while stopping at the boundary of the affine scope.  <br /></td></tr>
<tr class="memitem:ac82ec61d5cae9ebb4489d2ab9ad6e8f8" id="r_ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ac82ec61d5cae9ebb4489d2ab9ad6e8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <br /></td></tr>
<tr class="memitem:a34c1ca39d435d06366058d16b5fe4225" id="r_a34c1ca39d435d06366058d16b5fe4225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34c1ca39d435d06366058d16b5fe4225">isLoopParallelAndContainsReduction</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a34c1ca39d435d06366058d16b5fe4225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether a loop is a parallel loop and contains a reduction loop.  <br /></td></tr>
<tr class="memitem:a5ad383995f97dc30a0d6891e33fd499a" id="r_a5ad383995f97dc30a0d6891e33fd499a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ad383995f97dc30a0d6891e33fd499a">getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a5ad383995f97dc30a0d6891e33fd499a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <br /></td></tr>
<tr class="memitem:ab6cceed0c6debb9af0d3bd76c9ed52f4" id="r_ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6cceed0c6debb9af0d3bd76c9ed52f4">getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;dependenceConstraints, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classbool.html">bool</a> isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:ab6cceed0c6debb9af0d3bd76c9ed52f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <br /></td></tr>
<tr class="memitem:acfb5cde2210f8126b02cd84843a0c43b" id="r_acfb5cde2210f8126b02cd84843a0c43b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfb5cde2210f8126b02cd84843a0c43b">getSliceIterationCount</a> (const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;sliceTripCountMap)</td></tr>
<tr class="memdesc:acfb5cde2210f8126b02cd84843a0c43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of iterations for the <span class="tt">slicetripCountMap</span> provided.  <br /></td></tr>
<tr class="memitem:af1b7ee261b2662fe2f0c257c9e04f3b6" id="r_af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1b7ee261b2662fe2f0c257c9e04f3b6">buildSliceTripCountMap</a> (const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *tripCountMap)</td></tr>
<tr class="memdesc:af1b7ee261b2662fe2f0c257c9e04f3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'.  <br /></td></tr>
<tr class="memitem:a29213ed6d6cdad5cdd69bb66c6df863f" id="r_a29213ed6d6cdad5cdd69bb66c6df863f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29213ed6d6cdad5cdd69bb66c6df863f">computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; opsB, <a class="el" href="classunsigned.html">unsigned</a> loopDepth, <a class="el" href="classunsigned.html">unsigned</a> numCommonLoops, <a class="el" href="classbool.html">bool</a> isBackwardSlice, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:a29213ed6d6cdad5cdd69bb66c6df863f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid.  <br /></td></tr>
<tr class="memitem:af32168fb86ad493527c61d139acee48a" id="r_af32168fb86ad493527c61d139acee48a"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af32168fb86ad493527c61d139acee48a">insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:af32168fb86ad493527c61d139acee48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <br /></td></tr>
<tr class="memitem:ac5e109cfdab6f0859fbbc3e0bf08ebac" id="r_ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5e109cfdab6f0859fbbc3e0bf08ebac">getIntOrFloatMemRefSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:ac5e109cfdab6f0859fbbc3e0bf08ebac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of a memref with element type int or float in bytes if it's statically shaped, std::nullopt otherwise.  <br /></td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1" id="r_addef193d35d8d7990addced6bcb731c1"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer&gt; </td></tr>
<tr class="memitem:addef193d35d8d7990addced6bcb731c1 template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addef193d35d8d7990addced6bcb731c1">boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, <a class="el" href="classbool.html">bool</a> <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>)</td></tr>
<tr class="memdesc:addef193d35d8d7990addced6bcb731c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <br /></td></tr>
<tr class="memitem:a3a39bbf8628440572cdd76a10d58dc53" id="r_a3a39bbf8628440572cdd76a10d58dc53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a39bbf8628440572cdd76a10d58dc53">getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;a, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:a3a39bbf8628440572cdd76a10d58dc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <br /></td></tr>
<tr class="memitem:a93666d2fb7a3b0598ecf69542f1a5ab7" id="r_a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a93666d2fb7a3b0598ecf69542f1a5ab7">getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a93666d2fb7a3b0598ecf69542f1a5ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <br /></td></tr>
<tr class="memitem:afd9e0f536b1471778961ba51c2227f07" id="r_afd9e0f536b1471778961ba51c2227f07"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd9e0f536b1471778961ba51c2227f07">getMemRefIntOrFloatEltSizeInBytes</a> (MemRefType memRefType)</td></tr>
<tr class="memdesc:afd9e0f536b1471778961ba51c2227f07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memref's element type's size in bytes where the elemental type is an int or float or a vector of such types.  <br /></td></tr>
<tr class="memitem:a1f2e85e904cf88ca63479dad00941e87" id="r_a1f2e85e904cf88ca63479dad00941e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f2e85e904cf88ca63479dad00941e87">simplifyIntegerSet</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set)</td></tr>
<tr class="memdesc:a1f2e85e904cf88ca63479dad00941e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference.  <br /></td></tr>
<tr class="memitem:a9cc3df9a0cea6ad3bf48958ad2d54128" id="r_a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cc3df9a0cea6ad3bf48958ad2d54128">getInnermostCommonLoopDepth</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *surroundingLoops=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a9cc3df9a0cea6ad3bf48958ad2d54128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the innermost common loop depth for the set of operations in 'ops'.  <br /></td></tr>
<tr class="memitem:af4c9fec2934b9a14a5883e9fabbe3f49" id="r_af4c9fec2934b9a14a5883e9fabbe3f49"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4c9fec2934b9a14a5883e9fabbe3f49">simplifyConstrainedMinMaxOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> constraints)</td></tr>
<tr class="memdesc:af4c9fec2934b9a14a5883e9fabbe3f49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to simplify the given affine.min or affine.max op to an affine map with a single result and operands, taking into account the specified constraint set.  <br /></td></tr>
<tr class="memitem:ae33ee1431de2b7e6802c9270b1ff60d1" id="r_ae33ee1431de2b7e6802c9270b1ff60d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Block.html">mlir::Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae33ee1431de2b7e6802c9270b1ff60d1">findInnermostCommonBlockInScope</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *a, <a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>)</td></tr>
<tr class="memdesc:ae33ee1431de2b7e6802c9270b1ff60d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the innermost common <span class="tt"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></span> of <span class="tt">a</span> and <span class="tt">b</span> in the affine scope that <span class="tt">a</span> and <span class="tt">b</span> are part of.  <br /></td></tr>
<tr class="memitem:a85ac5508d6eb2d2c7c2a2103ca7a1bfe" id="r_a85ac5508d6eb2d2c7c2a2103ca7a1bfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a85ac5508d6eb2d2c7c2a2103ca7a1bfe">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a85ac5508d6eb2d2c7c2a2103ca7a1bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of an op with trait <span class="tt">AffineScope</span> or is a region argument for such an op.  <br /></td></tr>
<tr class="memitem:a9b541bc609cc8c880c998cc99cdd1589" id="r_a9b541bc609cc8c880c998cc99cdd1589"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b541bc609cc8c880c998cc99cdd1589">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:a9b541bc609cc8c880c998cc99cdd1589"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of <span class="tt">region</span> or is an argument of <span class="tt">region</span>.  <br /></td></tr>
<tr class="memitem:ad353c117f0a45543a77ef884704a7ff0" id="r_ad353c117f0a45543a77ef884704a7ff0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad353c117f0a45543a77ef884704a7ff0">getAffineScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ad353c117f0a45543a77ef884704a7ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest region enclosing <span class="tt">op</span> that is held by an operation with trait <span class="tt">AffineScope</span>; <span class="tt">nullptr</span> if there is no such region.  <br /></td></tr>
<tr class="memitem:a8722fd9a0481c2680fd64fcb7fbbb583" id="r_a8722fd9a0481c2680fd64fcb7fbbb583"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8722fd9a0481c2680fd64fcb7fbbb583">getAffineAnalysisScope</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8722fd9a0481c2680fd64fcb7fbbb583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the closest region enclosing <span class="tt">op</span> that is held by a non-affine operation; <span class="tt">nullptr</span> if there is no such region.  <br /></td></tr>
<tr class="memitem:a43ded6085da1a665f8c367bea35e77fc" id="r_a43ded6085da1a665f8c367bea35e77fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43ded6085da1a665f8c367bea35e77fc">computeProduct</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; terms)</td></tr>
<tr class="memdesc:a43ded6085da1a665f8c367bea35e77fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of <span class="tt">terms</span>, creating an <span class="tt">affine.apply</span> if any of them are non-constant values.  <br /></td></tr>
<tr class="memitem:a245751b99c21bbee57456cef1e52bde4" id="r_a245751b99c21bbee57456cef1e52bde4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a245751b99c21bbee57456cef1e52bde4">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a245751b99c21bbee57456cef1e52bde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <span class="tt">AffineScope</span>.  <br /></td></tr>
<tr class="memitem:ab3030c26358d640e751344ee1fc60335" id="r_ab3030c26358d640e751344ee1fc60335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3030c26358d640e751344ee1fc60335">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:ab3030c26358d640e751344ee1fc60335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <span class="tt">region</span>, i.e., for all its uses in <span class="tt">region</span>.  <br /></td></tr>
<tr class="memitem:a9d387ed8b9220b1d4f32d7efe7cf6117" id="r_a9d387ed8b9220b1d4f32d7efe7cf6117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d387ed8b9220b1d4f32d7efe7cf6117">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9d387ed8b9220b1d4f32d7efe7cf6117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <span class="tt">AffineScope</span>.  <br /></td></tr>
<tr class="memitem:adeeefdd6013aa0720cc45eed32fd8eac" id="r_adeeefdd6013aa0720cc45eed32fd8eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adeeefdd6013aa0720cc45eed32fd8eac">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Region.html">Region</a> *region)</td></tr>
<tr class="memdesc:adeeefdd6013aa0720cc45eed32fd8eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <span class="tt">region</span>, i.e., for all its uses in <span class="tt">region</span>.  <br /></td></tr>
<tr class="memitem:ad96a1dbba3240e5a725ce9176f832a6f" id="r_ad96a1dbba3240e5a725ce9176f832a6f"><td class="memItemLeft" align="right" valign="top">ParseResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad96a1dbba3240e5a725ce9176f832a6f">parseDimAndSymbolList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;parser, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, <a class="el" href="classunsigned.html">unsigned</a> &amp;numDims)</td></tr>
<tr class="memdesc:ad96a1dbba3240e5a725ce9176f832a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses dimension and symbol list.  <br /></td></tr>
<tr class="memitem:a691ff98dafcd40a555ea1d127b06c9c3" id="r_a691ff98dafcd40a555ea1d127b06c9c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a691ff98dafcd40a555ea1d127b06c9c3">canonicalizeMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a691ff98dafcd40a555ea1d127b06c9c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies both <span class="tt">map</span> and <span class="tt">operands</span> in-place so as to:  <br /></td></tr>
<tr class="memitem:a8b47f23151bd884a4ce93312f1499a02" id="r_a8b47f23151bd884a4ce93312f1499a02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b47f23151bd884a4ce93312f1499a02">canonicalizeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a8b47f23151bd884a4ce93312f1499a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps.  <br /></td></tr>
<tr class="memitem:a0d5cb525632c1a12545d579561c40dcc" id="r_a0d5cb525632c1a12545d579561c40dcc"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d5cb525632c1a12545d579561c40dcc">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a0d5cb525632c1a12545d579561c40dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a composed AffineApplyOp by composing <span class="tt">map</span> and <span class="tt">operands</span> with other AffineApplyOps supplying those operands.  <br /></td></tr>
<tr class="memitem:a4c32299c7b12725419a820f4314fa39c" id="r_a4c32299c7b12725419a820f4314fa39c"><td class="memItemLeft" align="right" valign="top">AffineApplyOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c32299c7b12725419a820f4314fa39c">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> e, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memitem:a790378c2cd10eccca0bfe9fca0f84300" id="r_a790378c2cd10eccca0bfe9fca0f84300"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a790378c2cd10eccca0bfe9fca0f84300">makeComposedFoldedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a790378c2cd10eccca0bfe9fca0f84300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineApplyOp that applies <span class="tt">map</span> to <span class="tt">operands</span> after composing the map with the maps of any other AffineApplyOp supplying the operands, then immediately attempts to fold it.  <br /></td></tr>
<tr class="memitem:ad9f23150730054dc540e6470b3bf342e" id="r_ad9f23150730054dc540e6470b3bf342e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f23150730054dc540e6470b3bf342e">makeComposedFoldedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:ad9f23150730054dc540e6470b3bf342e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <span class="tt">makeComposedFoldedAffineApply</span> that applies to an expression.  <br /></td></tr>
<tr class="memitem:a369e8fce67650dea4a3ae344c29b3ee4" id="r_a369e8fce67650dea4a3ae344c29b3ee4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a369e8fce67650dea4a3ae344c29b3ee4">makeComposedFoldedMultiResultAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a369e8fce67650dea4a3ae344c29b3ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variant of <span class="tt">makeComposedFoldedAffineApply</span> suitable for multi-result maps.  <br /></td></tr>
<tr class="memitem:aefb27d3d2a62c6db2503c7cc8d62a6bb" id="r_aefb27d3d2a62c6db2503c7cc8d62a6bb"><td class="memItemLeft" align="right" valign="top">AffineMinOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefb27d3d2a62c6db2503c7cc8d62a6bb">makeComposedAffineMin</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:aefb27d3d2a62c6db2503c7cc8d62a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an AffineMinOp obtained by composing <span class="tt">map</span> and <span class="tt">operands</span> with AffineApplyOps supplying those operands.  <br /></td></tr>
<tr class="memitem:a81cf2e698dddd6dc85868bac07a74ca0" id="r_a81cf2e698dddd6dc85868bac07a74ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81cf2e698dddd6dc85868bac07a74ca0">makeComposedFoldedAffineMin</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:a81cf2e698dddd6dc85868bac07a74ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineMinOp that computes a minimum across the results of applying <span class="tt">map</span> to <span class="tt">operands</span>, then immediately attempts to fold it.  <br /></td></tr>
<tr class="memitem:a767162cfa21cd3e191f6c2e8f5bc9f1e" id="r_a767162cfa21cd3e191f6c2e8f5bc9f1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a767162cfa21cd3e191f6c2e8f5bc9f1e">makeComposedFoldedAffineMax</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; operands)</td></tr>
<tr class="memdesc:a767162cfa21cd3e191f6c2e8f5bc9f1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an AffineMinOp that computes a maximum across the results of applying <span class="tt">map</span> to <span class="tt">operands</span>, then immediately attempts to fold it.  <br /></td></tr>
<tr class="memitem:a89d2273335462b22fd078a52a6c687e7" id="r_a89d2273335462b22fd078a52a6c687e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89d2273335462b22fd078a52a6c687e7">fullyComposeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands, <a class="el" href="classbool.html">bool</a> composeAffineMin=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a89d2273335462b22fd078a52a6c687e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map <span class="tt">map</span> and its input <span class="tt">operands</span>, this method composes into <span class="tt">map</span>, maps of AffineApplyOps whose results are the values in <span class="tt">operands</span>, iteratively until no more of <span class="tt">operands</span> are the result of an AffineApplyOp.  <br /></td></tr>
<tr class="memitem:a78713c7b03663a8b9c23a4394a714e1a" id="r_a78713c7b03663a8b9c23a4394a714e1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a78713c7b03663a8b9c23a4394a714e1a">isAffineForInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a78713c7b03663a8b9c23a4394a714e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of an AffineForOp.  <br /></td></tr>
<tr class="memitem:ae078747217d5df8ac5077cadb329f087" id="r_ae078747217d5df8ac5077cadb329f087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae078747217d5df8ac5077cadb329f087">isAffineParallelInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:ae078747217d5df8ac5077cadb329f087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">val</span> is the induction variable of an AffineParallelOp.  <br /></td></tr>
<tr class="memitem:a2fb9a1f410c602d0a0aaf955705a15ac" id="r_a2fb9a1f410c602d0a0aaf955705a15ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb9a1f410c602d0a0aaf955705a15ac">isAffineInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a2fb9a1f410c602d0a0aaf955705a15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is the induction variable of an AffineForOp or AffineParallelOp.  <br /></td></tr>
<tr class="memitem:a483c308ea389d0ce4b47ef74a252b14e" id="r_a483c308ea389d0ce4b47ef74a252b14e"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a483c308ea389d0ce4b47ef74a252b14e">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a483c308ea389d0ce4b47ef74a252b14e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <br /></td></tr>
<tr class="memitem:abf27d6cea1330a4ac809686a75c43d25" id="r_abf27d6cea1330a4ac809686a75c43d25"><td class="memItemLeft" align="right" valign="top">AffineParallelOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf27d6cea1330a4ac809686a75c43d25">getAffineParallelInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:abf27d6cea1330a4ac809686a75c43d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the provided value is among the induction variables of an AffineParallelOp.  <br /></td></tr>
<tr class="memitem:a1da42aec5ee59df08774d6d55982b59c" id="r_a1da42aec5ee59df08774d6d55982b59c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da42aec5ee59df08774d6d55982b59c">extractForInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forInsts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *ivs)</td></tr>
<tr class="memdesc:a1da42aec5ee59df08774d6d55982b59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of AffineForOps and places them in the output argument <span class="tt">ivs</span>.  <br /></td></tr>
<tr class="memitem:a9a92b58f46c4e921cc3c899423b76a27" id="r_a9a92b58f46c4e921cc3c899423b76a27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a92b58f46c4e921cc3c899423b76a27">extractInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; affineOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;ivs)</td></tr>
<tr class="memdesc:a9a92b58f46c4e921cc3c899423b76a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of either AffineForOp or AffineParallelOp and places them in the output argument <span class="tt">ivs</span>.  <br /></td></tr>
<tr class="memitem:a0d2fe80f256b34a27f3f9fa0cce088a5" id="r_a0d2fe80f256b34a27f3f9fa0cce088a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2fe80f256b34a27f3f9fa0cce088a5">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; lbs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; steps, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a0d2fe80f256b34a27f3f9fa0cce088a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator.  <br /></td></tr>
<tr class="memitem:a38de885fc72eb338a5ec53d1ab65630c" id="r_a38de885fc72eb338a5ec53d1ab65630c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38de885fc72eb338a5ec53d1ab65630c">buildAffineLoopNest</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> lbs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> ubs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; steps, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt; bodyBuilderFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memitem:a861f3eb48860eab1e82710027ceae08f" id="r_a861f3eb48860eab1e82710027ceae08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a861f3eb48860eab1e82710027ceae08f">registerValueBoundsOpInterfaceExternalModels</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:ab9717faebcbb497b46d259b26da55635" id="r_ab9717faebcbb497b46d259b26da55635"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9717faebcbb497b46d259b26da55635">fullyComposeAndComputeConstantDelta</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value1, <a class="el" href="classmlir_1_1Value.html">Value</a> value2)</td></tr>
<tr class="memdesc:ab9717faebcbb497b46d259b26da55635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a constant delta of the given two values.  <br /></td></tr>
<tr class="memitem:ae3ab6f9e710bf9eb63bc8b3488c58631" id="r_ae3ab6f9e710bf9eb63bc8b3488c58631"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae3ab6f9e710bf9eb63bc8b3488c58631">canFuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, <a class="el" href="classunsigned.html">unsigned</a> dstLoopDepth, <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *srcSlice, <a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a> fusionStrategy=<a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html#a996eae93c3d38b2b1f428661df7acc46a1c27f9e3417768eefe1bab13d6de5de6">FusionStrategy::Generic</a>)</td></tr>
<tr class="memdesc:ae3ab6f9e710bf9eb63bc8b3488c58631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'.  <br /></td></tr>
<tr class="memitem:a87fd816295937f98c409c06f1407d96e" id="r_a87fd816295937f98c409c06f1407d96e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87fd816295937f98c409c06f1407d96e">fuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;srcSlice, <a class="el" href="classbool.html">bool</a> isInnermostSiblingInsertionFusion=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a87fd816295937f98c409c06f1407d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'.  <br /></td></tr>
<tr class="memitem:aa7270aca023f828cb4e8893705de7e0b" id="r_aa7270aca023f828cb4e8893705de7e0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7270aca023f828cb4e8893705de7e0b">getLoopNestStats</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> *stats)</td></tr>
<tr class="memdesc:aa7270aca023f828cb4e8893705de7e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect loop nest statistics (eg.  <br /></td></tr>
<tr class="memitem:a6e97fc7b7a01938ada405a335e7961a7" id="r_a6e97fc7b7a01938ada405a335e7961a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e97fc7b7a01938ada405a335e7961a7">getComputeCost</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;stats)</td></tr>
<tr class="memdesc:a6e97fc7b7a01938ada405a335e7961a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.  <br /></td></tr>
<tr class="memitem:a27b764a0cf88a53b85f7149423277f12" id="r_a27b764a0cf88a53b85f7149423277f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b764a0cf88a53b85f7149423277f12">getFusionComputeCost</a> (AffineForOp srcForOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;srcStats, AffineForOp dstForOp, <a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;dstStats, const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;slice, <a class="el" href="classint64__t.html">int64_t</a> *computeCost)</td></tr>
<tr class="memdesc:a27b764a0cf88a53b85f7149423277f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'.  <br /></td></tr>
<tr class="memitem:a3c01e230ac0a33fa2370a21e428e833e" id="r_a3c01e230ac0a33fa2370a21e428e833e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c01e230ac0a33fa2370a21e428e833e">gatherProducerConsumerMemrefs</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; srcOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; dstOps, <a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;producerConsumerMemrefs)</td></tr>
<tr class="memdesc:a3c01e230ac0a33fa2370a21e428e833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'.  <br /></td></tr>
<tr class="memitem:a1298df47a03112972950004cc449fed3" id="r_a1298df47a03112972950004cc449fed3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1298df47a03112972950004cc449fed3">loopUnrollFull</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a1298df47a03112972950004cc449fed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation completely if the trip count is known to be constant.  <br /></td></tr>
<tr class="memitem:a1e40110d365738e8699594b1d4f27e85" id="r_a1e40110d365738e8699594b1d4f27e85"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e40110d365738e8699594b1d4f27e85">loopUnrollByFactor</a> (AffineForOp forOp, uint64_t unrollFactor, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt; annotateFn=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> cleanUpUnroll=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a1e40110d365738e8699594b1d4f27e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <br /></td></tr>
<tr class="memitem:a6d6bdc8e2c261d88d25e21d30ab2899d" id="r_a6d6bdc8e2c261d88d25e21d30ab2899d"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d6bdc8e2c261d88d25e21d30ab2899d">loopUnrollUpToFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a6d6bdc8e2c261d88d25e21d30ab2899d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop by the specified unroll factor or its trip count, whichever is lower.  <br /></td></tr>
<tr class="memitem:a8dfe2c6d438e6cee369c98a6371b44bf" id="r_a8dfe2c6d438e6cee369c98a6371b44bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dfe2c6d438e6cee369c98a6371b44bf">isPerfectlyNested</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops)</td></tr>
<tr class="memdesc:a8dfe2c6d438e6cee369c98a6371b44bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">loops</span> is a perfectly nested loop nest, where loops appear in it from outermost to innermost.  <br /></td></tr>
<tr class="memitem:a3fdd1212128e826d76abbe85a61742b7" id="r_a3fdd1212128e826d76abbe85a61742b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdd1212128e826d76abbe85a61742b7">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;nestedLoops, AffineForOp root)</td></tr>
<tr class="memdesc:a3fdd1212128e826d76abbe85a61742b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <br /></td></tr>
<tr class="memitem:a8208a6014374243c317effcb573395dd" id="r_a8208a6014374243c317effcb573395dd"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8208a6014374243c317effcb573395dd">loopUnrollJamByFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:a8208a6014374243c317effcb573395dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor.  <br /></td></tr>
<tr class="memitem:a1c569833e90667ba35ace5840ac92307" id="r_a1c569833e90667ba35ace5840ac92307"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c569833e90667ba35ace5840ac92307">loopUnrollJamUpToFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:a1c569833e90667ba35ace5840ac92307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower.  <br /></td></tr>
<tr class="memitem:a17d92cbba68de00d9a29abd461274661" id="r_a17d92cbba68de00d9a29abd461274661"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17d92cbba68de00d9a29abd461274661">promoteIfSingleIteration</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a17d92cbba68de00d9a29abd461274661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration.  <br /></td></tr>
<tr class="memitem:aa6177db3daa7c8f6e03b62ec74334fdd" id="r_aa6177db3daa7c8f6e03b62ec74334fdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6177db3daa7c8f6e03b62ec74334fdd">promoteSingleIterationLoops</a> (func::FuncOp f)</td></tr>
<tr class="memdesc:aa6177db3daa7c8f6e03b62ec74334fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>.  <br /></td></tr>
<tr class="memitem:a46706cab45d0b917d5acff3ed72756c2" id="r_a46706cab45d0b917d5acff3ed72756c2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46706cab45d0b917d5acff3ed72756c2">affineForOpBodySkew</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts, <a class="el" href="classbool.html">bool</a> unrollPrologueEpilogue=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a46706cab45d0b917d5acff3ed72756c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew the operations in an affine.for's body with the specified operation-wise shifts.  <br /></td></tr>
<tr class="memitem:ad4fdfbbfeaedc902c83393747fa2fe7f" id="r_ad4fdfbbfeaedc902c83393747fa2fe7f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4fdfbbfeaedc902c83393747fa2fe7f">tilePerfectlyNested</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ad4fdfbbfeaedc902c83393747fa2fe7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops.  <br /></td></tr>
<tr class="memitem:a86baa652b01992ec11a10c7de8e2fe54" id="r_a86baa652b01992ec11a10c7de8e2fe54"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86baa652b01992ec11a10c7de8e2fe54">tilePerfectlyNestedParametric</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; input, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; tileSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *tiledNest=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a86baa652b01992ec11a10c7de8e2fe54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters.  <br /></td></tr>
<tr class="memitem:adbefeb28d61a80e2a403eb660deabbe7" id="r_adbefeb28d61a80e2a403eb660deabbe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbefeb28d61a80e2a403eb660deabbe7">interchangeLoops</a> (AffineForOp forOpA, AffineForOp forOpB)</td></tr>
<tr class="memdesc:adbefeb28d61a80e2a403eb660deabbe7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs loop interchange on 'forOpA' and 'forOpB'.  <br /></td></tr>
<tr class="memitem:a5aded67ac5853a2bdeff09550e8bb32c" id="r_a5aded67ac5853a2bdeff09550e8bb32c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5aded67ac5853a2bdeff09550e8bb32c">isValidLoopInterchangePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; loopPermMap)</td></tr>
<tr class="memdesc:a5aded67ac5853a2bdeff09550e8bb32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange).  <br /></td></tr>
<tr class="memitem:a7bcd13c7ee29ca2ec5cc65bfc85133fb" id="r_a7bcd13c7ee29ca2ec5cc65bfc85133fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7bcd13c7ee29ca2ec5cc65bfc85133fb">permuteLoops</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; inputNest, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; permMap)</td></tr>
<tr class="memdesc:a7bcd13c7ee29ca2ec5cc65bfc85133fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a loop permutation on a perfectly nested loop nest <span class="tt">inputNest</span> (where the contained loops appear from outer to inner) as specified by the permutation <span class="tt">permMap</span>: loop 'i' in <span class="tt">inputNest</span> is mapped to location 'loopPermMap[i]', where positions 0, 1, ... are from the outermost position to inner.  <br /></td></tr>
<tr class="memitem:ad1cc3f41464ffc9424244b2e3a3f2bd5" id="r_ad1cc3f41464ffc9424244b2e3a3f2bd5"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1cc3f41464ffc9424244b2e3a3f2bd5">sinkSequentialLoops</a> (AffineForOp forOp)</td></tr>
<tr class="memitem:ad1b737fda5e5d83d831e50dcb73d8e26" id="r_ad1b737fda5e5d83d831e50dcb73d8e26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad1b737fda5e5d83d831e50dcb73d8e26">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="memdesc:ad1b737fda5e5d83d831e50dcb73d8e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under each of the <span class="tt">targets</span>.  <br /></td></tr>
<tr class="memitem:a0c5e9321f0d01289b23d98a44b936cd8" id="r_a0c5e9321f0d01289b23d98a44b936cd8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c5e9321f0d01289b23d98a44b936cd8">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, AffineForOp <a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memdesc:a0c5e9321f0d01289b23d98a44b936cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under <span class="tt">target</span>.  <br /></td></tr>
<tr class="memitem:ac5f955e6ef5e73376cf17d57ce91fbd3" id="r_ac5f955e6ef5e73376cf17d57ce91fbd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint64__t.html">int64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f955e6ef5e73376cf17d57ce91fbd3">numEnclosingInvariantLoops</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;operand)</td></tr>
<tr class="memdesc:ac5f955e6ef5e73376cf17d57ce91fbd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs explicit copying for the contiguous sequence of operations in the block iterator range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;), where &lsquo;end&rsquo; can't be past the / terminator of the block (since additional operations are potentially / inserted right before <span class="tt">end</span>.  <br /></td></tr>
<tr class="memitem:afe2c60844cdcc6da96b39887426a7a73" id="r_afe2c60844cdcc6da96b39887426a7a73"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe2c60844cdcc6da96b39887426a7a73">createAffineParallelize</a> ()</td></tr>
<tr class="memitem:a619a33bf9775f498ae3eb6126f8ac9e1" id="r_a619a33bf9775f498ae3eb6126f8ac9e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a619a33bf9775f498ae3eb6126f8ac9e1">createAffineParallelize</a> (<a class="el" href="structmlir_1_1affine_1_1AffineParallelizeOptions.html">AffineParallelizeOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:aa65f8449ec0c16cda685788e865265dc" id="r_aa65f8449ec0c16cda685788e865265dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa65f8449ec0c16cda685788e865265dc">createAffineVectorize</a> ()</td></tr>
<tr class="memitem:a2f680ba9877f07ecc0c3ed9dab02a9a9" id="r_a2f680ba9877f07ecc0c3ed9dab02a9a9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f680ba9877f07ecc0c3ed9dab02a9a9">createAffineVectorize</a> (<a class="el" href="structmlir_1_1affine_1_1AffineVectorizeOptions.html">AffineVectorizeOptions</a> <a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>)</td></tr>
<tr class="memitem:a827b38ee918833bfaaed1371b507db9e" id="r_a827b38ee918833bfaaed1371b507db9e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a827b38ee918833bfaaed1371b507db9e">createSimplifyAffineMinMaxPass</a> ()</td></tr>
<tr class="memitem:ac2d37c95eae4f6e48b8711d87e482138" id="r_ac2d37c95eae4f6e48b8711d87e482138"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d37c95eae4f6e48b8711d87e482138">createSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memdesc:ac2d37c95eae4f6e48b8711d87e482138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simplification pass for affine structures (maps and sets).  <br /></td></tr>
<tr class="memitem:a1e33a259b4d2b2ba16b25214cfd87b90" id="r_a1e33a259b4d2b2ba16b25214cfd87b90"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e33a259b4d2b2ba16b25214cfd87b90">createAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a1e33a259b4d2b2ba16b25214cfd87b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops.  <br /></td></tr>
<tr class="memitem:a83e11cb92c70ca20b767c8323d74c033" id="r_a83e11cb92c70ca20b767c8323d74c033"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a83e11cb92c70ca20b767c8323d74c033">createAffineParallelizePass</a> ()</td></tr>
<tr class="memdesc:a83e11cb92c70ca20b767c8323d74c033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops.  <br /></td></tr>
<tr class="memitem:a960e99ffd0051a74f6ab1007e7b1ced3" id="r_a960e99ffd0051a74f6ab1007e7b1ced3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a960e99ffd0051a74f6ab1007e7b1ced3">createRaiseMemrefToAffine</a> ()</td></tr>
<tr class="memdesc:a960e99ffd0051a74f6ab1007e7b1ced3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that converts some memref operators to affine operators.  <br /></td></tr>
<tr class="memitem:a3e7f7eb4ce92936880206456af175d60" id="r_a3e7f7eb4ce92936880206456af175d60"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e7f7eb4ce92936880206456af175d60">createAffineLoopNormalizePass</a> (<a class="el" href="classbool.html">bool</a> promoteSingleIter=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a3e7f7eb4ce92936880206456af175d60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply normalization transformations to affine loop-like ops.  <br /></td></tr>
<tr class="memitem:a7ab146994c9d7fb84f7647b1c7f69623" id="r_a7ab146994c9d7fb84f7647b1c7f69623"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ab146994c9d7fb84f7647b1c7f69623">createAffineDataCopyGenerationPass</a> (<a class="el" href="classunsigned.html">unsigned</a> slowMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace, <a class="el" href="classunsigned.html">unsigned</a> tagMemorySpace=0, int minDmaTransferSize=1024, uint64_t fastMemCapacityBytes=std::numeric_limits&lt; uint64_t &gt;<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">::max</a>())</td></tr>
<tr class="memdesc:a7ab146994c9d7fb84f7647b1c7f69623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations.  <br /></td></tr>
<tr class="memitem:aea380e86b89f4c708beac838b978af47" id="r_aea380e86b89f4c708beac838b978af47"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea380e86b89f4c708beac838b978af47">createAffineDataCopyGenerationPass</a> ()</td></tr>
<tr class="memdesc:aea380e86b89f4c708beac838b978af47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <br /></td></tr>
<tr class="memitem:a0f1af7c53ffcf2175bed3528a5efd0d1" id="r_a0f1af7c53ffcf2175bed3528a5efd0d1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f1af7c53ffcf2175bed3528a5efd0d1">createAffineScalarReplacementPass</a> ()</td></tr>
<tr class="memdesc:a0f1af7c53ffcf2175bed3528a5efd0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs.  <br /></td></tr>
<tr class="memitem:a31f454dd30258cafd177eee0de1562e1" id="r_a31f454dd30258cafd177eee0de1562e1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31f454dd30258cafd177eee0de1562e1">createLoopCoalescingPass</a> ()</td></tr>
<tr class="memdesc:a31f454dd30258cafd177eee0de1562e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms perfectly nested loops with independent bounds into a single loop.  <br /></td></tr>
<tr class="memitem:a94bff65ed7d124cc37d8ef411947a9a3" id="r_a94bff65ed7d124cc37d8ef411947a9a3"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94bff65ed7d124cc37d8ef411947a9a3">createLoopFusionPass</a> (<a class="el" href="classunsigned.html">unsigned</a> fastMemorySpace=0, uint64_t localBufSizeThreshold=0, <a class="el" href="classbool.html">bool</a> maximalFusion=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, enum <a class="el" href="#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a> fusionMode=<a class="el" href="#a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6">FusionMode::Greedy</a>)</td></tr>
<tr class="memdesc:a94bff65ed7d124cc37d8ef411947a9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses affine loop nests at the top-level of the operation the pass is created on according to the type of fusion specified in <span class="tt">fusionMode</span>.  <br /></td></tr>
<tr class="memitem:a9faf839f27abf73616bc2ba7ed28b8d9" id="r_a9faf839f27abf73616bc2ba7ed28b8d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9faf839f27abf73616bc2ba7ed28b8d9">createLoopTilingPass</a> (uint64_t cacheSizeBytes)</td></tr>
<tr class="memdesc:a9faf839f27abf73616bc2ba7ed28b8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform tiling on loop nests.  <br /></td></tr>
<tr class="memitem:ad9180dd506c0f8b1a612dffadce18a93" id="r_ad9180dd506c0f8b1a612dffadce18a93"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9180dd506c0f8b1a612dffadce18a93">createLoopTilingPass</a> ()</td></tr>
<tr class="memdesc:ad9180dd506c0f8b1a612dffadce18a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload relying on pass options for initialization.  <br /></td></tr>
<tr class="memitem:a6ee39443c7af128fb1909ba34bbf3af9" id="r_a6ee39443c7af128fb1909ba34bbf3af9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee39443c7af128fb1909ba34bbf3af9">createLoopUnrollPass</a> (int unrollFactor=-1, <a class="el" href="classbool.html">bool</a> unrollUpToFactor=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;getUnrollFactor=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a6ee39443c7af128fb1909ba34bbf3af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unrolling pass with the provided parameters.  <br /></td></tr>
<tr class="memitem:ace0e439a1d5a4a00345ebea914e51e36" id="r_ace0e439a1d5a4a00345ebea914e51e36"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace0e439a1d5a4a00345ebea914e51e36">createLoopUnrollAndJamPass</a> (int unrollJamFactor=-1)</td></tr>
<tr class="memdesc:ace0e439a1d5a4a00345ebea914e51e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unroll jam pass to unroll jam by the specified factor.  <br /></td></tr>
<tr class="memitem:ac9e0e21ed1bde4dca79b101c3d0dd7e8" id="r_ac9e0e21ed1bde4dca79b101c3d0dd7e8"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9e0e21ed1bde4dca79b101c3d0dd7e8">createPipelineDataTransferPass</a> ()</td></tr>
<tr class="memdesc:ac9e0e21ed1bde4dca79b101c3d0dd7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy.  <br /></td></tr>
<tr class="memitem:ab6ffce291badfd37964dea394098ad7c" id="r_ab6ffce291badfd37964dea394098ad7c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ffce291badfd37964dea394098ad7c">createAffineExpandIndexOpsPass</a> ()</td></tr>
<tr class="memdesc:ab6ffce291badfd37964dea394098ad7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect).  <br /></td></tr>
<tr class="memitem:ad3bc5ab2aa37a753081b1abb6ea6534e" id="r_ad3bc5ab2aa37a753081b1abb6ea6534e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3bc5ab2aa37a753081b1abb6ea6534e">createAffineExpandIndexOpsAsAffinePass</a> ()</td></tr>
<tr class="memdesc:ad3bc5ab2aa37a753081b1abb6ea6534e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to expand affine index operations into affine.apply operations.  <br /></td></tr>
<tr class="memitem:a3b9a500abd5be19124c80bda2fc50094" id="r_a3b9a500abd5be19124c80bda2fc50094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b9a500abd5be19124c80bda2fc50094">registerAffineDataCopyGeneration</a> ()</td></tr>
<tr class="memitem:a2fac8aeefa61c56e265ee1439410b64d" id="r_a2fac8aeefa61c56e265ee1439410b64d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fac8aeefa61c56e265ee1439410b64d">registerAffineDataCopyGenerationPass</a> ()</td></tr>
<tr class="memitem:a69037d9a9cbcca49a76566bbef329aab" id="r_a69037d9a9cbcca49a76566bbef329aab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69037d9a9cbcca49a76566bbef329aab">registerAffineExpandIndexOps</a> ()</td></tr>
<tr class="memitem:a1314cc5eef0f21cf18b8537cb6ff7878" id="r_a1314cc5eef0f21cf18b8537cb6ff7878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1314cc5eef0f21cf18b8537cb6ff7878">registerAffineExpandIndexOpsPass</a> ()</td></tr>
<tr class="memitem:aef5c8a8afbe506ab64093673afe98a48" id="r_aef5c8a8afbe506ab64093673afe98a48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef5c8a8afbe506ab64093673afe98a48">registerAffineExpandIndexOpsAsAffine</a> ()</td></tr>
<tr class="memitem:a89b080421680bc9883d19871b533f721" id="r_a89b080421680bc9883d19871b533f721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89b080421680bc9883d19871b533f721">registerAffineExpandIndexOpsAsAffinePass</a> ()</td></tr>
<tr class="memitem:add0a1da2eff068786faa1fd567d51174" id="r_add0a1da2eff068786faa1fd567d51174"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0a1da2eff068786faa1fd567d51174">registerAffineLoopFusion</a> ()</td></tr>
<tr class="memitem:a41a988a588e6ded71e12a4ede33dd170" id="r_a41a988a588e6ded71e12a4ede33dd170"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41a988a588e6ded71e12a4ede33dd170">registerAffineLoopFusionPass</a> ()</td></tr>
<tr class="memitem:ae2c7cf5bd1041708e46ac7590e7f4de8" id="r_ae2c7cf5bd1041708e46ac7590e7f4de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2c7cf5bd1041708e46ac7590e7f4de8">registerAffineLoopInvariantCodeMotion</a> ()</td></tr>
<tr class="memitem:a041809df10115359f9d42abada686323" id="r_a041809df10115359f9d42abada686323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a041809df10115359f9d42abada686323">registerAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memitem:a1a00a995d27bbcbd2d689e6b2109c5f7" id="r_a1a00a995d27bbcbd2d689e6b2109c5f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a00a995d27bbcbd2d689e6b2109c5f7">registerAffineLoopNormalize</a> ()</td></tr>
<tr class="memitem:a4236d775d5a91ac5b0ef38691731e094" id="r_a4236d775d5a91ac5b0ef38691731e094"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4236d775d5a91ac5b0ef38691731e094">registerAffineLoopNormalizePass</a> ()</td></tr>
<tr class="memitem:aa9a6d401821f3cfd935015fd8141177b" id="r_aa9a6d401821f3cfd935015fd8141177b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9a6d401821f3cfd935015fd8141177b">registerAffineLoopTiling</a> ()</td></tr>
<tr class="memitem:a8882ecc60049ed23b3c0751891c057d0" id="r_a8882ecc60049ed23b3c0751891c057d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8882ecc60049ed23b3c0751891c057d0">registerAffineLoopTilingPass</a> ()</td></tr>
<tr class="memitem:a8d8a208bda536b1e2a5fa431610df88a" id="r_a8d8a208bda536b1e2a5fa431610df88a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8a208bda536b1e2a5fa431610df88a">registerAffineLoopUnroll</a> ()</td></tr>
<tr class="memitem:a1ad54915e40fda29c3eff8b1e36b51b7" id="r_a1ad54915e40fda29c3eff8b1e36b51b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ad54915e40fda29c3eff8b1e36b51b7">registerAffineLoopUnrollPass</a> ()</td></tr>
<tr class="memitem:aaff09c7d35877411a50d6762415ae1cc" id="r_aaff09c7d35877411a50d6762415ae1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaff09c7d35877411a50d6762415ae1cc">registerAffineLoopUnrollAndJam</a> ()</td></tr>
<tr class="memitem:ac148f829a3e3e995fd372401bb96c114" id="r_ac148f829a3e3e995fd372401bb96c114"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac148f829a3e3e995fd372401bb96c114">registerAffineLoopUnrollAndJamPass</a> ()</td></tr>
<tr class="memitem:a4a243fea66d6c538fa0f9b6658e72028" id="r_a4a243fea66d6c538fa0f9b6658e72028"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a243fea66d6c538fa0f9b6658e72028">registerAffineParallelize</a> ()</td></tr>
<tr class="memitem:a6bb3fe72efd2baf00c7543dd5fb72100" id="r_a6bb3fe72efd2baf00c7543dd5fb72100"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bb3fe72efd2baf00c7543dd5fb72100">registerAffineParallelizePass</a> ()</td></tr>
<tr class="memitem:ac1a043513a0546d69ac2b8291783a6a1" id="r_ac1a043513a0546d69ac2b8291783a6a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1a043513a0546d69ac2b8291783a6a1">registerAffinePipelineDataTransfer</a> ()</td></tr>
<tr class="memitem:acd39100953121f5eb93a5d3587fb7ed5" id="r_acd39100953121f5eb93a5d3587fb7ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd39100953121f5eb93a5d3587fb7ed5">registerAffinePipelineDataTransferPass</a> ()</td></tr>
<tr class="memitem:ac5f200b042e78f45c3b78b0961818a49" id="r_ac5f200b042e78f45c3b78b0961818a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f200b042e78f45c3b78b0961818a49">registerAffineScalarReplacement</a> ()</td></tr>
<tr class="memitem:a51a5d772e3b790133ba25f652b73c322" id="r_a51a5d772e3b790133ba25f652b73c322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a5d772e3b790133ba25f652b73c322">registerAffineScalarReplacementPass</a> ()</td></tr>
<tr class="memitem:a01aba474c7fcff4c99db616542187059" id="r_a01aba474c7fcff4c99db616542187059"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01aba474c7fcff4c99db616542187059">registerAffineVectorize</a> ()</td></tr>
<tr class="memitem:a0a774f563cf2f456f6c7d3dc7a5cc4b2" id="r_a0a774f563cf2f456f6c7d3dc7a5cc4b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a774f563cf2f456f6c7d3dc7a5cc4b2">registerAffineVectorizePass</a> ()</td></tr>
<tr class="memitem:a9817e27dc4c6db6b6850553e93af6de4" id="r_a9817e27dc4c6db6b6850553e93af6de4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9817e27dc4c6db6b6850553e93af6de4">registerLoopCoalescing</a> ()</td></tr>
<tr class="memitem:add5e6c6044cb533e13478794b2065b10" id="r_add5e6c6044cb533e13478794b2065b10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add5e6c6044cb533e13478794b2065b10">registerLoopCoalescingPass</a> ()</td></tr>
<tr class="memitem:a2c69ab9703862bb1d37351324c2d153e" id="r_a2c69ab9703862bb1d37351324c2d153e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c69ab9703862bb1d37351324c2d153e">registerRaiseMemrefDialect</a> ()</td></tr>
<tr class="memitem:a9d4f0e0e151c11aab70d1bb400f7a4ec" id="r_a9d4f0e0e151c11aab70d1bb400f7a4ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d4f0e0e151c11aab70d1bb400f7a4ec">registerRaiseMemrefDialectPass</a> ()</td></tr>
<tr class="memitem:ac5f4c0ea34e0c3d776523a03590f911f" id="r_ac5f4c0ea34e0c3d776523a03590f911f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5f4c0ea34e0c3d776523a03590f911f">registerSimplifyAffineMinMaxPass</a> ()</td></tr>
<tr class="memitem:a1a4947f104eccecabf3c2ce644ef0b18" id="r_a1a4947f104eccecabf3c2ce644ef0b18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4947f104eccecabf3c2ce644ef0b18">registerSimplifyAffineMinMaxPassPass</a> ()</td></tr>
<tr class="memitem:a0f3e0e5eaae45040a5b7821727629667" id="r_a0f3e0e5eaae45040a5b7821727629667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f3e0e5eaae45040a5b7821727629667">registerSimplifyAffineStructures</a> ()</td></tr>
<tr class="memitem:a6e14bbfae2229ed9a96634ef205f65f9" id="r_a6e14bbfae2229ed9a96634ef205f65f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e14bbfae2229ed9a96634ef205f65f9">registerSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memitem:ab376d73318fc0ea41cded4220f15fd94" id="r_ab376d73318fc0ea41cded4220f15fd94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab376d73318fc0ea41cded4220f15fd94">registerAffinePasses</a> ()</td></tr>
<tr class="memitem:a131df27a14db6c8a12e643fa2a0a5603" id="r_a131df27a14db6c8a12e643fa2a0a5603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a131df27a14db6c8a12e643fa2a0a5603">registerTransformDialectExtension</a> (<a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;registry)</td></tr>
<tr class="memitem:a5114cd1965e100b6f419e30ca42720f5" id="r_a5114cd1965e100b6f419e30ca42720f5"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5114cd1965e100b6f419e30ca42720f5">lowerAffineDelinearizeIndexOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineDelinearizeIndexOp op)</td></tr>
<tr class="memdesc:a5114cd1965e100b6f419e30ca42720f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers <span class="tt">affine.delinearize_index</span> into a sequence of division and remainder operations.  <br /></td></tr>
<tr class="memitem:a90391c4033121397ca4cb25888f8acfc" id="r_a90391c4033121397ca4cb25888f8acfc"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90391c4033121397ca4cb25888f8acfc">lowerAffineLinearizeIndexOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineLinearizeIndexOp op)</td></tr>
<tr class="memdesc:a90391c4033121397ca4cb25888f8acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers <span class="tt">affine.linearize_index</span> into a sequence of multiplications and additions.  <br /></td></tr>
<tr class="memitem:ad0254031e77bf59bb9352e139ce07540" id="r_ad0254031e77bf59bb9352e139ce07540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0254031e77bf59bb9352e139ce07540">populateAffineExpandIndexOpsPatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:ad0254031e77bf59bb9352e139ce07540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect).  <br /></td></tr>
<tr class="memitem:afb8bb2407dc150a9486edb551538afde" id="r_afb8bb2407dc150a9486edb551538afde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb8bb2407dc150a9486edb551538afde">populateAffineExpandIndexOpsAsAffinePatterns</a> (<a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;<a class="el" href="namespacemlir.html#a8789c71249b4fcc3059f4ba4a9d27f26">patterns</a>)</td></tr>
<tr class="memdesc:afb8bb2407dc150a9486edb551538afde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate patterns that expand affine index operations into their equivalent <span class="tt">affine.apply</span> representations.  <br /></td></tr>
<tr class="memitem:af183bca84d167ae145cb1eb3cb7ccaee" id="r_af183bca84d167ae145cb1eb3cb7ccaee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af183bca84d167ae145cb1eb3cb7ccaee">reorderOperandsByHoistability</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineApplyOp op)</td></tr>
<tr class="memdesc:af183bca84d167ae145cb1eb3cb7ccaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to rewrite <span class="tt">op</span>'s affine map and reorder its operands such that they are in increasing order of hoistability (i.e.  <br /></td></tr>
<tr class="memitem:a7a469c3be86c49c78459dd5cda4bd128" id="r_a7a469c3be86c49c78459dd5cda4bd128"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; AffineApplyOp &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a469c3be86c49c78459dd5cda4bd128">decompose</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineApplyOp op)</td></tr>
<tr class="memdesc:a7a469c3be86c49c78459dd5cda4bd128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split an "affine.apply" operation into smaller ops.  <br /></td></tr>
<tr class="memitem:a3c342c069f431842d231d674e90e2541" id="r_a3c342c069f431842d231d674e90e2541"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c342c069f431842d231d674e90e2541">reifyValueBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">ValueBoundsConstraintSet::Variable</a> &amp;var, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a3c342c069f431842d231d674e90e2541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the given variable in terms of SSA values for which <span class="tt">stopCondition</span> is met.  <br /></td></tr>
<tr class="memitem:a51a2845645fcfad9550c1ac55f33e632" id="r_a51a2845645fcfad9550c1ac55f33e632"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a2845645fcfad9550c1ac55f33e632">reifyIndexValueBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:a51a2845645fcfad9550c1ac55f33e632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the given index-typed value in terms of SSA values for which <span class="tt">stopCondition</span> is met.  <br /></td></tr>
<tr class="memitem:aeccde276863cb70af4a37c9be4c95f02" id="r_aeccde276863cb70af4a37c9be4c95f02"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccde276863cb70af4a37c9be4c95f02">reifyShapedValueDimBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a> type, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classint64__t.html">int64_t</a> dim, <a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a> stopCondition=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classbool.html">bool</a> closedUB=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>)</td></tr>
<tr class="memdesc:aeccde276863cb70af4a37c9be4c95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reify a bound for the specified dimension of the given shaped value in terms of SSA values for which <span class="tt">stopCondition</span> is met.  <br /></td></tr>
<tr class="memitem:ab359330f8474c6425f2343941b20c03b" id="r_ab359330f8474c6425f2343941b20c03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab359330f8474c6425f2343941b20c03b">materializeComputedBound</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> boundMap, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; &gt; mapOperands)</td></tr>
<tr class="memdesc:ab359330f8474c6425f2343941b20c03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize an already computed bound with Affine dialect ops.  <br /></td></tr>
<tr class="memitem:ac3d33a598ceba944409eed9c050cb32a" id="r_ac3d33a598ceba944409eed9c050cb32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3d33a598ceba944409eed9c050cb32a">simplifyAffineMinOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineMinOp op)</td></tr>
<tr class="memdesc:ac3d33a598ceba944409eed9c050cb32a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform tries to simplify the affine min operation <span class="tt">op</span>, by finding a common lower bound for a set of expressions in the affine map results.  <br /></td></tr>
<tr class="memitem:a0ef87e3d47ba2f545f09a0e7c8a05ab6" id="r_a0ef87e3d47ba2f545f09a0e7c8a05ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ef87e3d47ba2f545f09a0e7c8a05ab6">simplifyAffineMaxOp</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, AffineMaxOp op)</td></tr>
<tr class="memdesc:a0ef87e3d47ba2f545f09a0e7c8a05ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform tries to simplify the affine max operation <span class="tt">op</span>, by finding a common upper bound for a set of expressions in the affine map results.  <br /></td></tr>
<tr class="memitem:ac8ba5400dd55afc238cc0a85164da986" id="r_ac8ba5400dd55afc238cc0a85164da986"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ba5400dd55afc238cc0a85164da986">simplifyAffineMinMaxOps</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; ops, <a class="el" href="classbool.html">bool</a> *modified=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:ac8ba5400dd55afc238cc0a85164da986"><td class="mdescLeft">&#160;</td><td class="mdescRight">This transform applies <span class="tt">simplifyAffineMinOp</span> and <span class="tt">simplifyAffineMaxOp</span> to all the <span class="tt">affine.min</span> or <span class="tt">affine.max</span> operations in <span class="tt">ops</span>.  <br /></td></tr>
<tr class="memitem:a65c46d8d3632fed8f99f96ea54bbbc0f" id="r_a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65c46d8d3632fed8f99f96ea54bbbc0f">affineParallelize</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; parallelReductions={}, AffineParallelOp *resOp=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:a65c46d8d3632fed8f99f96ea54bbbc0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces a parallel affine.for op with a 1-d affine.parallel op.  <br /></td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d" id="r_ae989950373589c5cc01381c0febcee4d"><td class="memTemplParams" colspan="2">template&lt;typename EffectType, typename T&gt; </td></tr>
<tr class="memitem:ae989950373589c5cc01381c0febcee4d template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae989950373589c5cc01381c0febcee4d">hasNoInterveningEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *start, T memOp, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#a769670962602294d6480466fb4c81d16">mayAlias</a>)</td></tr>
<tr class="memdesc:ae989950373589c5cc01381c0febcee4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's.  <br /></td></tr>
<tr class="memitem:aab9523b9838e2a2f7b23d0f9953558f6" id="r_aab9523b9838e2a2f7b23d0f9953558f6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab9523b9838e2a2f7b23d0f9953558f6">mergeOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; producerStrides, const llvm::SmallBitVector &amp;droppedProducerDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerStrides, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedSizes, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedStrides)</td></tr>
<tr class="memdesc:aab9523b9838e2a2f7b23d0f9953558f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <span class="tt">combinedOffsets</span>, <span class="tt">combinedSizes</span> and <span class="tt">combinedStrides</span> to use when combining a producer slice <b>into</b> a consumer slice.  <br /></td></tr>
<tr class="memitem:ae7752d92fa12e20ac4b6a61942490ec8" id="r_ae7752d92fa12e20ac4b6a61942490ec8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7752d92fa12e20ac4b6a61942490ec8">mergeOffsetsSizesAndStrides</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, OffsetSizeAndStrideOpInterface producer, OffsetSizeAndStrideOpInterface consumer, const llvm::SmallBitVector &amp;droppedProducerDims, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedOffsets, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedSizes, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;combinedStrides)</td></tr>
<tr class="memdesc:ae7752d92fa12e20ac4b6a61942490ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills the <span class="tt">combinedOffsets</span>, <span class="tt">combinedSizes</span> and <span class="tt">combinedStrides</span> to use when combining a <span class="tt">producer</span> slice op <b>into</b> a <span class="tt">consumer</span> slice op.  <br /></td></tr>
<tr class="memitem:a829dd3c66cb0c7fd7fdab2f3a815bac2" id="r_a829dd3c66cb0c7fd7fdab2f3a815bac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a829dd3c66cb0c7fd7fdab2f3a815bac2">resolveIndicesIntoOpWithOffsetsAndStrides</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceStrides, const llvm::SmallBitVector &amp;rankReducedDims, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; consumerIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resolvedIndices)</td></tr>
<tr class="memdesc:a829dd3c66cb0c7fd7fdab2f3a815bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the 'consumerIndices' of a load/store operation operating on an op with offsets and strides, return the combined indices.  <br /></td></tr>
<tr class="memitem:a8f4081391a1f634fc8180a92f228534b" id="r_a8f4081391a1f634fc8180a92f228534b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f4081391a1f634fc8180a92f228534b">resolveIndicesIntoOpWithOffsetsAndStrides</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceOffsets, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mixedSourceStrides, const llvm::SmallBitVector &amp;rankReducedDims, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> consumerIndices, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;resolvedIndices)</td></tr>
<tr class="memitem:a077878ca8c3dd66d2989e3fbd1ad93a6" id="r_a077878ca8c3dd66d2989e3fbd1ad93a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a077878ca8c3dd66d2989e3fbd1ad93a6">resolveSizesIntoOpWithSizes</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; sourceSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; destSizes, const llvm::SmallBitVector &amp;rankReducedSourceDims, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;resolvedSizes)</td></tr>
<tr class="memdesc:a077878ca8c3dd66d2989e3fbd1ad93a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given <span class="tt">sourceSizes</span>, <span class="tt">destSizes</span> and information about which dimensions are dropped by the source: <span class="tt">rankReducedSourceDims</span>, compute the resolved sizes that correspond to dest_op(source_op).  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a7ac41cc03dea5e719278bacddd8f0829" name="a7ac41cc03dea5e719278bacddd8f0829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac41cc03dea5e719278bacddd8f0829">&#9670;&#160;</a></span>FilterFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a7ac41cc03dea5e719278bacddd8f0829">mlir::affine::FilterFunctionType</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that: </p>
<ol type="1">
<li>recursively matches a substructure in the tree;</li>
<li>uses a filter function to refine matches with extra semantic constraints (passed via a lambda of type <a class="el" href="#a7ac41cc03dea5e719278bacddd8f0829" title="A NestedPattern is a nested operation walker that:">FilterFunctionType</a>);</li>
<li>TODO: optionally applies actions (lambda).</li>
</ol>
<p>Nested patterns are meant to capture imperfectly nested loops while matching properties over the whole loop nest. For instance, in vectorization we are interested in capturing all the imperfectly nested loops of a certain type and such that all the load and stores have certain access patterns along the loops' induction variables). Such NestedMatches are first captured using the <span class="tt">match</span> function and are later processed to analyze properties and apply transformations in a non-greedy way.</p>
<p>The NestedMatches captured in the IR can grow large, especially after aggressive unrolling. As experience has shown, it is generally better to use a plain walk over operations to match flat patterns but the current implementation is competitive nonetheless. </p>

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00091">91</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a0e3d2cec8b9f06af928ef8b6fe719bc2" name="a0e3d2cec8b9f06af928ef8b6fe719bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">&#9670;&#160;</a></span>ReductionLoopMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">mlir::affine::ReductionLoopMap</a> = <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a>, 2&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00043">43</a> of file <a class="el" href="Dialect_2Affine_2Utils_8h_source.html">Utils.h</a>.</p>

</div>
</div>
<a id="a307b24b11d3236cad28c2a63938a2d38" name="a307b24b11d3236cad28c2a63938a2d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307b24b11d3236cad28c2a63938a2d38">&#9670;&#160;</a></span>VectorizableLoopFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a307b24b11d3236cad28c2a63938a2d38">mlir::affine::VectorizableLoopFun</a> = std::function&lt;<a class="el" href="classbool.html">bool</a>(AffineForOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8h_source.html#l00088">88</a> of file <a class="el" href="LoopAnalysis_8h_source.html">LoopAnalysis.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a955654b005f9ba55cfe8948a18593a1d" name="a955654b005f9ba55cfe8948a18593a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955654b005f9ba55cfe8948a18593a1d">&#9670;&#160;</a></span>FusionMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a955654b005f9ba55cfe8948a18593a1d">mlir::affine::FusionMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fusion mode to attempt. </p>
<p>The default mode <span class="tt">Greedy</span> does both producer-consumer and sibling fusion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6" name="a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6"></a>Greedy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1dad17c9ca2b9301ef3d0cccfa9b6baf7ad" name="a955654b005f9ba55cfe8948a18593a1dad17c9ca2b9301ef3d0cccfa9b6baf7ad"></a>ProducerConsumer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a955654b005f9ba55cfe8948a18593a1da0293acfd01e25304d05b1a7379cf3eb1" name="a955654b005f9ba55cfe8948a18593a1da0293acfd01e25304d05b1a7379cf3eb1"></a>Sibling&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l00035">35</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a46706cab45d0b917d5acff3ed72756c2" name="a46706cab45d0b917d5acff3ed72756c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46706cab45d0b917d5acff3ed72756c2">&#9670;&#160;</a></span>affineForOpBodySkew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineForOpBodySkew </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>shifts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>unrollPrologueEpilogue</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skew the operations in an affine.for's body with the specified operation-wise shifts. </p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied. If <span class="tt">unrollPrologueEpilogue</span> is set, fully unroll the prologue and epilogue loops when possible. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00230">230</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">mlir::applyOpPatternsGreedily()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00027">mlir::ExistingAndNewOps</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00175">generateShiftedLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00483">isOpwiseShiftValid()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a65c46d8d3632fed8f99f96ea54bbbc0f" name="a65c46d8d3632fed8f99f96ea54bbbc0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c46d8d3632fed8f99f96ea54bbbc0f">&#9670;&#160;</a></span>affineParallelize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::affineParallelize </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>parallelReductions</em></span><span class="paramdefsep"> = </span><span class="paramdefval">{}</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineParallelOp *</td>          <td class="paramname"><span class="paramname"><em>resOp</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces a parallel affine.for op with a 1-d affine.parallel op. </p>
<p><span class="tt">forOp</span>'s body is taken by the affine.parallel op and the former is erased. (mlir::isLoopParallel can be used to detect a parallel affine.for op.) The reductions specified in <span class="tt">parallelReductions</span> are also parallelized. Parallelization will fail in the presence of loop iteration arguments that are not listed in <span class="tt">parallelReductions</span>. <span class="tt">resOp</span> if non-null is set to the newly created affine.parallel op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00352">352</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Builders_8h_source.html#l00442">mlir::OpBuilder::getInsertionBlock()</a>, <a class="el" href="Builders_8h_source.html#l00445">mlir::OpBuilder::getInsertionPoint()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00350">mlir::Operation::getOperand()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00037">mlir::affine::LoopReduction::kind</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00237">mlir::Operation::setOperands()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00043">mlir::affine::LoopReduction::value</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="addef193d35d8d7990addced6bcb731c1" name="addef193d35d8d7990addced6bcb731c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addef193d35d8d7990addced6bcb731c1">&#9670;&#160;</a></span>boundCheckLoadOrStoreOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOpPointer&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::boundCheckLoadOrStoreOp </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOpPointer</td>          <td class="paramname"><span class="paramname"><em>loadOrStoreOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>emitError</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise. </p>
<p>Emits a diagnostic error (with location information) if emitError is true. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>.</p>

</div>
</div>
<a id="a0d2fe80f256b34a27f3f9fa0cce088a5" name="a0d2fe80f256b34a27f3f9fa0cce088a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2fe80f256b34a27f3f9fa0cce088a5">&#9670;&#160;</a></span>buildAffineLoopNest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a perfect nest of affine.for loops, i.e., each loop except the innermost one contains only another loop and a terminator. </p>
<p>The loops iterate from "lbs" to "ubs" with "steps". The body of the innermost loop is populated by calling "bodyBuilderFn" and providing it with an <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a>, a <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> and a list of loop induction variables. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03048">3048</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l03026">buildAffineLoopFromConstants()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02985">buildAffineLoopNestImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01646">mlir::linalg::GenerateLoopNest&lt; LoopTy &gt;::doit()</a>.</p>

</div>
</div>
<a id="a38de885fc72eb338a5ec53d1ab65630c" name="a38de885fc72eb338a5ec53d1ab65630c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38de885fc72eb338a5ec53d1ab65630c">&#9670;&#160;</a></span>buildAffineLoopNest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::buildAffineLoopNest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>lbs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>ubs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>steps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>bodyBuilderFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l03056">3056</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l03035">buildAffineLoopFromValues()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02985">buildAffineLoopNestImpl()</a>.</p>

</div>
</div>
<a id="af1b7ee261b2662fe2f0c257c9e04f3b6" name="af1b7ee261b2662fe2f0c257c9e04f3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b7ee261b2662fe2f0c257c9e04f3b6">&#9670;&#160;</a></span>buildSliceTripCountMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::buildSliceTripCountMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; *</td>          <td class="paramname"><span class="paramname"><em>tripCountMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a map 'tripCountMap' from AffineForOp to constant trip count for loop nest surrounding represented by slice loop bounds in 'slice'. </p>
<p>Returns true on success, false otherwise (if a non-constant trip count was encountered). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">1818</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">getConstDifference()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02938">getForInductionVarOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00574">getFusionComputeCost()</a>.</p>

</div>
</div>
<a id="ae3ab6f9e710bf9eb63bc8b3488c58631" name="ae3ab6f9e710bf9eb63bc8b3488c58631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ab6f9e710bf9eb63bc8b3488c58631">&#9670;&#160;</a></span>canFuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> mlir::affine::canFuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dstForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *</td>          <td class="paramname"><span class="paramname"><em>srcSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html">FusionStrategy</a></td>          <td class="paramname"><span class="paramname"><em>fusionStrategy</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="classmlir_1_1affine_1_1FusionStrategy.html#a996eae93c3d38b2b1f428661df7acc46a1c27f9e3417768eefe1bab13d6de5de6">FusionStrategy::Generic</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'. </p>
<p>Returns <a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> 'Success' if fusion of the src/dst loop nests is feasible (i.e. they are in the same block and dependences would not be violated). Otherwise returns a <a class="el" href="structmlir_1_1affine_1_1FusionResult.html">FusionResult</a> explaining why fusion is not feasible. NOTE: This function is not feature complete and should only be used in testing. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00248">248</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00034">mlir::affine::FusionResult::FailBlockDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00035">mlir::affine::FusionResult::FailFusionDependence</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00037">mlir::affine::FusionResult::FailIncorrectSlice</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00033">mlir::affine::FusionResult::FailPrecondition</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00171">gatherLoadsAndStores()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00060">mlir::affine::FusionStrategy::Generic</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00309">mlir::affine::SliceComputationResult::GenericFailure</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00133">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">getNumCommonSurroundingLoops()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00088">mlir::affine::FusionStrategy::getSiblingFusionMemRef()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00085">mlir::affine::FusionStrategy::getStrategy()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00308">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00065">mlir::affine::FusionStrategy::ProducerConsumer</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00071">mlir::affine::FusionStrategy::Sibling</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00032">mlir::affine::FusionResult::Success</a>, and <a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#ae1bf161ba038ce8ed38567be7adba786">mlir::affine::SliceComputationResult::value</a>.</p>

</div>
</div>
<a id="a691ff98dafcd40a555ea1d127b06c9c3" name="a691ff98dafcd40a555ea1d127b06c9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691ff98dafcd40a555ea1d127b06c9c3">&#9670;&#160;</a></span>canonicalizeMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::canonicalizeMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies both <span class="tt">map</span> and <span class="tt">operands</span> in-place so as to: </p>
<ol type="1">
<li>drop duplicate operands</li>
<li>drop unused dims and symbols from map</li>
<li>promote valid symbols to symbolic operands in case they appeared as dimensional operands</li>
<li>propagate constant operands and drop them </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01759">1759</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01509">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02663">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00508">mlir::affine::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="Loops_8cpp_source.html#l00038">makeCanonicalAffineApplies()</a>, <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">materializeComputedBound()</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">reorderOperandsByHoistability()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01275">replaceDimOrSym()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="a8b47f23151bd884a4ce93312f1499a02" name="a8b47f23151bd884a4ce93312f1499a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b47f23151bd884a4ce93312f1499a02">&#9670;&#160;</a></span>canonicalizeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::canonicalizeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *</td>          <td class="paramname"><span class="paramname"><em>set</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01764">1764</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01682">canonicalizeMapOrSetAndOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00203">mlir::affine::FlatAffineValueConstraints::addAffineIfOpDomain()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l02584">createSeparationCondition()</a>.</p>

</div>
</div>
<a id="a627f529204bbf5826df07986dc54aa5c" name="a627f529204bbf5826df07986dc54aa5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f529204bbf5826df07986dc54aa5c">&#9670;&#160;</a></span>checkMemrefAccessDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a> mlir::affine::checkMemrefAccessDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcAccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dstAccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>loopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>dependenceConstraints</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *</td>          <td class="paramname"><span class="paramname"><em>dependenceComponents</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>allowRAR</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">609</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00382">addOrderingConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00408">computeDirectionVector()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l01479">mlir::presburger::IntegerRelation::convertVarKind()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l04133">mlir::Operation::dump()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02740">mlir::presburger::IntegerRelation::dump()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00167">mlir::affine::DependenceResult::Failure</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::affine::MemRefAccess::getAccessRelation()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00275">getAffineAnalysisScope()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00320">getCommonBlockInAffineScope()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02428">mlir::presburger::IntegerRelation::getDomainSet()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00293">getNumCommonLoops()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00226">mlir::presburger::IntegerRelation::getNumDomainVars()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00163">mlir::presburger::PresburgerSpace::getRelationSpace()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00121">mlir::presburger::IntegerRelation::getSpace()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00165">mlir::affine::DependenceResult::HasDependence</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02545">mlir::presburger::IntegerRelation::inverse()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00695">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00284">mlir::presburger::PresburgerSpace::isUsingIds()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l02654">mlir::presburger::IntegerRelation::mergeAndCompose()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, <a class="el" href="IntegerRelation_8h_source.html#l00139">mlir::presburger::IntegerRelation::resetIds()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00356">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">computeSliceUnion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00697">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00575">hasCyclicDependence()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00520">isTilingValid()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">mayDependence()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a43ded6085da1a665f8c367bea35e77fc" name="a43ded6085da1a665f8c367bea35e77fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ded6085da1a665f8c367bea35e77fc">&#9670;&#160;</a></span>computeProduct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::computeProduct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>terms</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the product of <span class="tt">terms</span>, creating an <span class="tt">affine.apply</span> if any of them are non-constant values. </p>
<p>If any of <span class="tt">terms</span> is <span class="tt">nullptr</span>, return <span class="tt">nullptr</span>. </p>

</div>
</div>
<a id="a29213ed6d6cdad5cdd69bb66c6df863f" name="a29213ed6d6cdad5cdd69bb66c6df863f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29213ed6d6cdad5cdd69bb66c6df863f">&#9670;&#160;</a></span>computeSliceUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html">SliceComputationResult</a> mlir::affine::computeSliceUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>opsA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>opsB</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>loopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numCommonLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isBackwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *</td>          <td class="paramname"><span class="paramname"><em>sliceUnion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB', and then verifies if it is valid. </p>
<p>The parameter 'numCommonLoops' is the number of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice' is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a function of IVs and symbols of loop nest surrounding ops in 'opsB' at 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop nest surrounding ops in 'opsB', as a function of IVs and symbols of loop nest surrounding ops in 'opsA' at 'loopDepth'. Returns '<a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate 'failure' otherwise.</p>
<p>Returns '<a class="el" href="structmlir_1_1affine_1_1SliceComputationResult.html#a4ee39b3fde28b841ed203728087810e9aa85f3aac90ad660d5de9933c03cd26ef">SliceComputationResult::Success</a>' if union was computed correctly, an appropriate failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">1633</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01585">addMissingLoopIVBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01240">mlir::FlatLinearValueConstraints::areVarsAlignedWithOther()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00934">mlir::affine::ComputationSliceState::clearBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00306">mlir::affine::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00167">mlir::affine::DependenceResult::Failure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00309">mlir::affine::SliceComputationResult::GenericFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp.html#a420db562c84b0a026e92385cb33aaf6f">getContext()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01601">getInnermostCommonLoopDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">getNestingDepth()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00231">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00229">mlir::presburger::IntegerRelation::getNumLocalVars()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00308">mlir::affine::SliceComputationResult::IncorrectSliceFailure</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00331">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01036">mlir::affine::ComputationSliceState::isSliceValid()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01351">mlir::FlatLinearValueConstraints::mergeAndAlignVarsWithOther()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00307">mlir::affine::SliceComputationResult::Success</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00329">mlir::affine::ComputationSliceState::ubOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>, and <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01490">mlir::FlatLinearValueConstraints::unionBoundingBox()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00248">canFuseLoops()</a>.</p>

</div>
</div>
<a id="aea380e86b89f4c708beac838b978af47" name="aea380e86b89f4c708beac838b978af47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea380e86b89f4c708beac838b978af47">&#9670;&#160;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00097">97</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="a7ab146994c9d7fb84f7647b1c7f69623" name="a7ab146994c9d7fb84f7647b1c7f69623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab146994c9d7fb84f7647b1c7f69623">&#9670;&#160;</a></span>createAffineDataCopyGenerationPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>slowMemorySpace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>fastMemorySpace</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>tagMemorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>minDmaTransferSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1024</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>fastMemCapacityBytes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">std::numeric_limits&lt;uint64_t&gt;<a class="el" href="PolynomialApproximation_8cpp.html#acbcaffd2f4cbc4dd948549fd577631eb">::max</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations. </p>
<p>Generates copies for memref's living in 'slowMemorySpace' into newly created buffers in 'fastMemorySpace', and replaces memory operations to the former by the latter. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00089">89</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

</div>
</div>
<a id="ad3bc5ab2aa37a753081b1abb6ea6534e" name="ad3bc5ab2aa37a753081b1abb6ea6534e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3bc5ab2aa37a753081b1abb6ea6534e">&#9670;&#160;</a></span>createAffineExpandIndexOpsAsAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createAffineExpandIndexOpsAsAffinePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to expand affine index operations into affine.apply operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html#l00095">95</a> of file <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html">AffineExpandIndexOpsAsAffine.cpp</a>.</p>

</div>
</div>
<a id="ab6ffce291badfd37964dea394098ad7c" name="ab6ffce291badfd37964dea394098ad7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ffce291badfd37964dea394098ad7c">&#9670;&#160;</a></span>createAffineExpandIndexOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createAffineExpandIndexOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect). </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00235">235</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

</div>
</div>
<a id="a1e33a259b4d2b2ba16b25214cfd87b90" name="a1e33a259b4d2b2ba16b25214cfd87b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e33a259b4d2b2ba16b25214cfd87b90">&#9670;&#160;</a></span>createAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant operations out of affine loops. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00205">205</a> of file <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html">AffineLoopInvariantCodeMotion.cpp</a>.</p>

</div>
</div>
<a id="a3e7f7eb4ce92936880206456af175d60" name="a3e7f7eb4ce92936880206456af175d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e7f7eb4ce92936880206456af175d60">&#9670;&#160;</a></span>createAffineLoopNormalizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineLoopNormalizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>promoteSingleIter</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply normalization transformations to affine loop-like ops. </p>
<p>If <span class="tt">promoteSingleIter</span> is true, single iteration loops are promoted (i.e., the loop is replaced by its loop body). </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopNormalize_8cpp_source.html#l00053">53</a> of file <a class="el" href="AffineLoopNormalize_8cpp_source.html">AffineLoopNormalize.cpp</a>.</p>

</div>
</div>
<a id="afe2c60844cdcc6da96b39887426a7a73" name="afe2c60844cdcc6da96b39887426a7a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2c60844cdcc6da96b39887426a7a73">&#9670;&#160;</a></span>createAffineParallelize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::affine::createAffineParallelize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineParallelize_8cpp_source.html#l00765">765</a> of file <a class="el" href="AffineParallelize_8cpp_source.html">AffineParallelize.cpp</a>.</p>

</div>
</div>
<a id="a619a33bf9775f498ae3eb6126f8ac9e1" name="a619a33bf9775f498ae3eb6126f8ac9e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619a33bf9775f498ae3eb6126f8ac9e1">&#9670;&#160;</a></span>createAffineParallelize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::affine::createAffineParallelize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1AffineParallelizeOptions.html">AffineParallelizeOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineParallelize_8cpp_source.html#l00769">769</a> of file <a class="el" href="AffineParallelize_8cpp_source.html">AffineParallelize.cpp</a>.</p>

</div>
</div>
<a id="a83e11cb92c70ca20b767c8323d74c033" name="a83e11cb92c70ca20b767c8323d74c033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e11cb92c70ca20b767c8323d74c033">&#9670;&#160;</a></span>createAffineParallelizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineParallelizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert all parallel affine.for's into 1-d affine.parallel ops. </p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l00035">Greedy</a>.</p>

</div>
</div>
<a id="a0f1af7c53ffcf2175bed3528a5efd0d1" name="a0f1af7c53ffcf2175bed3528a5efd0d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1af7c53ffcf2175bed3528a5efd0d1">&#9670;&#160;</a></span>createAffineScalarReplacementPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createAffineScalarReplacementPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to replace affine memref accesses by scalars using store to load forwarding and redundant load elimination; consequently also eliminate dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="AffineScalarReplacement_8cpp_source.html#l00043">43</a> of file <a class="el" href="AffineScalarReplacement_8cpp_source.html">AffineScalarReplacement.cpp</a>.</p>

</div>
</div>
<a id="aa65f8449ec0c16cda685788e865265dc" name="aa65f8449ec0c16cda685788e865265dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65f8449ec0c16cda685788e865265dc">&#9670;&#160;</a></span>createAffineVectorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::affine::createAffineVectorize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00990">990</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a2f680ba9877f07ecc0c3ed9dab02a9a9" name="a2f680ba9877f07ecc0c3ed9dab02a9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f680ba9877f07ecc0c3ed9dab02a9a9">&#9670;&#160;</a></span>createAffineVectorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::affine::createAffineVectorize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1AffineVectorizeOptions.html">AffineVectorizeOptions</a></td>          <td class="paramname"><span class="paramname"><em>options</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SuperVectorize_8cpp_source.html#l00994">994</a> of file <a class="el" href="SuperVectorize_8cpp_source.html">SuperVectorize.cpp</a>.</p>

</div>
</div>
<a id="a31f454dd30258cafd177eee0de1562e1" name="a31f454dd30258cafd177eee0de1562e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f454dd30258cafd177eee0de1562e1">&#9670;&#160;</a></span>createLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms perfectly nested loops with independent bounds into a single loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopCoalescing_8cpp_source.html#l00048">48</a> of file <a class="el" href="LoopCoalescing_8cpp_source.html">LoopCoalescing.cpp</a>.</p>

</div>
</div>
<a id="a94bff65ed7d124cc37d8ef411947a9a3" name="a94bff65ed7d124cc37d8ef411947a9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bff65ed7d124cc37d8ef411947a9a3">&#9670;&#160;</a></span>createLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::affine::createLoopFusionPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>fastMemorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>localBufSizeThreshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>maximalFusion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="#a955654b005f9ba55cfe8948a18593a1d">FusionMode</a></td>          <td class="paramname"><span class="paramname"><em>fusionMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a955654b005f9ba55cfe8948a18593a1da01657b4c44acbd92a9bda8650c0e51a6">FusionMode::Greedy</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses affine loop nests at the top-level of the operation the pass is created on according to the type of fusion specified in <span class="tt">fusionMode</span>. </p>
<p>Buffers of size less than or equal to <span class="tt">localBufSizeThreshold</span> are promoted to memory space <span class="tt">fastMemorySpace</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l01556">1556</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="ad9180dd506c0f8b1a612dffadce18a93" name="ad9180dd506c0f8b1a612dffadce18a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9180dd506c0f8b1a612dffadce18a93">&#9670;&#160;</a></span>createLoopTilingPass() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload relying on pass options for initialization. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00083">83</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a9faf839f27abf73616bc2ba7ed28b8d9" name="a9faf839f27abf73616bc2ba7ed28b8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faf839f27abf73616bc2ba7ed28b8d9">&#9670;&#160;</a></span>createLoopTilingPass() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>cacheSizeBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform tiling on loop nests. </p>
<p>Creates a pass to perform loop tiling on all suitable loop nests of a Function. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00079">79</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="ace0e439a1d5a4a00345ebea914e51e36" name="ace0e439a1d5a4a00345ebea914e51e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0e439a1d5a4a00345ebea914e51e36">&#9670;&#160;</a></span>createLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::affine::createLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>unrollJamFactor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unroll jam pass to unroll jam by the specified factor. </p>
<p>A factor of -1 lets the pass use the default factor or the one on the command line if provided. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00073">73</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

</div>
</div>
<a id="a6ee39443c7af128fb1909ba34bbf3af9" name="a6ee39443c7af128fb1909ba34bbf3af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee39443c7af128fb1909ba34bbf3af9">&#9670;&#160;</a></span>createLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1InterfacePass.html">InterfacePass</a>&lt; FunctionOpInterface &gt; &gt; mlir::affine::createLoopUnrollPass </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>unrollUpToFactor</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classunsigned.html">unsigned</a>(AffineForOp)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>getUnrollFactor</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unrolling pass with the provided parameters. </p>
<p>'getUnrollFactor' is a function callback for clients to supply a function that computes an unroll factor - the callback takes precedence over unroll factors supplied through other means. If -1 is passed as the unrollFactor and no callback is provided, anything passed from the command-line (if at all) or the default unroll factor is used (LoopUnroll:kDefaultUnrollFactor). </p>

<p class="definition">Definition at line <a class="el" href="LoopUnroll_8cpp_source.html#l00146">146</a> of file <a class="el" href="LoopUnroll_8cpp_source.html">LoopUnroll.cpp</a>.</p>

</div>
</div>
<a id="ac9e0e21ed1bde4dca79b101c3d0dd7e8" name="ac9e0e21ed1bde4dca79b101c3d0dd7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e0e21ed1bde4dca79b101c3d0dd7e8">&#9670;&#160;</a></span>createPipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createPipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00054">54</a> of file <a class="el" href="PipelineDataTransfer_8cpp_source.html">PipelineDataTransfer.cpp</a>.</p>

</div>
</div>
<a id="a960e99ffd0051a74f6ab1007e7b1ced3" name="a960e99ffd0051a74f6ab1007e7b1ced3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960e99ffd0051a74f6ab1007e7b1ced3">&#9670;&#160;</a></span>createRaiseMemrefToAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createRaiseMemrefToAffine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that converts some memref operators to affine operators. </p>

<p class="definition">Definition at line <a class="el" href="RaiseMemrefDialect_8cpp_source.html#l00185">185</a> of file <a class="el" href="RaiseMemrefDialect_8cpp_source.html">RaiseMemrefDialect.cpp</a>.</p>

</div>
</div>
<a id="a827b38ee918833bfaaed1371b507db9e" name="a827b38ee918833bfaaed1371b507db9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827b38ee918833bfaaed1371b507db9e">&#9670;&#160;</a></span>createSimplifyAffineMinMaxPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt; mlir::affine::createSimplifyAffineMinMaxPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We declare an explicit private instantiation because <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class.">Pass</a> classes should only be visible by the current library. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l01194">1194</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

</div>
</div>
<a id="ac2d37c95eae4f6e48b8711d87e482138" name="ac2d37c95eae4f6e48b8711d87e482138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d37c95eae4f6e48b8711d87e482138">&#9670;&#160;</a></span>createSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a>&lt; func::FuncOp &gt; &gt; mlir::affine::createSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simplification pass for affine structures (maps and sets). </p>
<p>In addition, this pass also normalizes memrefs to have the trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00085">85</a> of file <a class="el" href="SimplifyAffineStructures_8cpp_source.html">SimplifyAffineStructures.cpp</a>.</p>

</div>
</div>
<a id="a7a469c3be86c49c78459dd5cda4bd128" name="a7a469c3be86c49c78459dd5cda4bd128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a469c3be86c49c78459dd5cda4bd128">&#9670;&#160;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; AffineApplyOp &gt; mlir::affine::decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineApplyOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split an "affine.apply" operation into smaller ops. </p>
<p>This reassociates a large AffineApplyOp into an ordered list of smaller AffineApplyOps. This can be used right before lowering affine ops to arith to exhibit more opportunities for CSE and LICM. Return the sink AffineApplyOp on success or failure if <span class="tt">op</span> does not decompose into smaller AffineApplyOps. Note that this can be undone by canonicalization which tries to maximally compose chains of AffineApplyOps. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00095">95</a> of file <a class="el" href="DecomposeAffineOps_8cpp_source.html">DecomposeAffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00041">mlir::Add</a>, <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00084">createSubApply()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00043">mlir::Mul</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, and <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>.</p>

</div>
</div>
<a id="aa7b53bee9c367aacba5fc65c40c8477c" name="aa7b53bee9c367aacba5fc65c40c8477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b53bee9c367aacba5fc65c40c8477c">&#9670;&#160;</a></span>defaultFilterFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::defaultFilterFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00092">92</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a1da42aec5ee59df08774d6d55982b59c" name="a1da42aec5ee59df08774d6d55982b59c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da42aec5ee59df08774d6d55982b59c">&#9670;&#160;</a></span>extractForInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::extractForInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>forInsts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of AffineForOps and places them in the output argument <span class="tt">ivs</span>. </p>
<p>Extracts the induction variables from a list of AffineForOps and returns them. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02962">2962</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l02263">getFullMemRefAsRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00772">tilePerfectlyNested()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00814">tilePerfectlyNestedParametric()</a>.</p>

</div>
</div>
<a id="a9a92b58f46c4e921cc3c899423b76a27" name="a9a92b58f46c4e921cc3c899423b76a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a92b58f46c4e921cc3c899423b76a27">&#9670;&#160;</a></span>extractInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::extractInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>affineOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of either AffineForOp or AffineParallelOp and places them in the output argument <span class="tt">ivs</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02969">2969</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

</div>
</div>
<a id="ae33ee1431de2b7e6802c9270b1ff60d1" name="ae33ee1431de2b7e6802c9270b1ff60d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33ee1431de2b7e6802c9270b1ff60d1">&#9670;&#160;</a></span>findInnermostCommonBlockInScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Block.html">Block</a> * mlir::affine::findInnermostCommonBlockInScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the innermost common <span class="tt"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></span> of <span class="tt">a</span> and <span class="tt">b</span> in the affine scope that <span class="tt">a</span> and <span class="tt">b</span> are part of. </p>
<p>Return nullptr if they belong to different affine scopes. Also, return nullptr if they do not have a common <span class="tt"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a></span> ancestor (for eg., when they are part of the <span class="tt">then</span> and <span class="tt">else</span> regions of an op that itself starts an affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02391">2391</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l00275">getAffineAnalysisScope()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

</div>
</div>
<a id="a89d2273335462b22fd078a52a6c687e7" name="a89d2273335462b22fd078a52a6c687e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d2273335462b22fd078a52a6c687e7">&#9670;&#160;</a></span>fullyComposeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::fullyComposeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an affine map <span class="tt">map</span> and its input <span class="tt">operands</span>, this method composes into <span class="tt">map</span>, maps of AffineApplyOps whose results are the values in <span class="tt">operands</span>, iteratively until no more of <span class="tt">operands</span> are the result of an AffineApplyOp. </p>
<p>When this function returns, <span class="tt">map</span> becomes the composed affine map, and each <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <span class="tt">operands</span> is guaranteed to be either a loop IV or a terminal symbol, i.e., a symbol defined at the top level or a block/function argument. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01400">1400</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, and <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01439">composeMultiResultAffineMap()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">fullyComposeAndComputeConstantDelta()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00508">mlir::affine::MemRefAccess::getAccessMap()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>.</p>

</div>
</div>
<a id="ab9717faebcbb497b46d259b26da55635" name="ab9717faebcbb497b46d259b26da55635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9717faebcbb497b46d259b26da55635">&#9670;&#160;</a></span>fullyComposeAndComputeConstantDelta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::affine::fullyComposeAndComputeConstantDelta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a constant delta of the given two values. </p>
<p>Return "failure" if we cannot determine a constant delta. <span class="tt">value1</span>/<span class="tt">value2</span> must be index-typed.</p>
<p>This function is similar to <span class="tt">ValueBoundsConstraintSet::computeConstantDistance</span>. To work around limitations in <span class="tt"><a class="el" href="classmlir_1_1FlatLinearConstraints.html" title="FlatLinearConstraints is an extension of IntegerPolyhedron.">FlatLinearConstraints</a></span>, this function fully composes <span class="tt">value1</span> and <span class="tt">value2</span> (if they are the result of affine.apply ops) before populating the constraint set. The folding/composing logic can see opportunities for simplifications that the constraint set implementation cannot see. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00169">169</a> of file <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00629">mlir::ValueBoundsConstraintSet::computeConstantBound()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00044">mlir::presburger::EQ</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Value_8h_source.html#l00108">mlir::Value::getContext()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00251">mlir::vector::isDisjointTransferIndices()</a>.</p>

</div>
</div>
<a id="a87fd816295937f98c409c06f1407d96e" name="a87fd816295937f98c409c06f1407d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87fd816295937f98c409c06f1407d96e">&#9670;&#160;</a></span>fuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::fuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dstForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isInnermostSiblingInsertionFusion</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fuses 'srcForOp' into 'dstForOp' with destination loop block insertion point and source slice loop bounds specified in 'srcSlice'. </p>
<p><span class="tt">isInnermostSiblingInsertionFusion</span> enables cleanup of &lsquo;srcForOp that is a single-iteration reduction loop being sibling-fused into a 'dstForOp&rsquo;. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">425</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">buildSliceTripCountMap()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01759">canonicalizeMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02938">getForInductionVarOwner()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01856">getSliceIterationCount()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00331">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02182">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="IRMapping_8h_source.html#l00058">mlir::IRMapping::lookupOrNull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">promoteIfSingleIteration()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00357">promoteSingleIterReductionLoop()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00329">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>.</p>

</div>
</div>
<a id="a3c01e230ac0a33fa2370a21e428e833e" name="a3c01e230ac0a33fa2370a21e428e833e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c01e230ac0a33fa2370a21e428e833e">&#9670;&#160;</a></span>gatherProducerConsumerMemrefs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::gatherProducerConsumerMemrefs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>srcOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>dstOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>producerConsumerMemrefs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'producerConsumerMemrefs' the memrefs involved in a producer-consumer dependence between write ops in 'srcOps' and read ops in 'dstOps'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00639">639</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00169">gatherProducerConsumerMemrefs()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="a8722fd9a0481c2680fd64fcb7fbbb583" name="a8722fd9a0481c2680fd64fcb7fbbb583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8722fd9a0481c2680fd64fcb7fbbb583">&#9670;&#160;</a></span>getAffineAnalysisScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::affine::getAffineAnalysisScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest region enclosing <span class="tt">op</span> that is held by a non-affine operation; <span class="tt">nullptr</span> if there is no such region. </p>
<p>This method is meant to be used by affine analysis methods (e.g. dependence analysis) which are only meaningful when performed among/between operations from the same analysis scope. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00275">275</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02391">findInnermostCommonBlockInScope()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a9085efe05b8bc0b7c3b4f643d70eb1e7" name="a9085efe05b8bc0b7c3b4f643d70eb1e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9085efe05b8bc0b7c3b4f643d70eb1e7">&#9670;&#160;</a></span>getAffineForIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getAffineForIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'loops' with IVs of the affine.for ops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one while not traversing outside of the surrounding affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">851</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02263">getFullMemRefAsRegion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00574">getFusionComputeCost()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01601">getInnermostCommonLoopDepth()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00088">getLastDependentOpInRange()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00336">mlir::affine::MemRefDependenceGraph::init()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">insertBackwardComputationSlice()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00063">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="a50b5b72a6baee24bfab9faebd198fe9b" name="a50b5b72a6baee24bfab9faebd198fe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b5b72a6baee24bfab9faebd198fe9b">&#9670;&#160;</a></span>getAffineIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getAffineIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ivs' with IVs of the surrounding affine.for and affine.parallel ops ordered from the outermost one to the innermost while not traversing outside of the surrounding affine scope. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02091">2091</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">getNumCommonSurroundingLoops()</a>.</p>

</div>
</div>
<a id="abf27d6cea1330a4ac809686a75c43d25" name="abf27d6cea1330a4ac809686a75c43d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27d6cea1330a4ac809686a75c43d25">&#9670;&#160;</a></span>getAffineParallelInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineParallelOp mlir::affine::getAffineParallelInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is among the induction variables of an AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02949">2949</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02930">isAffineParallelInductionVar()</a>.</p>

</div>
</div>
<a id="ad353c117f0a45543a77ef884704a7ff0" name="ad353c117f0a45543a77ef884704a7ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad353c117f0a45543a77ef884704a7ff0">&#9670;&#160;</a></span>getAffineScope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Region.html">Region</a> * mlir::affine::getAffineScope </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the closest region enclosing <span class="tt">op</span> that is held by an operation with trait <span class="tt">AffineScope</span>; <span class="tt">nullptr</span> if there is no such region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00265">265</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02012">mlir::affine::AffineDmaStartOp::verifyInvariantsImpl()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02148">mlir::affine::AffineDmaWaitOp::verifyInvariantsImpl()</a>.</p>

</div>
</div>
<a id="ab6cceed0c6debb9af0d3bd76c9ed52f4" name="ab6cceed0c6debb9af0d3bd76c9ed52f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6cceed0c6debb9af0d3bd76c9ed52f4">&#9670;&#160;</a></span>getComputationSliceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getComputationSliceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>depSourceOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>depSinkOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dependenceConstraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>loopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isBackwardSlice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *</td>          <td class="paramname"><span class="paramname"><em>sliceState</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'. </p>
<p>If 'isBackwardSlice' is true, a backwards slice is computed in which the slice bounds of loop nest surrounding 'depSourceAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess' at 'loopDepth'. If 'isBackwardSlice' is false, a forward slice is computed in which the slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at 'loopDepth'. The slice loop bounds and associated operands are returned in 'sliceState'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">1870</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">getAffineForIVs()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02191">getSequentialLoops()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01856">getSliceIterationCount()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00364">mlir::FlatLinearValueConstraints::getValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00331">mlir::affine::ComputationSliceState::insertPoint</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02182">isLoopParallelAndContainsReduction()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01106">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00321">mlir::affine::ComputationSliceState::ivs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01865">kSliceFusionBarrierAttrName</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01482">mlir::FlatLinearValueConstraints::projectOut()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00329">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a6e97fc7b7a01938ada405a335e7961a7" name="a6e97fc7b7a01938ada405a335e7961a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e97fc7b7a01938ada405a335e7961a7">&#9670;&#160;</a></span>getComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::affine::getComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total cost of the loop nest rooted at 'forOp' using 'stats'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00563">563</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00527">getComputeCostHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a03531487e4feec545babe224a2f9b671" name="a03531487e4feec545babe224a2f9b671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03531487e4feec545babe224a2f9b671">&#9670;&#160;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::affine::getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop if it's a constant, std::nullopt otherwise. </p>
<p>This uses affine expression analysis and is able to determine constant trip count in non-trivial cases.</p>
<p>This method uses affine expression analysis (in turn using getTripCount) and is able to determine constant trip count in non-trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">216</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">getTripCountMapAndOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00089">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00230">affineForOpBodySkew()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">buildSliceTripCountMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00474">getLoopNestStats()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01061">loopUnrollJamUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00886">loopUnrollUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">promoteIfSingleIteration()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00357">promoteSingleIterReductionLoop()</a>.</p>

</div>
</div>
<a id="a79027d97c42b5b7d7f7f06529719117a" name="a79027d97c42b5b7d7f7f06529719117a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79027d97c42b5b7d7f7f06529719117a">&#9670;&#160;</a></span>getDependenceComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getDependenceComponents </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>maxLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1affine_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>depCompsVec</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth]. </p>
<p>Gathers dependence components for dependences between all ops in loop nest rooted at 'forOp' at loop depths in range [1, maxLoopDepth]. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00697">697</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">checkMemrefAccessDependence()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00181">hasDependence()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01336">isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01453">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a1f8e59ec9faff34b64ebb0411a383c3a" name="a1f8e59ec9faff34b64ebb0411a383c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8e59ec9faff34b64ebb0411a383c3a">&#9670;&#160;</a></span>getEnclosingAffineOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getEnclosingAffineOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'ops' with affine operations enclosing <span class="tt">op</span> ordered from outermost to innermost while stopping at the boundary of the affine scope. </p>
<p>affine.for, affine.if, or affine.parallel ops comprise such surrounding affine ops. <span class="tt">ops</span> is guaranteed by design to have a successive chain of affine parent ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00865">865</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01764">findHighestBlockForPlacement()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00283">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a483c308ea389d0ce4b47ef74a252b14e" name="a483c308ea389d0ce4b47ef74a252b14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483c308ea389d0ce4b47ef74a252b14e">&#9670;&#160;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02938">2938</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00154">mlir::affine::FlatAffineValueConstraints::addDomainFromSliceMaps()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01585">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00246">mlir::affine::FlatAffineValueConstraints::addSliceBounds()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00306">mlir::affine::FlatAffineValueConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00659">getLargestKnownDivisor()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00749">getLowerBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00293">getNumCommonLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00882">mlir::affine::ComputationSliceState::getSourceAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00757">getUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02926">isAffineForInductionVar()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01106">mlir::affine::ComputationSliceState::isMaximal()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00697">isNonNegativeBoundedBy()</a>, and <a class="el" href="SuperVectorize_8cpp_source.html#l01097">isUniformDefinition()</a>.</p>

</div>
</div>
<a id="a27b764a0cf88a53b85f7149423277f12" name="a27b764a0cf88a53b85f7149423277f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b764a0cf88a53b85f7149423277f12">&#9670;&#160;</a></span>getFusionComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::getFusionComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>srcForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcStats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>dstForOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dstStats</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>slice</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>computeCost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. Returns true on success, failure otherwise (e.g. non-constant trip counts).</p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00574">574</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">buildSliceTripCountMap()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">getAffineForIVs()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00527">getComputeCostHelper()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01856">getSliceIterationCount()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00331">mlir::affine::ComputationSliceState::insertPoint</a>.</p>

</div>
</div>
<a id="a320102486b693e875ebb36f63c3bfc51" name="a320102486b693e875ebb36f63c3bfc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320102486b693e875ebb36f63c3bfc51">&#9670;&#160;</a></span>getIndexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getIndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a system of constraints with dimensional variables corresponding to the loop IVs of the forOps and AffineIfOp's operands appearing in that order. </p>
<p>Bounds of the loop are used to add appropriate inequalities. Constraints from the index sets of AffineIfOp are also added. Any symbols founds in the bound operands are added as symbols in the system. Returns failure for the yet unimplemented cases. <span class="tt">ops</span> accepts both AffineForOp and AffineIfOp. </p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00363">checkIfHyperRectangular()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02665">createFullTiles()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l02584">createSeparationCondition()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00283">getOpIndexSet()</a>.</p>

</div>
</div>
<a id="a9cc3df9a0cea6ad3bf48958ad2d54128" name="a9cc3df9a0cea6ad3bf48958ad2d54128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc3df9a0cea6ad3bf48958ad2d54128">&#9670;&#160;</a></span>getInnermostCommonLoopDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::affine::getInnermostCommonLoopDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *</td>          <td class="paramname"><span class="paramname"><em>surroundingLoops</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the innermost common loop depth for the set of operations in 'ops'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01601">1601</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">getAffineForIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">computeSliceUnion()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="ac5e109cfdab6f0859fbbc3e0bf08ebac" name="ac5e109cfdab6f0859fbbc3e0bf08ebac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5e109cfdab6f0859fbbc3e0bf08ebac">&#9670;&#160;</a></span>getIntOrFloatMemRefSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; mlir::affine::getIntOrFloatMemRefSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>memRefType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of a memref with element type int or float in bytes if it's statically shaped, std::nullopt otherwise. </p>
<p>Returns the size of memref data in bytes if it's statically shaped, std::nullopt otherwise.</p>
<p>If the element of the memref has vector type, takes into account size of the vector as well. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01463">1463</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">getMemRefIntOrFloatEltSizeInBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01947">generateCopy()</a>.</p>

</div>
</div>
<a id="a4225805ce5c9b30cced3e7ca2adc8d55" name="a4225805ce5c9b30cced3e7ca2adc8d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4225805ce5c9b30cced3e7ca2adc8d55">&#9670;&#160;</a></span>getInvariantAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a4aa33aa05f4fcff8a40613b43fb06f01">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::affine::getInvariantAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an induction variable <span class="tt">iv</span> of type AffineForOp and <span class="tt">indices</span> of type IndexType, returns the set of <span class="tt">indices</span> that are independent of <span class="tt">iv</span>. </p>
<p>Prerequisites (inherited from <span class="tt">isAccessInvariant</span> above):</p><ol type="1">
<li><span class="tt">iv</span> and <span class="tt">indices</span> of the proper type;</li>
<li>at most one affine.apply is reachable from each index in <span class="tt">indices</span>;</li>
</ol>
<p>Emits a note if it encounters a chain of affine.apply and conservatively those cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00308">308</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00282">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01185">isIVMappedToMultipleIndices()</a>, and <a class="el" href="VectorUtils_8cpp_source.html#l00124">makePermutationMap()</a>.</p>

</div>
</div>
<a id="a93c2752858f86e707624c0702a16d2d2" name="a93c2752858f86e707624c0702a16d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c2752858f86e707624c0702a16d2d2">&#9670;&#160;</a></span>getLargestDivisorOfTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affine::getLargestDivisorOfTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest known integral divisor of the trip count. </p>
<p>Affine expression analysis is used (indirectly through getTripCount), and this method is thus able to determine non-trivial divisors. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">243</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">getTripCountMapAndOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="aa7270aca023f828cb4e8893705de7e0b" name="aa7270aca023f828cb4e8893705de7e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7270aca023f828cb4e8893705de7e0b">&#9670;&#160;</a></span>getLoopNestStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::getLoopNestStats </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOpRoot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1LoopNestStats.html">LoopNestStats</a> *</td>          <td class="paramname"><span class="paramname"><em>stats</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect loop nest statistics (eg. </p>
<p>loop trip count and operation count) in 'stats' for loop nest rooted at 'forOp'. Returns true on success, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00474">474</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00127">mlir::affine::LoopNestStats::loopMap</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00129">mlir::affine::LoopNestStats::opCountMap</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00131">mlir::affine::LoopNestStats::tripCountMap</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a93666d2fb7a3b0598ecf69542f1a5ab7" name="a93666d2fb7a3b0598ecf69542f1a5ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93666d2fb7a3b0598ecf69542f1a5ab7">&#9670;&#160;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::affine::getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02173">2173</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00500">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="afd9e0f536b1471778961ba51c2227f07" name="afd9e0f536b1471778961ba51c2227f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e0f536b1471778961ba51c2227f07">&#9670;&#160;</a></span>getMemRefIntOrFloatEltSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; mlir::affine::getMemRefIntOrFloatEltSizeInBytes </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>memRefType</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the memref's element type's size in bytes where the elemental type is an int or float or a vector of such types. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01419">1419</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00333">createPrivateMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01463">getIntOrFloatMemRefSizeInBytes()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01438">mlir::affine::MemRefRegion::getRegionSize()</a>.</p>

</div>
</div>
<a id="ac82ec61d5cae9ebb4489d2ab9ad6e8f8" name="ac82ec61d5cae9ebb4489d2ab9ad6e8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac82ec61d5cae9ebb4489d2ab9ad6e8f8">&#9670;&#160;</a></span>getNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::affine::getNestingDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation. </p>
<p>Returns the nesting depth of this statement, i.e., the number of loops surrounding this statement. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">2063</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">computeSliceUnion()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02124">getMemoryFootprintBytes()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00575">hasCyclicDependence()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">mayDependence()</a>.</p>

</div>
</div>
<a id="a3a39bbf8628440572cdd76a10d58dc53" name="a3a39bbf8628440572cdd76a10d58dc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a39bbf8628440572cdd76a10d58dc53">&#9670;&#160;</a></span>getNumCommonSurroundingLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::affine::getNumCommonSurroundingLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of surrounding loops common to both A and B. </p>
<p>Returns the number of surrounding loops common to 'loopsA' and 'loopsB', where each lists loops from outer-most to inner-most in loop nest. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">2108</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02091">getAffineIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00248">canFuseLoops()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00575">hasCyclicDependence()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">hasNoInterveningEffect()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="a3fdd1212128e826d76abbe85a61742b7" name="a3fdd1212128e826d76abbe85a61742b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdd1212128e826d76abbe85a61742b7">&#9670;&#160;</a></span>getPerfectlyNestedLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nestedLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>root</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00856">856</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00064">getTopLevelTileableBands()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01453">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a77346d5ef6933117f2eeb04d320b1745" name="a77346d5ef6933117f2eeb04d320b1745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77346d5ef6933117f2eeb04d320b1745">&#9670;&#160;</a></span>getReachableAffineApplyOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getReachableAffineApplyOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>affineApplyOps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <span class="tt">affineApplyOps</span>, the sequence of those AffineApplyOp Operations that are reachable via a search starting from <span class="tt">operands</span> and ending at those operands that are not the result of an AffineApplyOp. </p>

</div>
</div>
<a id="a9722cddbbf47c30fa4f5f4d0ed39f7ab" name="a9722cddbbf47c30fa4f5f4d0ed39f7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9722cddbbf47c30fa4f5f4d0ed39f7ab">&#9670;&#160;</a></span>getRelationFromMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rel</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a relation from the given AffineMap/AffineValueMap <span class="tt">map</span>, containing all pairs of the form <span class="tt">operands -&gt; result</span> that satisfy <span class="tt">map</span>. </p>
<p><span class="tt">rel</span> is set to the relation built. For example, give the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a>:</p>
<p>(d0, d1)[s0] -&gt; (d0 + s0, d0 - s0)</p>
<p>the resulting relation formed is:</p>
<p>(d0, d1) -&gt; (r1, r2) [d0 d1 r1 r2 s0 const] 1 0 -1 0 1 0 = 0 0 1 0 -1 -1 0 = 0</p>
<p>For <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes.">AffineValueMap</a>, the domain and symbols have <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> set corresponding to the <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <span class="tt">map</span>. Returns failure if the <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> could not be flattened (i.e., semi-affine is not yet handled). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00498">498</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00364">mlir::presburger::IntegerRelation::addEquality()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00191">mlir::getFlattenedAffineExprs()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00231">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00435">mlir::FlatLinearValueConstraints::setValue()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00458">mlir::affine::MemRefAccess::getAccessRelation()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l00538">getRelationFromMap()</a>.</p>

</div>
</div>
<a id="ab216bbb57cc8cdf47c2cd1e4670adbc2" name="ab216bbb57cc8cdf47c2cd1e4670adbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab216bbb57cc8cdf47c2cd1e4670adbc2">&#9670;&#160;</a></span>getRelationFromMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::getRelationFromMap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">presburger::IntegerRelation</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rel</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00538">538</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00231">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00228">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00102">mlir::affine::AffineValueMap::getOperand()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00498">getRelationFromMap()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00067">mlir::presburger::IntegerRelation::setId()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a5ad383995f97dc30a0d6891e33fd499a" name="a5ad383995f97dc30a0d6891e33fd499a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad383995f97dc30a0d6891e33fd499a">&#9670;&#160;</a></span>getSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *</td>          <td class="paramname"><span class="paramname"><em>sequentialLoops</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02191">2191</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="acfb5cde2210f8126b02cd84843a0c43b" name="acfb5cde2210f8126b02cd84843a0c43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb5cde2210f8126b02cd84843a0c43b">&#9670;&#160;</a></span>getSliceIterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affine::getSliceIterationCount </td>
          <td>(</td>
          <td class="paramtype">const llvm::SmallDenseMap&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, uint64_t, 8 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sliceTripCountMap</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of iterations for the <span class="tt">slicetripCountMap</span> provided. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01856">1856</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>, and <a class="el" href="LoopFusionUtils_8cpp_source.html#l00574">getFusionComputeCost()</a>.</p>

</div>
</div>
<a id="a5d5e2d802af8800beea28156d1604091" name="a5d5e2d802af8800beea28156d1604091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5e2d802af8800beea28156d1604091">&#9670;&#160;</a></span>getSupportedReductions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getSupportedReductions </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="structmlir_1_1affine_1_1LoopReduction.html">LoopReduction</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>supportedReductions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate <span class="tt">supportedReductions</span> with descriptors of the supported reductions. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00083">83</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00040">getSupportedReduction()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a544bc2c1d4dc4d79bac4cb89321cbe09" name="a544bc2c1d4dc4d79bac4cb89321cbe09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544bc2c1d4dc4d79bac4cb89321cbe09">&#9670;&#160;</a></span>getTripCountMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::getTripCountMapAndOperands </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *</td>          <td class="paramname"><span class="paramname"><em>tripCountMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>tripCountOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise. </p>
<p>Returns the trip count of the loop as an affine expression if the latter is expressible as an affine expression, and nullptr otherwise.</p>
<p>This method always succeeds as long as the lower bound is not a multi-result map. The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions</p>
<p>The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00166">166</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01006">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00036">mlir::affine::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00110">mlir::affine::AffineValueMap::getAffineMap()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00124">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00077">mlir::affine::AffineValueMap::getNumResults()</a>, <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>, <a class="el" href="AffineValueMap_8h_source.html#l00073">mlir::affine::AffineValueMap::getResult()</a>, and <a class="el" href="AffineValueMap_8h_source.html#l00072">mlir::affine::AffineValueMap::setResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00045">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">getLargestDivisorOfTripCount()</a>.</p>

</div>
</div>
<a id="ae20aaeff227a5723102c54a6a88bedd5" name="ae20aaeff227a5723102c54a6a88bedd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20aaeff227a5723102c54a6a88bedd5">&#9670;&#160;</a></span>hasCyclicDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::hasCyclicDependence </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>root</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the affine nest rooted at <span class="tt">root</span> has a cyclic dependence among its affine memory accesses. </p>
<p>The dependence could be through any dependences carried by loops contained in <span class="tt">root</span> (inclusive of <span class="tt">root</span>) and those carried by loop bodies (blocks) contained. Dependences carried by loops outer to <span class="tt">root</span> aren't relevant. This method doesn't consider/account for aliases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00575">575</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">getNestingDepth()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">getNumCommonSurroundingLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00187">noDependence()</a>.</p>

</div>
</div>
<a id="ab2d96430280537a906b65fe1e2184447" name="ab2d96430280537a906b65fe1e2184447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d96430280537a906b65fe1e2184447">&#9670;&#160;</a></span>hasDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::hasDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to a dependence result. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00181">181</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8h_source.html#l00165">mlir::affine::DependenceResult::HasDependence</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00697">getDependenceComponents()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00187">getMaxLoopDepth()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00520">isTilingValid()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>.</p>

</div>
</div>
<a id="ae989950373589c5cc01381c0febcee4d" name="ae989950373589c5cc01381c0febcee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae989950373589c5cc01381c0febcee4d">&#9670;&#160;</a></span>hasNoInterveningEffect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EffectType, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::hasNoInterveningEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>memOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>mayAlias</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hoists out affine.if/else to as high as possible, i.e., past all invariant affine.fors/parallel's. </p>
<p>Returns success if any hoisting happened; folded` is / set to true if the op was folded or erased. This hoisting could lead to / significant code expansion in some cases. LogicalResult hoistAffineIfOp(AffineIfOp ifOp, bool *folded = nullptr);</p>
<p>/ Holds parameters to perform n-D vectorization on a single loop nest. / For example, for the following loop nest: / / func @vec2d(in: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>, out: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>) { / affine.for i0 = 0 to 64 { / affine.for i1 = 0 to 128 { / affine.for i2 = 0 to 512 { / ld = affine.load in[i0, i1, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a> / affine.store ld, out[i0, i1, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a> / } / } / } / return / } / / and VectorizationStrategy = 'vectorSizes = {8, 4}', 'loopToVectorDim = / {{i1-&gt;0}, {i2-&gt;1}}', SuperVectorizer will generate: / / func @vec2d(arg0: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>, arg1: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>) { / affine.for arg2 = 0 to 64 { / affine.for arg3 = 0 to 128 step 8 { / affine.for arg4 = 0 to 512 step 4 { / cst = arith.constant 0.000000e+00 : f32 / %0 = vector.transfer_read arg0[arg2, arg3, arg4], cst : ... / vector.transfer_write %0, arg1[arg2, arg3, arg4] : ... / } / } / } / return / } TODO: Hoist to a VectorizationStrategy.cpp when appropriate. struct VectorizationStrategy { Vectorization factors to apply to each target vector dimension. Each factor will be applied to a different loop. <a class="el" href="classllvm_1_1SmallVector.html">SmallVector&lt;int64_t, 8&gt;</a> vectorSizes; Maps each AffineForOp vectorization candidate with its vector dimension. The candidate will be vectorized using the vectorization factor in 'vectorSizes' for that dimension. <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap&lt;Operation *, unsigned&gt;</a> loopToVectorDim; Maps loops that implement vectorizable reductions to the corresponding reduction descriptors. <a class="el" href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap</a> reductionLoops; };</p>
<p>/ Replace affine store and load accesses by scalars by forwarding stores to / loads and eliminate invariant affine loads; consequently, eliminate dead / allocs. void affineScalarReplace(func::FuncOp f, DominanceInfo &amp;domInfo,
                         PostDominanceInfo &amp;postDomInfo,
                         AliasAnalysis &amp;analysis);</p>
<p>/ Vectorizes affine loops in 'loops' using the n-D vectorization factors in / 'vectorSizes'. By default, each vectorization factor is applied / inner-to-outer to the loops of each loop nest. 'fastestVaryingPattern' can / be optionally used to provide a different loop vectorization order. / If <span class="tt">reductionLoops</span> is not empty, the given reduction loops may be / vectorized along the reduction dimension. / TODO: Vectorizing reductions is supported only for 1-D vectorization. void vectorizeAffineLoops( <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *parentOp, <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet&lt;Operation *, DenseMapInfo&lt;Operation *&gt;&gt;</a> &amp;loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> vectorSizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;int64_t&gt;</a> fastestVaryingPattern, const <a class="el" href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap</a> &amp;reductionLoops = <a class="el" href="#a0e3d2cec8b9f06af928ef8b6fe719bc2">ReductionLoopMap()</a>);</p>
<p>/ External utility to vectorize affine loops from a single loop nest using an / n-D vectorization strategy (see doc in VectorizationStrategy definition). / <a class="el" href="namespacemlir.html#aed48aeaaa3484827b729cced4fb0dfb6" title="Tile a nest of standard for loops rooted at rootForOp by finding such parametric tile sizes that the ...">Loops</a> are provided in a 2D vector container. The first dimension represents / the nesting level relative to the loops to be vectorized. The second / dimension contains the loops. This means that: / a) every loop in 'loops[i]' must have a parent loop in 'loops[i-1]', / b) a loop in 'loops[i]' may or may not have a child loop in 'loops[i+1]'. / / For example, for the following loop nest: / / func @vec2d(in0: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>, in1: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x128xf32&gt;</a>, / out0: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a>, / out1: <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x128xf32&gt;</a>) { / affine.for i0 = 0 to 64 { / affine.for i1 = 0 to 128 { / affine.for i2 = 0 to 512 { / ld = affine.load in0[i0, i1, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a> / affine.store ld, out0[i0, i1, i2] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x512xf32&gt;</a> / } / affine.for i3 = 0 to 128 { / ld = affine.load in1[i0, i1, i3] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x128xf32&gt;</a> / affine.store ld, out1[i0, i1, i3] : <a class="el" href="namespacemlir_1_1memref.html">memref&lt;64x128x128xf32&gt;</a> / } / } / } / return / } / / loops = {{i0}, {i2, i3}}, to vectorize the outermost and the two / innermost loops; / loops = {{i1}, {i2, i3}}, to vectorize the middle and the two innermost / loops; / loops = {{i2}}, to vectorize only the first innermost loop; / loops = {{i3}}, to vectorize only the second innermost loop; / loops = {{i1}}, to vectorize only the middle loop. LogicalResult vectorizeAffineLoopNest(std::vector&lt;SmallVector&lt;AffineForOp, 2&gt;&gt; &amp;loops,
                        const VectorizationStrategy &amp;strategy);</p>
<p>/ Normalize a affine.parallel op so that lower bounds are 0 and steps are 1. / As currently implemented, this transformation cannot fail and will return / early if the op is already in a normalized form. void normalizeAffineParallel(AffineParallelOp op);</p>
<p>/ Normalize an affine.for op. An affine.for op is normalized by converting the / lower bound to zero and loop step to one. The upper bound is set to the trip / count of the loop. Original loops must have a lower bound with only a single / result. There is no such restriction on upper bounds. Returns success if the / loop has been normalized (or is already in the normal form). If / <span class="tt">promoteSingleIter</span> is true, the loop is simply promoted if it has a single / iteration. LogicalResult normalizeAffineFor(AffineForOp op, bool promoteSingleIter = false);</p>
<p>/ Traverse <span class="tt">e</span> and return an <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> where all occurrences of <span class="tt">dim</span> have / been replaced by either: / - <span class="tt">min</span> if <span class="tt">positivePath</span> is true when we reach an occurrence of <span class="tt">dim</span> / - <span class="tt">max</span> if <span class="tt">positivePath</span> is true when we reach an occurrence of <span class="tt">dim</span> / <span class="tt">positivePath</span> is negated each time we hit a multiplicative or divisive / binary op with a constant negative coefficient. <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> substWithMin(<a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> e, <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> dim, <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> min, <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> max, bool positivePath = true);</p>
<p>/ Replaces all "dereferencing" uses of <span class="tt">oldMemRef</span> with <span class="tt">newMemRef</span> while / optionally remapping the old memref's indices using the supplied affine map, / <span class="tt">indexRemap</span>. The new memref could be of a different shape or rank. / <span class="tt">extraIndices</span> provides any additional access indices to be added to the / start. / / <span class="tt">indexRemap</span> remaps indices of the old memref access to a new set of indices / that are used to index the memref. Additional input operands to indexRemap / can be optionally provided in <span class="tt">extraOperands</span>, and they occupy the start / of its input list. <span class="tt">indexRemap</span>'s dimensional inputs are expected to / correspond to memref's indices, and its symbolic inputs if any should be / provided in <span class="tt">symbolOperands</span>.</p>
<p>/ If <span class="tt">userFilterFn</span> is specified, restrict replacement to only those users / that pass the specified filter (i.e., the filter returns true). / / 'allowNonDereferencingOps', if set, allows replacement of non-dereferencing / uses of a memref without any requirement for access index rewrites as long / as the user operation has the MemRefsNormalizable trait. The default value / of this flag is false. / / 'replaceInDeallocOp', if set, lets DeallocOp, a non-dereferencing user, to / also be a candidate for replacement. The default value of this flag is / false. / / Returns true on success and false if the replacement is not possible, / whenever a memref is used as an operand in a non-dereferencing context and / 'allowNonDereferencingOps' is false, except for dealloc's on the memref / which are left untouched. See comments at function definition for an / example.</p>
<p>Ex: to replace load A[i, j] with load Abuf[t mod 2, ii - i, j]: The SSA value corresponding to 't mod 2' should be in 'extraIndices', and index remap will perform (i, j) -&gt; (ii - i, j), i.e., indexRemap = (d0, d1, d2) -&gt; (d0 - d1, d2), and ii will be the extra operand. Without any extra operands, note that 'indexRemap' would just be applied to existing indices (i, j).</p>
<p>TODO: allow extraIndices to be added at any position. LogicalResult replaceAllMemRefUsesWith( <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> extraIndices = {}, <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> indexRemap = AffineMap(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> extraOperands = {}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> symbolOperands = {}, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref&lt;bool(Operation *)&gt;</a> userFilterFn = nullptr, bool allowNonDereferencingOps = false, bool replaceInDeallocOp = false);</p>
<p>/ Performs the same replacement as the other version above but only for the / dereferencing uses of <span class="tt">oldMemRef</span> in <span class="tt">op</span>, except in cases where / 'allowNonDereferencingOps' is set to true where we replace the / non-dereferencing uses as well. LogicalResult replaceAllMemRefUsesWith(<a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> extraIndices = {}, <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> indexRemap = AffineMap(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> extraOperands = {}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> symbolOperands = {}, bool allowNonDereferencingOps = false);</p>
<p>/ Rewrites the memref defined by alloc or reinterpret_cast op to have an / identity layout map and updates all its indexing uses. Returns failure if / any of its uses escape (while leaving the IR in a valid state). template &lt;typename AllocLikeOp&gt; LogicalResult normalizeMemRef(AllocLikeOp op); extern template LogicalResult normalizeMemRef&lt;memref::AllocaOp&gt;(memref::AllocaOp op); extern template LogicalResult normalizeMemRef&lt;memref::AllocOp&gt;(memref::AllocOp op); LogicalResult normalizeMemRef(memref::ReinterpretCastOp op);</p>
<p>/ Normalizes <span class="tt">memrefType</span> so that the affine layout map of the memref is / transformed to an identity map with a new shape being computed for the / normalized memref type and returns it. The old memref type is simplify / returned if the normalization failed. MemRefType normalizeMemRefType(MemRefType memrefType);</p>
<p>/ Given an operation, inserts one or more single result affine apply / operations, results of which are exclusively used by this operation. / The operands of these newly created affine apply ops are / guaranteed to be loop iterators or terminal symbols of a function. / / Before / / affine.for i = 0 to #map(N) / idx = affine.apply (d0) -&gt; (d0 mod 2) (i) / send A[idx], ... / v = "compute"(idx, ...) / / After / / affine.for i = 0 to #map(N) / idx = affine.apply (d0) -&gt; (d0 mod 2) (i) / send A[idx], ... / idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) / v = "compute"(idx_, ...)</p>
<p>/ This allows the application of different transformations on send and / compute (for eg. different shifts/delays) / / Fills <span class="tt">sliceOps</span> with the list of affine.apply operations. / In the following cases, <span class="tt">sliceOps</span> remains empty: / 1. If none of opInst's operands were the result of an affine.apply / (i.e., there was no affine computation slice to create). / 2. If all the affine.apply op's supplying operands to this opInst did not / have any uses other than those in this opInst. void createAffineComputationSlice(Operation *opInst,
                                  SmallVectorImpl&lt;AffineApplyOp&gt; *sliceOps);</p>
<p>/ Emit code that computes the given affine expression using standard / arithmetic operations applied to the provided dimension and symbol values. <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> expandAffineExpr(OpBuilder &amp;builder, Location loc, AffineExpr expr,
                       ValueRange dimValues, ValueRange symbolValues);</p>
<p>/ Create a sequence of operations that implement the <span class="tt">affineMap</span> applied to / the given <span class="tt">operands</span> (as it it were an AffineApplyOp). std::optional&lt;SmallVector&lt;Value, 8&gt;&gt; expandAffineMap(OpBuilder &amp;builder,
                                                     Location loc,
                                                     AffineMap affineMap,
                                                     ValueRange operands);</p>
<p>/ Holds the result of (div a, b) and (mod a, b). struct DivModValue { <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> quotient; <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> remainder; };</p>
<p>/ Create IR to calculate (div lhs, rhs) and (mod lhs, rhs). DivModValue getDivMod(OpBuilder &amp;b, Location loc, Value lhs, Value rhs);</p>
<p>/ Generate the IR to delinearize <span class="tt">linearIndex</span> given the <span class="tt">basis</span> and return / the multi-index. <span class="tt">hasOuterBound</span> indicates whether <span class="tt">basis</span> has an entry / given the size of the first multi-index result - if it is true, the function / will return <span class="tt">basis.size()</span> values, otherwise, it will return <span class="tt">basis.size() +
    1</span>. FailureOr&lt;SmallVector&lt;Value&gt;&gt; delinearizeIndex(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> loc, <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value&gt;</a> basis, bool hasOuterBound = true);</p>
<p>FailureOr&lt;SmallVector&lt;Value&gt;&gt; delinearizeIndex(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> loc, <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> linearIndex, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;OpFoldResult&gt;</a> basis, bool hasOuterBound = true);</p>
<p>Generate IR that extracts the linear index from a multi-index according to a basis/shape. The basis may contain either <span class="tt">multiIndex.size()</span> or <span class="tt">multiIndex.size() - 1</span> elements. <a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> linearizeIndex(ArrayRef&lt;OpFoldResult&gt; multiIndex,
                            ArrayRef&lt;OpFoldResult&gt; basis,
                            ImplicitLocOpBuilder &amp;builder);</p>
<p><a class="el" href="classmlir_1_1OpFoldResult.html" title="This class represents a single result from folding an operation.">OpFoldResult</a> linearizeIndex(OpBuilder &amp;builder, Location loc,
                            ArrayRef&lt;OpFoldResult&gt; multiIndex,
                            ArrayRef&lt;OpFoldResult&gt; basis);</p>
<p>/ Ensure that all operations that could be executed after <span class="tt">start</span> / (noninclusive) and prior to <span class="tt">memOp</span> (e.g. on a control flow/op path / between the operations) do not have the potential memory effect / <span class="tt">EffectType</span> on <span class="tt">memOp</span>. <span class="tt">memOp</span> is an operation that reads or writes to / a memref. For example, if <span class="tt">EffectType</span> is <a class="el" href="structmlir_1_1MemoryEffects_1_1Write.html" title="The following effect indicates that the operation writes to some resource.">MemoryEffects::Write</a>, this method / will check if there is no write to the memory between <span class="tt">start</span> and <span class="tt">memOp</span> / that would change the read within <span class="tt">memOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">687</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">getNumCommonSurroundingLoops()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>, <a class="el" href="IR_2Region_8cpp_source.html#l00045">mlir::Region::getParentRegion()</a>, <a class="el" href="Block_8h_source.html#l00270">mlir::Block::getSuccessors()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00263">mlir::Operation::isAncestor()</a>, <a class="el" href="IR_2Region_8h_source.html#l00222">mlir::Region::isAncestor()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00912">findUnusedStore()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00959">loadCSE()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp.html#a1f557a42a0a9b74a791a37fc062ecc13">mlir::affine::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, affine::AffineReadOpInterface &gt;()</a>.</p>

</div>
</div>
<a id="af32168fb86ad493527c61d139acee48a" name="af32168fb86ad493527c61d139acee48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32168fb86ad493527c61d139acee48a">&#9670;&#160;</a></span>insertBackwardComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::insertBackwardComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>srcOpInst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>dstOpInst</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dstLoopDepth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1ComputationSliceState.html">ComputationSliceState</a> *</td>          <td class="paramname"><span class="paramname"><em>sliceState</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'. </p>
<p>Creates a computation slice of the loop nest surrounding 'srcOpInst', updates the slice loop bounds with any non-null bound maps specified in 'sliceState', and inserts this slice into the loop nest surrounding 'dstOpInst' at loop depth 'dstLoopDepth'.</p>
<p>Returns the top-level loop of the computation slice on success, returns nullptr otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">1982</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01543">findInstPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00851">getAffineForIVs()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01560">getInstAtPosition()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00327">mlir::affine::ComputationSliceState::lbOperands</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00323">mlir::affine::ComputationSliceState::lbs</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00329">mlir::affine::ComputationSliceState::ubOperands</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00325">mlir::affine::ComputationSliceState::ubs</a>.</p>

</div>
</div>
<a id="adbefeb28d61a80e2a403eb660deabbe7" name="adbefeb28d61a80e2a403eb660deabbe7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbefeb28d61a80e2a403eb660deabbe7">&#9670;&#160;</a></span>interchangeLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOpA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOpB</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs loop interchange on 'forOpA' and 'forOpB'. </p>
<p>Performs loop interchange on 'forOpA' and 'forOpB', where 'forOpB' is nested within 'forOpA' as the only non-terminator operation in its block.</p>
<p>Requires that 'forOpA' and 'forOpB' are part of a perfectly nested sequence of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01279">1279</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

</div>
</div>
<a id="a78713c7b03663a8b9c23a4394a714e1a" name="a78713c7b03663a8b9c23a4394a714e1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78713c7b03663a8b9c23a4394a714e1a">&#9670;&#160;</a></span>isAffineForInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isAffineForInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of an AffineForOp. </p>
<p>Returns true if the provided value is the induction variable of a AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02926">2926</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02938">getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01585">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00293">getNumCommonLoops()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00282">isAccessIndexInvariant()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02934">isAffineInductionVar()</a>.</p>

</div>
</div>
<a id="a2fb9a1f410c602d0a0aaf955705a15ac" name="a2fb9a1f410c602d0a0aaf955705a15ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb9a1f410c602d0a0aaf955705a15ac">&#9670;&#160;</a></span>isAffineInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isAffineInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the provided value is the induction variable of an AffineForOp or AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02934">2934</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02926">isAffineForInductionVar()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02930">isAffineParallelInductionVar()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00314">isValidDim()</a>.</p>

</div>
</div>
<a id="ae078747217d5df8ac5077cadb329f087" name="ae078747217d5df8ac5077cadb329f087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae078747217d5df8ac5077cadb329f087">&#9670;&#160;</a></span>isAffineParallelInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isAffineParallelInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">val</span> is the induction variable of an AffineParallelOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l02930">2930</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l02949">getAffineParallelInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00293">getNumCommonLoops()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l02934">isAffineInductionVar()</a>.</p>

</div>
</div>
<a id="a971420849a0dcea8b985c4aae2c1a419" name="a971420849a0dcea8b985c4aae2c1a419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971420849a0dcea8b985c4aae2c1a419">&#9670;&#160;</a></span>isContiguousAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isContiguousAccess </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>iv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoadOrStoreOp</td>          <td class="paramname"><span class="paramname"><em>memoryOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>memRefDim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given: </p>
<ol type="1">
<li>an induction variable <span class="tt">iv</span> of type AffineForOp;</li>
<li>a <span class="tt">memoryOp</span> of type const LoadOp&amp; or const StoreOp&amp;; determines whether <span class="tt">memoryOp</span> has a contiguous access along <span class="tt">iv</span>. Contiguous is defined as either invariant or varying only along a unique MemRef dim. Upon success, the unique MemRef dim is written in <span class="tt">memRefDim</span> (or -1 to convey the memRef access is invariant along <span class="tt">iv</span>).</li>
</ol>
<p>Prerequisites:</p><ol type="1">
<li><span class="tt">memRefDim</span> ~= nullptr;</li>
<li><span class="tt">iv</span> of the proper type;</li>
<li>the MemRef accessed by <span class="tt">memoryOp</span> has no layout map or at most an identity layout map.</li>
</ol>
<p>Currently only supports no layout map or identity layout map in the memref. Returns false if the memref has a non-identity layoutMap. This behavior is conservative. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00320">320</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00282">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00447">isVectorizableLoopBody()</a>.</p>

</div>
</div>
<a id="a623d044442600d97d7a7b5ecb597a166" name="a623d044442600d97d7a7b5ecb597a166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623d044442600d97d7a7b5ecb597a166">&#9670;&#160;</a></span>isInvariantAccess()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isInvariantAccess </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOp</td>          <td class="paramname"><span class="paramname"><em>memOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if an affine read or write operation depends on <span class="tt">forOp</span>'s IV, i.e., if the memory access is invariant on <span class="tt">forOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00294">294</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineValueMap_8cpp_source.html#l00027">mlir::affine::AffineValueMap::composeSimplifyAndCanonicalize()</a>, and <a class="el" href="AffineValueMap_8cpp_source.html#l00106">mlir::affine::AffineValueMap::getOperands()</a>.</p>

</div>
</div>
<a id="a7c415a3c0be0bdd484b55efb8d4f5e18" name="a7c415a3c0be0bdd484b55efb8d4f5e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c415a3c0be0bdd484b55efb8d4f5e18">&#9670;&#160;</a></span>isLoopMemoryParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isLoopMemoryParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if &lsquo;forOp&rsquo; is a parallel loop. </p>
<p>If <span class="tt">parallelReductions</span> is / provided, populates it with descriptors of the parallelizable reductions and / treats them as not preventing parallelization. bool isLoopParallel( AffineForOp forOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;LoopReduction&gt;</a> *parallelReductions = nullptr);</p>
<p>/ Returns true if &lsquo;forOp&rsquo; doesn't have memory dependences preventing parallelization. Memrefs that are allocated inside <span class="tt">forOp</span> do not impact its dependences and parallelism. This function does not check iter_args (for values other than memref types) and should be used only as a building block for complete parallelism-checking functions. </p>

</div>
</div>
<a id="a34c1ca39d435d06366058d16b5fe4225" name="a34c1ca39d435d06366058d16b5fe4225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c1ca39d435d06366058d16b5fe4225">&#9670;&#160;</a></span>isLoopParallelAndContainsReduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isLoopParallelAndContainsReduction </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether a loop is a parallel loop and contains a reduction loop. </p>
<p>Returns whether a loop is parallel and contains a reduction loop. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02182">2182</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="acf9ac00d2450032a64d31d68d1c82408" name="acf9ac00d2450032a64d31d68d1c82408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9ac00d2450032a64d31d68d1c82408">&#9670;&#160;</a></span>isOpwiseShiftValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isOpwiseShiftValid </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>shifts</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts. </p>
<p>Checks whether SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.</p>
<p>This method checks if a 'def' and all its uses have the same shift factor. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00483">483</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00230">affineForOpBodySkew()</a>.</p>

</div>
</div>
<a id="a8dfe2c6d438e6cee369c98a6371b44bf" name="a8dfe2c6d438e6cee369c98a6371b44bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfe2c6d438e6cee369c98a6371b44bf">&#9670;&#160;</a></span>isPerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isPerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">loops</span> is a perfectly nested loop nest, where loops appear in it from outermost to innermost. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01361">1361</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00383">performPreTilingChecks()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01383">permuteLoops()</a>.</p>

</div>
</div>
<a id="a114e1e8e803cf90761ffc5a667f3c0c7" name="a114e1e8e803cf90761ffc5a667f3c0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114e1e8e803cf90761ffc5a667f3c0c7">&#9670;&#160;</a></span>isTilingValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isTilingValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether hyper-rectangular loop tiling of the nest represented by <span class="tt">loops</span> is valid. </p>
<p>The validity condition is from Irigoin and Triolet, which states that two tiles cannot depend on each other. We simplify such condition to just checking whether there is any negative dependence direction, since we have the prior knowledge that the tiling results will be hyper-rectangles, which are scheduled in the lexicographically increasing order on the vector of loop indices. This function will return failure when any dependence component is negative along any of <span class="tt">loops</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00520">520</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">checkMemrefAccessDependence()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00181">hasDependence()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00064">getTopLevelTileableBands()</a>.</p>

</div>
</div>
<a id="a85ac5508d6eb2d2c7c2a2103ca7a1bfe" name="a85ac5508d6eb2d2c7c2a2103ca7a1bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ac5508d6eb2d2c7c2a2103ca7a1bfe">&#9670;&#160;</a></span>isTopLevelValue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of an op with trait <span class="tt">AffineScope</span> or is a region argument for such an op. </p>
<p>A utility function to check if a value is defined at the top level of an op with trait <span class="tt">AffineScope</span>.</p>
<p>A value of index type defined at the top level is always a valid symbol for all its uses.</p>
<p>If the value is defined in an unlinked region, conservatively assume it is not top-level. A value of index type defined at the top level is always a valid symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00250">250</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00314">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00062">remainsLegalAfterInline()</a>.</p>

</div>
</div>
<a id="a9b541bc609cc8c880c998cc99cdd1589" name="a9b541bc609cc8c880c998cc99cdd1589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b541bc609cc8c880c998cc99cdd1589">&#9670;&#160;</a></span>isTopLevelValue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of <span class="tt">region</span> or is an argument of <span class="tt">region</span>. </p>
<p>A value of index type defined at the top level of a <span class="tt">AffineScope</span> region is always a valid symbol for all uses in that region. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00050">50</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00230">mlir::Operation::getParentRegion()</a>.</p>

</div>
</div>
<a id="a245751b99c21bbee57456cef1e52bde4" name="a245751b99c21bbee57456cef1e52bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245751b99c21bbee57456cef1e52bde4">&#9670;&#160;</a></span>isValidDim() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in the region of the closest surrounding op that has the trait <span class="tt">AffineScope</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00290">290</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02934">isAffineInductionVar()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00492">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00290">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01636">legalizeDemotedDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00128">remainsLegalAfterInline()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="ab3030c26358d640e751344ee1fc60335" name="ab3030c26358d640e751344ee1fc60335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3030c26358d640e751344ee1fc60335">&#9670;&#160;</a></span>isValidDim() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id in <span class="tt">region</span>, i.e., for all its uses in <span class="tt">region</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00314">314</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02934">isAffineInductionVar()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">isTopLevelValue()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>.</p>

</div>
</div>
<a id="a5aded67ac5853a2bdeff09550e8bb32c" name="a5aded67ac5853a2bdeff09550e8bb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aded67ac5853a2bdeff09550e8bb32c">&#9670;&#160;</a></span>isValidLoopInterchangePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isValidLoopInterchangePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>loops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>loopPermMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange). </p>
<p>Checks if the loop interchange permutation 'loopPermMap' of the perfectly nested sequence of loops in 'loops' would violate dependences. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01336">1336</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01302">checkLoopInterchangeDependences()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00697">getDependenceComponents()</a>.</p>

</div>
</div>
<a id="a9d387ed8b9220b1d4f32d7efe7cf6117" name="a9d387ed8b9220b1d4f32d7efe7cf6117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d387ed8b9220b1d4f32d7efe7cf6117">&#9670;&#160;</a></span>isValidSymbol() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given value can be used as a symbol in the region of the closest surrounding op that has the trait <span class="tt">AffineScope</span>. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00412">412</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00265">getAffineScope()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00250">isTopLevelValue()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00033">mlir::affine::FlatAffineValueConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01588">canonicalizePromotedSymbols()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01257">mlir::affine::MemRefRegion::compute()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00898">mlir::affine::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00349">isMemRefSizeValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00492">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00314">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00412">isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01636">legalizeDemotedDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00128">remainsLegalAfterInline()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">remainsLegalAfterInline()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00529">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="adeeefdd6013aa0720cc45eed32fd8eac" name="adeeefdd6013aa0720cc45eed32fd8eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeeefdd6013aa0720cc45eed32fd8eac">&#9670;&#160;</a></span>isValidSymbol() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *</td>          <td class="paramname"><span class="paramname"><em>region</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol for <span class="tt">region</span>, i.e., for all its uses in <span class="tt">region</span>. </p>
<p>A value can be used as a symbol for <span class="tt">region</span> iff it meets one of the following conditions: *) It is a constant.</p>
<p>*) It is a result of a <span class="tt">Pure</span> operation whose operands are valid symbolic *) identifiers. *) It is a result of the dim op on a memref whose corresponding size is a valid symbol. *) It is defined at the top level of 'region' or is its argument. *) It dominates <span class="tt">region</span>'s parent op. If <span class="tt">region</span> is null, conservatively assume the symbol definition scope does not exist and only accept the values that would be symbols regardless of the surrounding region structure, i.e. the first three cases above. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00457">457</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00368">isDimOpValidSymbol()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, <a class="el" href="SideEffectInterfaces_8cpp_source.html#l00403">mlir::isPure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00432">isTopLevelValueOrAbove()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, and <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>.</p>

</div>
</div>
<a id="a8739b5a311c3583c17ae8802a491f2be" name="a8739b5a311c3583c17ae8802a491f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8739b5a311c3583c17ae8802a491f2be">&#9670;&#160;</a></span>isVectorizableLoopBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>memRefDim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vectorTransferMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are either: </p>
<ol type="1">
<li>invariant along the loop induction variable created by 'loop';</li>
<li>varying along at most one memory dimension. If such a unique dimension is found, it is written into <span class="tt">memRefDim</span>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00447">447</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00320">isContiguousAccess()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00380">isVectorizableLoopBodyWithOpCond()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01923">load</a>.</p>

</div>
</div>
<a id="a14ee6f64e3efdd85b5f35ca0b7e4acec" name="a14ee6f64e3efdd85b5f35ca0b7e4acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ee6f64e3efdd85b5f35ca0b7e4acec">&#9670;&#160;</a></span>isVectorizableLoopBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>loop</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1NestedPattern.html">NestedPattern</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>vectorTransferMatcher</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable; i.e.: </p>
<ol type="1">
<li>no conditionals are nested under the loop;</li>
<li>all nested load/stores are to scalar MemRefs. TODO: relax the no-conditionals restriction </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00473">473</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00380">isVectorizableLoopBodyWithOpCond()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SuperVectorize_8cpp_source.html#l01595">vectorizeLoopNest()</a>.</p>

</div>
</div>
<a id="a1e40110d365738e8699594b1d4f27e85" name="a1e40110d365738e8699594b1d4f27e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e40110d365738e8699594b1d4f27e85">&#9670;&#160;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classvoid.html">void</a>(<a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>annotateFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>cleanUpUnroll</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors. Requires positive loop bounds and step. If specified, annotates the Ops in each unrolled iteration by applying <span class="tt">annotateFn</span>. When <span class="tt">cleanUpUnroll</span> is true, we can ensure the cleanup loop is unrolled regardless of the unroll factor.</p>
<p>Returns success if the loop is successfully unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00995">995</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00294">mlir::generateUnrolledLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">getLargestDivisorOfTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">promoteIfSingleIteration()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00886">loopUnrollUpToFactor()</a>.</p>

</div>
</div>
<a id="a1298df47a03112972950004cc449fed3" name="a1298df47a03112972950004cc449fed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1298df47a03112972950004cc449fed3">&#9670;&#160;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation completely if the trip count is known to be constant. </p>
<p>Unrolls this loop completely.</p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00871">871</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">promoteIfSingleIteration()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00230">affineForOpBodySkew()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="a8208a6014374243c317effcb573395dd" name="a8208a6014374243c317effcb573395dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8208a6014374243c317effcb573395dd">&#9670;&#160;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollJamFactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor. </p>
<p><span class="tt">forOp</span> can be a loop with iteration arguments performing supported reductions and its inner loops can have iteration arguments. Returns success if the loop is successfully unroll-jammed. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01084">1084</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01072">areInnerBoundsInvariant()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00243">getLargestDivisorOfTripCount()</a>, <a class="el" href="ArithOps_8cpp_source.html#l02786">mlir::arith::getReductionOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00083">getSupportedReductions()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00119">promoteIfSingleIteration()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>, <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>, <a class="el" href="LoopLikeInterface_8h_source.html#l00058">mlir::JamBlockGatherer&lt; OpTy &gt;::subBlocks</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="Value_8h_source.html#l00208">mlir::Value::use_empty()</a>, and <a class="el" href="LoopLikeInterface_8h_source.html#l00061">mlir::JamBlockGatherer&lt; OpTy &gt;::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01061">loopUnrollJamUpToFactor()</a>.</p>

</div>
</div>
<a id="a1c569833e90667ba35ace5840ac92307" name="a1c569833e90667ba35ace5840ac92307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c569833e90667ba35ace5840ac92307">&#9670;&#160;</a></span>loopUnrollJamUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollJamUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollJamFactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01061">1061</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a6d6bdc8e2c261d88d25e21d30ab2899d" name="a6d6bdc8e2c261d88d25e21d30ab2899d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6bdc8e2c261d88d25e21d30ab2899d">&#9670;&#160;</a></span>loopUnrollUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::loopUnrollUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>unrollFactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop by the specified unroll factor or its trip count, whichever is lower. </p>
<p>Unrolls this loop by the specified factor or by the trip count (if constant) whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00886">886</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="a5114cd1965e100b6f419e30ca42720f5" name="a5114cd1965e100b6f419e30ca42720f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5114cd1965e100b6f419e30ca42720f5">&#9670;&#160;</a></span>lowerAffineDelinearizeIndexOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::lowerAffineDelinearizeIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineDelinearizeIndexOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers <span class="tt">affine.delinearize_index</span> into a sequence of division and remainder operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00087">87</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8h_source.html#l00047">mlir::computeStrides()</a>, <a class="el" href="Builders_8h_source.html#l00526">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a90391c4033121397ca4cb25888f8acfc" name="a90391c4033121397ca4cb25888f8acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90391c4033121397ca4cb25888f8acfc">&#9670;&#160;</a></span>lowerAffineLinearizeIndexOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::lowerAffineLinearizeIndexOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineLinearizeIndexOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers <span class="tt">affine.linearize_index</span> into a sequence of multiplications and additions. </p>
<p>Make a best effort to sort the input indices so that the most loop-invariant terms are at the left of the additions to enable loop-invariant code motion. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00145">145</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

</div>
</div>
<a id="a4c32299c7b12725419a820f4314fa39c" name="a4c32299c7b12725419a820f4314fa39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c32299c7b12725419a820f4314fa39c">&#9670;&#160;</a></span>makeComposedAffineApply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::affine::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>e</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01427">1427</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01416">makeComposedAffineApply()</a>.</p>

</div>
</div>
<a id="a0d5cb525632c1a12545d579561c40dcc" name="a0d5cb525632c1a12545d579561c40dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5cb525632c1a12545d579561c40dcc">&#9670;&#160;</a></span>makeComposedAffineApply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineApplyOp mlir::affine::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a composed AffineApplyOp by composing <span class="tt">map</span> and <span class="tt">operands</span> with other AffineApplyOps supplying those operands. </p>
<p>The operands of the resulting AffineApplyOp do not change the length of AffineApplyOp chains. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01416">1416</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01336">composeAffineMapAndOperands()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00738">mlir::foldAttributesIntoMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="Tiling_8cpp_source.html#l00262">mlir::linalg::computeMultiTileSizes()</a>, <a class="el" href="SuperVectorize_8cpp_source.html#l01024">createMask()</a>, <a class="el" href="DistributionUtils_8cpp_source.html#l00104">mlir::gpu::WarpDistributionPattern::delinearizeLaneId()</a>, <a class="el" href="TensorInferTypeOpInterfaceImpl_8cpp_source.html#l00022">getCollapsedOutputDimFromInputShape()</a>, <a class="el" href="VectorToGPU_8cpp_source.html#l00052">getXferIndices()</a>, <a class="el" href="ExtractSliceFromReshapeUtils_8cpp_source.html#l00032">invertSliceIndexing()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01427">makeComposedAffineApply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">makeComposedFoldedAffineApply()</a>, <a class="el" href="MultiBuffer_8cpp_source.html#l00082">mlir::memref::multiBuffer()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01677">mlir::linalg::updateBoundsForCyclicDistribution()</a>.</p>

</div>
</div>
<a id="aefb27d3d2a62c6db2503c7cc8d62a6bb" name="aefb27d3d2a62c6db2503c7cc8d62a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb27d3d2a62c6db2503c7cc8d62a6bb">&#9670;&#160;</a></span>makeComposedAffineMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineMinOp mlir::affine::makeComposedAffineMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an AffineMinOp obtained by composing <span class="tt">map</span> and <span class="tt">operands</span> with AffineApplyOps supplying those operands. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01534">1534</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01525">makeComposedMinMax()</a>.</p>

</div>
</div>
<a id="ad9f23150730054dc540e6470b3bf342e" name="ad9f23150730054dc540e6470b3bf342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f23150730054dc540e6470b3bf342e">&#9670;&#160;</a></span>makeComposedFoldedAffineApply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>expr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <span class="tt">makeComposedFoldedAffineApply</span> that applies to an expression. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01503">1503</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00308">mlir::AffineMap::inferFromExprList()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">makeComposedFoldedAffineApply()</a>.</p>

</div>
</div>
<a id="a790378c2cd10eccca0bfe9fca0f84300" name="a790378c2cd10eccca0bfe9fca0f84300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790378c2cd10eccca0bfe9fca0f84300">&#9670;&#160;</a></span>makeComposedFoldedAffineApply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineApplyOp that applies <span class="tt">map</span> to <span class="tt">operands</span> after composing the map with the maps of any other AffineApplyOp supplying the operands, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. The <span class="tt">map</span> must be a single-result affine map. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01469">1469</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Matchers_8h_source.html#l00369">mlir::m_Constant()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01416">makeComposedAffineApply()</a>, <a class="el" href="Matchers_8h_source.html#l00490">mlir::matchPattern()</a>, and <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00374">mlir::affine::AffineBuilder::add()</a>, <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00994">HopperBuilder::buildBarrierArriveTx()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00080">buildLinearId()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l00973">HopperBuilder::buildTmaAsyncLoad()</a>, <a class="el" href="FoldMemRefAliasOps_8cpp_source.html#l00202">calculateExpandedAccessIndices()</a>, <a class="el" href="Tiling_8cpp_source.html#l00362">calculateTileOffsetsAndSizes()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00387">mlir::affine::AffineBuilder::ceil()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00195">common3DIdBuilderFn()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00107">commonLinearIdBuilderFn()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01954">composedAffineMultiply()</a>, <a class="el" href="Tiling_8cpp_source.html#l00156">mlir::linalg::computeContinuousTileSizes()</a>, <a class="el" href="PadTilingInterface_8cpp_source.html#l00099">mlir::linalg::computePaddedShape()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00175">mlir::memref::computeSuffixProductIRBlockImpl()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02022">mlir::linalg::computeTileSizes()</a>, <a class="el" href="ExpandStridedMetadata_8cpp_source.html#l00261">mlir::memref::createExpandStridedMetadataPass()</a>, <a class="el" href="VectorTransferSplitRewritePatterns_8cpp_source.html#l00036">createInBoundsCond()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00726">createInitialTensorsForTiling()</a>, <a class="el" href="Dialect_2Tensor_2Utils_2Utils_8cpp_source.html#l00023">mlir::tensor::createPadHighOp()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00749">denormalizeInductionVariableForIndexType()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03788">denormalizeIndVar()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00688">emitNormalizedLoopBoundsForIndexType()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00383">mlir::affine::AffineBuilder::floor()</a>, <a class="el" href="ReshapePatterns_8cpp_source.html#l00462">mlir::tensor::getCollapsedExtractSliceInfo()</a>, <a class="el" href="VectorTransferOpTransforms_8cpp_source.html#l00714">getCollapsedIndices()</a>, <a class="el" href="VectorEmulateNarrowType_8cpp_source.html#l00078">getCompressedMaskOp()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00128">getIndicesForLoadOrStore()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00113">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="MemRef_2Transforms_2EmulateNarrowType_8cpp_source.html#l00090">getOffsetForBitwidth()</a>, <a class="el" href="Dialect_2SCF_2Utils_2Utils_8cpp_source.html#l00803">getProductOfIndexes()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00794">getSplitReductionIvs()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00101">getUserTileSizesAndNumThreads()</a>, <a class="el" href="Dialect_2GPU_2TransformOps_2Utils_8cpp_source.html#l00231">laneIdBuilderFn()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00217">mlir::linalg::lowerPack()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01503">makeComposedFoldedAffineApply()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mergeOffsetsSizesAndStrides()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00380">mlir::affine::AffineBuilder::mul()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l03771">normalizeUpperBounds()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l02155">mlir::linalg::offsetIndices()</a>, <a class="el" href="Linalg_2Transforms_2Transforms_8cpp_source.html#l00748">mlir::linalg::packMatmulGreedily()</a>, <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">resolveIndicesIntoOpWithOffsetsAndStrides()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00253">mlir::memref::resolveSourceIndicesCollapseShape()</a>, <a class="el" href="NVGPUTransformOps_8cpp_source.html#l01034">CopyBuilder::rewrite()</a>, <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00377">mlir::affine::AffineBuilder::sub()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

</div>
</div>
<a id="a767162cfa21cd3e191f6c2e8f5bc9f1e" name="a767162cfa21cd3e191f6c2e8f5bc9f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767162cfa21cd3e191f6c2e8f5bc9f1e">&#9670;&#160;</a></span>makeComposedFoldedAffineMax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineMax </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineMinOp that computes a maximum across the results of applying <span class="tt">map</span> to <span class="tt">operands</span>, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01579">1579</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01540">makeComposedFoldedMinMax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00345">buildMax()</a>, <a class="el" href="MemRefUtils_8cpp_source.html#l00051">mlir::memref::getLinearizedMemRefOffsetAndSize()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, and <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00396">mlir::affine::AffineBuilder::max()</a>.</p>

</div>
</div>
<a id="a81cf2e698dddd6dc85868bac07a74ca0" name="a81cf2e698dddd6dc85868bac07a74ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81cf2e698dddd6dc85868bac07a74ca0">&#9670;&#160;</a></span>makeComposedFoldedAffineMin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::makeComposedFoldedAffineMin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an AffineMinOp that computes a minimum across the results of applying <span class="tt">map</span> to <span class="tt">operands</span>, then immediately attempts to fold it. </p>
<p>If folding results in a constant value, no ops are actually created. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01572">1572</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01540">makeComposedFoldedMinMax()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TensorTilingInterfaceImpl_8cpp_source.html#l00088">mlir::tensor::bubbleUpPadSlice()</a>, <a class="el" href="Tiling_8cpp_source.html#l00353">buildMin()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l01891">mlir::linalg::computeSliceParameters()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00237">getBoundedTileSize()</a>, <a class="el" href="TileUsingInterface_8cpp_source.html#l00474">getTileOffsetAndSizesWithForAllOp()</a>, <a class="el" href="Dialect_2Affine_2Utils_8h_source.html#l00391">mlir::affine::AffineBuilder::min()</a>, and <a class="el" href="Split_8cpp_source.html#l00067">mlir::linalg::splitOp()</a>.</p>

</div>
</div>
<a id="a369e8fce67650dea4a3ae344c29b3ee4" name="a369e8fce67650dea4a3ae344c29b3ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369e8fce67650dea4a3ae344c29b3ee4">&#9670;&#160;</a></span>makeComposedFoldedMultiResultAffineApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::makeComposedFoldedMultiResultAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>composeAffineMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Variant of <span class="tt">makeComposedFoldedAffineApply</span> suitable for multi-result maps. </p>
<p>Note that this may create as many affine.apply operations as the map has results given that affine.apply must be single-result. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01514">1514</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Tiling_8cpp_source.html#l00262">mlir::linalg::computeMultiTileSizes()</a>, <a class="el" href="DecomposeLinalgOps_8cpp_source.html#l00105">getGenericOpLoopRange()</a>, <a class="el" href="Tiling_8cpp_source.html#l00044">mlir::linalg::makeTiledLoopRanges()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00433">tileLinalgOpImpl()</a>.</p>

</div>
</div>
<a id="ab359330f8474c6425f2343941b20c03b" name="ab359330f8474c6425f2343941b20c03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab359330f8474c6425f2343941b20c03b">&#9670;&#160;</a></span>materializeComputedBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> mlir::affine::materializeComputedBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>boundMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>mapOperands</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Materialize an already computed bound with Affine dialect ops. </p>
<ul>
<li><span class="tt">ValueBoundsOpInterface::computeBound</span> computes bounds but does not create IR. It is dialect independent.</li>
<li><span class="tt">materializeComputedBound</span> materializes computed bounds with Affine dialect ops.</li>
<li><span class="tt">reifyIndexValueBound</span>/<span class="tt">reifyShapedValueDimBound</span> are a combination of the two functions mentioned above. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">34</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="AffineOps_8cpp_source.html#l01759">canonicalizeMapAndOperands()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00377">mlir::AffineMap::getSingleConstantResult()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="IR_2Types_8cpp_source.html#l00054">mlir::Type::isIndex()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00369">mlir::AffineMap::isSingleConstant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRef_2Transforms_2IndependenceTransforms_8cpp_source.html#l00019">makeIndependent()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="aab9523b9838e2a2f7b23d0f9953558f6" name="aab9523b9838e2a2f7b23d0f9953558f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9523b9838e2a2f7b23d0f9953558f6">&#9670;&#160;</a></span>mergeOffsetsSizesAndStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::mergeOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>producerOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>producerSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>producerStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>droppedProducerDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedStrides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <span class="tt">combinedOffsets</span>, <span class="tt">combinedSizes</span> and <span class="tt">combinedStrides</span> to use when combining a producer slice <b>into</b> a consumer slice. </p>
<p>This function performs the following computation:</p><ul>
<li>Combined offsets = producer_offsets * consumer_strides + consumer_offsets</li>
<li>Combined sizes = consumer_sizes</li>
<li>Combined strides = producer_strides * consumer_strides </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">17</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">makeComposedFoldedAffineApply()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00061">mergeOffsetsSizesAndStrides()</a>.</p>

</div>
</div>
<a id="ae7752d92fa12e20ac4b6a61942490ec8" name="ae7752d92fa12e20ac4b6a61942490ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7752d92fa12e20ac4b6a61942490ec8">&#9670;&#160;</a></span>mergeOffsetsSizesAndStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::mergeOffsetsSizesAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OffsetSizeAndStrideOpInterface</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>droppedProducerDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>combinedStrides</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills the <span class="tt">combinedOffsets</span>, <span class="tt">combinedSizes</span> and <span class="tt">combinedStrides</span> to use when combining a <span class="tt">producer</span> slice op <b>into</b> a <span class="tt">consumer</span> slice op. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00061">61</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00017">mergeOffsetsSizesAndStrides()</a>.</p>

</div>
</div>
<a id="aee44441a5ada09f5106e1a52ea905f2d" name="aee44441a5ada09f5106e1a52ea905f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44441a5ada09f5106e1a52ea905f2d">&#9670;&#160;</a></span>noDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::noDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1DependenceResult.html">DependenceResult</a></td>          <td class="paramname"><span class="paramname"><em>result</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the provided <a class="el" href="structmlir_1_1affine_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element.">DependenceResult</a> corresponds to the absence of a dependence. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00187">187</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8h_source.html#l00166">mlir::affine::DependenceResult::NoDependence</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00575">hasCyclicDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">mayDependence()</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">mayHaveEffect()</a>.</p>

</div>
</div>
<a id="ac5f955e6ef5e73376cf17d57ce91fbd3" name="ac5f955e6ef5e73376cf17d57ce91fbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f955e6ef5e73376cf17d57ce91fbd3">&#9670;&#160;</a></span>numEnclosingInvariantLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint64__t.html">int64_t</a> mlir::affine::numEnclosingInvariantLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>operand</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs explicit copying for the contiguous sequence of operations in the block iterator range [&lsquo;begin&rsquo;, &lsquo;end&rsquo;), where &lsquo;end&rsquo; can't be past the / terminator of the block (since additional operations are potentially / inserted right before <span class="tt">end</span>. </p>
<p><span class="tt">copyOptions</span> provides various parameters, and / the output argument <span class="tt">copyNests</span> is the set of all copy nests inserted, each / represented by its root affine.for. Since we generate alloc's and dealloc's / for all fast buffers (before and after the range of operations resp. or at a / hoisted position), all of the fast memory capacity is assumed to be / available for processing this block range. When 'filterMemRef' is specified, / copies are only generated for the provided MemRef. Returns success if the / explicit copying succeeded for all memrefs on which affine load/stores were / encountered. For memrefs for whose element types a size in bytes can't be / computed (<span class="tt">index</span> type), their capacity is not accounted for and the / <span class="tt">fastMemCapacityBytes</span> copy option would be non-functional in such cases. LogicalResult affineDataCopyGenerate(Block::iterator begin, Block::iterator end,
                                     const AffineCopyOptions &amp;copyOptions,
                                     std::optional&lt;Value&gt; filterMemRef,
                                     DenseSet&lt;Operation *&gt; &amp;copyNests);</p>
<p>/ A convenience version of affineDataCopyGenerate for all ops in the body of / an AffineForOp. LogicalResult affineDataCopyGenerate(AffineForOp forOp,
                                     const AffineCopyOptions &amp;copyOptions,
                                     std::optional&lt;Value&gt; filterMemRef,
                                     DenseSet&lt;Operation *&gt; &amp;copyNests);</p>
<p>/ Result for calling generateCopyForMemRegion. struct CopyGenerateResult { Number of bytes used by alloc. uint64_t sizeInBytes;</p>
<p>The newly created buffer allocation. <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *alloc;</p>
<p>Generated loop nest for copying data between the allocated buffer and the original memref. <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> *copyNest; };</p>
<p>/ generateCopyForMemRegion is similar to affineDataCopyGenerate, but works / with a single memref region. <span class="tt">memrefRegion</span> is supposed to contain analysis / information within analyzedOp. The generated prologue and epilogue always / surround <span class="tt">analyzedOp</span>. / / Note that <span class="tt">analyzedOp</span> is a single op for API convenience, and the / [begin, end) version can be added as needed. / / Also note that certain options in <span class="tt">copyOptions</span> aren't looked at anymore, / like slowMemorySpace. LogicalResult generateCopyForMemRegion(const MemRefRegion &amp;memrefRegion,
                                       Operation *analyzedOp,
                                       const AffineCopyOptions &amp;copyOptions,
                                       CopyGenerateResult &amp;result);</p>
<p>/ Replace a perfect nest of "for" loops with a single linearized loop. Assumes / <span class="tt">loops</span> contains a list of perfectly nested loops outermost to innermost / that are normalized (step one and lower bound of zero) and with bounds and / steps independent of any loop induction variable involved in the nest. / Coalescing affine.for loops is not always possible, i.e., the result may not / be representable using affine.for. LogicalResult coalesceLoops(MutableArrayRef&lt;AffineForOp&gt; loops);</p>
<p>/ Maps <span class="tt">forOp</span> for execution on a parallel grid of virtual <span class="tt">processorIds</span> of / size given by <span class="tt">numProcessors</span>. This is achieved by embedding the SSA values / corresponding to <span class="tt">processorIds</span> and <span class="tt">numProcessors</span> into the bounds and step / of the <span class="tt">forOp</span>. No check is performed on the legality of the rewrite, it is / the caller's responsibility to ensure legality. / / Requires that <span class="tt">processorIds</span> and <span class="tt">numProcessors</span> have the same size and that / for each idx, <span class="tt">processorIds</span>[idx] takes, at runtime, all values between 0 / and <span class="tt">numProcessors</span>[idx] - 1. This corresponds to traditional use cases for: / 1. GPU (threadIdx, get_local_id(), ...) / 2. MPI (MPI_Comm_rank) / 3. OpenMP (omp_get_thread_num) / / Example: / Assuming a 2-d grid with processorIds = [blockIdx.x, threadIdx.x] and / numProcessors = [gridDim.x, blockDim.x], the loop: / / <span class="tt">
/    scf.for i = lb to ub step step {
/      ...
/    }
/ </span> / / is rewritten into a version resembling the following pseudo-IR: / / <span class="tt">
/    scf.for i = lb + step * (threadIdx.x + blockIdx.x * blockDim.x)
/       to ub step gridDim.x * blockDim.x * step {
/      ...
/    }
/ </span> void mapLoopToProcessorIds(scf::ForOp forOp, ArrayRef&lt;Value&gt; processorId,
                           ArrayRef&lt;Value&gt; numProcessors);</p>
<p>/ Gathers all AffineForOps in 'func.func' grouped by loop depth. void gatherLoops(func::FuncOp func,
                 std::vector&lt;SmallVector&lt;AffineForOp, 2&gt;&gt; &amp;depthToLoops);</p>
<p>/ Creates an AffineForOp while ensuring that the lower and upper bounds are / canonicalized, i.e., unused and duplicate operands are removed, any constant / operands propagated/folded in, and duplicate bound maps dropped. AffineForOp createCanonicalizedAffineForOp(<a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> b, <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> lbOperands, <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1ValueRange.html" title="This class provides an abstraction over the different types of ranges over Values.">ValueRange</a> ubOperands, <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued.">AffineMap</a> ubMap, <a class="el" href="classint64__t.html">int64_t</a> step = 1);</p>
<p>/ Separates full tiles from partial tiles for a perfect nest <span class="tt">nest</span> by / generating a conditional guard that selects between the full tile version / and the partial tile version using an AffineIfOp. The original loop nest / is replaced by this guarded two version form. / / affine.if (cond) / // full_tile / else / // partial tile / LogicalResult separateFullTiles(<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef&lt;AffineForOp&gt;</a> nest, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;AffineForOp&gt;</a> *fullTileNest = nullptr);</p>
<p>/ Walk an affine.for to find a band to coalesce. LogicalResult coalescePerfectlyNestedAffineLoops(AffineForOp op);</p>
<p>/ Count the number of loops surrounding <span class="tt">operand</span> such that operand could be hoisted above. Stop counting at the first loop over which the operand cannot be hoisted. This counts any LoopLikeOpInterface, not just affine.for. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l02822">2822</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00238">mlir::Operation::getParentOfType()</a>.</p>

</div>
</div>
<a id="ad96a1dbba3240e5a725ce9176f832a6f" name="ad96a1dbba3240e5a725ce9176f832a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a1dbba3240e5a725ce9176f832a6f">&#9670;&#160;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ParseResult mlir::affine::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>parser</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>operands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>numDims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses dimension and symbol list. </p>
<p>Parses dimension and symbol list and returns true if parsing failed.</p>
<p><span class="tt">numDims</span> is set to the number of dimensions in the list parsed. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00507">507</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1AsmParser.html#a1d400e969b4479eec3faf8f272c99f44">mlir::AsmParser::getBuilder()</a>, <a class="el" href="Builders_8cpp_source.html#l00051">mlir::Builder::getIndexType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00826">mlir::AsmParser::OptionalSquare</a>, <a class="el" href="OpImplementation_8h_source.html#l00816">mlir::AsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af16d3e3ef46bd2bd45b4e8db657c221a">mlir::OpAsmParser::parseOperandList()</a>, and <a class="el" href="OpImplementation_8h_source.html#l01634">mlir::OpAsmParser::resolveOperands()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l02293">parseBound()</a>.</p>

</div>
</div>
<a id="a7bcd13c7ee29ca2ec5cc65bfc85133fb" name="a7bcd13c7ee29ca2ec5cc65bfc85133fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bcd13c7ee29ca2ec5cc65bfc85133fb">&#9670;&#160;</a></span>permuteLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::affine::permuteLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>inputNest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>permMap</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a loop permutation on a perfectly nested loop nest <span class="tt">inputNest</span> (where the contained loops appear from outer to inner) as specified by the permutation <span class="tt">permMap</span>: loop 'i' in <span class="tt">inputNest</span> is mapped to location 'loopPermMap[i]', where positions 0, 1, ... are from the outermost position to inner. </p>
<p>Returns the position in <span class="tt">inputNest</span> of the AffineForOp that becomes the new outermost loop of this nest. This method always succeeds, asserts out on invalid input / specifications. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01383">1383</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01361">isPerfectlyNested()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01453">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="afb8bb2407dc150a9486edb551538afde" name="afb8bb2407dc150a9486edb551538afde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb8bb2407dc150a9486edb551538afde">&#9670;&#160;</a></span>populateAffineExpandIndexOpsAsAffinePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::populateAffineExpandIndexOpsAsAffinePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that expand affine index operations into their equivalent <span class="tt">affine.apply</span> representations. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html#l00089">89</a> of file <a class="el" href="AffineExpandIndexOpsAsAffine_8cpp_source.html">AffineExpandIndexOpsAsAffine.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="ad0254031e77bf59bb9352e139ce07540" name="ad0254031e77bf59bb9352e139ce07540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0254031e77bf59bb9352e139ce07540">&#9670;&#160;</a></span>populateAffineExpandIndexOpsPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::populateAffineExpandIndexOpsPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewritePatternSet.html">RewritePatternSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>patterns</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate patterns that expand affine index operations into more fundamental operations (not necessarily restricted to Affine dialect). </p>

<p class="definition">Definition at line <a class="el" href="AffineExpandIndexOps_8cpp_source.html#l00229">229</a> of file <a class="el" href="AffineExpandIndexOps_8cpp_source.html">AffineExpandIndexOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>.</p>

</div>
</div>
<a id="a17d92cbba68de00d9a29abd461274661" name="a17d92cbba68de00d9a29abd461274661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d92cbba68de00d9a29abd461274661">&#9670;&#160;</a></span>promoteIfSingleIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a AffineForOp to its containing block if the loop was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp was known to have a single iteration. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00119">119</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="ArithOps_8cpp_source.html#l00359">mlir::arith::ConstantIndexOp::create()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00216">getConstantTripCount()</a>, <a class="el" href="Builders_8cpp_source.html#l00383">mlir::Builder::getDimIdentityMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00103">replaceIterArgsAndYieldResults()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00425">fuseLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00960">generateCleanupLoopForUnroll()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00175">generateShiftedLoop()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00995">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00871">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01084">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="aa6177db3daa7c8f6e03b62ec74334fdd" name="aa6177db3daa7c8f6e03b62ec74334fdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6177db3daa7c8f6e03b62ec74334fdd">&#9670;&#160;</a></span>promoteSingleIterationLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::promoteSingleIterationLoops </td>
          <td>(</td>
          <td class="paramtype">func::FuncOp</td>          <td class="paramname"><span class="paramname"><em>f</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations.">Block</a>. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

</div>
</div>
<a id="a3b9a500abd5be19124c80bda2fc50094" name="a3b9a500abd5be19124c80bda2fc50094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9a500abd5be19124c80bda2fc50094">&#9670;&#160;</a></span>registerAffineDataCopyGeneration()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineDataCopyGeneration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01287">1287</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2fac8aeefa61c56e265ee1439410b64d" name="a2fac8aeefa61c56e265ee1439410b64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fac8aeefa61c56e265ee1439410b64d">&#9670;&#160;</a></span>registerAffineDataCopyGenerationPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01294">1294</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a69037d9a9cbcca49a76566bbef329aab" name="a69037d9a9cbcca49a76566bbef329aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69037d9a9cbcca49a76566bbef329aab">&#9670;&#160;</a></span>registerAffineExpandIndexOps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineExpandIndexOps </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01308">1308</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aef5c8a8afbe506ab64093673afe98a48" name="aef5c8a8afbe506ab64093673afe98a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5c8a8afbe506ab64093673afe98a48">&#9670;&#160;</a></span>registerAffineExpandIndexOpsAsAffine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineExpandIndexOpsAsAffine </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01329">1329</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a89b080421680bc9883d19871b533f721" name="a89b080421680bc9883d19871b533f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b080421680bc9883d19871b533f721">&#9670;&#160;</a></span>registerAffineExpandIndexOpsAsAffinePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineExpandIndexOpsAsAffinePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01336">1336</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1314cc5eef0f21cf18b8537cb6ff7878" name="a1314cc5eef0f21cf18b8537cb6ff7878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1314cc5eef0f21cf18b8537cb6ff7878">&#9670;&#160;</a></span>registerAffineExpandIndexOpsPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineExpandIndexOpsPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01315">1315</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="add0a1da2eff068786faa1fd567d51174" name="add0a1da2eff068786faa1fd567d51174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0a1da2eff068786faa1fd567d51174">&#9670;&#160;</a></span>registerAffineLoopFusion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopFusion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01350">1350</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a41a988a588e6ded71e12a4ede33dd170" name="a41a988a588e6ded71e12a4ede33dd170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a988a588e6ded71e12a4ede33dd170">&#9670;&#160;</a></span>registerAffineLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01357">1357</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ae2c7cf5bd1041708e46ac7590e7f4de8" name="ae2c7cf5bd1041708e46ac7590e7f4de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c7cf5bd1041708e46ac7590e7f4de8">&#9670;&#160;</a></span>registerAffineLoopInvariantCodeMotion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopInvariantCodeMotion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01371">1371</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a041809df10115359f9d42abada686323" name="a041809df10115359f9d42abada686323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041809df10115359f9d42abada686323">&#9670;&#160;</a></span>registerAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01378">1378</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1a00a995d27bbcbd2d689e6b2109c5f7" name="a1a00a995d27bbcbd2d689e6b2109c5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a00a995d27bbcbd2d689e6b2109c5f7">&#9670;&#160;</a></span>registerAffineLoopNormalize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopNormalize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01392">1392</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4236d775d5a91ac5b0ef38691731e094" name="a4236d775d5a91ac5b0ef38691731e094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4236d775d5a91ac5b0ef38691731e094">&#9670;&#160;</a></span>registerAffineLoopNormalizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopNormalizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01399">1399</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aa9a6d401821f3cfd935015fd8141177b" name="aa9a6d401821f3cfd935015fd8141177b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a6d401821f3cfd935015fd8141177b">&#9670;&#160;</a></span>registerAffineLoopTiling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopTiling </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01413">1413</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8882ecc60049ed23b3c0751891c057d0" name="a8882ecc60049ed23b3c0751891c057d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8882ecc60049ed23b3c0751891c057d0">&#9670;&#160;</a></span>registerAffineLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopTilingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01420">1420</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a8d8a208bda536b1e2a5fa431610df88a" name="a8d8a208bda536b1e2a5fa431610df88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8a208bda536b1e2a5fa431610df88a">&#9670;&#160;</a></span>registerAffineLoopUnroll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopUnroll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01434">1434</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="aaff09c7d35877411a50d6762415ae1cc" name="aaff09c7d35877411a50d6762415ae1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff09c7d35877411a50d6762415ae1cc">&#9670;&#160;</a></span>registerAffineLoopUnrollAndJam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopUnrollAndJam </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01455">1455</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac148f829a3e3e995fd372401bb96c114" name="ac148f829a3e3e995fd372401bb96c114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac148f829a3e3e995fd372401bb96c114">&#9670;&#160;</a></span>registerAffineLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01462">1462</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1ad54915e40fda29c3eff8b1e36b51b7" name="a1ad54915e40fda29c3eff8b1e36b51b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad54915e40fda29c3eff8b1e36b51b7">&#9670;&#160;</a></span>registerAffineLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineLoopUnrollPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01441">1441</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a4a243fea66d6c538fa0f9b6658e72028" name="a4a243fea66d6c538fa0f9b6658e72028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a243fea66d6c538fa0f9b6658e72028">&#9670;&#160;</a></span>registerAffineParallelize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineParallelize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01476">1476</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6bb3fe72efd2baf00c7543dd5fb72100" name="a6bb3fe72efd2baf00c7543dd5fb72100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb3fe72efd2baf00c7543dd5fb72100">&#9670;&#160;</a></span>registerAffineParallelizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineParallelizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01483">1483</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ab376d73318fc0ea41cded4220f15fd94" name="ab376d73318fc0ea41cded4220f15fd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab376d73318fc0ea41cded4220f15fd94">&#9670;&#160;</a></span>registerAffinePasses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffinePasses </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01644">1644</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllPasses_8cpp_source.html#l00059">mlir::registerAllPasses()</a>.</p>

</div>
</div>
<a id="ac1a043513a0546d69ac2b8291783a6a1" name="ac1a043513a0546d69ac2b8291783a6a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a043513a0546d69ac2b8291783a6a1">&#9670;&#160;</a></span>registerAffinePipelineDataTransfer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffinePipelineDataTransfer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01497">1497</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="acd39100953121f5eb93a5d3587fb7ed5" name="acd39100953121f5eb93a5d3587fb7ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd39100953121f5eb93a5d3587fb7ed5">&#9670;&#160;</a></span>registerAffinePipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffinePipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01504">1504</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac5f200b042e78f45c3b78b0961818a49" name="ac5f200b042e78f45c3b78b0961818a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f200b042e78f45c3b78b0961818a49">&#9670;&#160;</a></span>registerAffineScalarReplacement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineScalarReplacement </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01518">1518</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a51a5d772e3b790133ba25f652b73c322" name="a51a5d772e3b790133ba25f652b73c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a5d772e3b790133ba25f652b73c322">&#9670;&#160;</a></span>registerAffineScalarReplacementPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineScalarReplacementPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01525">1525</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a01aba474c7fcff4c99db616542187059" name="a01aba474c7fcff4c99db616542187059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01aba474c7fcff4c99db616542187059">&#9670;&#160;</a></span>registerAffineVectorize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineVectorize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01539">1539</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0a774f563cf2f456f6c7d3dc7a5cc4b2" name="a0a774f563cf2f456f6c7d3dc7a5cc4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a774f563cf2f456f6c7d3dc7a5cc4b2">&#9670;&#160;</a></span>registerAffineVectorizePass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerAffineVectorizePass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01546">1546</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9817e27dc4c6db6b6850553e93af6de4" name="a9817e27dc4c6db6b6850553e93af6de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9817e27dc4c6db6b6850553e93af6de4">&#9670;&#160;</a></span>registerLoopCoalescing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerLoopCoalescing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01560">1560</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="add5e6c6044cb533e13478794b2065b10" name="add5e6c6044cb533e13478794b2065b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5e6c6044cb533e13478794b2065b10">&#9670;&#160;</a></span>registerLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01567">1567</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a2c69ab9703862bb1d37351324c2d153e" name="a2c69ab9703862bb1d37351324c2d153e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c69ab9703862bb1d37351324c2d153e">&#9670;&#160;</a></span>registerRaiseMemrefDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerRaiseMemrefDialect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01581">1581</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a9d4f0e0e151c11aab70d1bb400f7a4ec" name="a9d4f0e0e151c11aab70d1bb400f7a4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4f0e0e151c11aab70d1bb400f7a4ec">&#9670;&#160;</a></span>registerRaiseMemrefDialectPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerRaiseMemrefDialectPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01588">1588</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="ac5f4c0ea34e0c3d776523a03590f911f" name="ac5f4c0ea34e0c3d776523a03590f911f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f4c0ea34e0c3d776523a03590f911f">&#9670;&#160;</a></span>registerSimplifyAffineMinMaxPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerSimplifyAffineMinMaxPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01602">1602</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a1a4947f104eccecabf3c2ce644ef0b18" name="a1a4947f104eccecabf3c2ce644ef0b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4947f104eccecabf3c2ce644ef0b18">&#9670;&#160;</a></span>registerSimplifyAffineMinMaxPassPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerSimplifyAffineMinMaxPassPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01609">1609</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a0f3e0e5eaae45040a5b7821727629667" name="a0f3e0e5eaae45040a5b7821727629667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e0e5eaae45040a5b7821727629667">&#9670;&#160;</a></span>registerSimplifyAffineStructures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerSimplifyAffineStructures </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01623">1623</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a6e14bbfae2229ed9a96634ef205f65f9" name="a6e14bbfae2229ed9a96634ef205f65f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e14bbfae2229ed9a96634ef205f65f9">&#9670;&#160;</a></span>registerSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Passes_8h_source.html#l01630">1630</a> of file <a class="el" href="Dialect_2Affine_2Passes_8h_source.html">Passes.h</a>.</p>

</div>
</div>
<a id="a131df27a14db6c8a12e643fa2a0a5603" name="a131df27a14db6c8a12e643fa2a0a5603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a131df27a14db6c8a12e643fa2a0a5603">&#9670;&#160;</a></span>registerTransformDialectExtension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::scf::registerTransformDialectExtension </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineTransformOps_8cpp_source.html#l00215">215</a> of file <a class="el" href="AffineTransformOps_8cpp_source.html">AffineTransformOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00222">mlir::DialectRegistry::addExtensions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllExtensions_8cpp_source.html#l00072">mlir::registerAllExtensions()</a>.</p>

</div>
</div>
<a id="a861f3eb48860eab1e82710027ceae08f" name="a861f3eb48860eab1e82710027ceae08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861f3eb48860eab1e82710027ceae08f">&#9670;&#160;</a></span>registerValueBoundsOpInterfaceExternalModels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::registerValueBoundsOpInterfaceExternalModels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectRegistry.html">DialectRegistry</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>registry</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html#l00155">155</a> of file <a class="el" href="Affine_2IR_2ValueBoundsOpInterfaceImpl_8cpp_source.html">ValueBoundsOpInterfaceImpl.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectRegistry_8h_source.html#l00215">mlir::DialectRegistry::addExtension()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegisterAllDialects_8cpp_source.html#l00109">mlir::registerAllDialects()</a>.</p>

</div>
</div>
<a id="a51a2845645fcfad9550c1ac55f33e632" name="a51a2845645fcfad9550c1ac55f33e632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a2845645fcfad9550c1ac55f33e632">&#9670;&#160;</a></span>reifyIndexValueBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyIndexValueBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a></td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the given index-typed value in terms of SSA values for which <span class="tt">stopCondition</span> is met. </p>
<p>If no stop condition is specified, reify in terms of the operands of the owner op.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <span class="tt">closedUB</span> is set to "true", upper bounds are also closed.</p>
<p>Example: %0 = arith.addi a, b : index %1 = arith.addi %0, c : index</p>
<ul>
<li>If <span class="tt">stopCondition</span> evaluates to "true" for %0 and c, "%0 + %c" is an EQ bound for %1.</li>
<li>If <span class="tt">stopCondition</span> evaluates to "true" for a, b and c, "%a + %b + %c" is an EQ bound for %1.</li>
<li>Otherwise, if the owners of a, b or c do not implement the ValueBoundsOpInterface, no bound can be computed. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00100">100</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="aeccde276863cb70af4a37c9be4c95f02" name="aeccde276863cb70af4a37c9be4c95f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccde276863cb70af4a37c9be4c95f02">&#9670;&#160;</a></span>reifyShapedValueDimBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyShapedValueDimBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a></td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the specified dimension of the given shaped value in terms of SSA values for which <span class="tt">stopCondition</span> is met. </p>
<p>If no stop condition is specified, reify in terms of the operands of the owner op.</p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <span class="tt">closedUB</span> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00082">82</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">reifyValueBound()</a>.</p>

</div>
</div>
<a id="a3c342c069f431842d231d674e90e2541" name="a3c342c069f431842d231d674e90e2541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c342c069f431842d231d674e90e2541">&#9670;&#160;</a></span>reifyValueBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; mlir::affine::reifyValueBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">presburger::BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1ValueBoundsConstraintSet_1_1Variable.html">ValueBoundsConstraintSet::Variable</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>var</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueBoundsConstraintSet.html#a404e07bad50e360592a8dfe1056bf25c">ValueBoundsConstraintSet::StopConditionFn</a></td>          <td class="paramname"><span class="paramname"><em>stopCondition</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>closedUB</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reify a bound for the given variable in terms of SSA values for which <span class="tt">stopCondition</span> is met. </p>
<p>By default, lower/equal bounds are closed and upper bounds are open. If <span class="tt">closedUB</span> is set to "true", upper bounds are also closed. </p>

<p class="definition">Definition at line <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00019">19</a> of file <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html">ReifyValueBounds.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="ValueBoundsOpInterface_8cpp_source.html#l00463">mlir::ValueBoundsConstraintSet::computeBound()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00034">materializeComputedBound()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00100">reifyIndexValueBound()</a>, and <a class="el" href="Affine_2Transforms_2ReifyValueBounds_8cpp_source.html#l00082">reifyShapedValueDimBound()</a>.</p>

</div>
</div>
<a id="af183bca84d167ae145cb1eb3cb7ccaee" name="af183bca84d167ae145cb1eb3cb7ccaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af183bca84d167ae145cb1eb3cb7ccaee">&#9670;&#160;</a></span>reorderOperandsByHoistability()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::reorderOperandsByHoistability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineApplyOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to rewrite <span class="tt">op</span>'s affine map and reorder its operands such that they are in increasing order of hoistability (i.e. </p>
<p>the least hoistable) operands come first in the operand list. </p>

<p class="definition">Definition at line <a class="el" href="DecomposeAffineOps_8cpp_source.html#l00041">41</a> of file <a class="el" href="DecomposeAffineOps_8cpp_source.html">DecomposeAffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01759">canonicalizeMapAndOperands()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00247">mlir::RewriterBase::finalizeOpModification()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">mlir::getAffineSymbolExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00031">mlir::AffineExpr::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00496">mlir::AffineMap::replaceDimsAndSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00622">mlir::RewriterBase::startOpModification()</a>.</p>

</div>
</div>
<a id="a829dd3c66cb0c7fd7fdab2f3a815bac2" name="a829dd3c66cb0c7fd7fdab2f3a815bac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829dd3c66cb0c7fd7fdab2f3a815bac2">&#9670;&#160;</a></span>resolveIndicesIntoOpWithOffsetsAndStrides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSourceOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSourceStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>rankReducedDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>consumerIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resolvedIndices</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given the 'consumerIndices' of a load/store operation operating on an op with offsets and strides, return the combined indices. </p>
<p>For example, using <span class="tt">memref.load</span> and <span class="tt">memref.subview</span> as an illustration:</p>
<div class="fragment"><div class="line">%0 = ... : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a></div>
<div class="line">%1 = <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref</a>.subview %0[%arg0, %arg1][...][%stride1, %stride2] :</div>
<div class="line">  <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a> to <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x4xf32, offset=?, strides=[?, ?]&gt;</a></div>
<div class="line">%2 = <a class="code hl_variable" href="LoopUtils_8cpp.html#ab3c0736f545f4a75f723449c452395b3">load</a> %1[%i1, %i2] : <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;4x4xf32, offset=?, strides=[?, ?]&gt;</a></div>
<div class="ttc" id="aLoopUtils_8cpp_html_ab3c0736f545f4a75f723449c452395b3"><div class="ttname"><a href="LoopUtils_8cpp.html#ab3c0736f545f4a75f723449c452395b3">load</a></div><div class="ttdeci">auto load</div><div class="ttdef"><b>Definition</b> <a href="LoopUtils_8cpp_source.html#l01923">LoopUtils.cpp:1923</a></div></div>
<div class="ttc" id="anamespacemlir_1_1memref_html"><div class="ttname"><a href="namespacemlir_1_1memref.html">mlir::memref</a></div><div class="ttdef"><b>Definition</b> <a href="Dialect_2Affine_2Passes_8h_source.html#l00026">Passes.h:26</a></div></div>
</div><!-- fragment --><p>could be folded into:</p>
<div class="fragment"><div class="line">%2 = <a class="code hl_variable" href="LoopUtils_8cpp.html#ab3c0736f545f4a75f723449c452395b3">load</a> %0[%arg0 + %i1 * %stride1][%arg1 + %i2 * %stride2] :</div>
<div class="line">     <a class="code hl_namespace" href="namespacemlir_1_1memref.html">memref&lt;12x42xf32&gt;</a></div>
</div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">80</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01469">makeComposedFoldedAffineApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldMemRefsOps_8cpp_source.html#l00031">mlir::amdgpu::foldMemrefViewOp()</a>, <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a8f4081391a1f634fc8180a92f228534b" name="a8f4081391a1f634fc8180a92f228534b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4081391a1f634fc8180a92f228534b">&#9670;&#160;</a></span>resolveIndicesIntoOpWithOffsetsAndStrides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::resolveIndicesIntoOpWithOffsetsAndStrides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSourceOffsets</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>mixedSourceStrides</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>rankReducedDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>consumerIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resolvedIndices</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8h_source.html#l00082">82</a> of file <a class="el" href="ViewLikeInterfaceUtils_8h_source.html">ViewLikeInterfaceUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00081">mlir::getAsOpFoldResult()</a>, and <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00080">resolveIndicesIntoOpWithOffsetsAndStrides()</a>.</p>

</div>
</div>
<a id="a077878ca8c3dd66d2989e3fbd1ad93a6" name="a077878ca8c3dd66d2989e3fbd1ad93a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a077878ca8c3dd66d2989e3fbd1ad93a6">&#9670;&#160;</a></span>resolveSizesIntoOpWithSizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> mlir::affine::resolveSizesIntoOpWithSizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>sourceSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>destSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::SmallBitVector &amp;</td>          <td class="paramname"><span class="paramname"><em>rankReducedSourceDims</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>resolvedSizes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given <span class="tt">sourceSizes</span>, <span class="tt">destSizes</span> and information about which dimensions are dropped by the source: <span class="tt">rankReducedSourceDims</span>, compute the resolved sizes that correspond to dest_op(source_op). </p>
<p>In practice, this amounts to filtering by <span class="tt">rankReducedSourceDims</span> and taking from <span class="tt">sourceSizes</span> if a dimension is dropped, otherwise taking from <span class="tt">destSizes</span>. </p>

<p class="definition">Definition at line <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html#l00112">112</a> of file <a class="el" href="ViewLikeInterfaceUtils_8cpp_source.html">ViewLikeInterfaceUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FoldTensorSubsetOps_8cpp_source.html#l00178">InsertSliceOfInsertSliceFolder&lt; OpTy &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a0ef87e3d47ba2f545f09a0e7c8a05ab6" name="a0ef87e3d47ba2f545f09a0e7c8a05ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ef87e3d47ba2f545f09a0e7c8a05ab6">&#9670;&#160;</a></span>simplifyAffineMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::simplifyAffineMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMaxOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform tries to simplify the affine max operation <span class="tt">op</span>, by finding a common upper bound for a set of expressions in the affine map results. </p>
<p>It returns whether the transform updated <span class="tt">op</span>'s affine map.</p>
<p>In concrete terms, given an operation like: <span class="tt">affine.max affine_map&lt;(d0)[s0, s1] -&gt; (d0, s1, s0, 128)&gt;(i)[s0, s1]</span> If <span class="tt">d0 &gt; 128</span> and <span class="tt">s0 &gt; s1 &gt; 128</span>, the transform will update <span class="tt">op</span> to: <span class="tt">affine.max affine_map&lt;(d0)[s0, s1] -&gt; (d0, s0)&gt;(i)[s0, s1]</span>. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00145">145</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">simplifyAffineMinMaxOps()</a>.</p>

</div>
</div>
<a id="ac8ba5400dd55afc238cc0a85164da986" name="ac8ba5400dd55afc238cc0a85164da986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ba5400dd55afc238cc0a85164da986">&#9670;&#160;</a></span>simplifyAffineMinMaxOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::simplifyAffineMinMaxOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>ops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> *</td>          <td class="paramname"><span class="paramname"><em>modified</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform applies <span class="tt">simplifyAffineMinOp</span> and <span class="tt">simplifyAffineMaxOp</span> to all the <span class="tt">affine.min</span> or <span class="tt">affine.max</span> operations in <span class="tt">ops</span>. </p>
<p>After simplification, it invokes the <span class="tt">affine.min/max</span> canonicalization patterns on <span class="tt">ops</span>.</p>
<p>This transform returns failure if the greedy pattern rewriter failed to converge during canonicalization, otherwise it returns success. If provided, <span class="tt">modified</span> is set to <span class="tt">true</span> if the IR was modified in any way. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">149</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l01030">mlir::applyOpPatternsGreedily()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00285">mlir::changed</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00027">mlir::ExistingAndNewOps</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8h_source.html#l00320">mlir::OpBuilder::getListener()</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00283">mlir::patterns</a>, <a class="el" href="GreedyPatternRewriteDriver_8h_source.html#l00113">mlir::GreedyRewriteConfig::setStrictness()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00145">simplifyAffineMaxOp()</a>, <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00141">simplifyAffineMinOp()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="ac3d33a598ceba944409eed9c050cb32a" name="ac3d33a598ceba944409eed9c050cb32a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d33a598ceba944409eed9c050cb32a">&#9670;&#160;</a></span>simplifyAffineMinOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mlir::affine::simplifyAffineMinOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineMinOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This transform tries to simplify the affine min operation <span class="tt">op</span>, by finding a common lower bound for a set of expressions in the affine map results. </p>
<p>It returns whether the transform updated <span class="tt">op</span>'s affine map.</p>
<p>In concrete terms, given an operation like: <span class="tt">affine.min affine_map&lt;(d0)[s0, s1] -&gt; (d0, s1, s0, 128)&gt;(i)[s0, s1]</span> If <span class="tt">d0 &lt; 128</span> and <span class="tt">128 &lt; s1 &lt; s0</span>, the transform will update <span class="tt">op</span> to: <span class="tt">affine.min affine_map&lt;(d0)[s0, s1] -&gt; (d0, 128)&gt;(i)[s0, s1]</span>. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00141">141</a> of file <a class="el" href="SimplifyAffineMinMax_8cpp_source.html">SimplifyAffineMinMax.cpp</a>.</p>

<p class="reference">References <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00033">simplifyAffineMinMaxOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyAffineMinMax_8cpp_source.html#l00149">simplifyAffineMinMaxOps()</a>.</p>

</div>
</div>
<a id="af4c9fec2934b9a14a5883e9fabbe3f49" name="af4c9fec2934b9a14a5883e9fabbe3f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4c9fec2934b9a14a5883e9fabbe3f49">&#9670;&#160;</a></span>simplifyConstrainedMinMaxOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1affine_1_1AffineValueMap.html">AffineValueMap</a> &gt; mlir::affine::simplifyConstrainedMinMaxOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a></td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to simplify the given affine.min or affine.max op to an affine map with a single result and operands, taking into account the specified constraint set. </p>
<p>Return failure if no simplified version could be found. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">2286</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">addConstToResults()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00371">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02226">alignAndAddBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01181">mlir::FlatLinearValueConstraints::appendDimVar()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01759">canonicalizeMapAndOperands()</a>, <a class="el" href="Builders_8cpp_source.html#l00372">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00364">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Builders_8cpp_source.html#l00368">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00634">mlir::presburger::IntegerRelation::getConstantBound64()</a>, <a class="el" href="StaticValueUtils_8cpp_source.html#l00134">mlir::getConstantIntValue()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00216">mlir::Operation::getContext()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00374">mlir::FlatLinearValueConstraints::getMaybeValues()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00232">mlir::presburger::IntegerRelation::getNumDimAndSymbolVars()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l00700">mlir::FlatLinearConstraints::getSliceBounds()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00695">mlir::presburger::IntegerRelation::isEmpty()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00511">mlir::AffineMap::replace()</a>, <a class="el" href="mlir_2IR_2AffineMap_8h_source.html#l00267">mlir::AffineMap::shiftDims()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02212">unpackOptionalValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineCanonicalizationUtils_8cpp_source.html#l00065">canonicalizeMinMaxOp()</a>.</p>

</div>
</div>
<a id="a1f2e85e904cf88ca63479dad00941e87" name="a1f2e85e904cf88ca63479dad00941e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2e85e904cf88ca63479dad00941e87">&#9670;&#160;</a></span>simplifyIntegerSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> mlir::affine::simplifyIntegerSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td>          <td class="paramname"><span class="paramname"><em>set</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify the integer set by simplifying the underlying affine expressions by flattening and some simple inference. </p>
<p>Also, drop any duplicate constraints. Returns the simplified integer set. This method runs in time linear in the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02200">2200</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01087">mlir::FlatLinearConstraints::getAsIntegerSet()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00057">mlir::IntegerSet::getContext()</a>, <a class="el" href="mlir_2IR_2IntegerSet_8h_source.html#l00056">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00015">mlir::IntegerSet::getNumDims()</a>, <a class="el" href="IR_2IntegerSet_8cpp_source.html#l00016">mlir::IntegerSet::getNumSymbols()</a>, <a class="el" href="IntegerRelation_8cpp_source.html#l00695">mlir::presburger::IntegerRelation::isEmpty()</a>, and <a class="el" href="IntegerRelation_8cpp_source.html#l01915">mlir::presburger::IntegerRelation::removeTrivialRedundancy()</a>.</p>

</div>
</div>
<a id="ad1cc3f41464ffc9424244b2e3a3f2bd5" name="ad1cc3f41464ffc9424244b2e3a3f2bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1cc3f41464ffc9424244b2e3a3f2bd5">&#9670;&#160;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::affine::sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>forOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01453">1453</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01302">checkLoopInterchangeDependences()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00697">getDependenceComponents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00856">getPerfectlyNestedLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00147">mlir::affine::DependenceComponent::lb</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01383">permuteLoops()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00149">mlir::affine::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00233">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a0c5e9321f0d01289b23d98a44b936cd8" name="a0c5e9321f0d01289b23d98a44b936cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c5e9321f0d01289b23d98a44b936cd8">&#9670;&#160;</a></span>tile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; mlir::affine::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>forOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under <span class="tt">target</span>. </p>
<p>Returns the new AffineForOps, one per <span class="tt">forOps</span>, nested immediately under <span class="tt">target</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01596">1596</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l01584">tile()</a>.</p>

</div>
</div>
<a id="ad1b737fda5e5d83d831e50dcb73d8e26" name="ad1b737fda5e5d83d831e50dcb73d8e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1b737fda5e5d83d831e50dcb73d8e26">&#9670;&#160;</a></span>tile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt; mlir::affine::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>forOps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>sizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>targets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <span class="tt">forOps</span> by <span class="tt">sizes</span> and sinking them, in their order of occurrence in <span class="tt">forOps</span>, under each of the <span class="tt">targets</span>. </p>
<p>Returns the new AffineForOps, one per each of (<span class="tt">forOps</span>, <span class="tt">targets</span>) pair, nested immediately under each of <span class="tt">targets</span>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01584">1584</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01529">stripmineSink()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01596">tile()</a>.</p>

</div>
</div>
<a id="ad4fdfbbfeaedc902c83393747fa2fe7f" name="ad4fdfbbfeaedc902c83393747fa2fe7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fdfbbfeaedc902c83393747fa2fe7f">&#9670;&#160;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *</td>          <td class="paramname"><span class="paramname"><em>tiledNest</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops. </p>
<p>A band is a contiguous set of loops. This utility doesn't check for the validity of tiling itself, but just performs it. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00772">772</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00688">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00423">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02962">extractForInductionVars()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00383">performPreTilingChecks()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
<a id="a86baa652b01992ec11a10c7de8e2fe54" name="a86baa652b01992ec11a10c7de8e2fe54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86baa652b01992ec11a10c7de8e2fe54">&#9670;&#160;</a></span>tilePerfectlyNestedParametric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult mlir::affine::tilePerfectlyNestedParametric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;</td>          <td class="paramname"><span class="paramname"><em>input</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>tileSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *</td>          <td class="paramname"><span class="paramname"><em>tiledNest</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops, using SSA values as tiling parameters. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00814">814</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00660">constructParametricallyTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00423">constructTiledLoopNest()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02962">extractForInductionVars()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00383">performPreTilingChecks()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
