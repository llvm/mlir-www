<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Analysis/Utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_3891eb46e86f88fa378e794bc956ef77.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Utils.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PresburgerRelation_8h_source.html">mlir/Analysis/Presburger/PresburgerRelation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/AffineAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopAnalysis_8h_source.html">mlir/Dialect/Affine/Analysis/LoopAnalysis.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StaticValueUtils_8h_source.html">mlir/Dialect/Utils/StaticValueUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;llvm/ADT/SetVector.h&quot;</code><br />
<code>#include &quot;llvm/Support/Debug.h&quot;</code><br />
<code>#include &quot;llvm/Support/DebugLog.h&quot;</code><br />
<code>#include &quot;llvm/Support/raw_ostream.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;analysis-utils&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab7365fa1c3a77e6dbf089404d9d07984" id="r_ab7365fa1c3a77e6dbf089404d9d07984"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> = <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1d686d1808595a37c4f9ac170ae21a5" id="r_aa1d686d1808595a37c4f9ac170ae21a5"><td class="memTemplParams" colspan="2">template&lt;typename... EffectTys&gt; </td></tr>
<tr class="memitem:aa1d686d1808595a37c4f9ac170ae21a5 template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1d686d1808595a37c4f9ac170ae21a5">getEffectedValues</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:aa1d686d1808595a37c4f9ac170ae21a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the values that this op has a memref effect of type <span class="tt">EffectTys</span> on, not considering recursive effects.  <br /></td></tr>
<tr class="memitem:a414d83d67a4c8a20e7919cc622724d87" id="r_a414d83d67a4c8a20e7919cc622724d87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a414d83d67a4c8a20e7919cc622724d87">addNodeToMDG</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *nodeOp, <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;mdg, <a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; &amp;memrefAccesses)</td></tr>
<tr class="memdesc:a414d83d67a4c8a20e7919cc622724d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <span class="tt">op</span> to MDG creating a new node and adding its memory accesses (affine or non-affine to memrefAccesses (memref -&gt; list of nodes with accesses) map.  <br /></td></tr>
<tr class="memitem:a0714cd1626efd69db4b0f9b362baf91a" id="r_a0714cd1626efd69db4b0f9b362baf91a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0714cd1626efd69db4b0f9b362baf91a">getMemRef</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *memOp)</td></tr>
<tr class="memdesc:a0714cd1626efd69db4b0f9b362baf91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the memref being read/written by a memref/affine load/store op.  <br /></td></tr>
<tr class="memitem:a772b7f491c2609dba8bc57c7a81cea5f" id="r_a772b7f491c2609dba8bc57c7a81cea5f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a772b7f491c2609dba8bc57c7a81cea5f">mayDependence</a> (const <a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> &amp;srcNode, const <a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> &amp;dstNode, <a class="el" href="classmlir_1_1Value.html">Value</a> memref)</td></tr>
<tr class="memdesc:a772b7f491c2609dba8bc57c7a81cea5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there may be a dependence on <span class="tt">memref</span> from srcNode's memory ops to dstNode's memory ops, while using the affine memory dependence analysis checks.  <br /></td></tr>
<tr class="memitem:a3542347364fbb51462878559000b825a" id="r_a3542347364fbb51462878559000b825a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3542347364fbb51462878559000b825a">findInstPosition</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1Block.html">Block</a> *limitBlock, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *positions)</td></tr>
<tr class="memitem:afc6fada389cdc5a681c8816c6d12f6d4" id="r_afc6fada389cdc5a681c8816c6d12f6d4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc6fada389cdc5a681c8816c6d12f6d4">getInstAtPosition</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; positions, <a class="el" href="classunsigned.html">unsigned</a> level, <a class="el" href="classmlir_1_1Block.html">Block</a> *block)</td></tr>
<tr class="memitem:a8dfdaca76bbdbbf0358499c5b9f3acc6" id="r_a8dfdaca76bbdbbf0358499c5b9f3acc6"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dfdaca76bbdbbf0358499c5b9f3acc6">addMissingLoopIVBounds</a> (<a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &amp;ivs, <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *cst)</td></tr>
<tr class="memitem:a0c1794d21c2964d204a2a8ff7bf97243" id="r_a0c1794d21c2964d204a2a8ff7bf97243"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c1794d21c2964d204a2a8ff7bf97243">getConstDifference</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> lbMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> ubMap)</td></tr>
<tr class="memitem:a8cbbc934d9ffcb362b60f6e176630473" id="r_a8cbbc934d9ffcb362b60f6e176630473"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cbbc934d9ffcb362b60f6e176630473">getMemoryFootprintBytes</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> start, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, int memorySpace)</td></tr>
<tr class="memitem:ac4f925f8305023a91831e2eebbe77d08" id="r_ac4f925f8305023a91831e2eebbe77d08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4f925f8305023a91831e2eebbe77d08">unpackOptionalValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; source, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a5d2c023108742a1ce78ba9823c06ea35">target</a>)</td></tr>
<tr class="memitem:ae787f49f8ac3482c3ccf70b239a3db59" id="r_ae787f49f8ac3482c3ccf70b239a3db59"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae787f49f8ac3482c3ccf70b239a3db59">alignAndAddBound</a> (<a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;constraints, <a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">BoundType</a> type, <a class="el" href="classunsigned.html">unsigned</a> pos, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands)</td></tr>
<tr class="memdesc:ae787f49f8ac3482c3ccf70b239a3db59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bound an identifier <span class="tt">pos</span> in a given <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> with constraints drawn from an affine map.  <br /></td></tr>
<tr class="memitem:addab4561bd5643eda9d807ce62c72adf" id="r_addab4561bd5643eda9d807ce62c72adf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addab4561bd5643eda9d807ce62c72adf">addConstToResults</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classint64__t.html">int64_t</a> val)</td></tr>
<tr class="memdesc:addab4561bd5643eda9d807ce62c72adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <span class="tt">val</span> to each result of <span class="tt">map</span>.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8be167f9ac0211859d0ad0d632b7de40" id="r_a8be167f9ac0211859d0ad0d632b7de40"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8be167f9ac0211859d0ad0d632b7de40">kSliceFusionBarrierAttrName</a> = &quot;slice_fusion_barrier&quot;</td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;analysis-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00030">30</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ab7365fa1c3a77e6dbf089404d9d07984" name="ab7365fa1c3a77e6dbf089404d9d07984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7365fa1c3a77e6dbf089404d9d07984">&#9670;&#160;</a></span>Node</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using Node = <a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph_1_1Node.html">MemRefDependenceGraph::Node</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00038">38</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="addab4561bd5643eda9d807ce62c72adf" name="addab4561bd5643eda9d807ce62c72adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addab4561bd5643eda9d807ce62c72adf">&#9670;&#160;</a></span>addConstToResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> addConstToResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a></td>          <td class="paramname"><span class="paramname"><em>val</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <span class="tt">val</span> to each result of <span class="tt">map</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02241">2241</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="a8dfdaca76bbdbbf0358499c5b9f3acc6" name="a8dfdaca76bbdbbf0358499c5b9f3acc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dfdaca76bbdbbf0358499c5b9f3acc6">&#9670;&#160;</a></span>addMissingLoopIVBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult addMissingLoopIVBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ivs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> *</td>          <td class="paramname"><span class="paramname"><em>cst</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01585">1585</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00074">mlir::affine::FlatAffineValueConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02938">mlir::affine::getForInductionVarOwner()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00231">mlir::presburger::IntegerRelation::getNumDimVars()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00354">mlir::FlatLinearValueConstraints::getValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02926">mlir::affine::isAffineForInductionVar()</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01633">mlir::affine::computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a414d83d67a4c8a20e7919cc622724d87" name="a414d83d67a4c8a20e7919cc622724d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414d83d67a4c8a20e7919cc622724d87">&#9670;&#160;</a></span>addNodeToMDG()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> * addNodeToMDG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>nodeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1affine_1_1MemRefDependenceGraph.html">MemRefDependenceGraph</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mdg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="namespacemlir.html#a70f70d8c0fc9767c6d18b1592cd9a7ee">SetVector</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memrefAccesses</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <span class="tt">op</span> to MDG creating a new node and adding its memory accesses (affine or non-affine to memrefAccesses (memref -&gt; list of nodes with accesses) map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00191">191</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00043">mlir::affine::LoopNestStateCollector::collect()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00165">getEffectedValues()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00041">mlir::affine::LoopNestStateCollector::loadOpInsts</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00049">mlir::affine::LoopNestStateCollector::memrefFrees</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00045">mlir::affine::LoopNestStateCollector::memrefLoads</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00047">mlir::affine::LoopNestStateCollector::memrefStores</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00152">mlir::affine::MemRefDependenceGraph::nextNodeId</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00141">mlir::affine::MemRefDependenceGraph::nodes</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html#l00043">mlir::affine::LoopNestStateCollector::storeOpInsts</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00336">mlir::affine::MemRefDependenceGraph::init()</a>.</p>

</div>
</div>
<a id="ae787f49f8ac3482c3ccf70b239a3db59" name="ae787f49f8ac3482c3ccf70b239a3db59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae787f49f8ac3482c3ccf70b239a3db59">&#9670;&#160;</a></span>alignAndAddBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult alignAndAddBound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html">FlatAffineValueConstraints</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>constraints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1presburger.html#a04de81efca09b0849dde1d037c6e841d">BoundType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>operands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bound an identifier <span class="tt">pos</span> in a given <a class="el" href="classmlir_1_1affine_1_1FlatAffineValueConstraints.html" title="FlatAffineValueConstraints is an extension of FlatLinearValueConstraints with helper functions for Af...">FlatAffineValueConstraints</a> with constraints drawn from an affine map. </p>
<p>Before adding the constraint, the dimensions/symbols of the affine map are aligned with <span class="tt">constraints</span>. <span class="tt">operands</span> are the SSA <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> operands used with the affine map. Note: This function adds a new symbol column to the <span class="tt">constraints</span> for each dimension/symbol that exists in the affine map but not in <span class="tt">constraints</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02226">2226</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::affine::FlatAffineValueConstraints::addBound()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01517">mlir::alignAffineMapWithValues()</a>, <a class="el" href="FlatLinearValueConstraints_8cpp_source.html#l01186">mlir::FlatLinearValueConstraints::appendSymbolVar()</a>, <a class="el" href="FlatLinearValueConstraints_8h_source.html#l00374">mlir::FlatLinearValueConstraints::getMaybeValues()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02212">unpackOptionalValues()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a id="a3542347364fbb51462878559000b825a" name="a3542347364fbb51462878559000b825a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3542347364fbb51462878559000b825a">&#9670;&#160;</a></span>findInstPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> findInstPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>limitBlock</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01543">1543</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, and <a class="el" href="Block_8cpp_source.html#l00031">mlir::Block::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<a id="a0c1794d21c2964d204a2a8ff7bf97243" name="a0c1794d21c2964d204a2a8ff7bf97243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1794d21c2964d204a2a8ff7bf97243">&#9670;&#160;</a></span>getConstDifference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; uint64_t &gt; getConstDifference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>lbMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>ubMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01798">1798</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00390">mlir::AffineMap::getNumDims()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00398">mlir::AffineMap::getNumResults()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00407">mlir::AffineMap::getResult()</a>, and <a class="el" href="IR_2AffineExpr_8cpp_source.html#l01612">mlir::simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01818">mlir::affine::buildSliceTripCountMap()</a>.</p>

</div>
</div>
<a id="aa1d686d1808595a37c4f9ac170ae21a5" name="aa1d686d1808595a37c4f9ac170ae21a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d686d1808595a37c4f9ac170ae21a5">&#9670;&#160;</a></span>getEffectedValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... EffectTys&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> getEffectedValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the values that this op has a memref effect of type <span class="tt">EffectTys</span> on, not considering recursive effects. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00165">165</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00191">addNodeToMDG()</a>.</p>

</div>
</div>
<a id="afc6fada389cdc5a681c8816c6d12f6d4" name="afc6fada389cdc5a681c8816c6d12f6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6fada389cdc5a681c8816c6d12f6d4">&#9670;&#160;</a></span>getInstAtPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * getInstAtPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>level</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> *</td>          <td class="paramname"><span class="paramname"><em>block</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01560">1560</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01560">getInstAtPosition()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00677">mlir::Operation::getRegions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01560">getInstAtPosition()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01982">mlir::affine::insertBackwardComputationSlice()</a>.</p>

</div>
</div>
<a id="a8cbbc934d9ffcb362b60f6e176630473" name="a8cbbc934d9ffcb362b60f6e176630473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbbc934d9ffcb362b60f6e176630473">&#9670;&#160;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classint64__t.html">int64_t</a> &gt; getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>block</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a></td>          <td class="paramname"><span class="paramname"><em>end</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>memorySpace</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02124">2124</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00268">mlir::Operation::emitError()</a>, <a class="el" href="IR_2Operation_8cpp_source.html#l00280">mlir::Operation::emitWarning()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00223">mlir::Operation::getLoc()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">mlir::affine::getNestingDepth()</a>, <a class="el" href="LoopUtils_8cpp.html#ad077dc835cc07a8b6e9fd23f222b4ac6">inserted()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="Block_8h_source.html#l00308">mlir::Block::walk()</a>.</p>

</div>
</div>
<a id="a0714cd1626efd69db4b0f9b362baf91a" name="a0714cd1626efd69db4b0f9b362baf91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0714cd1626efd69db4b0f9b362baf91a">&#9670;&#160;</a></span>getMemRef()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> getMemRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>memOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the memref being read/written by a memref/affine load/store op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00246">246</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00149">mlir::affine::MemRefDependenceGraph::Node::getLoadAndStoreMemrefSet()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00139">mlir::affine::MemRefDependenceGraph::Node::getLoadOpsForMemref()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00134">getProducerCandidates()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00130">mlir::affine::MemRefDependenceGraph::Node::getStoreOpsForMemref()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">mayDependence()</a>.</p>

</div>
</div>
<a id="a772b7f491c2609dba8bc57c7a81cea5f" name="a772b7f491c2609dba8bc57c7a81cea5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772b7f491c2609dba8bc57c7a81cea5f">&#9670;&#160;</a></span>mayDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mayDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ab7365fa1c3a77e6dbf089404d9d07984">Node</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dstNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>memref</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there may be a dependence on <span class="tt">memref</span> from srcNode's memory ops to dstNode's memory ops, while using the affine memory dependence analysis checks. </p>
<p>The method assumes that there is at least one memory op in srcNode's loads and stores on <span class="tt">memref</span>, and similarly for <span class="tt">dstNode</span>. <span class="tt">srcNode.op</span> and <span class="tt">destNode.op</span> are expected to be nested in the same block and so the dependences are tested at the depth of that block. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00264">264</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00246">getMemRef()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02063">mlir::affine::getNestingDepth()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00187">mlir::affine::noDependence()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l00336">mlir::affine::MemRefDependenceGraph::init()</a>.</p>

</div>
</div>
<a id="ac4f925f8305023a91831e2eebbe77d08" name="ac4f925f8305023a91831e2eebbe77d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f925f8305023a91831e2eebbe77d08">&#9670;&#160;</a></span>unpackOptionalValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> unpackOptionalValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>target</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02212">2212</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02100">target</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02226">alignAndAddBound()</a>, and <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02286">mlir::affine::simplifyConstrainedMinMaxOp()</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a8be167f9ac0211859d0ad0d632b7de40" name="a8be167f9ac0211859d0ad0d632b7de40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be167f9ac0211859d0ad0d632b7de40">&#9670;&#160;</a></span>kSliceFusionBarrierAttrName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const kSliceFusionBarrierAttrName = &quot;slice_fusion_barrier&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01865">1865</a> of file <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l01870">mlir::affine::getComputationSliceState()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
