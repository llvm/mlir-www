<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: include/mlir/IR/OpDefinition.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a href="dir_5654f77406fb9ceec87e68ef828ceea2.html">mlir</a></li><li class="navelem"><a href="dir_84ef7c054b4edc3447cfba80cee80f65.html">IR</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">OpDefinition.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="IR_2Dialect_8h_source.html">mlir/IR/Dialect.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ODSSupport_8h_source.html">mlir/IR/ODSSupport.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2Operation_8h_source.html">mlir/IR/Operation.h</a>&quot;</code><br />
<code>#include &quot;llvm/Support/PointerLikeTypeTraits.h&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="OpDefinition_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3AOptionalParseResult" id="r_mlir_3A_3AOptionalParseResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">mlir::OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <span class="tt">Optional</span> functionality for ParseResult.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AEmptyProperties" id="r_mlir_3A_3AEmptyProperties"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyProperties.html">mlir::EmptyProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure used by default as a "marker" when no "Properties" are set on an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a>.  <a href="structmlir_1_1EmptyProperties.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3APropertiesSelector_3C_20Op_2C_20class_20_3E" id="r_mlir_3A_3APropertiesSelector_3C_20Op_2C_20class_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector.html">mlir::PropertiesSelector&lt; Op, class &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits to detect whether an <a class="el" href="classmlir_1_1Operation.html" title="Operation is the basic unit of execution within MLIR.">Operation</a> defined a <span class="tt">Properties</span> type, otherwise it'll default to <span class="tt"><a class="el" href="structmlir_1_1EmptyProperties.html" title="Structure used by default as a &quot;marker&quot; when no &quot;Properties&quot; are set on an Operation.">EmptyProperties</a></span>.  <a href="structmlir_1_1PropertiesSelector.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3APropertiesSelector_3C_20Op_2C_20std_3A_3Avoid_5Ft_3C_20typename_20Op_3A_3AProperties_20_3E_20_3E" id="r_mlir_3A_3APropertiesSelector_3C_20Op_2C_20std_3A_3Avoid_5Ft_3C_20typename_20Op_3A_3AProperties_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PropertiesSelector_3_01Op_00_01std_1_1void__t_3_01typename_01Op_1_1Properties_01_4_01_4.html">mlir::PropertiesSelector&lt; Op, std::void_t&lt; typename Op::Properties &gt; &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpState" id="r_mlir_3A_3AOpState"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">mlir::OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpFoldResult" id="r_mlir_3A_3AOpFoldResult"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">mlir::OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:llvm_3A_3ACastInfo_3C_20To_2C_20mlir_3A_3AOpFoldResult_20_3E" id="r_llvm_3A_3ACastInfo_3C_20To_2C_20mlir_3A_3AOpFoldResult_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1CastInfo_3_01To_00_01mlir_1_1OpFoldResult_01_4.html">llvm::CastInfo&lt; To, mlir::OpFoldResult &gt;</a></td></tr>
<tr class="memitem:llvm_3A_3ACastInfo_3C_20To_2C_20const_20mlir_3A_3AOpFoldResult_20_3E" id="r_llvm_3A_3ACastInfo_3C_20To_2C_20const_20mlir_3A_3AOpFoldResult_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1CastInfo_3_01To_00_01const_01mlir_1_1OpFoldResult_01_4.html">llvm::CastInfo&lt; To, const mlir::OpFoldResult &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ATraitBase_3C_20ConcreteType_2C_20TraitType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ATraitBase_3C_20ConcreteType_2C_20TraitType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1TraitBase.html">mlir::OpTrait::TraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class for implementing traits.  <a href="classmlir_1_1OpTrait_1_1TraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiOperandTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiOperandTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html">mlir::OpTrait::detail::MultiOperandTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple operands.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiOperandTraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOpInvariants_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOpInvariants_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OpInvariants.html">mlir::OpTrait::OpInvariants&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><span class="tt">verifyInvariantsImpl</span> verifies the invariants like the types, attrs, .etc.  <a href="classmlir_1_1OpTrait_1_1OpInvariants.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AZeroOperands_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AZeroOperands_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroOperands.html">mlir::OpTrait::ZeroOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have no SSA operand.  <a href="classmlir_1_1OpTrait_1_1ZeroOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneOperand_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneOperand_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneOperand.html">mlir::OpTrait::OneOperand&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have exactly one SSA operand.  <a href="classmlir_1_1OpTrait_1_1OneOperand.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANOperands_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANOperands_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands.html">mlir::OpTrait::NOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1NOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANOperands_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANOperands_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NOperands_1_1Impl.html">mlir::OpTrait::NOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNOperands_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNOperands_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a at least a specified number of operands.  <a href="classmlir_1_1OpTrait_1_1AtLeastNOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNOperands_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNOperands_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNOperands_1_1Impl.html">mlir::OpTrait::AtLeastNOperands&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AVariadicOperands_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AVariadicOperands_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicOperands.html">mlir::OpTrait::VariadicOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of SSA operands.  <a href="classmlir_1_1OpTrait_1_1VariadicOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AZeroRegions_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AZeroRegions_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroRegions.html">mlir::OpTrait::ZeroRegions&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero regions.  <a href="classmlir_1_1OpTrait_1_1ZeroRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiRegionTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiRegionTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html">mlir::OpTrait::detail::MultiRegionTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple regions.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiRegionTraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneRegion_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneRegion_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneRegion.html">mlir::OpTrait::OneRegion&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single region.  <a href="classmlir_1_1OpTrait_1_1OneRegion.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANRegions_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANRegions_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions.html">mlir::OpTrait::NRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1NRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANRegions_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANRegions_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NRegions_1_1Impl.html">mlir::OpTrait::NRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNRegions_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNRegions_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of regions.  <a href="classmlir_1_1OpTrait_1_1AtLeastNRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNRegions_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNRegions_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNRegions_1_1Impl.html">mlir::OpTrait::AtLeastNRegions&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AVariadicRegions_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AVariadicRegions_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicRegions.html">mlir::OpTrait::VariadicRegions&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of regions.  <a href="classmlir_1_1OpTrait_1_1VariadicRegions.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AZeroResults_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AZeroResults_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroResults.html">mlir::OpTrait::ZeroResults&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have zero results.  <a href="classmlir_1_1OpTrait_1_1ZeroResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiResultTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiResultTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html">mlir::OpTrait::detail::MultiResultTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple results.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiResultTraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneResult_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneResult_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneResult.html">mlir::OpTrait::OneResult&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneTypedResult_3C_20ResultType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneTypedResult_3C_20ResultType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneTypedResult.html">mlir::OpTrait::OneTypedResult&lt; ResultType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait is used for return value APIs for ops that are known to have a specific type other than <span class="tt"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></span>.  <a href="classmlir_1_1OpTrait_1_1OneTypedResult.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneTypedResult_3C_20ResultType_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneTypedResult_3C_20ResultType_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneTypedResult_1_1Impl.html">mlir::OpTrait::OneTypedResult&lt; ResultType &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides return value APIs for ops that are known to have a single result.  <a href="classmlir_1_1OpTrait_1_1OneTypedResult_1_1Impl.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANResults_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANResults_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults.html">mlir::OpTrait::NResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of results.  <a href="classmlir_1_1OpTrait_1_1NResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANResults_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANResults_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NResults_1_1Impl.html">mlir::OpTrait::NResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNResults_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNResults_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have at least a specified number of results.  <a href="classmlir_1_1OpTrait_1_1AtLeastNResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNResults_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNResults_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNResults_1_1Impl.html">mlir::OpTrait::AtLeastNResults&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AVariadicResults_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AVariadicResults_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicResults.html">mlir::OpTrait::VariadicResults&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of results.  <a href="classmlir_1_1OpTrait_1_1VariadicResults.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANoTerminator_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANoTerminator_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NoTerminator.html">mlir::OpTrait::NoTerminator&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class indicates that the regions associated with this op don't have terminators.  <a href="classmlir_1_1OpTrait_1_1NoTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AIsTerminator_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AIsTerminator_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsTerminator.html">mlir::OpTrait::IsTerminator&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be terminators.  <a href="classmlir_1_1OpTrait_1_1IsTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AZeroSuccessors_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AZeroSuccessors_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ZeroSuccessors.html">mlir::OpTrait::ZeroSuccessors&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have zero successors.  <a href="classmlir_1_1OpTrait_1_1ZeroSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiSuccessorTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3Adetail_3A_3AMultiSuccessorTraitBase_3C_20ConcreteType_2C_20TraitType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html">mlir::OpTrait::detail::MultiSuccessorTraitBase&lt; ConcreteType, TraitType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility trait base that provides accessors for derived traits that have multiple successors.  <a href="structmlir_1_1OpTrait_1_1detail_1_1MultiSuccessorTraitBase.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOneSuccessor_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOneSuccessor_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OneSuccessor.html">mlir::OpTrait::OneSuccessor&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have a single successor.  <a href="classmlir_1_1OpTrait_1_1OneSuccessor.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANSuccessors_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANSuccessors_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors.html">mlir::OpTrait::NSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to have a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1NSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANSuccessors_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANSuccessors_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1NSuccessors_1_1Impl.html">mlir::OpTrait::NSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNSuccessors_3C_20N_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNSuccessors_3C_20N_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs for ops that are known to have at least a specified number of successors.  <a href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAtLeastNSuccessors_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAtLeastNSuccessors_3C_20N_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AtLeastNSuccessors_1_1Impl.html">mlir::OpTrait::AtLeastNSuccessors&lt; N &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AVariadicSuccessors_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AVariadicSuccessors_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html">mlir::OpTrait::VariadicSuccessors&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops which have an unknown number of successors.  <a href="classmlir_1_1OpTrait_1_1VariadicSuccessors.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASingleBlock_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASingleBlock_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlock.html">mlir::OpTrait::SingleBlock&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block.  <a href="structmlir_1_1OpTrait_1_1SingleBlock.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASingleBlockImplicitTerminator_3C_20TerminatorOpType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASingleBlockImplicitTerminator_3C_20TerminatorOpType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides APIs and verifiers for ops with regions having a single block that must terminate with <span class="tt">TerminatorOpType</span>.  <a href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASingleBlockImplicitTerminator_3C_20TerminatorOpType_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASingleBlockImplicitTerminator_3C_20TerminatorOpType_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator_1_1Impl.html">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AhasSingleBlockImplicitTerminator_3C_20Op_2C_20hasTerminator_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AhasSingleBlockImplicitTerminator_3C_20Op_2C_20hasTerminator_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html">mlir::OpTrait::hasSingleBlockImplicitTerminator&lt; Op, hasTerminator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support to check if an operation has the <a class="el" href="structmlir_1_1OpTrait_1_1SingleBlockImplicitTerminator.html" title="This class provides APIs and verifiers for ops with regions having a single block that must terminate...">SingleBlockImplicitTerminator</a> trait.  <a href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AhasSingleBlockImplicitTerminator_3C_20Op_2C_20false_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AhasSingleBlockImplicitTerminator_3C_20Op_2C_20false_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1hasSingleBlockImplicitTerminator_3_01Op_00_01false_01_4.html">mlir::OpTrait::hasSingleBlockImplicitTerminator&lt; Op, false &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsShape_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsShape_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsShape.html">mlir::OpTrait::SameOperandsShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand shape: all operands are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultShape_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultShape_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html">mlir::OpTrait::SameOperandsAndResultShape&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result shape: both are scalars, vectors/tensors of the same shape.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultShape.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsElementType_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsElementType_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html">mlir::OpTrait::SameOperandsElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsElementType.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultElementType_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultElementType_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html">mlir::OpTrait::SameOperandsAndResultElementType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result element type (or the type itself if it is scalar).  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultElementType.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultType_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultType_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html">mlir::OpTrait::SameOperandsAndResultType&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides verification for ops that are known to have the same operand and result type.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultType.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultRank_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameOperandsAndResultRank_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameOperandsAndResultRank.html">mlir::OpTrait::SameOperandsAndResultRank&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that op has same ranks for all operands and results types, if known.  <a href="classmlir_1_1OpTrait_1_1SameOperandsAndResultRank.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AResultsAreBoolLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AResultsAreBoolLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html">mlir::OpTrait::ResultsAreBoolLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a boolean type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreBoolLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AResultsAreFloatLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AResultsAreFloatLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html">mlir::OpTrait::ResultsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a floating point type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AResultsAreSignlessIntegerLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AResultsAreSignlessIntegerLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html">mlir::OpTrait::ResultsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that any results of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1ResultsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AIsCommutative_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AIsCommutative_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsCommutative.html">mlir::OpTrait::IsCommutative&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is commutative.  <a href="classmlir_1_1OpTrait_1_1IsCommutative.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AIsInvolution_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AIsInvolution_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsInvolution.html">mlir::OpTrait::IsInvolution&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is an involution.  <a href="classmlir_1_1OpTrait_1_1IsInvolution.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AIsIdempotent_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AIsIdempotent_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIdempotent.html">mlir::OpTrait::IsIdempotent&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class adds property that the operation is idempotent.  <a href="classmlir_1_1OpTrait_1_1IsIdempotent.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOperandsAreFloatLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOperandsAreFloatLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html">mlir::OpTrait::OperandsAreFloatLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a float type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreFloatLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AOperandsAreSignlessIntegerLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AOperandsAreSignlessIntegerLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html">mlir::OpTrait::OperandsAreSignlessIntegerLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have a signless integer or index type, a vector thereof, or a tensor thereof.  <a href="classmlir_1_1OpTrait_1_1OperandsAreSignlessIntegerLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ASameTypeOperands_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ASameTypeOperands_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1SameTypeOperands.html">mlir::OpTrait::SameTypeOperands&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class verifies that all operands of the specified op have the same type.  <a href="classmlir_1_1OpTrait_1_1SameTypeOperands.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AConstantLike_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AConstantLike_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1ConstantLike.html">mlir::OpTrait::ConstantLike&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for a sub-set of ops that are known to be constant-like.  <a href="classmlir_1_1OpTrait_1_1ConstantLike.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AIsIsolatedFromAbove_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AIsIsolatedFromAbove_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides the API for ops that are known to be isolated from above.  <a href="classmlir_1_1OpTrait_1_1IsIsolatedFromAbove.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAffineScope_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAffineScope_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AffineScope.html">mlir::OpTrait::AffineScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that defines a new scope for polyhedral optimization purposes.  <a href="classmlir_1_1OpTrait_1_1AffineScope.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAutomaticAllocationScope_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAutomaticAllocationScope_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html">mlir::OpTrait::AutomaticAllocationScope&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait of region holding operations that define a new scope for automatic allocations, i.e., allocations that are freed when control is transferred back from the operation's region.  <a href="classmlir_1_1OpTrait_1_1AutomaticAllocationScope.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AHasParent_3C_20ParentOpTypes_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AHasParent_3C_20ParentOpTypes_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1HasParent.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a verifier for ops that are expecting their parent to be one of the given parent ops.  <a href="structmlir_1_1OpTrait_1_1HasParent.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AHasParent_3C_20ParentOpTypes_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AHasParent_3C_20ParentOpTypes_20_3E_3A_3AImpl_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1HasParent_1_1Impl.html">mlir::OpTrait::HasParent&lt; ParentOpTypes &gt;::Impl&lt; ConcreteType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAttrSizedOperandSegments_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAttrSizedOperandSegments_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html">mlir::OpTrait::AttrSizedOperandSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A trait for operations that have an attribute specifying operand segments.  <a href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AAttrSizedResultSegments_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AAttrSizedResultSegments_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html">mlir::OpTrait::AttrSizedResultSegments&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classmlir_1_1OpTrait_1_1AttrSizedOperandSegments.html" title="A trait for operations that have an attribute specifying operand segments.">AttrSizedOperandSegments</a> but used for results.  <a href="classmlir_1_1OpTrait_1_1AttrSizedResultSegments.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ANoRegionArguments_3C_20ConcrentType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ANoRegionArguments_3C_20ConcrentType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1NoRegionArguments.html">mlir::OpTrait::NoRegionArguments&lt; ConcrentType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait provides a verifier for ops that are expecting their regions to not have any arguments.  <a href="structmlir_1_1OpTrait_1_1NoRegionArguments.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AMemRefsNormalizable_3C_20ConcrentType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AMemRefsNormalizable_3C_20ConcrentType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1MemRefsNormalizable.html">mlir::OpTrait::MemRefsNormalizable&lt; ConcrentType &gt;</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AElementwise_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AElementwise_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html">mlir::OpTrait::Elementwise&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags element-wise ops on vectors or tensors.  <a href="structmlir_1_1OpTrait_1_1Elementwise.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AScalarizable_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AScalarizable_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html">mlir::OpTrait::Scalarizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically scalarized.  <a href="structmlir_1_1OpTrait_1_1Scalarizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3AVectorizable_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3AVectorizable_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html">mlir::OpTrait::Vectorizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically vectorized.  <a href="structmlir_1_1OpTrait_1_1Vectorizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3ATensorizable_3C_20ConcreteType_20_3E" id="r_mlir_3A_3AOpTrait_3A_3ATensorizable_3C_20ConcreteType_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html">mlir::OpTrait::Tensorizable&lt; ConcreteType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This trait tags <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span> operatons that can be systematically tensorized.  <a href="structmlir_1_1OpTrait_1_1Tensorizable.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOp_3C_20ConcreteType_2C_20Traits_20_3E" id="r_mlir_3A_3AOp_3C_20ConcreteType_2C_20Traits_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">mlir::Op&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="memitem:mlir_3A_3AOpInterface_3C_20ConcreteType_2C_20Traits_20_3E" id="r_mlir_3A_3AOpInterface_3C_20ConcreteType_2C_20Traits_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">mlir::OpInterface&lt; ConcreteType, Traits &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="memitem:llvm_3A_3ADenseMapInfo_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20mlir_3A_3AOpState_2C_20T_20_3E_3A_3Avalue_20_26_26_21mlir_3A_3Adetail_3A_3AIsInterface_3C_20T_20_3E_3A_3Avalue_20_3E_20_3E" id="r_llvm_3A_3ADenseMapInfo_3C_20T_2C_20std_3A_3Aenable_5Fif_5Ft_3C_20std_3A_3Ais_5Fbase_5Fof_3C_20mlir_3A_3AOpState_2C_20T_20_3E_3A_3Avalue_20_26_26_21mlir_3A_3Adetail_3A_3AIsInterface_3C_20T_20_3E_3A_3Avalue_20_3E_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1DenseMapInfo_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is__base__of_3_01mlir_1_1O3c54e4595db9bebd6b31d5f03d33a299.html">llvm::DenseMapInfo&lt; T, std::enable_if_t&lt; std::is_base_of&lt; mlir::OpState, T &gt;::value &amp;&amp;!mlir::detail::IsInterface&lt; T &gt;::value &gt; &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Aimpl" id="r_mlir_3A_3Aimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">mlir::impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
<tr class="memitem:llvm" id="r_llvm"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpAsmOpInterface, see OpAsmInterface.td for more details. <br /></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait" id="r_mlir_3A_3AOpTrait"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">mlir::OpTrait</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Aimpl" id="r_mlir_3A_3AOpTrait_3A_3Aimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html">mlir::OpTrait::impl</a></td></tr>
<tr class="memitem:mlir_3A_3AOpTrait_3A_3Adetail" id="r_mlir_3A_3AOpTrait_3A_3Adetail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1detail.html">mlir::OpTrait::detail</a></td></tr>
<tr class="memitem:mlir_3A_3Aop_5Fdefinition_5Fimpl" id="r_mlir_3A_3Aop_5Fdefinition_5Fimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html">mlir::op_definition_impl</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4c5fad6da649fd35570ab4588816c6ac" id="r_a4c5fad6da649fd35570ab4588816c6ac"><td class="memTemplParams" colspan="2">template&lt;class T&gt; </td></tr>
<tr class="memitem:a4c5fad6da649fd35570ab4588816c6ac template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html#a4c5fad6da649fd35570ab4588816c6ac">mlir::OpTrait::has_implicit_terminator_t</a> = typename T::ImplicitTerminatorOpT</td></tr>
<tr class="memdesc:a4c5fad6da649fd35570ab4588816c6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check is an op defines the <span class="tt">ImplicitTerminatorOpT</span> member.  <br /></td></tr>
<tr class="memitem:a5cb87aecb5daf42d8fd1df467673636f" id="r_a5cb87aecb5daf42d8fd1df467673636f"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Args&gt; </td></tr>
<tr class="memitem:a5cb87aecb5daf42d8fd1df467673636f template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a5cb87aecb5daf42d8fd1df467673636f">mlir::op_definition_impl::has_single_result_fold_trait</a></td></tr>
<tr class="memdesc:a5cb87aecb5daf42d8fd1df467673636f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a 'foldTrait' method for single result operations.  <br /></td></tr>
<tr class="memitem:a087eda32a53d7488afc61ab683477f54" id="r_a087eda32a53d7488afc61ab683477f54"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a087eda32a53d7488afc61ab683477f54 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a087eda32a53d7488afc61ab683477f54">mlir::op_definition_impl::detect_has_single_result_fold_trait</a></td></tr>
<tr class="memitem:a9447f91f0977b93448961f9952031b3d" id="r_a9447f91f0977b93448961f9952031b3d"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Args&gt; </td></tr>
<tr class="memitem:a9447f91f0977b93448961f9952031b3d template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a9447f91f0977b93448961f9952031b3d">mlir::op_definition_impl::has_fold_trait</a></td></tr>
<tr class="memdesc:a9447f91f0977b93448961f9952031b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a general 'foldTrait' method.  <br /></td></tr>
<tr class="memitem:ab7dcb07035e25a6249e2dfe7866caf29" id="r_ab7dcb07035e25a6249e2dfe7866caf29"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ab7dcb07035e25a6249e2dfe7866caf29 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab7dcb07035e25a6249e2dfe7866caf29">mlir::op_definition_impl::detect_has_fold_trait</a> = llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1op__definition__impl.html#a9447f91f0977b93448961f9952031b3d">has_fold_trait</a>, T&gt;</td></tr>
<tr class="memitem:a12ca7fca37096c6ab3fbb9dfdad5147a" id="r_a12ca7fca37096c6ab3fbb9dfdad5147a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a12ca7fca37096c6ab3fbb9dfdad5147a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a12ca7fca37096c6ab3fbb9dfdad5147a">mlir::op_definition_impl::detect_has_any_fold_trait</a></td></tr>
<tr class="memdesc:a12ca7fca37096c6ab3fbb9dfdad5147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides any <span class="tt">foldTrait</span> method.  <br /></td></tr>
<tr class="memitem:a0926fb7a3554b723b4dd5c14a4a97ba7" id="r_a0926fb7a3554b723b4dd5c14a4a97ba7"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Args&gt; </td></tr>
<tr class="memitem:a0926fb7a3554b723b4dd5c14a4a97ba7 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a0926fb7a3554b723b4dd5c14a4a97ba7">mlir::op_definition_impl::has_verify_trait</a> = decltype(T::verifyTrait(std::declval&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;()))</td></tr>
<tr class="memdesc:a0926fb7a3554b723b4dd5c14a4a97ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <span class="tt">verifyTrait</span> method.  <br /></td></tr>
<tr class="memitem:a87527e61f1ad67c0b11cc3d6b6115297" id="r_a87527e61f1ad67c0b11cc3d6b6115297"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a87527e61f1ad67c0b11cc3d6b6115297 template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a87527e61f1ad67c0b11cc3d6b6115297">mlir::op_definition_impl::detect_has_verify_trait</a> = llvm::is_detected&lt;<a class="el" href="namespacemlir_1_1op__definition__impl.html#a0926fb7a3554b723b4dd5c14a4a97ba7">has_verify_trait</a>, T&gt;</td></tr>
<tr class="memitem:ac5e6e6e1f623eddf59c6710ce93e6cfb" id="r_ac5e6e6e1f623eddf59c6710ce93e6cfb"><td class="memTemplParams" colspan="2">template&lt;typename T, typename... Args&gt; </td></tr>
<tr class="memitem:ac5e6e6e1f623eddf59c6710ce93e6cfb template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ac5e6e6e1f623eddf59c6710ce93e6cfb">mlir::op_definition_impl::has_verify_region_trait</a></td></tr>
<tr class="memdesc:ac5e6e6e1f623eddf59c6710ce93e6cfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if T provides a <span class="tt">verifyTrait</span> method.  <br /></td></tr>
<tr class="memitem:a7a9972472e0437c431f9157858b5a74a" id="r_a7a9972472e0437c431f9157858b5a74a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a7a9972472e0437c431f9157858b5a74a template"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a7a9972472e0437c431f9157858b5a74a">mlir::op_definition_impl::detect_has_verify_region_trait</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e7451c7364716df0ac50255d1bb0dba" id="r_a8e7451c7364716df0ac50255d1bb0dba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#a8e7451c7364716df0ac50255d1bb0dba">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:a8e7451c7364716df0ac50255d1bb0dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an operation, generated by <span class="tt">buildTerminatorOp</span>, at the end of the region's only block if it does not have a terminator already.  <br /></td></tr>
<tr class="memitem:ad89ade716be6ba0ebae6e192aa722859" id="r_ad89ade716be6ba0ebae6e192aa722859"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#ad89ade716be6ba0ebae6e192aa722859">mlir::impl::ensureRegionTerminator</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="namespacemlir.html#aeb139bbbd94ce3525f61d508772f5d69">function_ref</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *(<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>)&gt; buildTerminatorOp)</td></tr>
<tr class="memdesc:ad89ade716be6ba0ebae6e192aa722859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a simple <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> and forward to the <a class="el" href="classmlir_1_1OpBuilder.html" title="This class helps build Operations.">OpBuilder</a> version of this function.  <br /></td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3" id="r_abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">mlir::operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e" id="r_aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">mlir::operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1OpState.html">OpState</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memitem:a8c357b30f2e56803678fe5f7b75e80a1" id="r_a8c357b30f2e56803678fe5f7b75e80a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c357b30f2e56803678fe5f7b75e80a1">mlir::operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> ofr)</td></tr>
<tr class="memdesc:a8c357b30f2e56803678fe5f7b75e80a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <br /></td></tr>
<tr class="memitem:a4b8f6ec965d2fe8aa8366a1a2a3a5625" id="r_a4b8f6ec965d2fe8aa8366a1a2a3a5625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4b8f6ec965d2fe8aa8366a1a2a3a5625">mlir::operator&lt;&lt;</a> (<a class="el" href="classraw__ostream.html">raw_ostream</a> &amp;os, <a class="el" href="classmlir_1_1OpState.html">OpState</a> op)</td></tr>
<tr class="memdesc:a4b8f6ec965d2fe8aa8366a1a2a3a5625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing to a stream.  <br /></td></tr>
<tr class="memitem:a430c52e30f547cce594baec77ad010fc" id="r_a430c52e30f547cce594baec77ad010fc"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a430c52e30f547cce594baec77ad010fc">mlir::OpTrait::impl::foldCommutative</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memitem:a0132989f6240955f0653f9e2f544593e" id="r_a0132989f6240955f0653f9e2f544593e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a0132989f6240955f0653f9e2f544593e">mlir::OpTrait::impl::foldIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ad8adca9caae669acd6c6100fa24fe2ca" id="r_ad8adca9caae669acd6c6100fa24fe2ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad8adca9caae669acd6c6100fa24fe2ca">mlir::OpTrait::impl::foldInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a8dc8e54e8c1d63dcd42fb7b3035d0cdf" id="r_a8dc8e54e8c1d63dcd42fb7b3035d0cdf"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a8dc8e54e8c1d63dcd42fb7b3035d0cdf">mlir::OpTrait::impl::verifyZeroOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:aa809f4f4d8b09d82d6a8fd16dd2c9710" id="r_aa809f4f4d8b09d82d6a8fd16dd2c9710"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aa809f4f4d8b09d82d6a8fd16dd2c9710">mlir::OpTrait::impl::verifyOneOperand</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a1e0d9ddc91b449aa789d17f9586507fe" id="r_a1e0d9ddc91b449aa789d17f9586507fe"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1e0d9ddc91b449aa789d17f9586507fe">mlir::OpTrait::impl::verifyNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="memitem:a115a23d65257edee446fa4d25c6d53bf" id="r_a115a23d65257edee446fa4d25c6d53bf"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a115a23d65257edee446fa4d25c6d53bf">mlir::OpTrait::impl::verifyIsIdempotent</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a2d96b2cde016d241b493b4ad3a97b1e8" id="r_a2d96b2cde016d241b493b4ad3a97b1e8"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d96b2cde016d241b493b4ad3a97b1e8">mlir::OpTrait::impl::verifyIsInvolution</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a889058045dff9baa6b2a4a9950abbc7a" id="r_a889058045dff9baa6b2a4a9950abbc7a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a889058045dff9baa6b2a4a9950abbc7a">mlir::OpTrait::impl::verifyAtLeastNOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="memitem:a34cda488cf33c7043eb3a386c3cd4231" id="r_a34cda488cf33c7043eb3a386c3cd4231"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a34cda488cf33c7043eb3a386c3cd4231">mlir::OpTrait::impl::verifyOperandsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a1bd39e6ccba62558b270c9dad614273a" id="r_a1bd39e6ccba62558b270c9dad614273a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a1bd39e6ccba62558b270c9dad614273a">mlir::OpTrait::impl::verifyOperandsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:aefe4f6aa15d39476a2c01e85e7d52021" id="r_aefe4f6aa15d39476a2c01e85e7d52021"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#aefe4f6aa15d39476a2c01e85e7d52021">mlir::OpTrait::impl::verifySameTypeOperands</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a43a7adc47a424579bb05234b174532c2" id="r_a43a7adc47a424579bb05234b174532c2"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a43a7adc47a424579bb05234b174532c2">mlir::OpTrait::impl::verifyZeroRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a90522054e6b01d158e20f5a94e4b1aee" id="r_a90522054e6b01d158e20f5a94e4b1aee"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a90522054e6b01d158e20f5a94e4b1aee">mlir::OpTrait::impl::verifyOneRegion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ae3e80ada4c0550c82e88f4e4d840f4ad" id="r_ae3e80ada4c0550c82e88f4e4d840f4ad"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae3e80ada4c0550c82e88f4e4d840f4ad">mlir::OpTrait::impl::verifyNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="memitem:a53730de6badc603ad6f726118d16f287" id="r_a53730de6badc603ad6f726118d16f287"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a53730de6badc603ad6f726118d16f287">mlir::OpTrait::impl::verifyAtLeastNRegions</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numRegions)</td></tr>
<tr class="memitem:a58c8dcdc2de687b5948f14a209f930ca" id="r_a58c8dcdc2de687b5948f14a209f930ca"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a58c8dcdc2de687b5948f14a209f930ca">mlir::OpTrait::impl::verifyZeroResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ae95e50903d49322f2b78695b60b6bcc1" id="r_ae95e50903d49322f2b78695b60b6bcc1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ae95e50903d49322f2b78695b60b6bcc1">mlir::OpTrait::impl::verifyOneResult</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:add6d5eefac26d790469de86a7f077421" id="r_add6d5eefac26d790469de86a7f077421"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d5eefac26d790469de86a7f077421">mlir::OpTrait::impl::verifyNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="memitem:a110f9468129a20d2293ae53d7fe2ef0a" id="r_a110f9468129a20d2293ae53d7fe2ef0a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a110f9468129a20d2293ae53d7fe2ef0a">mlir::OpTrait::impl::verifyAtLeastNResults</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numOperands)</td></tr>
<tr class="memitem:a5e92618f861bedecfef4ad880f180081" id="r_a5e92618f861bedecfef4ad880f180081"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e92618f861bedecfef4ad880f180081">mlir::OpTrait::impl::verifySameOperandsShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:afab88926993882bfc40c836a88e5fe66" id="r_afab88926993882bfc40c836a88e5fe66"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#afab88926993882bfc40c836a88e5fe66">mlir::OpTrait::impl::verifySameOperandsAndResultShape</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ac82438cfd273eb4a921e6e4bf7491daa" id="r_ac82438cfd273eb4a921e6e4bf7491daa"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac82438cfd273eb4a921e6e4bf7491daa">mlir::OpTrait::impl::verifySameOperandsElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ad3a11e847e87cb0d535a2d211df24088" id="r_ad3a11e847e87cb0d535a2d211df24088"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ad3a11e847e87cb0d535a2d211df24088">mlir::OpTrait::impl::verifySameOperandsAndResultElementType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a5e846953be56c5cd49c049e25d293d92" id="r_a5e846953be56c5cd49c049e25d293d92"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a5e846953be56c5cd49c049e25d293d92">mlir::OpTrait::impl::verifySameOperandsAndResultType</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a908e2770558c3ccd9969e54a1aac68ce" id="r_a908e2770558c3ccd9969e54a1aac68ce"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a908e2770558c3ccd9969e54a1aac68ce">mlir::OpTrait::impl::verifySameOperandsAndResultRank</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:add6d0fe5f6a3c7e9dcbef8c906538ecf" id="r_add6d0fe5f6a3c7e9dcbef8c906538ecf"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#add6d0fe5f6a3c7e9dcbef8c906538ecf">mlir::OpTrait::impl::verifyResultsAreBoolLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a078673dba11a98a41584775609a09e85" id="r_a078673dba11a98a41584775609a09e85"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a078673dba11a98a41584775609a09e85">mlir::OpTrait::impl::verifyResultsAreFloatLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a2d3ceabf6cb31385e6c2f43371b614d3" id="r_a2d3ceabf6cb31385e6c2f43371b614d3"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a2d3ceabf6cb31385e6c2f43371b614d3">mlir::OpTrait::impl::verifyResultsAreSignlessIntegerLike</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a7d4b2825599a0e6a222707b3b6b53f75" id="r_a7d4b2825599a0e6a222707b3b6b53f75"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a7d4b2825599a0e6a222707b3b6b53f75">mlir::OpTrait::impl::verifyIsTerminator</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ab6c25ed99de1e19c5eeaa6b08b1239ea" id="r_ab6c25ed99de1e19c5eeaa6b08b1239ea"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ab6c25ed99de1e19c5eeaa6b08b1239ea">mlir::OpTrait::impl::verifyZeroSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ac938fc6e2ff3dc37694950498ae9dba6" id="r_ac938fc6e2ff3dc37694950498ae9dba6"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ac938fc6e2ff3dc37694950498ae9dba6">mlir::OpTrait::impl::verifyOneSuccessor</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a4403585b9eec4de7bddd7f41981c34b1" id="r_a4403585b9eec4de7bddd7f41981c34b1"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4403585b9eec4de7bddd7f41981c34b1">mlir::OpTrait::impl::verifyNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="memitem:a6cceb3d69b10bcd82a82246f93b967a4" id="r_a6cceb3d69b10bcd82a82246f93b967a4"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a6cceb3d69b10bcd82a82246f93b967a4">mlir::OpTrait::impl::verifyAtLeastNSuccessors</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classunsigned.html">unsigned</a> numSuccessors)</td></tr>
<tr class="memitem:a54b4da033b9e5d568efc60dc9c050430" id="r_a54b4da033b9e5d568efc60dc9c050430"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a54b4da033b9e5d568efc60dc9c050430">mlir::OpTrait::impl::verifyValueSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef attrName, StringRef valueGroupName, size_t expectedCount)</td></tr>
<tr class="memitem:a4fbacb7693a2df8b34e96340ab89a94a" id="r_a4fbacb7693a2df8b34e96340ab89a94a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a4fbacb7693a2df8b34e96340ab89a94a">mlir::OpTrait::impl::verifyOperandSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="memitem:ade217d2c5c5168f9b61dd5a7c6c812de" id="r_ade217d2c5c5168f9b61dd5a7c6c812de"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ade217d2c5c5168f9b61dd5a7c6c812de">mlir::OpTrait::impl::verifyResultSizeAttr</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, StringRef sizeAttrName)</td></tr>
<tr class="memitem:a232a88a3d7d7399639ab0a50678c305e" id="r_a232a88a3d7d7399639ab0a50678c305e"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a232a88a3d7d7399639ab0a50678c305e">mlir::OpTrait::impl::verifyNoRegionArguments</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a8ea847862ff70619d3d9d187e4e01e76" id="r_a8ea847862ff70619d3d9d187e4e01e76"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#a8ea847862ff70619d3d9d187e4e01e76">mlir::OpTrait::impl::verifyElementwise</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:ab15bc911e10042037458d32a120a0d9b" id="r_ab15bc911e10042037458d32a120a0d9b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1impl.html#ab15bc911e10042037458d32a120a0d9b">mlir::OpTrait::impl::verifyIsIsolatedFromAbove</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ab15bc911e10042037458d32a120a0d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for any values used by operations regions attached to the specified "IsIsolatedFromAbove" operation defined outside of it.  <br /></td></tr>
<tr class="memitem:a0c5480822c4898f287f588dfe98d1c85" id="r_a0c5480822c4898f287f588dfe98d1c85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html#a0c5480822c4898f287f588dfe98d1c85">mlir::OpTrait::hasElementwiseMappableTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a0c5480822c4898f287f588dfe98d1c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Together, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Elementwise.html" title="This trait tags element-wise ops on vectors or tensors.">Elementwise</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Scalarizable.html" title="This trait tags Elementwise operatons that can be systematically scalarized.">Scalarizable</a></span>, <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Vectorizable.html" title="This trait tags Elementwise operatons that can be systematically vectorized.">Vectorizable</a></span>, and <span class="tt"><a class="el" href="structmlir_1_1OpTrait_1_1Tensorizable.html" title="This trait tags Elementwise operatons that can be systematically tensorized.">Tensorizable</a></span> provide an easy way for scalar operations to conveniently generalize their behavior to vectors/tensors, and systematize conversion between these forms.  <br /></td></tr>
<tr class="memitem:a35df9e09f20c04343a817334a68fb5da" id="r_a35df9e09f20c04343a817334a68fb5da"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename T &gt; class... Traits&gt; </td></tr>
<tr class="memitem:a35df9e09f20c04343a817334a68fb5da template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a35df9e09f20c04343a817334a68fb5da">mlir::op_definition_impl::hasTrait</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> traitID)</td></tr>
<tr class="memdesc:a35df9e09f20c04343a817334a68fb5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this given Trait ID matches the IDs of any of the provided trait types <span class="tt">Traits</span>.  <br /></td></tr>
<tr class="memitem:a23f6a9fa450f9edfe7d57277d0cced86" id="r_a23f6a9fa450f9edfe7d57277d0cced86"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a23f6a9fa450f9edfe7d57277d0cced86 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a23f6a9fa450f9edfe7d57277d0cced86">mlir::op_definition_impl::hasTrait</a> (<a class="el" href="classmlir_1_1TypeID.html">TypeID</a> traitID)</td></tr>
<tr class="memitem:a3cc78dcecd16ccb04e39b9dbe458b1fb" id="r_a3cc78dcecd16ccb04e39b9dbe458b1fb"><td class="memTemplParams" colspan="2">template&lt;typename Trait&gt; </td></tr>
<tr class="memitem:a3cc78dcecd16ccb04e39b9dbe458b1fb template"><td class="memItemLeft" align="right" valign="top">static std::enable_if_t&lt; <a class="el" href="namespacemlir_1_1op__definition__impl.html#a087eda32a53d7488afc61ab683477f54">detect_has_single_result_fold_trait</a>&lt; Trait &gt;::value, LogicalResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3cc78dcecd16ccb04e39b9dbe458b1fb">mlir::op_definition_impl::foldTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a3cc78dcecd16ccb04e39b9dbe458b1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a <span class="tt">foldTrait</span> function that is specialized for operations that have a single result.  <br /></td></tr>
<tr class="memitem:a0b1fd6db183140575beaec3d27e40bd6" id="r_a0b1fd6db183140575beaec3d27e40bd6"><td class="memTemplParams" colspan="2">template&lt;typename Trait&gt; </td></tr>
<tr class="memitem:a0b1fd6db183140575beaec3d27e40bd6 template"><td class="memItemLeft" align="right" valign="top">static std::enable_if_t&lt; <a class="el" href="namespacemlir_1_1op__definition__impl.html#ab7dcb07035e25a6249e2dfe7866caf29">detect_has_fold_trait</a>&lt; Trait &gt;::value, LogicalResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a0b1fd6db183140575beaec3d27e40bd6">mlir::op_definition_impl::foldTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a0b1fd6db183140575beaec3d27e40bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of folding a trait that implements a generalized <span class="tt">foldTrait</span> function that is supports any operation type.  <br /></td></tr>
<tr class="memitem:a4ba8ee7ff8b805741102113d3260fe57" id="r_a4ba8ee7ff8b805741102113d3260fe57"><td class="memTemplParams" colspan="2">template&lt;typename Trait&gt; </td></tr>
<tr class="memitem:a4ba8ee7ff8b805741102113d3260fe57 template"><td class="memItemLeft" align="right" valign="top">static std::enable_if_t&lt;!<a class="el" href="namespacemlir_1_1op__definition__impl.html#a12ca7fca37096c6ab3fbb9dfdad5147a">detect_has_any_fold_trait</a>&lt; Trait &gt;::value, LogicalResult &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a4ba8ee7ff8b805741102113d3260fe57">mlir::op_definition_impl::foldTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;)</td></tr>
<tr class="memitem:a9f9f50d44f4d29093384d1517ee6bbc7" id="r_a9f9f50d44f4d29093384d1517ee6bbc7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a9f9f50d44f4d29093384d1517ee6bbc7 template"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a9f9f50d44f4d29093384d1517ee6bbc7">mlir::op_definition_impl::foldTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; &amp;results)</td></tr>
<tr class="memdesc:a9f9f50d44f4d29093384d1517ee6bbc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple type containing a set of traits, return the result of folding the given operation.  <br /></td></tr>
<tr class="memitem:aeab3645f6a133b49319eb6357e9ee63f" id="r_aeab3645f6a133b49319eb6357e9ee63f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:aeab3645f6a133b49319eb6357e9ee63f template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#aeab3645f6a133b49319eb6357e9ee63f">mlir::op_definition_impl::verifyTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:aeab3645f6a133b49319eb6357e9ee63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the given trait if it provides a verifier.  <br /></td></tr>
<tr class="memitem:a3f1995dca865ae098afe18a3230bd428" id="r_a3f1995dca865ae098afe18a3230bd428"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a3f1995dca865ae098afe18a3230bd428 template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a3f1995dca865ae098afe18a3230bd428">mlir::op_definition_impl::verifyTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a3f1995dca865ae098afe18a3230bd428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of traits, return the result of verifying the given operation.  <br /></td></tr>
<tr class="memitem:a128ed4525ea28bb3094197bcf3c2574f" id="r_a128ed4525ea28bb3094197bcf3c2574f"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a128ed4525ea28bb3094197bcf3c2574f template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#a128ed4525ea28bb3094197bcf3c2574f">mlir::op_definition_impl::verifyRegionTrait</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a128ed4525ea28bb3094197bcf3c2574f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the given trait if it provides a region verifier.  <br /></td></tr>
<tr class="memitem:ab994d3a7ec910aba95d06ad4b413711d" id="r_ab994d3a7ec910aba95d06ad4b413711d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ab994d3a7ec910aba95d06ad4b413711d template"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1op__definition__impl.html#ab994d3a7ec910aba95d06ad4b413711d">mlir::op_definition_impl::verifyRegionTraits</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:ab994d3a7ec910aba95d06ad4b413711d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a set of traits, return the result of verifying the regions of the given operation.  <br /></td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
