<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVMTypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1LLVMTypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">mlir::LLVMTypeConverter Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TypeConverter_8h_source.html">mlir/Conversion/LLVMCommon/TypeConverter.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Inheritance diagram for mlir::LLVMTypeConverter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="classmlir_1_1LLVMTypeConverter__inherit__graph.svg" width="195" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb9279107c83f744985d247e3c87cc09" id="r_abb9279107c83f744985d247e3c87cc09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb9279107c83f744985d247e3c87cc09">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:abb9279107c83f744985d247e3c87cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <br /></td></tr>
<tr class="memitem:aa0838be3560f61a0c13e8d39ff13f828" id="r_aa0838be3560f61a0c13e8d39ff13f828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0838be3560f61a0c13e8d39ff13f828">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;<a class="el" href="PassManagerOptions_8cpp.html#a565f4d58c99c19dde9d8fb7d12fd8a16">options</a>, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>)</td></tr>
<tr class="memdesc:aa0838be3560f61a0c13e8d39ff13f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <br /></td></tr>
<tr class="memitem:a47566416cff1df2ff38a4e46e5bddf1b" id="r_a47566416cff1df2ff38a4e46e5bddf1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47566416cff1df2ff38a4e46e5bddf1b">convertFunctionSignature</a> (FunctionType funcTy, <a class="el" href="classbool.html">bool</a> isVariadic, <a class="el" href="classbool.html">bool</a> useBarePtrCallConv, SignatureConversion &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>) const</td></tr>
<tr class="memdesc:a47566416cff1df2ff38a4e46e5bddf1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <br /></td></tr>
<tr class="memitem:a76e97c33926b2562068a3e1483698e15" id="r_a76e97c33926b2562068a3e1483698e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76e97c33926b2562068a3e1483698e15">convertFunctionSignature</a> (FunctionOpInterface funcOp, <a class="el" href="classbool.html">bool</a> isVariadic, <a class="el" href="classbool.html">bool</a> useBarePtrCallConv, LLVMTypeConverter::SignatureConversion &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; &gt; &amp;byValRefNonPtrAttrs) const</td></tr>
<tr class="memdesc:a76e97c33926b2562068a3e1483698e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <br /></td></tr>
<tr class="memitem:a32146e4cab341509dab49e585e27981a" id="r_a32146e4cab341509dab49e585e27981a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32146e4cab341509dab49e585e27981a">packFunctionResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classbool.html">bool</a> useBarePointerCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &gt; *groupedTypes=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>, <a class="el" href="classint64__t.html">int64_t</a> *numConvertedTypes=<a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a>) const</td></tr>
<tr class="memdesc:a32146e4cab341509dab49e585e27981a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types to be returned from a function into an LLVM-compatible type.  <br /></td></tr>
<tr class="memitem:a10b2654ba7a875df2dd830288792934c" id="r_a10b2654ba7a875df2dd830288792934c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b2654ba7a875df2dd830288792934c">packOperationResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types) const</td></tr>
<tr class="memdesc:a10b2654ba7a875df2dd830288792934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type.  <br /></td></tr>
<tr class="memitem:a3674de1b2fd3059e16868c0292114e38" id="r_a3674de1b2fd3059e16868c0292114e38"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3674de1b2fd3059e16868c0292114e38">convertCallingConventionType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>, <a class="el" href="classbool.html">bool</a> useBarePointerCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>) const</td></tr>
<tr class="memdesc:a3674de1b2fd3059e16868c0292114e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a type in the context of the default or bare pointer calling convention.  <br /></td></tr>
<tr class="memitem:ae1bae21dab08d18741a94aea9fa1b5be" id="r_ae1bae21dab08d18741a94aea9fa1b5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1bae21dab08d18741a94aea9fa1b5be">getContext</a> () const</td></tr>
<tr class="memdesc:ae1bae21dab08d18741a94aea9fa1b5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLIR context.  <br /></td></tr>
<tr class="memitem:ad899c4914472cef7ab52daf289b8fa31" id="r_ad899c4914472cef7ab52daf289b8fa31"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad899c4914472cef7ab52daf289b8fa31">getDialect</a> () const</td></tr>
<tr class="memdesc:ad899c4914472cef7ab52daf289b8fa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <br /></td></tr>
<tr class="memitem:a9ea1769ef6db9e5819be2a4d13c6ba5b" id="r_a9ea1769ef6db9e5819be2a4d13c6ba5b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ea1769ef6db9e5819be2a4d13c6ba5b">getOptions</a> () const</td></tr>
<tr class="memitem:a2505d1875adba7bafc9b9a4d307d3a3e" id="r_a2505d1875adba7bafc9b9a4d307d3a3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2505d1875adba7bafc9b9a4d307d3a3e">promoteOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> opOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt; adaptorOperands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classbool.html">bool</a> useBarePtrCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>) const</td></tr>
<tr class="memdesc:a2505d1875adba7bafc9b9a4d307d3a3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <br /></td></tr>
<tr class="memitem:a636e77ffebb9dbac0e4677d4de2dab0c" id="r_a636e77ffebb9dbac0e4677d4de2dab0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a636e77ffebb9dbac0e4677d4de2dab0c">promoteOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> opOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> adaptorOperands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classbool.html">bool</a> useBarePtrCallConv=<a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a>) const</td></tr>
<tr class="memitem:a9a0d71d9f3b2bab702e475f6890ed4a1" id="r_a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a0d71d9f3b2bab702e475f6890ed4a1">promoteOneMemRefDescriptor</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder) const</td></tr>
<tr class="memdesc:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <br /></td></tr>
<tr class="memitem:ae85823fd715ae2b9b86c5857fb6d37cc" id="r_ae85823fd715ae2b9b86c5857fb6d37cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; LLVM::LLVMFunctionType, LLVM::LLVMStructType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae85823fd715ae2b9b86c5857fb6d37cc">convertFunctionTypeCWrapper</a> (FunctionType type) const</td></tr>
<tr class="memdesc:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments.  <br /></td></tr>
<tr class="memitem:a5877616ac6642a9aeca41b0215db3c2b" id="r_a5877616ac6642a9aeca41b0215db3c2b"><td class="memItemLeft" align="right" valign="top">const llvm::DataLayout &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5877616ac6642a9aeca41b0215db3c2b">getDataLayout</a> () const</td></tr>
<tr class="memdesc:a5877616ac6642a9aeca41b0215db3c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout to use during and after conversion.  <br /></td></tr>
<tr class="memitem:ad48ce1c4841a7258aeb906f07c43e634" id="r_ad48ce1c4841a7258aeb906f07c43e634"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad48ce1c4841a7258aeb906f07c43e634">getDataLayoutAnalysis</a> () const</td></tr>
<tr class="memdesc:ad48ce1c4841a7258aeb906f07c43e634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout analysis to query during conversion.  <br /></td></tr>
<tr class="memitem:aeee2f27593c07c2c8e3bf8195252b1a8" id="r_aeee2f27593c07c2c8e3bf8195252b1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeee2f27593c07c2c8e3bf8195252b1a8">getIndexType</a> () const</td></tr>
<tr class="memdesc:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type.  <br /></td></tr>
<tr class="memitem:ae91b3adee39d4b558df51642b88890ae" id="r_ae91b3adee39d4b558df51642b88890ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae91b3adee39d4b558df51642b88890ae">getIndexTypeBitwidth</a> () const</td></tr>
<tr class="memdesc:ae91b3adee39d4b558df51642b88890ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <br /></td></tr>
<tr class="memitem:ac3faa948105d0db2cd0b26f7ae3920fa" id="r_ac3faa948105d0db2cd0b26f7ae3920fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3faa948105d0db2cd0b26f7ae3920fa">getPointerBitwidth</a> (<a class="el" href="classunsigned.html">unsigned</a> addressSpace=0) const</td></tr>
<tr class="memdesc:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer bitwidth.  <br /></td></tr>
<tr class="memitem:ae5bdd0b0c1b8f4b7ce1f7504a5673e58" id="r_ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">getMemRefDescriptorSize</a> (MemRefType type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the memref descriptor object in bytes.  <br /></td></tr>
<tr class="memitem:a5026b6f13d12445a8d60b3c9184aa904" id="r_a5026b6f13d12445a8d60b3c9184aa904"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5026b6f13d12445a8d60b3c9184aa904">getUnrankedMemRefDescriptorSize</a> (<a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:a5026b6f13d12445a8d60b3c9184aa904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the unranked memref descriptor object in bytes.  <br /></td></tr>
<tr class="memitem:ac8f665228b7d8d25949296df8e80cb19" id="r_ac8f665228b7d8d25949296df8e80cb19"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f665228b7d8d25949296df8e80cb19">getMemRefAddressSpace</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type) const</td></tr>
<tr class="memdesc:ac8f665228b7d8d25949296df8e80cb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <span class="tt">type</span> or failure if the memory space cannot be converted to an integer.  <br /></td></tr>
<tr class="memitem:a528df60590b2cfaf836106a55715d1db" id="r_a528df60590b2cfaf836106a55715d1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a528df60590b2cfaf836106a55715d1db">getMemRefDescriptorFields</a> (MemRefType type, <a class="el" href="classbool.html">bool</a> unpackAggregates) const</td></tr>
<tr class="memdesc:a528df60590b2cfaf836106a55715d1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a memref type into a list of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the memref descriptor.  <br /></td></tr>
<tr class="memitem:ac4f5690351e53c10618727ef67dd9f56" id="r_ac4f5690351e53c10618727ef67dd9f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4f5690351e53c10618727ef67dd9f56">getUnrankedMemRefDescriptorFields</a> () const</td></tr>
<tr class="memdesc:ac4f5690351e53c10618727ef67dd9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unranked memref type into a list of non-aggregate <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the unranked memref descriptor.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-static-methods" class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:add6a58ffa4a0f076c7e513d493c82fb3" id="r_add6a58ffa4a0f076c7e513d493c82fb3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add6a58ffa4a0f076c7e513d493c82fb3">canConvertToBarePtr</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type)</td></tr>
<tr class="memdesc:add6a58ffa4a0f076c7e513d493c82fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a memref type can be converted to a bare pointer.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7c8883828a1c71ea23fd045d82e1eaa1" id="r_a7c8883828a1c71ea23fd045d82e1eaa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c8883828a1c71ea23fd045d82e1eaa1">getCurrentThreadRecursiveStack</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0034100981a301427abe8367c89ef6a3" id="r_a0034100981a301427abe8367c89ef6a3"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0034100981a301427abe8367c89ef6a3">llvmDialect</a></td></tr>
<tr class="memdesc:a0034100981a301427abe8367c89ef6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <br /></td></tr>
<tr class="memitem:a7466ae2ed9e33d91b625d076c4dc517d" id="r_a7466ae2ed9e33d91b625d076c4dc517d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt; uint64_t, std::unique_ptr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7466ae2ed9e33d91b625d076c4dc517d">conversionCallStack</a></td></tr>
<tr class="memitem:a0a8ba63d13409bf975cd862683e071a8" id="r_a0a8ba63d13409bf975cd862683e071a8"><td class="memItemLeft" align="right" valign="top">llvm::sys::SmartRWMutex&lt; <a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a8ba63d13409bf975cd862683e071a8">callStackMutex</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-friends" class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9b34d77d5e460270f7b831c513dfe1b" id="r_af9b34d77d5e460270f7b831c513dfe1b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9b34d77d5e460270f7b831c513dfe1b">structFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a937d4dd628a8858b443a399410d2600b">result</a>)</td></tr>
<tr class="memdesc:af9b34d77d5e460270f7b831c513dfe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give structFuncArgTypeConverter access to memref-specific functions.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00035">35</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>
</div><a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb9279107c83f744985d247e3c87cc09" name="abb9279107c83f744985d247e3c87cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9279107c83f744985d247e3c87cc09">&#9670;&#160;</a></span>LLVMTypeConverter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *</td>          <td class="paramname"><span class="paramname"><em>analysis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.</p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00042">42</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00042">LLVMTypeConverter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00042">LLVMTypeConverter()</a>, and <a class="el" href="#af9b34d77d5e460270f7b831c513dfe1b">structFuncArgTypeConverter</a>.</p>

</div>
</div>
<a id="aa0838be3560f61a0c13e8d39ff13f828" name="aa0838be3560f61a0c13e8d39ff13f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0838be3560f61a0c13e8d39ff13f828">&#9670;&#160;</a></span>LLVMTypeConverter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *</td>          <td class="paramname"><span class="paramname"><em>ctx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>options</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *</td>          <td class="paramname"><span class="paramname"><em>analysis</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00115">115</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00813">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="TypeConverter_8h_source.html#l00206">llvmDialect</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00066">packRankedMemRefDesc()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00053">packUnrankedMemRefDesc()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00099">rankedMemRefMaterialization()</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02099">TypeRange</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00083">unrankedMemRefMaterialization()</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="add6a58ffa4a0f076c7e513d493c82fb3" name="add6a58ffa4a0f076c7e513d493c82fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a58ffa4a0f076c7e513d493c82fb3">&#9670;&#160;</a></span>canConvertToBarePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> LLVMTypeConverter::canConvertToBarePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a memref type can be converted to a bare pointer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00593">593</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00073">canBeCalledWithBarePointers()</a>.</p>

</div>
</div>
<a id="a3674de1b2fd3059e16868c0292114e38" name="a3674de1b2fd3059e16868c0292114e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3674de1b2fd3059e16868c0292114e38">&#9670;&#160;</a></span>convertCallingConventionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult LLVMTypeConverter::convertCallingConventionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a type in the context of the default or bare pointer calling convention. </p>
<p>Calling convention sensitive types, such as MemRefType and <a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>, are converted following the specific rules for the calling convention. Calling convention independent types are converted following the default <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00662">662</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>, and <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00826">mlir::barePtrFuncArgTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00702">packFunctionResults()</a>.</p>

</div>
</div>
<a id="a76e97c33926b2562068a3e1483698e15" name="a76e97c33926b2562068a3e1483698e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e97c33926b2562068a3e1483698e15">&#9670;&#160;</a></span>convertFunctionSignature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface</td>          <td class="paramname"><span class="paramname"><em>funcOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isVariadic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LLVMTypeConverter::SignatureConversion &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>byValRefNonPtrAttrs</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <span class="tt">result</span> is populated with argument mapping. Converted types of <span class="tt">llvm.byval</span> and <span class="tt">llvm.byref</span> function arguments which are not <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointers are overridden with <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointers. Overridden arguments are returned in <span class="tt">byValRefNonPtrAttrs</span>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00411">411</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00332">filterByValRefArgAttrs()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a id="a47566416cff1df2ff38a4e46e5bddf1b" name="a47566416cff1df2ff38a4e46e5bddf1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47566416cff1df2ff38a4e46e5bddf1b">&#9670;&#160;</a></span>convertFunctionSignature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionType</td>          <td class="paramname"><span class="paramname"><em>funcTy</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>isVariadic</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignatureConversion &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <span class="tt">result</span> is populated with argument mapping. </p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">mlir::convertFuncOpToLLVMFuncOp()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00078">mlir::GPUFuncOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae85823fd715ae2b9b86c5857fb6d37cc" name="ae85823fd715ae2b9b86c5857fb6d37cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85823fd715ae2b9b86c5857fb6d37cc">&#9670;&#160;</a></span>convertFunctionTypeCWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; LLVM::LLVMFunctionType, LLVM::LLVMStructType &gt; LLVMTypeConverter::convertFunctionTypeCWrapper </td>
          <td>(</td>
          <td class="paramtype">FunctionType</td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments. </p>
<p>Also converts the return type to a pointer argument if it is a struct. Returns true if this was the case. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00427">427</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00813">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00702">packFunctionResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00167">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00107">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="ae1bae21dab08d18741a94aea9fa1b5be" name="ae1bae21dab08d18741a94aea9fa1b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bae21dab08d18741a94aea9fa1b5be">&#9670;&#160;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp; LLVMTypeConverter::getContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLIR context. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00275">275</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00105">getDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01549">addOpaquePointerConversion()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00427">convertFunctionTypeCWrapper()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00554">getUnrankedMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00702">packFunctionResults()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00681">packOperationResults()</a>, <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">mlir::populateAMXLegalizeForLLVMExportPatterns()</a>, <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00505">mlir::populateGpuToLLVMSPVConversionPatterns()</a>, <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00695">mlir::populateGpuToNVVMConversionPatterns()</a>, and <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00431">mlir::populateGpuToROCDLConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7c8883828a1c71ea23fd045d82e1eaa1" name="a7c8883828a1c71ea23fd045d82e1eaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8883828a1c71ea23fd045d82e1eaa1">&#9670;&#160;</a></span>getCurrentThreadRecursiveStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp; LLVMTypeConverter::getCurrentThreadRecursiveStack </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00021">21</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00211">callStackMutex</a>, <a class="el" href="TypeConverter_8h_source.html#l00210">conversionCallStack</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00115">LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="a5877616ac6642a9aeca41b0215db3c2b" name="a5877616ac6642a9aeca41b0215db3c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5877616ac6642a9aeca41b0215db3c2b">&#9670;&#160;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::DataLayout &amp; mlir::LLVMTypeConverter::getDataLayout </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout to use during and after conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00136">136</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00088">getMemRefAlignment()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00073">getVectorAlignment()</a>.</p>

</div>
</div>
<a id="ad48ce1c4841a7258aeb906f07c43e634" name="ad48ce1c4841a7258aeb906f07c43e634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48ce1c4841a7258aeb906f07c43e634">&#9670;&#160;</a></span>getDataLayoutAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> * mlir::LLVMTypeConverter::getDataLayoutAnalysis </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout analysis to query during conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00139">139</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

</div>
</div>
<a id="ad899c4914472cef7ab52daf289b8fa31" name="ad899c4914472cef7ab52daf289b8fa31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad899c4914472cef7ab52daf289b8fa31">&#9670;&#160;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect * mlir::LLVMTypeConverter::getDialect </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00105">105</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00206">llvmDialect</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00032">mlir::ConvertToLLVMPattern::getDialect()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02199">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="aeee2f27593c07c2c8e3bf8195252b1a8" name="aeee2f27593c07c2c8e3bf8195252b1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee2f27593c07c2c8e3bf8195252b1a8">&#9670;&#160;</a></span>getIndexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::getIndexType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type. </p>
<p>The returned type is an integer type with the size configured for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00279">279</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00148">getIndexTypeBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00195">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSize()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptor()</a>, <a class="el" href="PtrToLLVM_8cpp_source.html#l00084">createMemRefMetadataType()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00036">mlir::ConvertToLLVMPattern::getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00486">getMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00526">getMemRefDescriptorSize()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00471">mlir::LLVM::getStridedElementPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00554">getUnrankedMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00558">getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00449">mlir::UnrankedMemRefDescriptor::offset()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00492">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00525">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00480">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00469">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00513">mlir::UnrankedMemRefDescriptor::stride()</a>, and <a class="el" href="MemRefBuilder_8cpp_source.html#l00504">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>.</p>

</div>
</div>
<a id="ae91b3adee39d4b558df51642b88890ae" name="ae91b3adee39d4b558df51642b88890ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91b3adee39d4b558df51642b88890ae">&#9670;&#160;</a></span>getIndexTypeBitwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> mlir::LLVMTypeConverter::getIndexTypeBitwidth </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00148">148</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, and <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00054">truncOrExtToLLVMType()</a>.</p>

</div>
</div>
<a id="ac8f665228b7d8d25949296df8e80cb19" name="ac8f665228b7d8d25949296df8e80cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f665228b7d8d25949296df8e80cb19">&#9670;&#160;</a></span>getMemRefAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; LLVMTypeConverter::getMemRefAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <span class="tt">type</span> or failure if the memory space cannot be converted to an integer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00575">575</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00439">mlir::BaseMemRefType::getMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptor()</a>, <a class="el" href="PtrToLLVM_8cpp_source.html#l00084">createMemRefMetadataType()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00670">getDynamicSharedMemorySymbol()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00081">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00486">getMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00526">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00558">getUnrankedMemRefDescriptorSize()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00125">isMemRefTypeSupported()</a>.</p>

</div>
</div>
<a id="a528df60590b2cfaf836106a55715d1db" name="a528df60590b2cfaf836106a55715d1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528df60590b2cfaf836106a55715d1db">&#9670;&#160;</a></span>getMemRefDescriptorFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 5 &gt; LLVMTypeConverter::getMemRefDescriptorFields </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>unpackAggregates</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a memref type into a list of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the memref descriptor. </p>
<p>If <span class="tt">unpackAggregates</span> is true the <span class="tt">sizes</span> and <span class="tt">strides</span> arrays in the descriptors are unpacked to individual index-typed elements, else they are kept as rank-sized arrays of index type. In particular, the list will contain:</p><ul>
<li>two pointers to the memref element type, followed by</li>
<li>an index-typed offset, followed by</li>
<li>(if unpackAggregates = true)<ul>
<li>one index-typed size per dimension of the memref, followed by</li>
<li>one index-typed stride per dimension of the memref.</li>
</ul>
</li>
<li>(if unpackArrregates = false)<ul>
<li>one rank-sized array of index-type for the size of each dimension</li>
<li>one rank-sized array of index-type for the stride of each dimension</li>
</ul>
</li>
</ul>
<p>For example, memref&lt;?x?xf32&gt; is converted to the following list:</p><ul>
<li><span class="tt">!llvm&lt;"float*"&gt;</span> (allocated pointer),</li>
<li><span class="tt">!llvm&lt;"float*"&gt;</span> (aligned pointer),</li>
<li><span class="tt">i64</span> (offset),</li>
<li><span class="tt">i64</span>, <span class="tt">i64</span> (sizes),</li>
<li><p class="startli"><span class="tt">i64</span>, <span class="tt">i64</span> (strides). These types can be recomposed to a memref descriptor struct.</p>
<p class="startli">The result contains the following types:</p><ol type="1">
<li>The pointer to the allocated data buffer, followed by</li>
<li>The pointer to the aligned data buffer, followed by</li>
<li>A lowered <span class="tt">index</span>-type integer containing the distance between the beginning of the buffer and the first element to be accessed through the view, followed by</li>
<li>An array containing as many <span class="tt">index</span>-type integers as the rank of the MemRef: the array represents the size, in number of elements, of the memref along the given dimension. For constant MemRef dimensions, the corresponding size entry is a constant whose runtime value must match the static value, followed by</li>
<li>A second array containing as many <span class="tt">index</span>-type integers as the rank of the MemRef: the second array represents the "stride" (in tensor abstraction sense), i.e. the number of consecutive elements of the underlying buffer. TODO: add assertions for the static cases.</li>
</ol>
<p class="startli">If <span class="tt">unpackAggregates</span> is set to true, the arrays described in (4) and (5) are expanded into individual index-type elements.</p>
<p class="startli">template &lt;typename Elem, typename Index, size_t Rank&gt; struct { Elem *allocatedPtr; Elem *alignedPtr; Index offset; Index sizes[Rank]; // omitted when rank == 0 Index strides[Rank]; // omitted when rank == 0 }; </p>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00486">486</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00332">mlir::emitError()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00575">getMemRefAddressSpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00066">packRankedMemRefDesc()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00801">mlir::structFuncArgTypeConverter()</a>.</p>

</div>
</div>
<a id="ae5bdd0b0c1b8f4b7ce1f7504a5673e58" name="ae5bdd0b0c1b8f4b7ce1f7504a5673e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">&#9670;&#160;</a></span>getMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMTypeConverter::getMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00526">526</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00575">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00283">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a9ea1769ef6db9e5819be2a4d13c6ba5b" name="a9ea1769ef6db9e5819be2a4d13c6ba5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea1769ef6db9e5819be2a4d13c6ba5b">&#9670;&#160;</a></span>getOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp; mlir::LLVMTypeConverter::getOptions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00107">107</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8cpp_source.html#l00762">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l02038">mlir::populateFinalizeMemRefToLLVMConversionPatterns()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00056">shouldUseBarePtrCallConv()</a>.</p>

</div>
</div>
<a id="ac3faa948105d0db2cd0b26f7ae3920fa" name="ac3faa948105d0db2cd0b26f7ae3920fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3faa948105d0db2cd0b26f7ae3920fa">&#9670;&#160;</a></span>getPointerBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMTypeConverter::getPointerBitwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>addressSpace</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pointer bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00283">283</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00526">getMemRefDescriptorSize()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00558">getUnrankedMemRefDescriptorSize()</a>.</p>

</div>
</div>
<a id="ac4f5690351e53c10618727ef67dd9f56" name="ac4f5690351e53c10618727ef67dd9f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f5690351e53c10618727ef67dd9f56">&#9670;&#160;</a></span>getUnrankedMemRefDescriptorFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 2 &gt; LLVMTypeConverter::getUnrankedMemRefDescriptorFields </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unranked memref type into a list of non-aggregate <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the unranked memref descriptor. </p>
<p>In particular, this list contains:</p><ul>
<li>an integer rank, followed by</li>
<li><p class="startli">a pointer to the memref descriptor struct. For example, memref&lt;<em>xf32&gt; is converted to the following list: i64 (rank) !llvm&lt;"i8&lt;/em&gt;"&gt; (type-erased pointer). These types can be recomposed to a unranked memref descriptor struct.</em></p>
<p class="startli"><em> In particular, the fields for an unranked memref descriptor are:</em></p>
</li>
</ul>
<ol type="1">
<li><em>index-typed rank, the dynamic rank of this MemRef</em></li>
<li><em>void* ptr, pointer to the static ranked MemRef descriptor. This will be stack allocated (alloca) copy of a MemRef descriptor that got casted to be unranked. </em></li>
</ol>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00554">554</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00053">packUnrankedMemRefDesc()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00801">mlir::structFuncArgTypeConverter()</a>.</p>

</div>
</div>
<a id="a5026b6f13d12445a8d60b3c9184aa904" name="a5026b6f13d12445a8d60b3c9184aa904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026b6f13d12445a8d60b3c9184aa904">&#9670;&#160;</a></span>getUnrankedMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classunsigned.html">unsigned</a> LLVMTypeConverter::getUnrankedMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>layout</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the unranked memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00558">558</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00575">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00283">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00557">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a32146e4cab341509dab49e585e27981a" name="a32146e4cab341509dab49e585e27981a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32146e4cab341509dab49e585e27981a">&#9670;&#160;</a></span>packFunctionResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packFunctionResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &gt; *</td>          <td class="paramname"><span class="paramname"><em>groupedTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint64__t.html">int64_t</a> *</td>          <td class="paramname"><span class="paramname"><em>numConvertedTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPToLLVMIRTranslation_8cpp.html#ad4cc417d4ffd42507c09b03f30422adc">nullptr</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types to be returned from a function into an LLVM-compatible type. </p>
<p>In particular, if more than one value is returned, create an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type with elements that correspond to each of the types converted with <span class="tt">convertCallingConventionType</span>.</p>
<p>Populate the converted (unpacked) types into <span class="tt">groupedTypes</span>, if provided. <span class="tt">groupedType</span> contains one nested vector per input type. In case of a 1:N conversion, a nested vector may contain 0 or more then 1 converted type.</p>
<p>In particular, if more than one value is returned, create an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type with elements that correspond to each of the types converted with <span class="tt">convertCallingConventionType</span>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00702">702</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00662">convertCallingConventionType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00427">convertFunctionTypeCWrapper()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00762">mlir::GPUReturnOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a10b2654ba7a875df2dd830288792934c" name="a10b2654ba7a875df2dd830288792934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b2654ba7a875df2dd830288792934c">&#9670;&#160;</a></span>packOperationResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packOperationResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>types</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type. </p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the LLVM-compatible types converted with <span class="tt">convertType</span>.</p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the types converted with <span class="tt">convertType</span>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00681">681</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00813">mlir::LLVM::isCompatibleType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00340">mlir::LLVM::detail::intrinsicRewrite()</a>, and <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00301">mlir::LLVM::detail::oneToOneRewrite()</a>.</p>

</div>
</div>
<a id="a9a0d71d9f3b2bab702e475f6890ed4a1" name="a9a0d71d9f3b2bab702e475f6890ed4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0d71d9f3b2bab702e475f6890ed4a1">&#9670;&#160;</a></span>promoteOneMemRefDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> LLVMTypeConverter::promoteOneMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>operand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00734">734</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00065">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00108">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="a2505d1875adba7bafc9b9a4d307d3a3e" name="a2505d1875adba7bafc9b9a4d307d3a3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2505d1875adba7bafc9b9a4d307d3a3e">&#9670;&#160;</a></span>promoteOperands() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; LLVMTypeConverter::promoteOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>opOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>adaptorOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>
<p>(The <a class="el" href="classmlir_1_1ArrayRef.html">ArrayRef</a> variant is for 1:N.) </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00757">757</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00088">mlir::MemRefDescriptor::alignedPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00248">mlir::MemRefDescriptor::unpack()</a>, and <a class="el" href="MemRefBuilder_8cpp_source.html#l00347">mlir::UnrankedMemRefDescriptor::unpack()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00748">promoteOperands()</a>.</p>

</div>
</div>
<a id="a636e77ffebb9dbac0e4677d4de2dab0c" name="a636e77ffebb9dbac0e4677d4de2dab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636e77ffebb9dbac0e4677d4de2dab0c">&#9670;&#160;</a></span>promoteOperands() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; LLVMTypeConverter::promoteOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>opOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td>          <td class="paramname"><span class="paramname"><em>adaptorOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>useBarePtrCallConv</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="OpenMPDialect_8cpp.html#ae6c865df784842196d411c1466b01686">false</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00748">748</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00757">promoteOperands()</a>.</p>

</div>
</div>
<a name="doc-related-members" id="doc-related-members"></a><h2 id="header-doc-related-members" class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="af9b34d77d5e460270f7b831c513dfe1b" name="af9b34d77d5e460270f7b831c513dfe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b34d77d5e460270f7b831c513dfe1b">&#9670;&#160;</a></span>structFuncArgTypeConverter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>converter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel friend">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give structFuncArgTypeConverter access to memref-specific functions. </p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00042">LLVMTypeConverter()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Member Data Documentation</h2>
<a id="a0a8ba63d13409bf975cd862683e071a8" name="a0a8ba63d13409bf975cd862683e071a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8ba63d13409bf975cd862683e071a8">&#9670;&#160;</a></span>callStackMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::sys::SmartRWMutex&lt;<a class="el" href="Dominance_8cpp.html#a1a24fc2eb8c1af6d06ac15bcec47f088">true</a>&gt; mlir::LLVMTypeConverter::callStackMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00211">211</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a7466ae2ed9e33d91b625d076c4dc517d" name="a7466ae2ed9e33d91b625d076c4dc517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7466ae2ed9e33d91b625d076c4dc517d">&#9670;&#160;</a></span>conversionCallStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#abde461319ad5039ddbf5b4e70f47618b">DenseMap</a>&lt;uint64_t, std::unique_ptr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt; &gt; &gt; mlir::LLVMTypeConverter::conversionCallStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00210">210</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a0034100981a301427abe8367c89ef6a3" name="a0034100981a301427abe8367c89ef6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034100981a301427abe8367c89ef6a3">&#9670;&#160;</a></span>llvmDialect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::llvmDialect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00206">206</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8h_source.html#l00105">getDialect()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00115">LLVMTypeConverter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a></li>
<li>lib/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
