<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::LLVMTypeConverter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1LLVMTypeConverter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::LLVMTypeConverter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  
 <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TypeConverter_8h_source.html">mlir/Conversion/LLVMCommon/TypeConverter.h</a>&quot;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for mlir::LLVMTypeConverter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classmlir_1_1LLVMTypeConverter__inherit__graph.svg" width="195" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abb9279107c83f744985d247e3c87cc09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:abb9279107c83f744985d247e3c87cc09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#abb9279107c83f744985d247e3c87cc09">More...</a><br /></td></tr>
<tr class="separator:abb9279107c83f744985d247e3c87cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838be3560f61a0c13e8d39ff13f828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">LLVMTypeConverter</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;options, const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *analysis=nullptr)</td></tr>
<tr class="memdesc:aa0838be3560f61a0c13e8d39ff13f828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#aa0838be3560f61a0c13e8d39ff13f828">More...</a><br /></td></tr>
<tr class="separator:aa0838be3560f61a0c13e8d39ff13f828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a134316f4850a9e646dc68e8376ad9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a53a134316f4850a9e646dc68e8376ad9">convertFunctionSignature</a> (FunctionType funcTy, bool isVariadic, bool useBarePtrCallConv, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result) const</td></tr>
<tr class="memdesc:a53a134316f4850a9e646dc68e8376ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <a href="classmlir_1_1LLVMTypeConverter.html#a53a134316f4850a9e646dc68e8376ad9">More...</a><br /></td></tr>
<tr class="separator:a53a134316f4850a9e646dc68e8376ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aa8fa70342ae4cf9d72e0532e8d46b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac6aa8fa70342ae4cf9d72e0532e8d46b">convertFunctionSignature</a> (FunctionOpInterface funcOp, bool isVariadic, bool useBarePtrCallConv, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">LLVMTypeConverter::SignatureConversion</a> &amp;result, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&gt; &amp;byValRefNonPtrAttrs) const</td></tr>
<tr class="memdesc:ac6aa8fa70342ae4cf9d72e0532e8d46b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a function type.  <a href="classmlir_1_1LLVMTypeConverter.html#ac6aa8fa70342ae4cf9d72e0532e8d46b">More...</a><br /></td></tr>
<tr class="separator:ac6aa8fa70342ae4cf9d72e0532e8d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f908311d50945ff0d644ad3beaee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a285f908311d50945ff0d644ad3beaee7">packFunctionResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, bool useBarePointerCallConv=false) const</td></tr>
<tr class="memdesc:a285f908311d50945ff0d644ad3beaee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types to be returned from a function into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#a285f908311d50945ff0d644ad3beaee7">More...</a><br /></td></tr>
<tr class="separator:a285f908311d50945ff0d644ad3beaee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b2654ba7a875df2dd830288792934c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a10b2654ba7a875df2dd830288792934c">packOperationResults</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types) const</td></tr>
<tr class="memdesc:a10b2654ba7a875df2dd830288792934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type.  <a href="classmlir_1_1LLVMTypeConverter.html#a10b2654ba7a875df2dd830288792934c">More...</a><br /></td></tr>
<tr class="separator:a10b2654ba7a875df2dd830288792934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aa7ebcd548b2fb3f46bad15f6563786bf">convertCallingConventionType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, bool useBarePointerCallConv=false) const</td></tr>
<tr class="memdesc:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a type in the context of the default or bare pointer calling convention.  <a href="classmlir_1_1LLVMTypeConverter.html#aa7ebcd548b2fb3f46bad15f6563786bf">More...</a><br /></td></tr>
<tr class="separator:aa7ebcd548b2fb3f46bad15f6563786bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d31697177d4412398c4c9a114cdb2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5d31697177d4412398c4c9a114cdb2f0">promoteBarePtrsToDescriptors</a> (<a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; stdTypes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values) const</td></tr>
<tr class="memdesc:a5d31697177d4412398c4c9a114cdb2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the bare pointers in 'values' that resulted from memrefs to descriptors.  <a href="classmlir_1_1LLVMTypeConverter.html#a5d31697177d4412398c4c9a114cdb2f0">More...</a><br /></td></tr>
<tr class="separator:a5d31697177d4412398c4c9a114cdb2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bae21dab08d18741a94aea9fa1b5be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae1bae21dab08d18741a94aea9fa1b5be">getContext</a> () const</td></tr>
<tr class="memdesc:ae1bae21dab08d18741a94aea9fa1b5be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLIR context.  <a href="classmlir_1_1LLVMTypeConverter.html#ae1bae21dab08d18741a94aea9fa1b5be">More...</a><br /></td></tr>
<tr class="separator:ae1bae21dab08d18741a94aea9fa1b5be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fef25eab0df64af252d7d14c4a0caec"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a1fef25eab0df64af252d7d14c4a0caec">getDialect</a> () const</td></tr>
<tr class="memdesc:a1fef25eab0df64af252d7d14c4a0caec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a1fef25eab0df64af252d7d14c4a0caec">More...</a><br /></td></tr>
<tr class="separator:a1fef25eab0df64af252d7d14c4a0caec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f142ecd8d10e44d253307880715607"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a48f142ecd8d10e44d253307880715607">getOptions</a> () const</td></tr>
<tr class="separator:a48f142ecd8d10e44d253307880715607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77513f669fae3497ae34732244ac6b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ab77513f669fae3497ae34732244ac6b9">promoteOperands</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> opOperands, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, bool useBarePtrCallConv=false) const</td></tr>
<tr class="memdesc:ab77513f669fae3497ae34732244ac6b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#ab77513f669fae3497ae34732244ac6b9">More...</a><br /></td></tr>
<tr class="separator:ab77513f669fae3497ae34732244ac6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a9a0d71d9f3b2bab702e475f6890ed4a1">promoteOneMemRefDescriptor</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> operand, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder) const</td></tr>
<tr class="memdesc:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing.  <a href="classmlir_1_1LLVMTypeConverter.html#a9a0d71d9f3b2bab702e475f6890ed4a1">More...</a><br /></td></tr>
<tr class="separator:a9a0d71d9f3b2bab702e475f6890ed4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="memItemLeft" align="right" valign="top">std::pair&lt; LLVM::LLVMFunctionType, LLVM::LLVMStructType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae85823fd715ae2b9b86c5857fb6d37cc">convertFunctionTypeCWrapper</a> (FunctionType type) const</td></tr>
<tr class="memdesc:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments.  <a href="classmlir_1_1LLVMTypeConverter.html#ae85823fd715ae2b9b86c5857fb6d37cc">More...</a><br /></td></tr>
<tr class="separator:ae85823fd715ae2b9b86c5857fb6d37cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="memItemLeft" align="right" valign="top">const llvm::DataLayout &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#adcd53b4634b1a8d32cebcce2e47fb8eb">getDataLayout</a> () const</td></tr>
<tr class="memdesc:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout to use during and after conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#adcd53b4634b1a8d32cebcce2e47fb8eb">More...</a><br /></td></tr>
<tr class="separator:adcd53b4634b1a8d32cebcce2e47fb8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">getDataLayoutAnalysis</a> () const</td></tr>
<tr class="memdesc:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the data layout analysis to query during conversion.  <a href="classmlir_1_1LLVMTypeConverter.html#a5e5617fe390dff357f3e9e39f9ed9e38">More...</a><br /></td></tr>
<tr class="separator:a5e5617fe390dff357f3e9e39f9ed9e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aeee2f27593c07c2c8e3bf8195252b1a8">getIndexType</a> () const</td></tr>
<tr class="memdesc:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type.  <a href="classmlir_1_1LLVMTypeConverter.html#aeee2f27593c07c2c8e3bf8195252b1a8">More...</a><br /></td></tr>
<tr class="separator:aeee2f27593c07c2c8e3bf8195252b1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b3adee39d4b558df51642b88890ae"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae91b3adee39d4b558df51642b88890ae">getIndexTypeBitwidth</a> () const</td></tr>
<tr class="memdesc:ae91b3adee39d4b558df51642b88890ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="classmlir_1_1LLVMTypeConverter.html#ae91b3adee39d4b558df51642b88890ae">More...</a><br /></td></tr>
<tr class="separator:ae91b3adee39d4b558df51642b88890ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac3faa948105d0db2cd0b26f7ae3920fa">getPointerBitwidth</a> (unsigned addressSpace=0) const</td></tr>
<tr class="memdesc:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pointer bitwidth.  <a href="classmlir_1_1LLVMTypeConverter.html#ac3faa948105d0db2cd0b26f7ae3920fa">More...</a><br /></td></tr>
<tr class="separator:ac3faa948105d0db2cd0b26f7ae3920fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">getMemRefDescriptorSize</a> (MemRefType type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">More...</a><br /></td></tr>
<tr class="separator:ae5bdd0b0c1b8f4b7ce1f7504a5673e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5026b6f13d12445a8d60b3c9184aa904"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a5026b6f13d12445a8d60b3c9184aa904">getUnrankedMemRefDescriptorSize</a> (<a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a> type, const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;layout) const</td></tr>
<tr class="memdesc:a5026b6f13d12445a8d60b3c9184aa904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the unranked memref descriptor object in bytes.  <a href="classmlir_1_1LLVMTypeConverter.html#a5026b6f13d12445a8d60b3c9184aa904">More...</a><br /></td></tr>
<tr class="separator:a5026b6f13d12445a8d60b3c9184aa904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f665228b7d8d25949296df8e80cb19"><td class="memItemLeft" align="right" valign="top">FailureOr&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac8f665228b7d8d25949296df8e80cb19">getMemRefAddressSpace</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type) const</td></tr>
<tr class="memdesc:ac8f665228b7d8d25949296df8e80cb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer.  <a href="classmlir_1_1LLVMTypeConverter.html#ac8f665228b7d8d25949296df8e80cb19">More...</a><br /></td></tr>
<tr class="separator:ac8f665228b7d8d25949296df8e80cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528df60590b2cfaf836106a55715d1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 5 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a528df60590b2cfaf836106a55715d1db">getMemRefDescriptorFields</a> (MemRefType type, bool unpackAggregates) const</td></tr>
<tr class="memdesc:a528df60590b2cfaf836106a55715d1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a memref type into a list of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the memref descriptor.  <a href="classmlir_1_1LLVMTypeConverter.html#a528df60590b2cfaf836106a55715d1db">More...</a><br /></td></tr>
<tr class="separator:a528df60590b2cfaf836106a55715d1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f5690351e53c10618727ef67dd9f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#ac4f5690351e53c10618727ef67dd9f56">getUnrankedMemRefDescriptorFields</a> () const</td></tr>
<tr class="memdesc:ac4f5690351e53c10618727ef67dd9f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an unranked memref type into a list of non-aggregate <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the unranked memref descriptor.  <a href="classmlir_1_1LLVMTypeConverter.html#ac4f5690351e53c10618727ef67dd9f56">More...</a><br /></td></tr>
<tr class="separator:ac4f5690351e53c10618727ef67dd9f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fae4fc72123cef7302a93ba314c6a"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:aad1fae4fc72123cef7302a93ba314c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1LLVMTypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">More...</a><br /></td></tr>
<tr class="separator:aad1fae4fc72123cef7302a93ba314c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28856d7176c4af44f64906de33b6ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a7c28856d7176c4af44f64906de33b6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1LLVMTypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">More...</a><br /></td></tr>
<tr class="separator:a7c28856d7176c4af44f64906de33b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a781dc5f696e4309ad385645a74295fe0">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a781dc5f696e4309ad385645a74295fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1LLVMTypeConverter.html#a781dc5f696e4309ad385645a74295fe0">More...</a><br /></td></tr>
<tr class="separator:a781dc5f696e4309ad385645a74295fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmlir_1_1TypeConverter"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmlir_1_1TypeConverter')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmlir_1_1TypeConverter.html">mlir::TypeConverter</a></td></tr>
<tr class="memitem:ac23c45fa40bd2771f27702f46fac5232 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac23c45fa40bd2771f27702f46fac5232">~TypeConverter</a> ()=default</td></tr>
<tr class="separator:ac23c45fa40bd2771f27702f46fac5232 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7055830377e3f38b6160a9712b5beba1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7055830377e3f38b6160a9712b5beba1">TypeConverter</a> ()=default</td></tr>
<tr class="separator:a7055830377e3f38b6160a9712b5beba1 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b77498262ce63baee43eafd23b3e6df inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7b77498262ce63baee43eafd23b3e6df">TypeConverter</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7b77498262ce63baee43eafd23b3e6df inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c8bca88d9cd366e8b727b1aca27ae inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7e7c8bca88d9cd366e8b727b1aca27ae">operator=</a> (const <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;other)</td></tr>
<tr class="separator:a7e7c8bca88d9cd366e8b727b1aca27ae inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;&gt; </td></tr>
<tr class="memitem:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">addConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function.  <a href="classmlir_1_1TypeConverter.html#a272bc4144b1ac5a3f7f1ad25c0e39e03">More...</a><br /></td></tr>
<tr class="separator:a272bc4144b1ac5a3f7f1ad25c0e39e03 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">addSourceMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of the following materializations require function objects that are convertible to the following form: <code>Value(OpBuilder &amp;, T, ValueRange, Location)</code>, where <code>T</code> is any subclass of <code><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">Type</a></code>.  <a href="classmlir_1_1TypeConverter.html#aaf35c0b4faa6fa6d8eda987ad71393e9">More...</a><br /></td></tr>
<tr class="separator:aaf35c0b4faa6fa6d8eda987ad71393e9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;                              std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">addTargetMaterialization</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method registers a materialization that will be called when converting a value to a target type according to a pattern's type converter.  <a href="classmlir_1_1TypeConverter.html#acfe54f9a4348e1d8aa30535f53ddaf37">More...</a><br /></td></tr>
<tr class="separator:acfe54f9a4348e1d8aa30535f53ddaf37 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename FnT , typename T  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;0&gt;, typename A  = typename llvm::function_traits&lt;std::decay_t&lt;FnT&gt;&gt;::template arg_t&lt;1&gt;&gt; </td></tr>
<tr class="memitem:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">addTypeAttributeConversion</a> (FnT &amp;&amp;callback)</td></tr>
<tr class="memdesc:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a conversion function for attributes within types.  <a href="classmlir_1_1TypeConverter.html#ac5b36cbf0a62aab9acb39d9299336980">More...</a><br /></td></tr>
<tr class="separator:ac5b36cbf0a62aab9acb39d9299336980 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given type.  <a href="classmlir_1_1TypeConverter.html#aad1fae4fc72123cef7302a93ba314c6a">More...</a><br /></td></tr>
<tr class="separator:aad1fae4fc72123cef7302a93ba314c6a inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This hook simplifies defining 1-1 type conversions.  <a href="classmlir_1_1TypeConverter.html#a7c28856d7176c4af44f64906de33b6ac">More...</a><br /></td></tr>
<tr class="separator:a7c28856d7176c4af44f64906de33b6ac inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename TargetType &gt; </td></tr>
<tr class="memitem:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">TargetType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">convertType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> t) const</td></tr>
<tr class="memdesc:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>.  <a href="classmlir_1_1TypeConverter.html#a781dc5f696e4309ad385645a74295fe0">More...</a><br /></td></tr>
<tr class="separator:a781dc5f696e4309ad385645a74295fe0 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">convertTypes</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;results) const</td></tr>
<tr class="memdesc:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given set of types, filling 'results' as necessary.  <a href="classmlir_1_1TypeConverter.html#ad8a2339e9128e1b05df14b075f6c3914">More...</a><br /></td></tr>
<tr class="separator:ad8a2339e9128e1b05df14b075f6c3914 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">isLegal</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type) const</td></tr>
<tr class="memdesc:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given type is legal for this type converter, i.e.  <a href="classmlir_1_1TypeConverter.html#a3050e11aff691748a33f690d842ada1c">More...</a><br /></td></tr>
<tr class="separator:a3050e11aff691748a33f690d842ada1c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplParams" colspan="2">template&lt;typename RangeT &gt; </td></tr>
<tr class="memitem:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;::value &amp;&amp;!std::is_convertible&lt; RangeT, <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">isLegal</a> (RangeT &amp;&amp;range) const</td></tr>
<tr class="memdesc:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all of the given types are legal for this type converter.  <a href="classmlir_1_1TypeConverter.html#a75fd289b2940df99c1e068a8dfef4759">More...</a><br /></td></tr>
<tr class="separator:a75fd289b2940df99c1e068a8dfef4759 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">isLegal</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op) const</td></tr>
<tr class="memdesc:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given operation has legal operand and result types.  <a href="classmlir_1_1TypeConverter.html#a2b1eee88c23ccdc294537f1a04a79d3c">More...</a><br /></td></tr>
<tr class="separator:a2b1eee88c23ccdc294537f1a04a79d3c inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">isLegal</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> *region) const</td></tr>
<tr class="memdesc:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the types of block arguments within the region are legal.  <a href="classmlir_1_1TypeConverter.html#a672cfe5a3dfbc0a44bb6ad90e496867f">More...</a><br /></td></tr>
<tr class="separator:a672cfe5a3dfbc0a44bb6ad90e496867f inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">isSignatureLegal</a> (FunctionType ty) const</td></tr>
<tr class="memdesc:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the inputs and outputs of the given function type are legal.  <a href="classmlir_1_1TypeConverter.html#ae22e7873e1d10ad53ffc8bc89bf4e094">More...</a><br /></td></tr>
<tr class="separator:ae22e7873e1d10ad53ffc8bc89bf4e094 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">convertSignatureArg</a> (unsigned inputNo, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result) const</td></tr>
<tr class="memdesc:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method allows for converting a specific argument of a signature.  <a href="classmlir_1_1TypeConverter.html#a79a08ffe75d1915342f5961a910cf700">More...</a><br /></td></tr>
<tr class="separator:a79a08ffe75d1915342f5961a910cf700 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60393514e60087a6f446c7f63f516bf9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a60393514e60087a6f446c7f63f516bf9">convertSignatureArgs</a> (<a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> types, <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &amp;result, unsigned origInputOffset=0) const</td></tr>
<tr class="separator:a60393514e60087a6f446c7f63f516bf9 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">SignatureConversion</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">convertBlockSignature</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> *block) const</td></tr>
<tr class="memdesc:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the type signature of the given block, by invoking 'convertSignatureArg' for each argument.  <a href="classmlir_1_1TypeConverter.html#aad8d5e5f4f53b68ae964d852a16e5352">More...</a><br /></td></tr>
<tr class="separator:aad8d5e5f4f53b68ae964d852a16e5352 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0694982a6432fdec13ec854cd011c632 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a0694982a6432fdec13ec854cd011c632">materializeSourceConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs) const</td></tr>
<tr class="memdesc:a0694982a6432fdec13ec854cd011c632 inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Materialize a conversion from a set of types into one result type by generating a cast sequence of some kind.  <a href="classmlir_1_1TypeConverter.html#a0694982a6432fdec13ec854cd011c632">More...</a><br /></td></tr>
<tr class="separator:a0694982a6432fdec13ec854cd011c632 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af266521b8a2e7e87a2e7048dbcf5745d inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#af266521b8a2e7e87a2e7048dbcf5745d">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs, <a class="el" href="classmlir_1_1Type.html">Type</a> originalType={}) const</td></tr>
<tr class="separator:af266521b8a2e7e87a2e7048dbcf5745d inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7b2e78bd21ab025bf2274ae81ce834 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#acc7b2e78bd21ab025bf2274ae81ce834">materializeTargetConversion</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> inputs, <a class="el" href="classmlir_1_1Type.html">Type</a> originalType={}) const</td></tr>
<tr class="separator:acc7b2e78bd21ab025bf2274ae81ce834 inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">convertTypeAttribute</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr) const</td></tr>
<tr class="memdesc:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an attribute present <code>attr</code> from within the type <code>type</code> using the registered conversion functions.  <a href="classmlir_1_1TypeConverter.html#a011b143e5a619f6f44d5bd46c29b95cc">More...</a><br /></td></tr>
<tr class="separator:a011b143e5a619f6f44d5bd46c29b95cc inherit pub_methods_classmlir_1_1TypeConverter"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">canConvertToBarePtr</a> (<a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> type)</td></tr>
<tr class="memdesc:add6a58ffa4a0f076c7e513d493c82fb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a memref type can be converted to a bare pointer.  <a href="classmlir_1_1LLVMTypeConverter.html#add6a58ffa4a0f076c7e513d493c82fb3">More...</a><br /></td></tr>
<tr class="separator:add6a58ffa4a0f076c7e513d493c82fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7c8883828a1c71ea23fd045d82e1eaa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7c8883828a1c71ea23fd045d82e1eaa1">getCurrentThreadRecursiveStack</a> ()</td></tr>
<tr class="separator:a7c8883828a1c71ea23fd045d82e1eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0034100981a301427abe8367c89ef6a3"><td class="memItemLeft" align="right" valign="top">LLVM::LLVMDialect *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">llvmDialect</a></td></tr>
<tr class="memdesc:a0034100981a301427abe8367c89ef6a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#a0034100981a301427abe8367c89ef6a3">More...</a><br /></td></tr>
<tr class="separator:a0034100981a301427abe8367c89ef6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7466ae2ed9e33d91b625d076c4dc517d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt; uint64_t, std::unique_ptr&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a7466ae2ed9e33d91b625d076c4dc517d">conversionCallStack</a></td></tr>
<tr class="separator:a7466ae2ed9e33d91b625d076c4dc517d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8ba63d13409bf975cd862683e071a8"><td class="memItemLeft" align="right" valign="top">llvm::sys::SmartRWMutex&lt; true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#a0a8ba63d13409bf975cd862683e071a8">callStackMutex</a></td></tr>
<tr class="separator:a0a8ba63d13409bf975cd862683e071a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af9b34d77d5e460270f7b831c513dfe1b"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html#af9b34d77d5e460270f7b831c513dfe1b">structFuncArgTypeConverter</a> (const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1Type.html">Type</a> type, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;result)</td></tr>
<tr class="memdesc:af9b34d77d5e460270f7b831c513dfe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give structFuncArgTypeConverter access to memref-specific functions.  <a href="classmlir_1_1LLVMTypeConverter.html#af9b34d77d5e460270f7b831c513dfe1b">More...</a><br /></td></tr>
<tr class="separator:af9b34d77d5e460270f7b831c513dfe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Conversion from types to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00035">35</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abb9279107c83f744985d247e3c87cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9279107c83f744985d247e3c87cc09">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using the default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using default <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>.</p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00042">42</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

</div>
</div>
<a id="aa0838be3560f61a0c13e8d39ff13f828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0838be3560f61a0c13e8d39ff13f828">&#9670;&nbsp;</a></span>LLVMTypeConverter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLVMTypeConverter::LLVMTypeConverter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a> *&#160;</td>
          <td class="paramname"><em>analysis</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an <a class="el" href="classmlir_1_1LLVMTypeConverter.html" title="Conversion from types to the LLVM IR dialect.">LLVMTypeConverter</a> using custom <a class="el" href="classmlir_1_1LowerToLLVMOptions.html" title="Options to control the LLVM lowering.">LowerToLLVMOptions</a>. </p>
<p>Optionally takes a data layout analysis to use in conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00115">115</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00161">mlir::TypeConverter::addConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00187">mlir::TypeConverter::addSourceMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00211">mlir::TypeConverter::addTargetMaterialization()</a>, <a class="el" href="DialectConversion_8h_source.html#l00240">mlir::TypeConverter::addTypeAttributeConversion()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l03090">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00795">mlir::LLVM::isCompatibleType()</a>, <a class="el" href="TypeConverter_8h_source.html#l00201">llvmDialect</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00066">packRankedMemRefDesc()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00053">packUnrankedMemRefDesc()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00099">rankedMemRefMaterialization()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00083">unrankedMemRefMaterialization()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="add6a58ffa4a0f076c7e513d493c82fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6a58ffa4a0f076c7e513d493c82fb3">&#9670;&nbsp;</a></span>canConvertToBarePtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LLVMTypeConverter::canConvertToBarePtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a memref type can be converted to a bare pointer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00592">592</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00074">canBeCalledWithBarePointers()</a>.</p>

</div>
</div>
<a id="aa7ebcd548b2fb3f46bad15f6563786bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ebcd548b2fb3f46bad15f6563786bf">&#9670;&nbsp;</a></span>convertCallingConventionType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertCallingConventionType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a type in the context of the default or bare pointer calling convention. </p>
<p>Calling convention sensitive types, such as MemRefType and <a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>, are converted following the specific rules for the calling convention. Calling convention independent types are converted following the default <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> type conversions. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00661">661</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00815">mlir::barePtrFuncArgTypeConverter()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00709">packFunctionResults()</a>.</p>

</div>
</div>
<a id="ac6aa8fa70342ae4cf9d72e0532e8d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aa8fa70342ae4cf9d72e0532e8d46b">&#9670;&nbsp;</a></span>convertFunctionSignature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionOpInterface&#160;</td>
          <td class="paramname"><em>funcOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVariadic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">LLVMTypeConverter::SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::optional&lt; <a class="el" href="classmlir_1_1NamedAttribute.html">NamedAttribute</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>byValRefNonPtrAttrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <code>result</code> is populated with argument mapping. Converted types of <code>llvm.byval</code> and <code>llvm.byref</code> function arguments which are not <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointers are overridden with <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> pointers. Overridden arguments are returned in <code>byValRefNonPtrAttrs</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00410">410</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00332">filterByValRefArgAttrs()</a>.</p>

</div>
</div>
<a id="a53a134316f4850a9e646dc68e8376ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a134316f4850a9e646dc68e8376ad9">&#9670;&nbsp;</a></span>convertFunctionSignature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::convertFunctionSignature </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>funcTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVariadic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter_1_1SignatureConversion.html">LLVMTypeConverter::SignatureConversion</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a function type. </p>
<p>The arguments and results are converted one by one and results are packed into a wrapped <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR structure type. <code>result</code> is populated with argument mapping. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00402">402</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">mlir::convertFuncOpToLLVMFuncOp()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="ae85823fd715ae2b9b86c5857fb6d37cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85823fd715ae2b9b86c5857fb6d37cc">&#9670;&nbsp;</a></span>convertFunctionTypeCWrapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; LLVM::LLVMFunctionType, LLVM::LLVMStructType &gt; LLVMTypeConverter::convertFunctionTypeCWrapper </td>
          <td>(</td>
          <td class="paramtype">FunctionType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the function type to a C-compatible format, in particular using pointers to memref descriptors for arguments. </p>
<p>Also converts the return type to a pointer argument if it is a struct. Returns true if this was the case. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00426">426</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00795">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00709">packFunctionResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="FuncToLLVM_8cpp_source.html#l00167">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00107">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="a7c28856d7176c4af44f64906de33b6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c28856d7176c4af44f64906de33b6ac">&#9670;&nbsp;</a></span>convertType() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This hook simplifies defining 1-1 type conversions. </p>
<p>This function returns the type to convert to on success, and a null type on failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00253">253</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

</div>
</div>
<a id="a781dc5f696e4309ad385645a74295fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781dc5f696e4309ad385645a74295fe0">&#9670;&nbsp;</a></span>convertType() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TargetType mlir::TypeConverter::convertType </td>
          <td>(</td>
          <td class="paramtype">typename TargetType&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempts a 1-1 type conversion, expecting the result type to be <code>TargetType</code>. </p>
<p>Returns the converted type cast to <code>TargetType</code> on success, and a null type on conversion or cast failure. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8h_source.html#l00259">259</a> of file <a class="el" href="DialectConversion_8h_source.html">DialectConversion.h</a>.</p>

</div>
</div>
<a id="aad1fae4fc72123cef7302a93ba314c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1fae4fc72123cef7302a93ba314c6a">&#9670;&nbsp;</a></span>convertType() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult TypeConverter::convertType</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given type. </p>
<p>This function should return failure if no valid conversion exists, success otherwise. If the new set of types is empty, the type is removed and any usages of the existing value are expected to be removed during conversion. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l00249">249</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00195">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00661">convertCallingConventionType()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00291">mlir::convertFuncOpToLLVMFuncOp()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00426">convertFunctionTypeCWrapper()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="VectorPattern_8cpp_source.html#l00019">mlir::LLVM::detail::extractNDVectorTypeInfo()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00058">extractOne()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00049">mlir::MemRefDescriptor::fromStaticShape()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00666">getDynamicSharedMemorySymbol()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00135">getIndexedPtrs()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00088">getMemRefAlignment()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00485">getMemRefDescriptorFields()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00489">mlir::LLVM::getStridedElementPtr()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00073">getVectorAlignment()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00041">insertOne()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00115">LLVMTypeConverter()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00077">mlir::GPUFuncOpLowering::matchAndRewrite()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00227">mlir::MemRefDescriptor::pack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00333">mlir::UnrankedMemRefDescriptor::pack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00688">packOperationResults()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00262">restoreByValRefArgumentType()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00635">mlir::impl::scalarizeVectorOp()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00606">scalarizeVectorOpHelper()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00786">mlir::structFuncArgTypeConverter()</a>, <a class="el" href="FuncToLLVM_8cpp_source.html#l00167">wrapExternalFunction()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00107">wrapForExternalCallers()</a>.</p>

</div>
</div>
<a id="ae1bae21dab08d18741a94aea9fa1b5be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bae21dab08d18741a94aea9fa1b5be">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> &amp; LLVMTypeConverter::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLIR context. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00275">275</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00105">getDialect()</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUToLLVMConversion_8cpp_source.html#l01546">addOpaquePointerConversion()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00426">convertFunctionTypeCWrapper()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00553">getUnrankedMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00709">packFunctionResults()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00688">packOperationResults()</a>, <a class="el" href="AMX_2Transforms_2LegalizeForLLVMExport_8cpp_source.html#l00041">mlir::populateAMXLegalizeForLLVMExportPatterns()</a>, <a class="el" href="GPUToLLVMSPV_8cpp_source.html#l00499">mlir::populateGpuToLLVMSPVConversionPatterns()</a>, and <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00592">mlir::populateGpuToNVVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a7c8883828a1c71ea23fd045d82e1eaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8883828a1c71ea23fd045d82e1eaa1">&#9670;&nbsp;</a></span>getCurrentThreadRecursiveStack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp; LLVMTypeConverter::getCurrentThreadRecursiveStack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00021">21</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00206">callStackMutex</a>, <a class="el" href="TypeConverter_8h_source.html#l00205">conversionCallStack</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00115">LLVMTypeConverter()</a>.</p>

</div>
</div>
<a id="adcd53b4634b1a8d32cebcce2e47fb8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd53b4634b1a8d32cebcce2e47fb8eb">&#9670;&nbsp;</a></span>getDataLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::DataLayout&amp; mlir::LLVMTypeConverter::getDataLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout to use during and after conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00131">131</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00056">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00088">getMemRefAlignment()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00073">getVectorAlignment()</a>.</p>

</div>
</div>
<a id="a5e5617fe390dff357f3e9e39f9ed9e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5617fe390dff357f3e9e39f9ed9e38">&#9670;&nbsp;</a></span>getDataLayoutAnalysis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1DataLayoutAnalysis.html">DataLayoutAnalysis</a>* mlir::LLVMTypeConverter::getDataLayoutAnalysis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the data layout analysis to query during conversion. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00134">134</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

</div>
</div>
<a id="a1fef25eab0df64af252d7d14c4a0caec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fef25eab0df64af252d7d14c4a0caec">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00105">105</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8h_source.html#l00201">llvmDialect</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00032">mlir::ConvertToLLVMPattern::getDialect()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l02166">mlir::populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="aeee2f27593c07c2c8e3bf8195252b1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee2f27593c07c2c8e3bf8195252b1a8">&#9670;&nbsp;</a></span>getIndexType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::getIndexType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of the index type. </p>
<p>The returned type is an integer type with the size configured for this type converter. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00279">279</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="TypeConverter_8h_source.html#l00143">getIndexTypeBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00195">mlir::MemRefDescriptor::bufferPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00036">mlir::ConvertToLLVMPattern::getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00485">getMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00525">getMemRefDescriptorSize()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00489">mlir::LLVM::getStridedElementPtr()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00553">getUnrankedMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00557">getUnrankedMemRefDescriptorSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00457">mlir::UnrankedMemRefDescriptor::offset()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00500">mlir::UnrankedMemRefDescriptor::setSize()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00533">mlir::UnrankedMemRefDescriptor::setStride()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00488">mlir::UnrankedMemRefDescriptor::size()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00477">mlir::UnrankedMemRefDescriptor::sizeBasePtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00521">mlir::UnrankedMemRefDescriptor::stride()</a>, and <a class="el" href="MemRefBuilder_8cpp_source.html#l00512">mlir::UnrankedMemRefDescriptor::strideBasePtr()</a>.</p>

</div>
</div>
<a id="ae91b3adee39d4b558df51642b88890ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91b3adee39d4b558df51642b88890ae">&#9670;&nbsp;</a></span>getIndexTypeBitwidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::LLVMTypeConverter::getIndexTypeBitwidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the bitwidth of the index type when converted to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00143">143</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00066">mlir::LowerToLLVMOptions::getIndexBitwidth()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, and <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00055">truncOrExtToLLVMType()</a>.</p>

</div>
</div>
<a id="ac8f665228b7d8d25949296df8e80cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f665228b7d8d25949296df8e80cb19">&#9670;&nbsp;</a></span>getMemRefAddressSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; unsigned &gt; LLVMTypeConverter::getMemRefAddressSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> address space corresponding to the memory space of the memref type <code>type</code> or failure if the memory space cannot be converted to an integer. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00574">574</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03224">mlir::TypeConverter::convertTypeAttribute()</a>, and <a class="el" href="IR_2BuiltinTypes_8cpp_source.html#l00400">mlir::BaseMemRefType::getMemorySpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00219">mlir::ConvertToLLVMPattern::copyUnrankedDescriptors()</a>, <a class="el" href="GPUOpsLowering_8cpp_source.html#l00666">getDynamicSharedMemorySymbol()</a>, <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00081">mlir::ConvertToLLVMPattern::getElementPtrType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00485">getMemRefDescriptorFields()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00525">getMemRefDescriptorSize()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00557">getUnrankedMemRefDescriptorSize()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00125">isMemRefTypeSupported()</a>.</p>

</div>
</div>
<a id="a528df60590b2cfaf836106a55715d1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528df60590b2cfaf836106a55715d1db">&#9670;&nbsp;</a></span>getMemRefDescriptorFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 5 &gt; LLVMTypeConverter::getMemRefDescriptorFields </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unpackAggregates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a memref type into a list of <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the memref descriptor. </p>
<p>If <code>unpackAggregates</code> is true the <code>sizes</code> and <code>strides</code> arrays in the descriptors are unpacked to individual index-typed elements, else they are kept as rank-sized arrays of index type. In particular, the list will contain:</p><ul>
<li>two pointers to the memref element type, followed by</li>
<li>an index-typed offset, followed by</li>
<li>(if unpackAggregates = true)<ul>
<li>one index-typed size per dimension of the memref, followed by</li>
<li>one index-typed stride per dimension of the memref.</li>
</ul>
</li>
<li>(if unpackArrregates = false)<ul>
<li>one rank-sized array of index-type for the size of each dimension</li>
<li>one rank-sized array of index-type for the stride of each dimension</li>
</ul>
</li>
</ul>
<p>For example, memref&lt;?x?xf32&gt; is converted to the following list:</p><ul>
<li><code>!llvm&lt;"float*"&gt;</code> (allocated pointer),</li>
<li><code>!llvm&lt;"float*"&gt;</code> (aligned pointer),</li>
<li><code>i64</code> (offset),</li>
<li><code>i64</code>, <code>i64</code> (sizes),</li>
<li><p class="startli"><code>i64</code>, <code>i64</code> (strides). These types can be recomposed to a memref descriptor struct.</p>
<p class="startli">The result contains the following types:</p><ol type="1">
<li>The pointer to the allocated data buffer, followed by</li>
<li>The pointer to the aligned data buffer, followed by</li>
<li>A lowered <code>index</code>-type integer containing the distance between the beginning of the buffer and the first element to be accessed through the view, followed by</li>
<li>An array containing as many <code>index</code>-type integers as the rank of the MemRef: the array represents the size, in number of elements, of the memref along the given dimension. For constant MemRef dimensions, the corresponding size entry is a constant whose runtime value must match the static value, followed by</li>
<li>A second array containing as many <code>index</code>-type integers as the rank of the MemRef: the second array represents the "stride" (in tensor abstraction sense), i.e. the number of consecutive elements of the underlying buffer. TODO: add assertions for the static cases.</li>
</ol>
<p class="startli">If <code>unpackAggregates</code> is set to true, the arrays described in (4) and (5) are expanded into individual index-type elements.</p>
<p class="startli">template &lt;typename Elem, typename Index, size_t Rank&gt; struct { Elem *allocatedPtr; Elem *alignedPtr; Index offset; Index sizes[Rank]; // omitted when rank == 0 Index strides[Rank]; // omitted when rank == 0 }; </p>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00485">485</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>, <a class="el" href="IR_2Diagnostics_8cpp_source.html#l00328">mlir::emitError()</a>, <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00574">getMemRefAddressSpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00066">packRankedMemRefDesc()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00786">mlir::structFuncArgTypeConverter()</a>.</p>

</div>
</div>
<a id="ae5bdd0b0c1b8f4b7ce1f7504a5673e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bdd0b0c1b8f4b7ce1f7504a5673e58">&#9670;&nbsp;</a></span>getMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype">MemRefType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00525">525</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">mlir::detail::divideCeil()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00574">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00283">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00560">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a48f142ecd8d10e44d253307880715607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f142ecd8d10e44d253307880715607">&#9670;&nbsp;</a></span>getOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classmlir_1_1LowerToLLVMOptions.html">LowerToLLVMOptions</a>&amp; mlir::LLVMTypeConverter::getOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00107">107</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="GPUOpsLowering_8cpp_source.html#l00758">mlir::GPUReturnOpLowering::matchAndRewrite()</a>, <a class="el" href="MemRefToLLVM_8cpp_source.html#l01993">mlir::populateFinalizeMemRefToLLVMConversionPatterns()</a>, and <a class="el" href="FuncToLLVM_8cpp_source.html#l00056">shouldUseBarePtrCallConv()</a>.</p>

</div>
</div>
<a id="ac3faa948105d0db2cd0b26f7ae3920fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3faa948105d0db2cd0b26f7ae3920fa">&#9670;&nbsp;</a></span>getPointerBitwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getPointerBitwidth </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>addressSpace</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pointer bitwidth. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00283">283</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoweringOptions_8h_source.html#l00056">mlir::LowerToLLVMOptions::dataLayout</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBuilder_8cpp_source.html#l00356">mlir::UnrankedMemRefDescriptor::computeSizes()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00525">getMemRefDescriptorSize()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00557">getUnrankedMemRefDescriptorSize()</a>.</p>

</div>
</div>
<a id="ac4f5690351e53c10618727ef67dd9f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f5690351e53c10618727ef67dd9f56">&#9670;&nbsp;</a></span>getUnrankedMemRefDescriptorFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 2 &gt; LLVMTypeConverter::getUnrankedMemRefDescriptorFields </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an unranked memref type into a list of non-aggregate <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR types that will form the unranked memref descriptor. </p>
<p>In particular, this list contains:</p><ul>
<li>an integer rank, followed by</li>
<li><p class="startli">a pointer to the memref descriptor struct. For example, memref&lt;<em>xf32&gt; is converted to the following list: i64 (rank) !llvm&lt;"i8&lt;/em&gt;"&gt; (type-erased pointer). These types can be recomposed to a unranked memref descriptor struct.</em></p>
<p class="startli"><em> In particular, the fields for an unranked memref descriptor are:</em></p>
</li>
</ul>
<ol type="1">
<li><em>index-typed rank, the dynamic rank of this MemRef</em></li>
<li><em>void* ptr, pointer to the static ranked MemRef descriptor. This will be stack allocated (alloca) copy of a MemRef descriptor that got casted to be unranked. </em></li>
</ol>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00553">553</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00053">packUnrankedMemRefDesc()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00786">mlir::structFuncArgTypeConverter()</a>.</p>

</div>
</div>
<a id="a5026b6f13d12445a8d60b3c9184aa904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026b6f13d12445a8d60b3c9184aa904">&#9670;&nbsp;</a></span>getUnrankedMemRefDescriptorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned LLVMTypeConverter::getUnrankedMemRefDescriptorSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUnrankedMemRefType.html">UnrankedMemRefType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the unranked memref descriptor object in bytes. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00557">557</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00468">mlir::detail::divideCeil()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00279">getIndexType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00574">getMemRefAddressSpace()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00283">getPointerBitwidth()</a>, and <a class="el" href="DataLayoutInterfaces_8cpp_source.html#l00560">mlir::DataLayout::getTypeSize()</a>.</p>

</div>
</div>
<a id="a285f908311d50945ff0d644ad3beaee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285f908311d50945ff0d644ad3beaee7">&#9670;&nbsp;</a></span>packFunctionResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packFunctionResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types to be returned from a function into an LLVM-compatible type. </p>
<p>In particular, if more than one value is returned, create an <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect structure type with elements that correspond to each of the types converted with <code>convertCallingConventionType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00709">709</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeConverter_8cpp_source.html#l00661">convertCallingConventionType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, <a class="el" href="LLVMTypes_8cpp_source.html#l00795">mlir::LLVM::isCompatibleType()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00426">convertFunctionTypeCWrapper()</a>, and <a class="el" href="GPUOpsLowering_8cpp_source.html#l00758">mlir::GPUReturnOpLowering::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="a10b2654ba7a875df2dd830288792934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b2654ba7a875df2dd830288792934c">&#9670;&nbsp;</a></span>packOperationResults()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> LLVMTypeConverter::packOperationResults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a>&#160;</td>
          <td class="paramname"><em>types</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a non-empty list of types of values produced by an operation into an LLVM-compatible type. </p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the LLVM-compatible types converted with <code>convertType</code>.</p>
<p>In particular, if more than one value is produced, create a literal structure with elements that correspond to each of the types converted with <code>convertType</code>. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00688">688</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l03027">convertType()</a>, <a class="el" href="TypeConverter_8cpp_source.html#l00275">getContext()</a>, and <a class="el" href="LLVMTypes_8cpp_source.html#l00795">mlir::LLVM::isCompatibleType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00358">mlir::LLVM::detail::intrinsicRewrite()</a>, and <a class="el" href="Conversion_2LLVMCommon_2Pattern_8cpp_source.html#l00318">mlir::LLVM::detail::oneToOneRewrite()</a>.</p>

</div>
</div>
<a id="a5d31697177d4412398c4c9a114cdb2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d31697177d4412398c4c9a114cdb2f0">&#9670;&nbsp;</a></span>promoteBarePtrsToDescriptors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LLVMTypeConverter::promoteBarePtrsToDescriptors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a> &amp;&#160;</td>
          <td class="paramname"><em>rewriter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt;&#160;</td>
          <td class="paramname"><em>stdTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the bare pointers in 'values' that resulted from memrefs to descriptors. </p>
<p>'stdTypes' holds the types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type).</p>
<p>'stdTypes' holds they types of 'values' before the conversion to the LLVM-IR dialect (i.e., MemRefType, or any other builtin type). </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00673">673</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00043">mlir::MemRefDescriptor::fromStaticShape()</a>.</p>

</div>
</div>
<a id="a9a0d71d9f3b2bab702e475f6890ed4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0d71d9f3b2bab702e475f6890ed4a1">&#9670;&nbsp;</a></span>promoteOneMemRefDescriptor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> LLVMTypeConverter::promoteOneMemRefDescriptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>operand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> struct representation of one MemRef descriptor to stack and use pointer to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00729">729</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Builders_8h_source.html#l00055">mlir::Builder::getContext()</a>, <a class="el" href="Builders_8cpp_source.html#l00064">mlir::Builder::getI64Type()</a>, <a class="el" href="Builders_8cpp_source.html#l00103">mlir::Builder::getIndexAttr()</a>, and <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="ab77513f669fae3497ae34732244ac6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77513f669fae3497ae34732244ac6b9">&#9670;&nbsp;</a></span>promoteOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 4 &gt; LLVMTypeConverter::promoteOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>opOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a>&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useBarePtrCallConv</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promote the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> representation of all operands including promoting MemRef descriptors to stack and use pointers to struct to avoid the complexity of the platform-specific C/C++ ABI lowering related to struct argument passing. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8cpp_source.html#l00744">744</a> of file <a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a>.</p>

<p class="reference">References <a class="el" href="MemRefBuilder_8cpp_source.html#l00088">mlir::MemRefDescriptor::alignedPtr()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00248">mlir::MemRefDescriptor::unpack()</a>, <a class="el" href="MemRefBuilder_8cpp_source.html#l00347">mlir::UnrankedMemRefDescriptor::unpack()</a>, and <a class="el" href="LoweringOptions_8h_source.html#l00035">mlir::LowerToLLVMOptions::useBarePtrCallConv</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af9b34d77d5e460270f7b831c513dfe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b34d77d5e460270f7b831c513dfe1b">&#9670;&nbsp;</a></span>structFuncArgTypeConverter</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult structFuncArgTypeConverter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Give structFuncArgTypeConverter access to memref-specific functions. </p>
<p>It converts a MemRef function argument to a list of non-aggregate types containing descriptor information, and an UnrankedmemRef function argument to a list containing the rank and a pointer to a descriptor struct. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0a8ba63d13409bf975cd862683e071a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8ba63d13409bf975cd862683e071a8">&#9670;&nbsp;</a></span>callStackMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::sys::SmartRWMutex&lt;true&gt; mlir::LLVMTypeConverter::callStackMutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00206">206</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a7466ae2ed9e33d91b625d076c4dc517d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7466ae2ed9e33d91b625d076c4dc517d">&#9670;&nbsp;</a></span>conversionCallStack</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a>&lt;uint64_t, std::unique_ptr&lt;<a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Type.html">Type</a>&gt; &gt; &gt; mlir::LLVMTypeConverter::conversionCallStack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00205">205</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8cpp_source.html#l00021">getCurrentThreadRecursiveStack()</a>.</p>

</div>
</div>
<a id="a0034100981a301427abe8367c89ef6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0034100981a301427abe8367c89ef6a3">&#9670;&nbsp;</a></span>llvmDialect</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LLVM::LLVMDialect* mlir::LLVMTypeConverter::llvmDialect</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>

<p class="definition">Definition at line <a class="el" href="TypeConverter_8h_source.html#l00201">201</a> of file <a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="TypeConverter_8h_source.html#l00105">getDialect()</a>, and <a class="el" href="TypeConverter_8cpp_source.html#l00115">LLVMTypeConverter()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8h_source.html">TypeConverter.h</a></li>
<li>lib/Conversion/LLVMCommon/<a class="el" href="TypeConverter_8cpp_source.html">TypeConverter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:29 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
