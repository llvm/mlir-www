<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Linalg/Transforms/ElementwiseOpFusion.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_8edb792440615361a0811a7329611599.html">Linalg</a></li><li class="navelem"><a href="dir_7e2f808e77498894ca0efbd745da2201.html">Transforms</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ElementwiseOpFusion.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Linalg_2Passes_8h_source.html">mlir/Dialect/Linalg/Passes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2IR_2Linalg_8h_source.html">mlir/Dialect/Linalg/IR/Linalg.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Linalg_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Linalg/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">mlir/Dialect/SparseTensor/IR/SparseTensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2Tensor_2Transforms_2Transforms_8h_source.html">mlir/Dialect/Tensor/Transforms/Transforms.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineExpr_8h_source.html">mlir/IR/AffineExpr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2AffineMap_8h_source.html">mlir/IR/AffineMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Matchers_8h_source.html">mlir/IR/Matchers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PatternMatch_8h_source.html">mlir/IR/PatternMatch.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Support_2LLVM_8h_source.html">mlir/Support/LLVM.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RegionUtils_8h_source.html">mlir/Transforms/RegionUtils.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &quot;mlir/Dialect/Linalg/Passes.h.inc&quot;</code><br />
</div>
<p><a href="ElementwiseOpFusion_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:mlir_3A_3Aimpl_3A_3ALinalgElementwiseOpFusionPassBase_3C_20DerivedT_20_3E" id="r_mlir_3A_3Aimpl_3A_3ALinalgElementwiseOpFusionPassBase_3C_20DerivedT_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1impl_1_1LinalgElementwiseOpFusionPassBase.html">mlir::impl::LinalgElementwiseOpFusionPassBase&lt; DerivedT &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:mlir" id="r_mlir"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="memitem:mlir_3A_3Aimpl" id="r_mlir_3A_3Aimpl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">mlir::impl</a></td></tr>
<tr class="memdesc:namespacemlir_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations.">Attribute</a> collections provide a dictionary-like interface. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a286fd5c13e0d72fb5b3a911e031e6b09" id="r_a286fd5c13e0d72fb5b3a911e031e6b09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a286fd5c13e0d72fb5b3a911e031e6b09">GEN_PASS_DEF_LINALGELEMENTWISEOPFUSIONPASS</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acff7364da2d72a1f2d7612a3b3217bf4" id="r_acff7364da2d72a1f2d7612a3b3217bf4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html#acff7364da2d72a1f2d7612a3b3217bf4">mlir::impl::createLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="memitem:a736979a5a4ca50383d3cde235bd30d6b" id="r_a736979a5a4ca50383d3cde235bd30d6b"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">::mlir::Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a736979a5a4ca50383d3cde235bd30d6b">mlir::createLinalgElementwiseOpFusionPass</a> ()</td></tr>
<tr class="memitem:a19679bdb1cb388e2cf93c2dab27ffe52" id="r_a19679bdb1cb388e2cf93c2dab27ffe52"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19679bdb1cb388e2cf93c2dab27ffe52">getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp</a> (<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *producerOpOperand, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> producerResultIndexMap, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> fusedConsumerArgIndexMap)</td></tr>
<tr class="memdesc:a19679bdb1cb388e2cf93c2dab27ffe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to <span class="tt">fusedOpIndexingMapAttrs</span> the indexing maps for the operands of the <span class="tt">producer</span> to use in the fused operation given the indexing map of the result of the producer in the consumer.  <br /></td></tr>
<tr class="memitem:a0e49a564904350d70c1b118d3dfb0f6c" id="r_a0e49a564904350d70c1b118d3dfb0f6c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0e49a564904350d70c1b118d3dfb0f6c">isOpOperandCanBeDroppedAfterFusedLinalgs</a> (GenericOp producer, GenericOp consumer, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt; opOperandsToIgnore)</td></tr>
<tr class="memitem:ad9250ab0e524e1c917e7ea17e5ca6e1b" id="r_ad9250ab0e524e1c917e7ea17e5ca6e1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9250ab0e524e1c917e7ea17e5ca6e1b">generateFusedElementwiseOpRegion</a> (<a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;rewriter, GenericOp fusedOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> consumerToProducerLoopsMap, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusedOperand, <a class="el" href="classunsigned.html">unsigned</a> nloops, llvm::SmallDenseSet&lt; int &gt; &amp;preservedProducerResults)</td></tr>
<tr class="memdesc:ad9250ab0e524e1c917e7ea17e5ca6e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate the region of the fused tensor operation.  <br /></td></tr>
<tr class="memitem:a8ec57ac31270575195e36ab2ecf09b61" id="r_a8ec57ac31270575195e36ab2ecf09b61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ec57ac31270575195e36ab2ecf09b61">isFusableWithReshapeByDimExpansion</a> (LinalgOp linalgOp, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusableOpOperand)</td></tr>
<tr class="memdesc:a8ec57ac31270575195e36ab2ecf09b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditions for folding a structured linalg operation with a reshape op by expanding the iteration space dimensionality for tensor operations.  <br /></td></tr>
<tr class="memitem:aff1bcc53176a04b539b16e59cbac323e" id="r_aff1bcc53176a04b539b16e59cbac323e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff1bcc53176a04b539b16e59cbac323e">getIndexingMapInExpandedOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, const ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memdesc:aff1bcc53176a04b539b16e59cbac323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the indexing map to use in the expanded op for a given the <span class="tt">indexingMap</span> of the original operation.  <br /></td></tr>
<tr class="memitem:a4d5d1e0fa32658babf26072538c730a9" id="r_a4d5d1e0fa32658babf26072538c730a9"><td class="memItemLeft" align="right" valign="top">static std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, RankedTensorType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d5d1e0fa32658babf26072538c730a9">getExpandedShapeAndType</a> (RankedTensorType originalType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, const ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memdesc:a4d5d1e0fa32658babf26072538c730a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the shape and type of the operand/result to use in the expanded op given the type in the original op.  <br /></td></tr>
<tr class="memitem:a8d31dc93b9278752fa34de60b5190272" id="r_a8d31dc93b9278752fa34de60b5190272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d31dc93b9278752fa34de60b5190272">getReassociationForExpansion</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, const ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memdesc:a8d31dc93b9278752fa34de60b5190272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reassociation maps to use in the <span class="tt">tensor.expand_shape</span> operation to convert the operands of the original operation to operands of the expanded operation.  <br /></td></tr>
<tr class="memitem:a500dd0360de9862e17d177987cb5a3f5" id="r_a500dd0360de9862e17d177987cb5a3f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a500dd0360de9862e17d177987cb5a3f5">updateExpandedGenericOpRegion</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;fusedRegion, const ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memdesc:a500dd0360de9862e17d177987cb5a3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the body of an expanded linalg operation having index semantics.  <br /></td></tr>
<tr class="memitem:a6539af1b252ac5a86d6ca0aecbd41a43" id="r_a6539af1b252ac5a86d6ca0aecbd41a43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6539af1b252ac5a86d6ca0aecbd41a43">createExpandedTransposeOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, TransposeOp transposeOp, <a class="el" href="classmlir_1_1Value.html">Value</a> expandedInput, <a class="el" href="classmlir_1_1Value.html">Value</a> output, ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memitem:a9c5bcaae5ea3303852b85705c3b82387" id="r_a9c5bcaae5ea3303852b85705c3b82387"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5bcaae5ea3303852b85705c3b82387">createExpandedGenericOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;expandedOpOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; outputs, ExpansionInfo &amp;expansionInfo, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; expandedOpIndexingMaps)</td></tr>
<tr class="memitem:aa287c8a73f16cba787066acdc3ae22ea" id="r_aa287c8a73f16cba787066acdc3ae22ea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa287c8a73f16cba787066acdc3ae22ea">createExpandedOp</a> (<a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter, LinalgOp linalgOp, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; expandedOpOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; outputs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; expandedOpIndexingMaps, ExpansionInfo &amp;expansionInfo)</td></tr>
<tr class="memitem:afa7f176f75f9f5e17fdc14b7bfc32ac7" id="r_afa7f176f75f9f5e17fdc14b7bfc32ac7"><td class="memItemLeft" align="right" valign="top">static std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa7f176f75f9f5e17fdc14b7bfc32ac7">fuseWithReshapeByExpansion</a> (LinalgOp linalgOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *reshapeOp, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusableOpOperand, <a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;rewriter)</td></tr>
<tr class="memdesc:afa7f176f75f9f5e17fdc14b7bfc32ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the fusion of a tensor.collapse_shape or a tensor.expand_shape op and a generic op as explained in <span class="tt">isFusableWithReshapeByExpansion</span>.  <br /></td></tr>
<tr class="memitem:ac4d43306dd817ce8b48fe47442c5dc81" id="r_ac4d43306dd817ce8b48fe47442c5dc81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4d43306dd817ce8b48fe47442c5dc81">getDomainReassociation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexingMap, <a class="el" href="namespacemlir.html#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a> rangeReassociation)</td></tr>
<tr class="memdesc:ac4d43306dd817ce8b48fe47442c5dc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a given list of indices in the range of the <span class="tt">indexingMap</span> that are folded, return the indices of the corresponding domain.  <br /></td></tr>
<tr class="memitem:a1e8600bfd4eb785212cfb519d4d94e49" id="r_a1e8600bfd4eb785212cfb519d4d94e49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e8600bfd4eb785212cfb519d4d94e49">getCollapsableIterationSpaceDims</a> (GenericOp genericOp, <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *fusableOperand, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memitem:a3460b8115cf574b9ca4031a730cceb54" id="r_a3460b8115cf574b9ca4031a730cceb54"><td class="memItemLeft" align="right" valign="top">LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3460b8115cf574b9ca4031a730cceb54">initialize</a> (<a class="el" href="classunsigned.html">unsigned</a> origNumLoops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; foldedIterationDims)</td></tr>
<tr class="memitem:a2bf3141199c22905ed620676841bf8fe" id="r_a2bf3141199c22905ed620676841bf8fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bf3141199c22905ed620676841bf8fe">getCollapsedOpToOrigOpMapping</a> () const</td></tr>
<tr class="memdesc:a2bf3141199c22905ed620676841bf8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return mapping from collapsed loop domain to original loop domain.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="a286fd5c13e0d72fb5b3a911e031e6b09" name="a286fd5c13e0d72fb5b3a911e031e6b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286fd5c13e0d72fb5b3a911e031e6b09">&#9670;&#160;</a></span>GEN_PASS_DEF_LINALGELEMENTWISEOPFUSIONPASS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GEN_PASS_DEF_LINALGELEMENTWISEOPFUSIONPASS</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00033">33</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a9c5bcaae5ea3303852b85705c3b82387" name="a9c5bcaae5ea3303852b85705c3b82387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5bcaae5ea3303852b85705c3b82387">&#9670;&#160;</a></span>createExpandedGenericOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * createExpandedGenericOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>resultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>expandedOpOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expandedOpIndexingMaps</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00805">805</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00055">mlir::Region::begin()</a>, <a class="el" href="Builders_8cpp_source.html#l00589">mlir::OpBuilder::cloneRegionBefore()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00686">mlir::Operation::getRegion()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">updateExpandedGenericOpRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00835">createExpandedOp()</a>.</p>

</div>
</div>
<a id="aa287c8a73f16cba787066acdc3ae22ea" name="aa287c8a73f16cba787066acdc3ae22ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa287c8a73f16cba787066acdc3ae22ea">&#9670;&#160;</a></span>createExpandedOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * createExpandedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a></td>          <td class="paramname"><span class="paramname"><em>resultTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expandedOpOperands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>outputs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>expandedOpIndexingMaps</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00835">835</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8cpp_source.html#l00197">mlir::clone()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00805">createExpandedGenericOp()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00789">createExpandedTransposeOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="a6539af1b252ac5a86d6ca0aecbd41a43" name="a6539af1b252ac5a86d6ca0aecbd41a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6539af1b252ac5a86d6ca0aecbd41a43">&#9670;&#160;</a></span>createExpandedTransposeOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * createExpandedTransposeOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TransposeOp</td>          <td class="paramname"><span class="paramname"><em>transposeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>expandedInput</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a></td>          <td class="paramname"><span class="paramname"><em>output</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00789">789</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IndexingUtils_8cpp_source.html#l00187">mlir::invertPermutationVector()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00835">createExpandedOp()</a>.</p>

</div>
</div>
<a id="afa7f176f75f9f5e17fdc14b7bfc32ac7" name="afa7f176f75f9f5e17fdc14b7bfc32ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7f176f75f9f5e17fdc14b7bfc32ac7">&#9670;&#160;</a></span>fuseWithReshapeByExpansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt; fuseWithReshapeByExpansion </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>reshapeOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusableOpOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements the fusion of a tensor.collapse_shape or a tensor.expand_shape op and a generic op as explained in <span class="tt">isFusableWithReshapeByExpansion</span>. </p>
<p>Assumes that those conditions have been satisfied. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">865</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00835">createExpandedOp()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00687">getExpandedShapeAndType()</a>, <a class="el" href="TensorOps_8cpp_source.html#l00066">mlir::tensor::getMixedSizes()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00710">getReassociationForExpansion()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00407">mlir::Operation::getResult()</a>, <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00564">isFusableWithReshapeByDimExpansion()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l01145">mlir::moveValueDefinitions()</a>, <a class="el" href="PatternMatch_8h_source.html#l00726">mlir::RewriterBase::notifyMatchFailure()</a>, <a class="el" href="Builders_8h_source.html#l00398">mlir::OpBuilder::setInsertionPoint()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02103">ValueRange</a>.</p>

</div>
</div>
<a id="ad9250ab0e524e1c917e7ea17e5ca6e1b" name="ad9250ab0e524e1c917e7ea17e5ca6e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9250ab0e524e1c917e7ea17e5ca6e1b">&#9670;&#160;</a></span>generateFusedElementwiseOpRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> generateFusedElementwiseOpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1RewriterBase.html">RewriterBase</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>fusedOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>consumerToProducerLoopsMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusedOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>nloops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>preservedProducerResults</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate the region of the fused tensor operation. </p>
<p>The region of the fused op must be empty. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00218">218</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00153">mlir::Block::addArgument()</a>, <a class="el" href="Builders_8cpp_source.html#l00562">mlir::OpBuilder::clone()</a>, <a class="el" href="Builders_8cpp_source.html#l00430">mlir::OpBuilder::createBlock()</a>, <a class="el" href="Block_8h_source.html#l00153">mlir::Block::front()</a>, <a class="el" href="UseDefLists_8h_source.html#l00160">mlir::IROperand&lt; DerivedT, IRValueT &gt;::get()</a>, <a class="el" href="Block_8h_source.html#l00129">mlir::Block::getArgument()</a>, <a class="el" href="Block_8h_source.html#l00087">mlir::Block::getArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00018">mlir::Value::getDefiningOp()</a>, <a class="el" href="Block_8h_source.html#l00128">mlir::Block::getNumArguments()</a>, <a class="el" href="Value_8cpp_source.html#l00226">mlir::OpOperand::getOperandNumber()</a>, <a class="el" href="Block_8h_source.html#l00193">mlir::Block::getOps()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00647">mlir::AffineMap::getSubMap()</a>, <a class="el" href="Block_8cpp_source.html#l00244">mlir::Block::getTerminator()</a>, <a class="el" href="IRMapping_8h_source.html#l00065">mlir::IRMapping::lookupOrDefault()</a>, <a class="el" href="IRMapping_8h_source.html#l00030">mlir::IRMapping::map()</a>, <a class="el" href="LoopUtils_8cpp.html#af34d730a7920f1ae277f8c166146132d">replacement()</a>, and <a class="el" href="Block_8h_source.html#l00212">mlir::Block::without_terminator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="a1e8600bfd4eb785212cfb519d4d94e49" name="a1e8600bfd4eb785212cfb519d4d94e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8600bfd4eb785212cfb519d4d94e49">&#9670;&#160;</a></span>getCollapsableIterationSpaceDims()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; getCollapsableIterationSpaceDims </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>genericOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusableOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>reassociation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01403">1403</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01289">getDomainReassociation()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00230">mlir::linalg::isParallelIterator()</a>, and <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00234">mlir::linalg::isReductionIterator()</a>.</p>

</div>
</div>
<a id="a2bf3141199c22905ed620676841bf8fe" name="a2bf3141199c22905ed620676841bf8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf3141199c22905ed620676841bf8fe">&#9670;&#160;</a></span>getCollapsedOpToOrigOpMapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; failure::getCollapsedOpToOrigOpMapping </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return mapping from collapsed loop domain to original loop domain. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00046">46</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

</div>
</div>
<a id="ac4d43306dd817ce8b48fe47442c5dc81" name="ac4d43306dd817ce8b48fe47442c5dc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d43306dd817ce8b48fe47442c5dc81">&#9670;&#160;</a></span>getDomainReassociation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> getDomainReassociation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a11a02d1f78682e704d9aa4a6ef3cb364">ReassociationIndicesRef</a></td>          <td class="paramname"><span class="paramname"><em>rangeReassociation</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For a given list of indices in the range of the <span class="tt">indexingMap</span> that are folded, return the indices of the corresponding domain. </p>
<p>Return <span class="tt">std::nullopt</span> on failure. Ensures that all the elements of the returned reassociation are distinct. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01289">1289</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00611">mlir::AffineMap::isProjectedPermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l01403">getCollapsableIterationSpaceDims()</a>.</p>

</div>
</div>
<a id="a4d5d1e0fa32658babf26072538c730a9" name="a4d5d1e0fa32658babf26072538c730a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5d1e0fa32658babf26072538c730a9">&#9670;&#160;</a></span>getExpandedShapeAndType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;, RankedTensorType &gt; getExpandedShapeAndType </td>
          <td>(</td>
          <td class="paramtype">RankedTensorType</td>          <td class="paramname"><span class="paramname"><em>originalType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the shape and type of the operand/result to use in the expanded op given the type in the original op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00687">687</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="StaticValueUtils_8cpp_source.html#l00226">mlir::decomposeMixedValues()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="aff1bcc53176a04b539b16e59cbac323e" name="aff1bcc53176a04b539b16e59cbac323e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1bcc53176a04b539b16e59cbac323e">&#9670;&#160;</a></span>getIndexingMapInExpandedOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> getIndexingMapInExpandedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>builder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the indexing map to use in the expanded op for a given the <span class="tt">indexingMap</span> of the original operation. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00668">668</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="a19679bdb1cb388e2cf93c2dab27ffe52" name="a19679bdb1cb388e2cf93c2dab27ffe52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19679bdb1cb388e2cf93c2dab27ffe52">&#9670;&#160;</a></span>getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> getIndexingMapOfProducerOperandsInCoordinatesOfFusedOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>producerOpOperand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>producerResultIndexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>fusedConsumerArgIndexMap</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append to <span class="tt">fusedOpIndexingMapAttrs</span> the indexing maps for the operands of the <span class="tt">producer</span> to use in the fused operation given the indexing map of the result of the producer in the consumer. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00047">47</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00552">mlir::AffineMap::compose()</a>, <a class="el" href="UseDefLists_8h_source.html#l00038">mlir::detail::IROperandBase::getOwner()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00139">mlir::linalg::areElementwiseOpsFusable()</a>, and <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00339">mlir::linalg::fuseElementwiseOps()</a>.</p>

</div>
</div>
<a id="a8d31dc93b9278752fa34de60b5190272" name="a8d31dc93b9278752fa34de60b5190272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d31dc93b9278752fa34de60b5190272">&#9670;&#160;</a></span>getReassociationForExpansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt; getReassociationForExpansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>indexingMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reassociation maps to use in the <span class="tt">tensor.expand_shape</span> operation to convert the operands of the original operation to operands of the expanded operation. </p>
<p>The same method is used to compute the <span class="tt">tensor.collapse_shape</span> used to collapse the result of the expanded op to get the value that can replace all uses of the results of the original op. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00710">710</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00262">indices</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="a3460b8115cf574b9ca4031a730cceb54" name="a3460b8115cf574b9ca4031a730cceb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3460b8115cf574b9ca4031a730cceb54">&#9670;&#160;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult failure::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>origNumLoops</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#ad3cda368514f1e456981bd339ef6bc92">ReassociationIndices</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>foldedIterationDims</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00001">1</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeSupport_8h_source.html#l00230">mlir::detail::AttributeUniquer::getWithTypeID()</a>.</p>

</div>
</div>
<a id="a8ec57ac31270575195e36ab2ecf09b61" name="a8ec57ac31270575195e36ab2ecf09b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec57ac31270575195e36ab2ecf09b61">&#9670;&#160;</a></span>isFusableWithReshapeByDimExpansion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isFusableWithReshapeByDimExpansion </td>
          <td>(</td>
          <td class="paramtype">LinalgOp</td>          <td class="paramname"><span class="paramname"><em>linalgOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *</td>          <td class="paramname"><span class="paramname"><em>fusableOpOperand</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conditions for folding a structured linalg operation with a reshape op by expanding the iteration space dimensionality for tensor operations. </p>
<p>These are preconditions assumed by <span class="tt">foldReshapeByDimExpansion</span> which implements the following fusion pattern.</p>
<p>Consider</p>
<p>c = linalg.generic ins(a, b : memref&lt;?x?x?xf32&gt;, memref&lt;?x?xf32&gt;) indexing_maps = [affine_map&lt;(d0, d1, d2) -&gt; (d1, d0, d2)&gt;, affine_map&lt;(d0, d1, d2) -&gt; (d1, d2)&gt;, affine_map&lt;(d0, d1, d2) -&gt; (d0, d2, d1)&gt;] d = tensor.expand_shape c [[0, 1], [2], [3, 4, 5]] : tensor&lt;?x?x?xf32&gt; into tensor&lt;?x?x?x?x?x?xf32&gt;</p>
<p>The reshape can be folded into the <span class="tt">linalgOp</span> if its loop dimensionality is increased to match the result (operand) of the tensor.expand_shape. The indexing_map of the fused tensor in the <span class="tt">linalgOp</span> and the reassociation map helps compute the indexing maps of the modified op. For the above example, based on the reassociation map it can be concluded that</p>
<ul>
<li>The loop used to access the first dimension of the fused tensor is split into two.</li>
<li>The loop used to access the second dimension of the fused tensor is kept as is.</li>
<li>The loop used to access the third dimension of the fused tensor is split into three.</li>
</ul>
<p>i.e. (e0, e1, e2, e3, e4) is the domain of the indexing map of the modified op, then</p>
<p>d0 -&gt; e0, e1 d1 -&gt; e2, e3, e4 d2 -&gt; e5</p>
<p>substituting this, the structured op can be rewritten as</p>
<p>d = linalg.generic ins(%0, %1 : ) indexing_maps = [affine_map&lt;(e0, e1, e2, e3, e4, e5) -&gt; (e2, e3, e4, e0, e1, e5)&gt;, affine_map&lt;(e0, e1, e2, e3, e4, e5) -&gt; (e2, e3, e4, e5)&gt;, affine_map&lt;(e0, e1, e2, e3, e4, e5) -&gt; (e0, e1, e5, e2, e3, e4)&gt;]</p>
<p>Since operands to the linalg generic are now 5D, reshapes can be introduced to make it consistent</p>
<p>%0 = tensor.expand_shape a [[0, 1, 2], [3, 4], [5]] : tensor&lt;?x?x?xf32&gt; into tensor&lt;?x?x?x?x?x?xf32&gt; %1 = tensor.expand_shape b [[0, 1, 2], [3]] : tensor&lt;?x?x?xf32&gt; into tensor&lt;?x?x?x?xf32&gt;</p>
<p>The added reshapes are again expanding patterns, so they will get fused with its producers if possible. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00564">564</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00865">fuseWithReshapeByExpansion()</a>.</p>

</div>
</div>
<a id="a0e49a564904350d70c1b118d3dfb0f6c" name="a0e49a564904350d70c1b118d3dfb0f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e49a564904350d70c1b118d3dfb0f6c">&#9670;&#160;</a></span>isOpOperandCanBeDroppedAfterFusedLinalgs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isOpOperandCanBeDroppedAfterFusedLinalgs </td>
          <td>(</td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>producer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GenericOp</td>          <td class="paramname"><span class="paramname"><em>consumer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> * &gt;</td>          <td class="paramname"><span class="paramname"><em>opOperandsToIgnore</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00079">79</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2AffineMap_8cpp_source.html#l00829">mlir::concatAffineMaps()</a>, and <a class="el" href="IR_2AffineMap_8cpp_source.html#l00784">mlir::inversePermutation()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00112">mlir::linalg::getPreservedProducerResults()</a>.</p>

</div>
</div>
<a id="a500dd0360de9862e17d177987cb5a3f5" name="a500dd0360de9862e17d177987cb5a3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500dd0360de9862e17d177987cb5a3f5">&#9670;&#160;</a></span>updateExpandedGenericOpRegion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> updateExpandedGenericOpRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rewriter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fusedRegion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ExpansionInfo &amp;</td>          <td class="paramname"><span class="paramname"><em>expansionInfo</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the body of an expanded linalg operation having index semantics. </p>
<p>The indices of the original operation need to be recovered by linearizing the indices of the correspoding dimensions of the expanded operation. For now it is assumed that the shapes of the expanded operation needed for linearization are static. </p>

<p class="definition">Definition at line <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00730">730</a> of file <a class="el" href="ElementwiseOpFusion_8cpp_source.html">ElementwiseOpFusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00311">mlir::bindDims()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2Region_8h_source.html#l00065">mlir::Region::front()</a>, <a class="el" href="Builders_8h_source.html#l00056">mlir::Builder::getContext()</a>, <a class="el" href="Block_8h_source.html#l00193">mlir::Block::getOps()</a>, <a class="el" href="Dialect_2Arith_2Utils_2Utils_8cpp_source.html#l00111">mlir::getValueOrCreateConstantIndexOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00127">mlir::RewriterBase::replaceOp()</a>, and <a class="el" href="Builders_8h_source.html#l00412">mlir::OpBuilder::setInsertionPointAfter()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ElementwiseOpFusion_8cpp_source.html#l00805">createExpandedGenericOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
