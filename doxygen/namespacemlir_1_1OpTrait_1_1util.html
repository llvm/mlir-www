<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::OpTrait::util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html">util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::OpTrait::util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad2a2d4bc1bc978eb3635b167b5c49ab1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html#ad2a2d4bc1bc978eb3635b167b5c49ab1">getBroadcastedShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;resultShape)</td></tr>
<tr class="memdesc:ad2a2d4bc1bc978eb3635b167b5c49ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true and sets <code>resultShape</code> to the broadcasted shape from the two given shapes if they are broadcast compatible.  <a href="namespacemlir_1_1OpTrait_1_1util.html#ad2a2d4bc1bc978eb3635b167b5c49ab1">More...</a><br /></td></tr>
<tr class="separator:ad2a2d4bc1bc978eb3635b167b5c49ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacc0b3b8e615ddda458be43d95c9c30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html#acacc0b3b8e615ddda458be43d95c9c30">staticallyKnownBroadcastable</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 6 &gt;&gt; shapes)</td></tr>
<tr class="memdesc:acacc0b3b8e615ddda458be43d95c9c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a broadcast between n shapes is guaranteed to be successful and not result in an error.  <a href="namespacemlir_1_1OpTrait_1_1util.html#acacc0b3b8e615ddda458be43d95c9c30">More...</a><br /></td></tr>
<tr class="separator:acacc0b3b8e615ddda458be43d95c9c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d453c4d6c204c5af3e54bf2c8f7b7a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html#a8d453c4d6c204c5af3e54bf2c8f7b7a5">staticallyKnownBroadcastable</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="separator:a8d453c4d6c204c5af3e54bf2c8f7b7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacd5d5b3ffaa8196f997e32e7414cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait_1_1util.html#acacd5d5b3ffaa8196f997e32e7414cf2">getBroadcastedType</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2, <a class="el" href="classmlir_1_1Type.html">Type</a> elementType=nullptr)</td></tr>
<tr class="memdesc:acacd5d5b3ffaa8196f997e32e7414cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result broadcast composition type from the two given types by following NumPy broadcast semantics.  <a href="namespacemlir_1_1OpTrait_1_1util.html#acacd5d5b3ffaa8196f997e32e7414cf2">More...</a><br /></td></tr>
<tr class="separator:acacd5d5b3ffaa8196f997e32e7414cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad2a2d4bc1bc978eb3635b167b5c49ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2a2d4bc1bc978eb3635b167b5c49ab1">&#9670;&nbsp;</a></span>getBroadcastedShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::OpTrait::util::getBroadcastedShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>resultShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true and sets <code>resultShape</code> to the broadcasted shape from the two given shapes if they are broadcast compatible. </p>
<p>Returns false and clears <code>resultShape</code> otherwise.</p>
<p>The rules for determining the result shape are:</p>
<p>Zip together the dimensions in the two given shapes by prepending the shape with less dimensions with 1s. For each dimension pair, deduces the result dimension according to the following order:</p><ul>
<li>If there are unknown dimensions, follows the TensorFlow behavior:<ul>
<li>If either dimension is greater than 1, we assume that the program is correct, and the other dimension will be broadcast to match it.</li>
<li>If either dimension is 1, the other dimension is the result.</li>
<li>Otherwise, the result dimension is unknown dimension.</li>
</ul>
</li>
<li>If one of the dimension is 1, the other dimension is the result.</li>
<li>If two dimensions are the same, that's the result.</li>
<li>Otherwise, incompatible shape. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Traits_8cpp_source.html#l00059">59</a> of file <a class="el" href="Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Traits_8cpp_source.html#l00132">getBroadcastedType()</a>, and <a class="el" href="Traits_8cpp_source.html#l00228">mlir::OpTrait::impl::verifyCompatibleOperandBroadcast()</a>.</p>

</div>
</div>
<a id="acacd5d5b3ffaa8196f997e32e7414cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacd5d5b3ffaa8196f997e32e7414cf2">&#9670;&nbsp;</a></span>getBroadcastedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::OpTrait::util::getBroadcastedType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>elementType</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result broadcast composition type from the two given types by following NumPy broadcast semantics. </p>
<p>Returned type may have dynamic shape if either of the input types has dynamic shape. Returns null type if the two given types are not broadcast-compatible.</p>
<p>elementType, if specified, will be used as the element type of the broadcasted result type. Otherwise it is required that the element type of type1 and type2 is the same and this element type will be used as the resultant element type. </p>

<p class="definition">Definition at line <a class="el" href="Traits_8cpp_source.html#l00132">132</a> of file <a class="el" href="Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">References <a class="el" href="BytecodeImplementation_8h_source.html#l00509">mlir::get()</a>, <a class="el" href="Traits_8cpp_source.html#l00059">getBroadcastedShape()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00023">mlir::getElementTypeOrSelf()</a>, and <a class="el" href="Traits_8cpp_source.html#l00117">getShape()</a>.</p>

</div>
</div>
<a id="a8d453c4d6c204c5af3e54bf2c8f7b7a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d453c4d6c204c5af3e54bf2c8f7b7a5">&#9670;&nbsp;</a></span>staticallyKnownBroadcastable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::OpTrait::util::staticallyKnownBroadcastable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Traits_8cpp_source.html#l00016">16</a> of file <a class="el" href="Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">References <a class="el" href="Traits_8cpp_source.html#l00024">staticallyKnownBroadcastable()</a>.</p>

</div>
</div>
<a id="acacc0b3b8e615ddda458be43d95c9c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacc0b3b8e615ddda458be43d95c9c30">&#9670;&nbsp;</a></span>staticallyKnownBroadcastable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::OpTrait::util::staticallyKnownBroadcastable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 6 &gt;&gt;&#160;</td>
          <td class="paramname"><em>shapes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a broadcast between n shapes is guaranteed to be successful and not result in an error. </p>
<p>False does not guarantee that the shapes are not broadcastable; it might guarantee that they are not broadcastable or it might mean that this function does not have enough information to know.</p>
<p>Conceptually, this returns true if getBroadcastedShape would have returned true and vice versa, with one exception. If a dimension is unknown in both shapes, getBroadcastedShape would return true and have a result with unknown dimension, while this function will return false because it's possible for both shapes to have a dimension greater than 1 and different which would fail to broadcast. </p>

<p class="definition">Definition at line <a class="el" href="Traits_8cpp_source.html#l00024">24</a> of file <a class="el" href="Traits_8cpp_source.html">Traits.cpp</a>.</p>

<p class="reference">References <a class="el" href="PolynomialApproximation_8cpp_source.html#l00212">max()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Traits_8cpp_source.html#l00016">staticallyKnownBroadcastable()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Aug 1 2025 16:33:31 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
