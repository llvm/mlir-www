<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::presburger::detail Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="namespacemlir.html">mlir</a></li><li class="navelem"><a href="namespacemlir_1_1presburger.html">presburger</a></li><li class="navelem"><a href="namespacemlir_1_1presburger_1_1detail.html">detail</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mlir::presburger::detail Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:GeneratingFunction" id="r_GeneratingFunction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a46ce29de7916a33c4c4ba5585faa20c0" id="r_a46ce29de7916a33c4c4ba5585faa20c0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a> = <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a></td></tr>
<tr class="memdesc:a46ce29de7916a33c4c4ba5585faa20c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polyhedron in H-representation is a set of inequalities in d variables with integer coefficients.  <br /></td></tr>
<tr class="memitem:a3e173d86ae99b80dca170097da2fe1a9" id="r_a3e173d86ae99b80dca170097da2fe1a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e173d86ae99b80dca170097da2fe1a9">PolyhedronV</a> = <a class="el" href="classmlir_1_1presburger_1_1IntMatrix.html">IntMatrix</a></td></tr>
<tr class="memdesc:a3e173d86ae99b80dca170097da2fe1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polyhedron in V-representation is a set of rays and points, i.e., vectors, stored as rows of a matrix.  <br /></td></tr>
<tr class="memitem:ab918c79081251d11ad633115df2d515b" id="r_ab918c79081251d11ad633115df2d515b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a> = <a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a></td></tr>
<tr class="memdesc:ab918c79081251d11ad633115df2d515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cone in either representation is a special case of a polyhedron in that representation.  <br /></td></tr>
<tr class="memitem:a17c9465252432e524bb309ea7e73ad05" id="r_a17c9465252432e524bb309ea7e73ad05"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a> = <a class="el" href="#a3e173d86ae99b80dca170097da2fe1a9">PolyhedronV</a></td></tr>
<tr class="memitem:af8bbb3eb7ced35e1563ee193a7e8850c" id="r_af8bbb3eb7ced35e1563ee193a7e8850c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">ParamPoint</a> = <a class="el" href="classmlir_1_1presburger_1_1FracMatrix.html">FracMatrix</a></td></tr>
<tr class="memitem:a4acfb500650c16ac9577e515b07e653f" id="r_a4acfb500650c16ac9577e515b07e653f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4acfb500650c16ac9577e515b07e653f">Point</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab5199a990abf56bb1aed55e313320a14" id="r_ab5199a990abf56bb1aed55e313320a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5199a990abf56bb1aed55e313320a14">defineHRep</a> (int numVars, int numSymbols=0)</td></tr>
<tr class="memitem:adbb5f9bfaecd1c967625b8f88d1457e0" id="r_adbb5f9bfaecd1c967625b8f88d1457e0"><td class="memItemLeft" align="right" valign="top">DynamicAPInt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbb5f9bfaecd1c967625b8f88d1457e0">getIndex</a> (const <a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a> &amp;cone)</td></tr>
<tr class="memdesc:adbb5f9bfaecd1c967625b8f88d1457e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of a cone, i.e., the volume of the parallelepiped spanned by its generators, which is equal to the number of integer points in its fundamental parallelepiped.  <br /></td></tr>
<tr class="memitem:a8861eb2956b8b818151076ff6bd549b2" id="r_a8861eb2956b8b818151076ff6bd549b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8861eb2956b8b818151076ff6bd549b2">getDual</a> (<a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a> cone)</td></tr>
<tr class="memdesc:a8861eb2956b8b818151076ff6bd549b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cone in H-representation, return its dual.  <br /></td></tr>
<tr class="memitem:aa71cf5dc1b4fc8e8b3c19c53fb4661fc" id="r_aa71cf5dc1b4fc8e8b3c19c53fb4661fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa71cf5dc1b4fc8e8b3c19c53fb4661fc">getDual</a> (<a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a> cone)</td></tr>
<tr class="memdesc:aa71cf5dc1b4fc8e8b3c19c53fb4661fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a cone in V-representation, return its dual.  <br /></td></tr>
<tr class="memitem:aaf535e43d9c8ca88aaca06fe75a14bd0" id="r_aaf535e43d9c8ca88aaca06fe75a14bd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf535e43d9c8ca88aaca06fe75a14bd0">computeUnimodularConeGeneratingFunction</a> (<a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">ParamPoint</a> vertex, int sign, const <a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a> &amp;cone)</td></tr>
<tr class="memdesc:aaf535e43d9c8ca88aaca06fe75a14bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the generating function for a unimodular cone.  <br /></td></tr>
<tr class="memitem:a4b4c2992fc94314b4b6a4b5d2b5a1714" id="r_a4b4c2992fc94314b4b6a4b5d2b5a1714"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">ParamPoint</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b4c2992fc94314b4b6a4b5d2b5a1714">solveParametricEquations</a> (<a class="el" href="classmlir_1_1presburger_1_1FracMatrix.html">FracMatrix</a> equations)</td></tr>
<tr class="memdesc:a4b4c2992fc94314b4b6a4b5d2b5a1714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the solution of a set of equations that express affine constraints between a set of variables and a set of parameters.  <br /></td></tr>
<tr class="memitem:ac8191fe663c70c741eec0fd947559b49" id="r_ac8191fe663c70c741eec0fd947559b49"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8191fe663c70c741eec0fd947559b49">computeChamberDecomposition</a> (<a class="el" href="classunsigned.html">unsigned</a> numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt; regionsAndGeneratingFunctions)</td></tr>
<tr class="memdesc:ac8191fe663c70c741eec0fd947559b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of possibly intersecting regions (<a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>) and the generating functions active in each region, produce a pairwise disjoint list of regions (chambers) and identify the generating function of the polytope in each chamber.  <br /></td></tr>
<tr class="memitem:acf8a3cc3aef4fd29060c970d312ece1d" id="r_acf8a3cc3aef4fd29060c970d312ece1d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acf8a3cc3aef4fd29060c970d312ece1d">computePolytopeGeneratingFunction</a> (const <a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a> &amp;poly)</td></tr>
<tr class="memdesc:acf8a3cc3aef4fd29060c970d312ece1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the generating function corresponding to a polytope.  <br /></td></tr>
<tr class="memitem:aa419c4d5a99bdc4d72db95529fed1d0e" id="r_aa419c4d5a99bdc4d72db95529fed1d0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a4acfb500650c16ac9577e515b07e653f">Point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa419c4d5a99bdc4d72db95529fed1d0e">getNonOrthogonalVector</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a4acfb500650c16ac9577e515b07e653f">Point</a> &gt; vectors)</td></tr>
<tr class="memdesc:aa419c4d5a99bdc4d72db95529fed1d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a vector that is not orthogonal to any of the given vectors, i.e., has nonzero dot product with those of the given vectors that are not null.  <br /></td></tr>
<tr class="memitem:af867702740547f47fe7c4961272dce1a" id="r_af867702740547f47fe7c4961272dce1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af867702740547f47fe7c4961272dce1a">getCoefficientInRationalFunction</a> (<a class="el" href="classunsigned.html">unsigned</a> power, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a> &gt; num, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a> &gt; den)</td></tr>
<tr class="memdesc:af867702740547f47fe7c4961272dce1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the coefficient of a given power of s in a rational function given by P(s)/Q(s), where P is a polynomial, in which the coefficients are QuasiPolynomials over d parameters (distinct from s), and and Q is a polynomial with <a class="el" href="structmlir_1_1presburger_1_1Fraction.html" title="A class to represent fractions.">Fraction</a> coefficients.  <br /></td></tr>
<tr class="memitem:a962f6d7cc092fc6fcd0e52b1a385df6f" id="r_a962f6d7cc092fc6fcd0e52b1a385df6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a962f6d7cc092fc6fcd0e52b1a385df6f">computeNumTerms</a> (const <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &amp;gf)</td></tr>
<tr class="memdesc:a962f6d7cc092fc6fcd0e52b1a385df6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the number of terms in a generating function, as a quasipolynomial in the parameter space of the input function.  <br /></td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="ab918c79081251d11ad633115df2d515b" name="ab918c79081251d11ad633115df2d515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab918c79081251d11ad633115df2d515b">&#9670;&#160;</a></span>ConeH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ab918c79081251d11ad633115df2d515b">mlir::presburger::detail::ConeH</a> = <a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A cone in either representation is a special case of a polyhedron in that representation. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8h_source.html#l00048">48</a> of file <a class="el" href="Barvinok_8h_source.html">Barvinok.h</a>.</p>

</div>
</div>
<a id="a17c9465252432e524bb309ea7e73ad05" name="a17c9465252432e524bb309ea7e73ad05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c9465252432e524bb309ea7e73ad05">&#9670;&#160;</a></span>ConeV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a17c9465252432e524bb309ea7e73ad05">mlir::presburger::detail::ConeV</a> = <a class="el" href="#a3e173d86ae99b80dca170097da2fe1a9">PolyhedronV</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Barvinok_8h_source.html#l00049">49</a> of file <a class="el" href="Barvinok_8h_source.html">Barvinok.h</a>.</p>

</div>
</div>
<a id="af8bbb3eb7ced35e1563ee193a7e8850c" name="af8bbb3eb7ced35e1563ee193a7e8850c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bbb3eb7ced35e1563ee193a7e8850c">&#9670;&#160;</a></span>ParamPoint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">mlir::presburger::detail::ParamPoint</a> = <a class="el" href="classmlir_1_1presburger_1_1FracMatrix.html">FracMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GeneratingFunction_8h_source.html#l00028">28</a> of file <a class="el" href="GeneratingFunction_8h_source.html">GeneratingFunction.h</a>.</p>

</div>
</div>
<a id="a4acfb500650c16ac9577e515b07e653f" name="a4acfb500650c16ac9577e515b07e653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acfb500650c16ac9577e515b07e653f">&#9670;&#160;</a></span>Point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4acfb500650c16ac9577e515b07e653f">mlir::presburger::detail::Point</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GeneratingFunction_8h_source.html#l00031">31</a> of file <a class="el" href="GeneratingFunction_8h_source.html">GeneratingFunction.h</a>.</p>

</div>
</div>
<a id="a46ce29de7916a33c4c4ba5585faa20c0" name="a46ce29de7916a33c4c4ba5585faa20c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46ce29de7916a33c4c4ba5585faa20c0">&#9670;&#160;</a></span>PolyhedronH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">mlir::presburger::detail::PolyhedronH</a> = <a class="el" href="classmlir_1_1presburger_1_1IntegerRelation.html">IntegerRelation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A polyhedron in H-representation is a set of inequalities in d variables with integer coefficients. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8h_source.html#l00040">40</a> of file <a class="el" href="Barvinok_8h_source.html">Barvinok.h</a>.</p>

</div>
</div>
<a id="a3e173d86ae99b80dca170097da2fe1a9" name="a3e173d86ae99b80dca170097da2fe1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e173d86ae99b80dca170097da2fe1a9">&#9670;&#160;</a></span>PolyhedronV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3e173d86ae99b80dca170097da2fe1a9">mlir::presburger::detail::PolyhedronV</a> = <a class="el" href="classmlir_1_1presburger_1_1IntMatrix.html">IntMatrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A polyhedron in V-representation is a set of rays and points, i.e., vectors, stored as rows of a matrix. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8h_source.html#l00044">44</a> of file <a class="el" href="Barvinok_8h_source.html">Barvinok.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ac8191fe663c70c741eec0fd947559b49" name="ac8191fe663c70c741eec0fd947559b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8191fe663c70c741eec0fd947559b49">&#9670;&#160;</a></span>computeChamberDecomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt; mlir::presburger::detail::computeChamberDecomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>regionsAndGeneratingFunctions</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of possibly intersecting regions (<a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>) and the generating functions active in each region, produce a pairwise disjoint list of regions (chambers) and identify the generating function of the polytope in each chamber. </p>
<p>This is an implementation of the Clauss-Loechner algorithm for chamber decomposition.</p>
<p>"Disjoint" here means that the intersection of two chambers is no full- dimensional.</p>
<p>The returned list partitions the universe into parts depending on which subset of GFs is active there, and gives the sum of active GFs for each part.</p>
<p>We maintain a list of pairwise disjoint chambers and the generating functions corresponding to each one. We iterate over the list of regions, each time adding the current region's generating function to the chambers where it is active and separating the chambers where it is not.</p>
<p>Given the region each generating function is active in, for each subset of generating functions the region that (the sum of) precisely this subset is in, is the intersection of the regions that these are active in, intersected with the complements of the remaining regions. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00240">240</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="PresburgerSpace_8h_source.html#l00170">mlir::presburger::PresburgerSpace::getSetSpace()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l01061">mlir::presburger::PresburgerSet::getUniverse()</a>, <a class="el" href="PresburgerRelation_8cpp_source.html#l01081">mlir::presburger::PresburgerSet::intersect()</a>, and <a class="el" href="PresburgerRelation_8cpp_source.html#l01045">mlir::presburger::PresburgerRelation::isFullDim()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00313">computePolytopeGeneratingFunction()</a>.</p>

</div>
</div>
<a id="a962f6d7cc092fc6fcd0e52b1a385df6f" name="a962f6d7cc092fc6fcd0e52b1a385df6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962f6d7cc092fc6fcd0e52b1a385df6f">&#9670;&#160;</a></span>computeNumTerms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a> mlir::presburger::detail::computeNumTerms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gf</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the number of terms in a generating function, as a quasipolynomial in the parameter space of the input function. </p>
<p>We have a generating function of the form f_p(x) = \sum_i sign_i * (x^n_i(p)) / (\prod_j (1 - x^d_{ij})</p>
<p>The generating function must be such that for all values of the parameters, the number of terms is finite.</p>
<p>where sign_i is ±1, n_i \in Q^p -&gt; Q^d is the sum of the vectors d_{ij}, weighted by the floors of d affine functions on p parameters. d_{ij} \in Q^d are vectors.</p>
<p>We need to find the number of terms of the form x^t in the expansion of this function. However, direct substitution (x = (1, ..., 1)) causes the denominator to become zero.</p>
<p>We therefore use the following procedure instead:</p><ol type="1">
<li>Substitute x_i = (s+1)^μ_i for some vector μ. This makes the generating function a function of a scalar s.</li>
<li>Write each term in this function as P(s)/Q(s), where P and Q are polynomials. P has coefficients as quasipolynomials in d parameters, while Q has coefficients as scalars.</li>
<li>Find the constant term in the expansion of each term P(s)/Q(s). This is equivalent to substituting s = 0.</li>
</ol>
<p>Verdoolaege, Sven, et al. "Counting integer points in parametric
polytopes using Barvinok's rational functions." Algorithmica 48 (2007): 37-66. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00690">690</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00107">mlir::presburger::abs()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00638">getBinomialCoefficients()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00515">getCoefficientInRationalFunction()</a>, <a class="el" href="GeneratingFunction_8h_source.html#l00071">mlir::presburger::detail::GeneratingFunction::getDenominators()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00472">getNonOrthogonalVector()</a>, <a class="el" href="GeneratingFunction_8h_source.html#l00069">mlir::presburger::detail::GeneratingFunction::getNumerators()</a>, <a class="el" href="GeneratingFunction_8h_source.html#l00065">mlir::presburger::detail::GeneratingFunction::getNumParams()</a>, <a class="el" href="GeneratingFunction_8h_source.html#l00067">mlir::presburger::detail::GeneratingFunction::getSigns()</a>, <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00545">mlir::presburger::multiplyPolynomials()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00609">normalizeDenominatorExponents()</a>, <a class="el" href="QuasiPolynomial_8cpp_source.html#l00102">mlir::presburger::QuasiPolynomial::simplify()</a>, and <a class="el" href="Barvinok_8cpp_source.html#l00558">substituteMuInTerm()</a>.</p>

</div>
</div>
<a id="acf8a3cc3aef4fd29060c970d312ece1d" name="acf8a3cc3aef4fd29060c970d312ece1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8a3cc3aef4fd29060c970d312ece1d">&#9670;&#160;</a></span>computePolytopeGeneratingFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; <a class="el" href="classmlir_1_1presburger_1_1PresburgerSet.html">PresburgerSet</a>, <a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> &gt; &gt; mlir::presburger::detail::computePolytopeGeneratingFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>poly</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the generating function corresponding to a polytope. </p>
<p>For a polytope expressed as a set of n inequalities, compute the generating function corresponding to the lattice points included in the polytope.</p>
<p>All tangent cones of the polytope must be unimodular.</p>
<p>This algorithm has three main steps:</p><ol type="1">
<li>Enumerate the vertices, by iterating over subsets of inequalities and checking for satisfiability. For each d-subset of inequalities (where d is the number of variables), we solve to obtain the vertex in terms of the parameters, and then check for the region in parameter space where this vertex satisfies the remaining (n - d) inequalities.</li>
<li>For each vertex, identify the tangent cone and compute the generating function corresponding to it. The generating function depends on the parametric expression of the vertex and the (non-parametric) generators of the tangent cone.</li>
<li>[Clauss-Loechner decomposition] Identify the regions in parameter space (chambers) where each vertex is active, and accordingly compute the GF of the polytope in each chamber.</li>
</ol>
<p>Verdoolaege, Sven, et al. "Counting integer points in parametric
polytopes using Barvinok's rational functions." Algorithmica 48 (2007): 37-66. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00313">313</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00371">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="Matrix_8cpp_source.html#l00288">mlir::presburger::Matrix&lt; T &gt;::addToRow()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00240">computeChamberDecomposition()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00080">computeUnimodularConeGeneratingFunction()</a>, <a class="el" href="Barvinok_8h_source.html#l00051">defineHRep()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00269">mlir::presburger::IntegerRelation::getInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00242">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00227">mlir::presburger::IntegerRelation::getNumRangeVars()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00228">mlir::presburger::IntegerRelation::getNumSymbolVars()</a>, <a class="el" href="PresburgerSpace_8h_source.html#l00163">mlir::presburger::PresburgerSpace::getRelationSpace()</a>, <a class="el" href="Matrix_8cpp_source.html#l00130">mlir::presburger::Matrix&lt; T &gt;::getRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00140">mlir::presburger::Matrix&lt; T &gt;::setRow()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00162">solveParametricEquations()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00407">mlir::presburger::Matrix&lt; T &gt;::splitByBitset()</a>.</p>

</div>
</div>
<a id="aaf535e43d9c8ca88aaca06fe75a14bd0" name="aaf535e43d9c8ca88aaca06fe75a14bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf535e43d9c8ca88aaca06fe75a14bd0">&#9670;&#160;</a></span>computeUnimodularConeGeneratingFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1presburger_1_1detail_1_1GeneratingFunction.html">GeneratingFunction</a> mlir::presburger::detail::computeUnimodularConeGeneratingFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">ParamPoint</a></td>          <td class="paramname"><span class="paramname"><em>vertex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sign</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cone</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the generating function for a unimodular cone. </p>
<p>The input cone must be unimodular; it assert-fails otherwise.</p>
<p>This consists of a single term of the form sign * x^num / prod_j (1 - x^den_j)</p>
<p>sign is either +1 or -1. den_j is defined as the set of generators of the cone. num is computed by expressing the vertex as a weighted sum of the generators, and then taking the floor of the coefficients. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00080">80</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fraction_8h_source.html#l00107">mlir::presburger::abs()</a>, <a class="el" href="Matrix_8cpp_source.html#l00580">mlir::presburger::FracMatrix::determinant()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00021">getDual()</a>, <a class="el" href="Barvinok_8cpp_source.html#l00063">getIndex()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00269">mlir::presburger::IntegerRelation::getInequalities()</a>, <a class="el" href="Matrix_8h_source.html#l00088">mlir::presburger::Matrix&lt; T &gt;::getNumColumns()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00242">mlir::presburger::IntegerRelation::getNumInequalities()</a>, <a class="el" href="Matrix_8h_source.html#l00086">mlir::presburger::Matrix&lt; T &gt;::getNumRows()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00235">mlir::presburger::IntegerRelation::getNumVars()</a>, <a class="el" href="Matrix_8cpp_source.html#l00130">mlir::presburger::Matrix&lt; T &gt;::getRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00323">mlir::presburger::Matrix&lt; T &gt;::negateRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00335">mlir::presburger::Matrix&lt; T &gt;::preMultiplyWithRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00230">mlir::presburger::Matrix&lt; T &gt;::removeRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00140">mlir::presburger::Matrix&lt; T &gt;::setRow()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00080">mlir::presburger::Matrix&lt; T &gt;::transpose()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00313">computePolytopeGeneratingFunction()</a>.</p>

</div>
</div>
<a id="ab5199a990abf56bb1aed55e313320a14" name="ab5199a990abf56bb1aed55e313320a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5199a990abf56bb1aed55e313320a14">&#9670;&#160;</a></span>defineHRep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a46ce29de7916a33c4c4ba5585faa20c0">PolyhedronH</a> mlir::presburger::detail::defineHRep </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numVars</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSymbols</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Barvinok_8h_source.html#l00051">51</a> of file <a class="el" href="Barvinok_8h_source.html">Barvinok.h</a>.</p>

<p class="reference">References <a class="el" href="PresburgerSpace_8h_source.html#l00170">mlir::presburger::PresburgerSpace::getSetSpace()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00313">computePolytopeGeneratingFunction()</a>, and <a class="el" href="Barvinok_8cpp_source.html#l00046">getDual()</a>.</p>

</div>
</div>
<a id="af867702740547f47fe7c4961272dce1a" name="af867702740547f47fe7c4961272dce1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af867702740547f47fe7c4961272dce1a">&#9670;&#160;</a></span>getCoefficientInRationalFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a> mlir::presburger::detail::getCoefficientInRationalFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>power</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1presburger_1_1QuasiPolynomial.html">QuasiPolynomial</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1presburger_1_1Fraction.html">Fraction</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>den</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the coefficient of a given power of s in a rational function given by P(s)/Q(s), where P is a polynomial, in which the coefficients are QuasiPolynomials over d parameters (distinct from s), and and Q is a polynomial with <a class="el" href="structmlir_1_1presburger_1_1Fraction.html" title="A class to represent fractions.">Fraction</a> coefficients. </p>
<p>We use the following recursive formula to find the coefficient of s^power in the rational function given by P(s)/Q(s).</p>
<p>Let P[i] denote the coefficient of s^i in the polynomial P(s). (P/Q)[r] = if (r == 0) then P[0]/Q[0] else (P[r] - {Σ_{i=1}^r (P/Q)[r-i] * Q[i])}/(Q[0]) We therefore recursively call <span class="tt">getCoefficientInRationalFunction</span> on all i \in [0, power).</p>
<p><a href="https://math.ucdavis.edu/~deloera/researchsummary/">https://math.ucdavis.edu/~deloera/researchsummary/</a> barvinokalgorithm-latte1.pdf, p. 1285 </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00515">515</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00690">computeNumTerms()</a>.</p>

</div>
</div>
<a id="a8861eb2956b8b818151076ff6bd549b2" name="a8861eb2956b8b818151076ff6bd549b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8861eb2956b8b818151076ff6bd549b2">&#9670;&#160;</a></span>getDual() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a> mlir::presburger::detail::getDual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a></td>          <td class="paramname"><span class="paramname"><em>cone</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cone in H-representation, return its dual. </p>
<p>Assuming that the input cone is pointed at the origin, converts it to its dual in V-representation.</p>
<p>The dual cone is in V-representation. This assumes that the input is pointed at the origin; it assert-fails otherwise.</p>
<p>Essentially we just remove the all-zeroes constant column. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00021">21</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8h_source.html#l00062">mlir::presburger::Matrix&lt; T &gt;::at()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00196">mlir::presburger::IntegerRelation::atIneq()</a>, <a class="el" href="IntegerRelation_8h_source.html#l00238">mlir::presburger::IntegerRelation::getNumCols()</a>, and <a class="el" href="IntegerRelation_8h_source.html#l00242">mlir::presburger::IntegerRelation::getNumInequalities()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00080">computeUnimodularConeGeneratingFunction()</a>.</p>

</div>
</div>
<a id="aa71cf5dc1b4fc8e8b3c19c53fb4661fc" name="aa71cf5dc1b4fc8e8b3c19c53fb4661fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71cf5dc1b4fc8e8b3c19c53fb4661fc">&#9670;&#160;</a></span>getDual() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab918c79081251d11ad633115df2d515b">ConeH</a> mlir::presburger::detail::getDual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a></td>          <td class="paramname"><span class="paramname"><em>cone</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a cone in V-representation, return its dual. </p>
<p>Converts a cone in V-representation to the H-representation of its dual, pointed at the origin (not at the original vertex).</p>
<p>The dual cone is in H-representation. The returned cone is pointed at the origin.</p>
<p>Essentially adds a column consisting only of zeroes to the end. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00046">46</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="IntegerRelation_8cpp_source.html#l00371">mlir::presburger::IntegerRelation::addInequality()</a>, <a class="el" href="Barvinok_8h_source.html#l00051">defineHRep()</a>, <a class="el" href="Matrix_8h_source.html#l00088">mlir::presburger::Matrix&lt; T &gt;::getNumColumns()</a>, <a class="el" href="Matrix_8h_source.html#l00086">mlir::presburger::Matrix&lt; T &gt;::getNumRows()</a>, <a class="el" href="Matrix_8cpp_source.html#l00130">mlir::presburger::Matrix&lt; T &gt;::getRow()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00148">mlir::presburger::Matrix&lt; T &gt;::insertColumn()</a>.</p>

</div>
</div>
<a id="adbb5f9bfaecd1c967625b8f88d1457e0" name="adbb5f9bfaecd1c967625b8f88d1457e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb5f9bfaecd1c967625b8f88d1457e0">&#9670;&#160;</a></span>getIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DynamicAPInt mlir::presburger::detail::getIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a17c9465252432e524bb309ea7e73ad05">ConeV</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cone</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of a cone, i.e., the volume of the parallelepiped spanned by its generators, which is equal to the number of integer points in its fundamental parallelepiped. </p>
<p>Find the index of a cone in V-representation.</p>
<p>If the index is 1, the cone is unimodular. Barvinok, A., and J. E. Pommersheim. "An algorithmic theory of lattice
points in polyhedra." p. 107 If it has more rays than the dimension, return</p><ol type="1">
<li></li>
</ol>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00063">63</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00546">mlir::presburger::IntMatrix::determinant()</a>, <a class="el" href="Matrix_8h_source.html#l00088">mlir::presburger::Matrix&lt; T &gt;::getNumColumns()</a>, and <a class="el" href="Matrix_8h_source.html#l00086">mlir::presburger::Matrix&lt; T &gt;::getNumRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00080">computeUnimodularConeGeneratingFunction()</a>.</p>

</div>
</div>
<a id="aa419c4d5a99bdc4d72db95529fed1d0e" name="aa419c4d5a99bdc4d72db95529fed1d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa419c4d5a99bdc4d72db95529fed1d0e">&#9670;&#160;</a></span>getNonOrthogonalVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a4acfb500650c16ac9577e515b07e653f">Point</a> mlir::presburger::detail::getNonOrthogonalVector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="#a4acfb500650c16ac9577e515b07e653f">Point</a> &gt;</td>          <td class="paramname"><span class="paramname"><em>vectors</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a vector that is not orthogonal to any of the given vectors, i.e., has nonzero dot product with those of the given vectors that are not null. </p>
<p>We use an iterative procedure to find a vector not orthogonal to a given set, ignoring the null vectors.</p>
<p>If any of the vectors is null, it is ignored.</p>
<p>Let the inputs be {x_1, ..., x_k}, all vectors of length n.</p>
<p>In the following, vs[:i] means the elements of vs up to and including the i'th one, &lt;vs, us&gt; means the dot product of vs and us, vs ++ [v] means the vector vs with the new element v appended to it.</p>
<p>We proceed iteratively; for steps d = 0, ... n-1, we construct a vector which is not orthogonal to any of {x_1[:d], ..., x_n[:d]}, ignoring the null vectors. At step d = 0, we let vs = [1]. Clearly this is not orthogonal to any vector in the set {x_1[0], ..., x_n[0]}, except the null ones, which we ignore. At step d &gt; 0 , we need a number v s.t. &lt;x_i[:d], vs++[v]&gt; != 0 for all i. =&gt; &lt;x_i[:d-1], vs&gt; + x_i[d]*v != 0 =&gt; v != - &lt;x_i[:d-1], vs&gt; / x_i[d] We compute this value for all x_i, and then set v to be the maximum element of this set plus one. Thus v is outside the set as desired, and we append it to vs to obtain the result of the d'th step. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00472">472</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Presburger_2Utils_8cpp_source.html#l00534">mlir::presburger::dotProduct()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00690">computeNumTerms()</a>.</p>

</div>
</div>
<a id="a4b4c2992fc94314b4b6a4b5d2b5a1714" name="a4b4c2992fc94314b4b6a4b5d2b5a1714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4c2992fc94314b4b6a4b5d2b5a1714">&#9670;&#160;</a></span>solveParametricEquations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; <a class="el" href="#af8bbb3eb7ced35e1563ee193a7e8850c">ParamPoint</a> &gt; mlir::presburger::detail::solveParametricEquations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1presburger_1_1FracMatrix.html">FracMatrix</a></td>          <td class="paramname"><span class="paramname"><em>equations</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the solution of a set of equations that express affine constraints between a set of variables and a set of parameters. </p>
<p>We use Gaussian elimination to find the solution to a set of d equations of the form a_1 x_1 + ... + a_d x_d + b_1 m_1 + ... + b_p m_p + c = 0 where x_i are variables, m_i are parameters and a_i, b_i, c are rational coefficients.</p>
<p>The solution expresses each variable as an affine function of the parameters.</p>
<p>If there is no solution, return null.</p>
<p>The solution expresses each x_i as an affine function of the m_i, and is therefore represented as a matrix of size d x (p+1). If there is no solution, we return null. </p>

<p class="definition">Definition at line <a class="el" href="Barvinok_8cpp_source.html#l00162">162</a> of file <a class="el" href="Barvinok_8cpp_source.html">Barvinok.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matrix_8cpp_source.html#l00288">mlir::presburger::Matrix&lt; T &gt;::addToRow()</a>, <a class="el" href="Matrix_8cpp_source.html#l00580">mlir::presburger::FracMatrix::determinant()</a>, <a class="el" href="Matrix_8h_source.html#l00088">mlir::presburger::Matrix&lt; T &gt;::getNumColumns()</a>, <a class="el" href="Matrix_8h_source.html#l00086">mlir::presburger::Matrix&lt; T &gt;::getNumRows()</a>, <a class="el" href="Matrix_8cpp_source.html#l00373">mlir::presburger::Matrix&lt; T &gt;::getSubMatrix()</a>, <a class="el" href="Matrix_8cpp_source.html#l00329">mlir::presburger::Matrix&lt; T &gt;::negateMatrix()</a>, <a class="el" href="Matrix_8cpp_source.html#l00302">mlir::presburger::Matrix&lt; T &gt;::scaleRow()</a>, and <a class="el" href="Matrix_8cpp_source.html#l00110">mlir::presburger::Matrix&lt; T &gt;::swapRows()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Barvinok_8cpp_source.html#l00313">computePolytopeGeneratingFunction()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
