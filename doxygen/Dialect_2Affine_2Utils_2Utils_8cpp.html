<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/Affine/Utils/Utils.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">MLIR<span id="projectnumber">&#160;22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',false);
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a href="dir_30022079959872f4a1874dfcab7bb1fc.html">Affine</a></li><li class="navelem"><a href="dir_36ccfdf0d236a67fd57e73c4a5bad479.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utils.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="Dialect_2Affine_2Utils_8h_source.html">mlir/Dialect/Affine/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Affine_2Analysis_2Utils_8h_source.html">mlir/Dialect/Affine/Analysis/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineOps_8h_source.html">mlir/Dialect/Affine/IR/AffineOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineValueMap_8h_source.html">mlir/Dialect/Affine/IR/AffineValueMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LoopUtils_8h_source.html">mlir/Dialect/Affine/LoopUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dialect_2Arith_2Utils_2Utils_8h_source.html">mlir/Dialect/Arith/Utils/Utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2MemRef_2IR_2MemRef_8h_source.html">mlir/Dialect/MemRef/IR/MemRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IndexingUtils_8h_source.html">mlir/Dialect/Utils/IndexingUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AffineExprVisitor_8h_source.html">mlir/IR/AffineExprVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominance_8h_source.html">mlir/IR/Dominance.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRMapping_8h_source.html">mlir/IR/IRMapping.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2IR_2IntegerSet_8h_source.html">mlir/IR/IntegerSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GreedyPatternRewriteDriver_8h_source.html">mlir/Transforms/GreedyPatternRewriteDriver.h</a>&quot;</code><br />
<code>#include &lt;optional&gt;</code><br />
</div>
<p><a href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d" id="r_ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;affine-utils&quot;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8361db875ebdd069691084e31cb1f90a" id="r_a8361db875ebdd069691084e31cb1f90a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> { <a class="el" href="#a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6">TileFloorDiv</a>
, <a class="el" href="#a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec">TileMod</a>
, <a class="el" href="#a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e">TileNone</a>
 }</td></tr>
<tr class="memdesc:a8361db875ebdd069691084e31cb1f90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum to set patterns of affine expr in tiled-layout map.  <a href="#a8361db875ebdd069691084e31cb1f90a">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a91ed5c48cf2d60834e274223a2fe3391" id="r_a91ed5c48cf2d60834e274223a2fe3391"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ed5c48cf2d60834e274223a2fe3391">promoteIfBlock</a> (AffineIfOp ifOp, <a class="el" href="classbool.html">bool</a> elseBlock)</td></tr>
<tr class="memdesc:a91ed5c48cf2d60834e274223a2fe3391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the <span class="tt">then</span> or the <span class="tt">else</span> block of <span class="tt">ifOp</span> (depending on whether <span class="tt">elseBlock</span> is false or true) into <span class="tt">ifOp</span>'s containing block, and discards the rest of the op.  <br /></td></tr>
<tr class="memitem:af44d21686f23de1926f37fac8c12166c" id="r_af44d21686f23de1926f37fac8c12166c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af44d21686f23de1926f37fac8c12166c">getOutermostInvariantForOp</a> (AffineIfOp ifOp)</td></tr>
<tr class="memdesc:af44d21686f23de1926f37fac8c12166c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the outermost affine.for/parallel op that the <span class="tt">ifOp</span> is invariant on.  <br /></td></tr>
<tr class="memitem:a3327936fe7d848e7ec99d8efaebf3794" id="r_a3327936fe7d848e7ec99d8efaebf3794"><td class="memItemLeft" align="right" valign="top">static AffineIfOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3327936fe7d848e7ec99d8efaebf3794">hoistAffineIfOp</a> (AffineIfOp ifOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *hoistOverOp)</td></tr>
<tr class="memdesc:a3327936fe7d848e7ec99d8efaebf3794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper for the mechanics of mlir::hoistAffineIfOp.  <br /></td></tr>
<tr class="memitem:ae5e21f26b1679f4db66be5d34b3f162b" id="r_ae5e21f26b1679f4db66be5d34b3f162b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5e21f26b1679f4db66be5d34b3f162b">mustReachAtInnermost</a> (const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;destAccess)</td></tr>
<tr class="memdesc:ae5e21f26b1679f4db66be5d34b3f162b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the memory operation of <span class="tt">destAccess</span> depends on <span class="tt">srcAccess</span> inside of the innermost common surrounding affine loop between the two accesses.  <br /></td></tr>
<tr class="memitem:a1b3e2b0216da6f19e2c46070b8d87a34" id="r_a1b3e2b0216da6f19e2c46070b8d87a34"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3e2b0216da6f19e2c46070b8d87a34">mayHaveEffect</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcMemOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *destMemOp, <a class="el" href="classunsigned.html">unsigned</a> minSurroundingLoops)</td></tr>
<tr class="memdesc:a1b3e2b0216da6f19e2c46070b8d87a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if <span class="tt">srcMemOp</span> may have an effect on <span class="tt">destMemOp</span> within the scope of the outermost <span class="tt">minSurroundingLoops</span> loops that surround them.  <br /></td></tr>
<tr class="memitem:ae73ee9cfbfbb9175f6293e365a3db050" id="r_ae73ee9cfbfbb9175f6293e365a3db050"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73ee9cfbfbb9175f6293e365a3db050">forwardStoreToLoad</a> (AffineReadOpInterface loadOp, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;memrefsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#a769670962602294d6480466fb4c81d16">mayAlias</a>)</td></tr>
<tr class="memdesc:ae73ee9cfbfbb9175f6293e365a3db050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve.  <br /></td></tr>
<tr class="memitem:a1f557a42a0a9b74a791a37fc062ecc13" id="r_a1f557a42a0a9b74a791a37fc062ecc13"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f557a42a0a9b74a791a37fc062ecc13">mlir::affine::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, affine::AffineReadOpInterface &gt;</a> (<a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *, affine::AffineReadOpInterface, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;)</td></tr>
<tr class="memitem:adfced9fe5f6177df4ff7c7a7ca846ccd" id="r_adfced9fe5f6177df4ff7c7a7ca846ccd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfced9fe5f6177df4ff7c7a7ca846ccd">findUnusedStore</a> (AffineWriteOpInterface writeA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;opsToErase, <a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;postDominanceInfo, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#a769670962602294d6480466fb4c81d16">mayAlias</a>)</td></tr>
<tr class="memitem:aafd918b27a25560313bd51b1ac7ca25a" id="r_aafd918b27a25560313bd51b1ac7ca25a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafd918b27a25560313bd51b1ac7ca25a">loadCSE</a> (AffineReadOpInterface loadA, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;loadOpsToErase, <a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;domInfo, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; <a class="el" href="EliminateBarriers_8cpp.html#a769670962602294d6480466fb4c81d16">mayAlias</a>)</td></tr>
<tr class="memitem:a52b3aaf9ddb375018760546de9922605" id="r_a52b3aaf9ddb375018760546de9922605"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52b3aaf9ddb375018760546de9922605">isDereferencingOp</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memitem:a7ac55f3783f12dff6291ddd1bf1dd2c7" id="r_a7ac55f3783f12dff6291ddd1bf1dd2c7"><td class="memItemLeft" align="right" valign="top">static LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac55f3783f12dff6291ddd1bf1dd2c7">getTileSizePos</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; &amp;tileSizePos)</td></tr>
<tr class="memdesc:a7ac55f3783f12dff6291ddd1bf1dd2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">map</span> is a tiled layout.  <br /></td></tr>
<tr class="memitem:a98eeb5102e386317908e1de10d00d202" id="r_a98eeb5102e386317908e1de10d00d202"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98eeb5102e386317908e1de10d00d202">isNormalizedMemRefDynamicDim</a> (<a class="el" href="classunsigned.html">unsigned</a> dim, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> layoutMap, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;inMemrefTypeDynDims)</td></tr>
<tr class="memdesc:a98eeb5102e386317908e1de10d00d202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <span class="tt">dim</span> dimension of memrefType with <span class="tt">layoutMap</span> becomes dynamic after normalization.  <br /></td></tr>
<tr class="memitem:ab1d1fa11b6b2534b14e10e5214f5a108" id="r_ab1d1fa11b6b2534b14e10e5214f5a108"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1d1fa11b6b2534b14e10e5214f5a108">createDimSizeExprForTiledLayout</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> oldMapOutput, <a class="el" href="#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a> pat)</td></tr>
<tr class="memdesc:ab1d1fa11b6b2534b14e10e5214f5a108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create affine expr to calculate dimension size for a tiled-layout map.  <br /></td></tr>
<tr class="memitem:a3ed3d43868db3acfbf4aab21af2c0cdb" id="r_a3ed3d43868db3acfbf4aab21af2c0cdb"><td class="memTemplParams" colspan="2">template&lt;typename AllocLikeOp&gt; </td></tr>
<tr class="memitem:a3ed3d43868db3acfbf4aab21af2c0cdb template"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvoid.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ed3d43868db3acfbf4aab21af2c0cdb">createNewDynamicSizes</a> (MemRefType oldMemRefType, MemRefType newMemRefType, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, AllocLikeOp allocOp, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> <a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;newDynamicSizes)</td></tr>
<tr class="memdesc:a3ed3d43868db3acfbf4aab21af2c0cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create new maps to calculate each dimension size of <span class="tt">newMemRefType</span>, and create <span class="tt">newDynamicSizes</span> from them by using AffineApplyOp.  <br /></td></tr>
<tr class="memitem:a487befd3a2e4a3b38457f688dd7791f2" id="r_a487befd3a2e4a3b38457f688dd7791f2"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a487befd3a2e4a3b38457f688dd7791f2">mlir::affine::normalizeMemRef&lt; memref::AllocaOp &gt;</a> (memref::AllocaOp op)</td></tr>
<tr class="memitem:a4919667f02e1b979a01f6d50c7be1fc8" id="r_a4919667f02e1b979a01f6d50c7be1fc8"><td class="memItemLeft" align="right" valign="top">template LogicalResult&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4919667f02e1b979a01f6d50c7be1fc8">mlir::affine::normalizeMemRef&lt; memref::AllocOp &gt;</a> (memref::AllocOp op)</td></tr>
<tr class="memitem:a9dd39ef7158794f7ad7e7031da04f6a6" id="r_a9dd39ef7158794f7ad7e7031da04f6a6"><td class="memItemLeft" align="right" valign="top">static FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dd39ef7158794f7ad7e7031da04f6a6">composedAffineMultiply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;<a class="el" href="LinalgTransformOps_8cpp.html#a21ad0bd836b90d08f4cf640b4c298e7c">b</a>, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> <a class="el" href="IR_2AffineExpr_8cpp.html#a204f446339af7929852f44df41484be5">lhs</a>, <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> <a class="el" href="VectorTransforms_8cpp.html#a611c177776150f2e11f15c1cec5764c1">rhs</a>)</td></tr>
<tr class="memdesc:a9dd39ef7158794f7ad7e7031da04f6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an affine map that computes <span class="tt">lhs</span> * <span class="tt">rhs</span>, composing in any other affine maps.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d" name="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&#160;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;affine-utils&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00031">31</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a8361db875ebdd069691084e31cb1f90a" name="a8361db875ebdd069691084e31cb1f90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8361db875ebdd069691084e31cb1f90a">&#9670;&#160;</a></span>TileExprPattern</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum to set patterns of affine expr in tiled-layout map. </p>
<p>TileFloorDiv: &lt;dim expr&gt; div &lt;tile size&gt; TileMod: &lt;dim expr&gt; mod &lt;tile size&gt; TileNone: None of the above Example: #tiled_2d_128x256 = affine_map&lt;(d0, d1) -&gt; (d0 div 128, d1 div 256, d0 mod 128, d1 mod 256)&gt; "d0 div 128" and "d1 div 256" ==&gt; TileFloorDiv "d0 mod 128" and "d1 mod 256" ==&gt; TileMod </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6" name="a8361db875ebdd069691084e31cb1f90aa0a2909cee5222be1729a359f34c482f6"></a>TileFloorDiv&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec" name="a8361db875ebdd069691084e31cb1f90aafab640cbd0e0ef2d840e36d087e561ec"></a>TileMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e" name="a8361db875ebdd069691084e31cb1f90aabb4b0501a7b81d89719cae036aa1937e"></a>TileNone&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">1484</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a9dd39ef7158794f7ad7e7031da04f6a6" name="a9dd39ef7158794f7ad7e7031da04f6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd39ef7158794f7ad7e7031da04f6a6">&#9670;&#160;</a></span>composedAffineMultiply()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FailureOr&lt; <a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a> &gt; composedAffineMultiply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a></td>          <td class="paramname"><span class="paramname"><em>loc</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an affine map that computes <span class="tt">lhs</span> * <span class="tt">rhs</span>, composing in any other affine maps. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01954">1954</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00325">mlir::bindSymbols()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00832">lhs</a>, <a class="el" href="AffineOps_8cpp_source.html#l01469">mlir::affine::makeComposedFoldedAffineApply()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l02249">rhs</a>.</p>

</div>
</div>
<a id="ab1d1fa11b6b2534b14e10e5214f5a108" name="ab1d1fa11b6b2534b14e10e5214f5a108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d1fa11b6b2534b14e10e5214f5a108">&#9670;&#160;</a></span>createDimSizeExprForTiledLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> createDimSizeExprForTiledLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td>          <td class="paramname"><span class="paramname"><em>oldMapOutput</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a8361db875ebdd069691084e31cb1f90a">TileExprPattern</a></td>          <td class="paramname"><span class="paramname"><em>pat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create affine expr to calculate dimension size for a tiled-layout map. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">1610</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00050">mlir::CeilDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00068">mlir::getAffineBinaryOpExpr()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00338">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00341">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">TileFloorDiv</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">TileMod</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>.</p>

</div>
</div>
<a id="a3ed3d43868db3acfbf4aab21af2c0cdb" name="a3ed3d43868db3acfbf4aab21af2c0cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed3d43868db3acfbf4aab21af2c0cdb">&#9670;&#160;</a></span>createNewDynamicSizes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AllocLikeOp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> createNewDynamicSizes </td>
          <td>(</td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>oldMemRefType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MemRefType</td>          <td class="paramname"><span class="paramname"><em>newMemRefType</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocLikeOp</td>          <td class="paramname"><span class="paramname"><em>allocOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>newDynamicSizes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create new maps to calculate each dimension size of <span class="tt">newMemRefType</span>, and create <span class="tt">newDynamicSizes</span> from them by using AffineApplyOp. </p>
<p>Steps for normalizing dynamic memrefs for a tiled layout map Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt; %0 = dim arg0, c1 :memref&lt;4x?xf32&gt; %1 = alloc(%0) : memref&lt;4x?xf32, #map0&gt;</p>
<p>(Before this function)</p><ol type="1">
<li>Check if <span class="tt">map</span>(#map0) is a tiled layout using <span class="tt"><a class="el" href="#a7ac55f3783f12dff6291ddd1bf1dd2c7" title="Check if map is a tiled layout.">getTileSizePos()</a></span>. Only single layout map is supported.</li>
<li>Create normalized memrefType using <span class="tt"><a class="el" href="#a98eeb5102e386317908e1de10d00d202" title="Check if dim dimension of memrefType with layoutMap becomes dynamic after normalization.">isNormalizedMemRefDynamicDim()</a></span>. It is memref&lt;4x?x?xf32&gt; in the above example.</li>
</ol>
<p>(In this function)</p><ol type="1">
<li>Create new maps to calculate each dimension of the normalized memrefType using <span class="tt"><a class="el" href="#ab1d1fa11b6b2534b14e10e5214f5a108" title="Create affine expr to calculate dimension size for a tiled-layout map.">createDimSizeExprForTiledLayout()</a></span>. In the tiled layout, the dimension size can be calculated by replacing "floordiv &lt;tile size&gt;" with "ceildiv &lt;tile size&gt;" and "mod &lt;tile size&gt;" with "&lt;tile size&gt;".</li>
</ol>
<ul>
<li>New map in the above example #map0 = affine_map&lt;(d0, d1) -&gt; (d0)&gt; #map1 = affine_map&lt;(d0, d1) -&gt; (d1 ceildiv 32)&gt; #map2 = affine_map&lt;(d0, d1) -&gt; (32)&gt;</li>
</ul>
<ol type="1">
<li>Create AffineApplyOp to apply the new maps. The output of AffineApplyOp is used in dynamicSizes of new AllocOp. %0 = dim arg0, c1 : memref&lt;4x?xf32&gt; c4 = arith.constant 4 : index %1 = affine.apply #map1(c4, %0) %2 = affine.apply #map2(c4, %0) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">1666</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01610">createDimSizeExprForTiledLayout()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l01224">mlir::AffineMap::get()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00399">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00394">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01492">getTileSizePos()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">TileFloorDiv</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">TileMod</a>, and <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01484">TileNone</a>.</p>

</div>
</div>
<a id="adfced9fe5f6177df4ff7c7a7ca846ccd" name="adfced9fe5f6177df4ff7c7a7ca846ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfced9fe5f6177df4ff7c7a7ca846ccd">&#9670;&#160;</a></span>findUnusedStore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> findUnusedStore </td>
          <td>(</td>
          <td class="paramtype">AffineWriteOpInterface</td>          <td class="paramname"><span class="paramname"><em>writeA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>opsToErase</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>postDominanceInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>mayAlias</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00912">912</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00873">mlir::Operation::getUsers()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">mlir::affine::hasNoInterveningEffect()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>, and <a class="el" href="Dominance_8h_source.html#l00213">mlir::PostDominanceInfo::postDominates()</a>.</p>

</div>
</div>
<a id="ae73ee9cfbfbb9175f6293e365a3db050" name="ae73ee9cfbfbb9175f6293e365a3db050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73ee9cfbfbb9175f6293e365a3db050">&#9670;&#160;</a></span>forwardStoreToLoad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> forwardStoreToLoad </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface</td>          <td class="paramname"><span class="paramname"><em>loadOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loadOpsToErase</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>memrefsToErase</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>mayAlias</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to eliminate loadOp by replacing it with a value stored into memory which the load is guaranteed to retrieve. </p>
<p>This check involves three components: 1) The store and load must be on the same location 2) The store must dominate (and therefore must always occur prior to) the load 3) No other operations will overwrite the memory loaded between the given load and store. If such a value exists, the replaced <span class="tt">loadOp</span> will be added to <span class="tt">loadOpsToErase</span> and its memref will be added to <span class="tt">memrefsToErase</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">835</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00158">mlir::DominanceInfo::dominates()</a>, <a class="el" href="Value_8h_source.html#l00105">mlir::Value::getType()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">mlir::affine::hasNoInterveningEffect()</a>, <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">mustReachAtInnermost()</a>, and <a class="el" href="Value_8h_source.html#l00149">mlir::Value::replaceAllUsesWith()</a>.</p>

</div>
</div>
<a id="af44d21686f23de1926f37fac8c12166c" name="af44d21686f23de1926f37fac8c12166c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44d21686f23de1926f37fac8c12166c">&#9670;&#160;</a></span>getOutermostInvariantForOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * getOutermostInvariantForOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp</td>          <td class="paramname"><span class="paramname"><em>ifOp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the outermost affine.for/parallel op that the <span class="tt">ifOp</span> is invariant on. </p>
<p>The <span class="tt">ifOp</span> could be hoisted and placed right before such an operation. This method assumes that the ifOp has been canonicalized (to be correct and effective). </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00262">262</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Operation_8h_source.html#l00378">mlir::Operation::getOperands()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00234">mlir::Operation::getParentOp()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00749">mlir::Operation::hasTrait()</a>.</p>

</div>
</div>
<a id="a7ac55f3783f12dff6291ddd1bf1dd2c7" name="a7ac55f3783f12dff6291ddd1bf1dd2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac55f3783f12dff6291ddd1bf1dd2c7">&#9670;&#160;</a></span>getTileSizePos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LogicalResult getTileSizePos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; std::tuple&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>, <a class="el" href="classunsigned.html">unsigned</a>, <a class="el" href="classunsigned.html">unsigned</a> &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>tileSizePos</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">map</span> is a tiled layout. </p>
<p>In the tiled layout, specific k dimensions being floordiv'ed by respective tile sizes appeare in a mod with the same tile sizes, and no other expression involves those k dimensions. This function stores a vector of tuples (<span class="tt">tileSizePos</span>) including <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression.">AffineExpr</a> for tile size, positions of corresponding <span class="tt">floordiv</span> and <span class="tt">mod</span>. If it is not a tiled layout, an empty vector is returned. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01492">1492</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00048">mlir::FloorDiv</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00033">mlir::AffineExpr::getKind()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00338">mlir::AffineBinaryOpExpr::getLHS()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="IR_2AffineExpr_8cpp_source.html#l00341">mlir::AffineBinaryOpExpr::getRHS()</a>, <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00046">mlir::Mod</a>, <a class="el" href="AffineAnalysis_8cpp.html#aa2afc59a21f80839c29f2812f75c36a4">success()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00117">mlir::AffineExpr::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01666">createNewDynamicSizes()</a>.</p>

</div>
</div>
<a id="a3327936fe7d848e7ec99d8efaebf3794" name="a3327936fe7d848e7ec99d8efaebf3794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3327936fe7d848e7ec99d8efaebf3794">&#9670;&#160;</a></span>hoistAffineIfOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AffineIfOp hoistAffineIfOp </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp</td>          <td class="paramname"><span class="paramname"><em>ifOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>hoistOverOp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper for the mechanics of mlir::hoistAffineIfOp. </p>
<p>Hoists <span class="tt">ifOp</span> just over <span class="tt">hoistOverOp</span>. Returns the new hoisted op if any hoisting happened, otherwise the same <span class="tt">ifOp</span>. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00289">289</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="LinalgTransformOps_8cpp_source.html#l02097">b</a>, <a class="el" href="IRMapping_8h_source.html#l00079">mlir::IRMapping::clear()</a>, <a class="el" href="IR_2Operation_8h_source.html#l00213">mlir::Operation::getBlock()</a>, <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00246">promoteIfBlock()</a>, and <a class="el" href="IR_2Operation_8h_source.html#l00797">mlir::Operation::walk()</a>.</p>

</div>
</div>
<a id="a52b3aaf9ddb375018760546de9922605" name="a52b3aaf9ddb375018760546de9922605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b3aaf9ddb375018760546de9922605">&#9670;&#160;</a></span>isDereferencingOp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isDereferencingOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01104">1104</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

</div>
</div>
<a id="a98eeb5102e386317908e1de10d00d202" name="a98eeb5102e386317908e1de10d00d202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eeb5102e386317908e1de10d00d202">&#9670;&#160;</a></span>isNormalizedMemRefDynamicDim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> isNormalizedMemRefDynamicDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td>          <td class="paramname"><span class="paramname"><em>layoutMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classunsigned.html">unsigned</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>inMemrefTypeDynDims</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if <span class="tt">dim</span> dimension of memrefType with <span class="tt">layoutMap</span> becomes dynamic after normalization. </p>
<p>Dimensions that include dynamic dimensions in the map output will become dynamic dimensions. Return true if <span class="tt">dim</span> is dynamic dimension.</p>
<p>Example: #map0 = affine_map&lt;(d0, d1) -&gt; (d0, d1 floordiv 32, d1 mod 32)&gt;</p>
<p>If d1 is dynamic dimension, 2nd and 3rd dimension of map output are dynamic. memref&lt;4x?xf32, #map0&gt; ==&gt; memref&lt;4x?x?xf32&gt; </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l01591">1591</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="WalkResult_8h_source.html#l00047">mlir::WalkResult::advance()</a>, <a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">mlir::getAffineDimExpr()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00339">mlir::AffineMap::getContext()</a>, <a class="el" href="IR_2AffineMap_8cpp_source.html#l00403">mlir::AffineMap::getResults()</a>, <a class="el" href="WalkResult_8h_source.html#l00046">mlir::WalkResult::interrupt()</a>, and <a class="el" href="mlir_2IR_2AffineExpr_8h_source.html#l00117">mlir::AffineExpr::walk()</a>.</p>

</div>
</div>
<a id="aafd918b27a25560313bd51b1ac7ca25a" name="aafd918b27a25560313bd51b1ac7ca25a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd918b27a25560313bd51b1ac7ca25a">&#9670;&#160;</a></span>loadCSE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> loadCSE </td>
          <td>(</td>
          <td class="paramtype">AffineReadOpInterface</td>          <td class="paramname"><span class="paramname"><em>loadA</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>loadOpsToErase</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>domInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em>mayAlias</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00959">959</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Dominance_8h_source.html#l00158">mlir::DominanceInfo::dominates()</a>, <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">mlir::affine::hasNoInterveningEffect()</a>, and <a class="el" href="EliminateBarriers_8cpp_source.html#l00424">mayAlias()</a>.</p>

</div>
</div>
<a id="a1b3e2b0216da6f19e2c46070b8d87a34" name="a1b3e2b0216da6f19e2c46070b8d87a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3e2b0216da6f19e2c46070b8d87a34">&#9670;&#160;</a></span>mayHaveEffect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mayHaveEffect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>srcMemOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *</td>          <td class="paramname"><span class="paramname"><em>destMemOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a></td>          <td class="paramname"><span class="paramname"><em>minSurroundingLoops</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if <span class="tt">srcMemOp</span> may have an effect on <span class="tt">destMemOp</span> within the scope of the outermost <span class="tt">minSurroundingLoops</span> loops that surround them. </p>
<p><span class="tt">srcMemOp</span> and <span class="tt">destMemOp</span> are expected to be affine read/write ops. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00654">654</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00275">mlir::affine::getAffineAnalysisScope()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">mlir::affine::getNumCommonSurroundingLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00083">mlir::affine::MemRefAccess::memref</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00187">mlir::affine::noDependence()</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">mlir::affine::hasNoInterveningEffect()</a>.</p>

</div>
</div>
<a id="a1f557a42a0a9b74a791a37fc062ecc13" name="a1f557a42a0a9b74a791a37fc062ecc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f557a42a0a9b74a791a37fc062ecc13">&#9670;&#160;</a></span>mlir::affine::hasNoInterveningEffect&lt; mlir::MemoryEffects::Read, affine::AffineReadOpInterface &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classbool.html">bool</a> <a class="el" href="namespacemlir_1_1affine.html#ae989950373589c5cc01381c0febcee4d">mlir::affine::hasNoInterveningEffect</a>&lt; <a class="el" href="structmlir_1_1MemoryEffects_1_1Read.html">mlir::MemoryEffects::Read</a>, affine::AffineReadOpInterface &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">mlir::Operation</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">affine::AffineReadOpInterface</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="classbool.html">bool</a>(<a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00687">mlir::affine::hasNoInterveningEffect()</a>.</p>

</div>
</div>
<a id="a487befd3a2e4a3b38457f688dd7791f2" name="a487befd3a2e4a3b38457f688dd7791f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487befd3a2e4a3b38457f688dd7791f2">&#9670;&#160;</a></span>mlir::affine::normalizeMemRef&lt; memref::AllocaOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template LogicalResult mlir::affine::normalizeMemRef&lt; memref::AllocaOp &gt; </td>
          <td>(</td>
          <td class="paramtype">memref::AllocaOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4919667f02e1b979a01f6d50c7be1fc8" name="a4919667f02e1b979a01f6d50c7be1fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4919667f02e1b979a01f6d50c7be1fc8">&#9670;&#160;</a></span>mlir::affine::normalizeMemRef&lt; memref::AllocOp &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template LogicalResult mlir::affine::normalizeMemRef&lt; memref::AllocOp &gt; </td>
          <td>(</td>
          <td class="paramtype">memref::AllocOp</td>          <td class="paramname"><span class="paramname"><em>op</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5e21f26b1679f4db66be5d34b3f162b" name="ae5e21f26b1679f4db66be5d34b3f162b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e21f26b1679f4db66be5d34b3f162b">&#9670;&#160;</a></span>mustReachAtInnermost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> mustReachAtInnermost </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>srcAccess</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1affine_1_1MemRefAccess.html">MemRefAccess</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destAccess</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the memory operation of <span class="tt">destAccess</span> depends on <span class="tt">srcAccess</span> inside of the innermost common surrounding affine loop between the two accesses. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00636">636</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00609">mlir::affine::checkMemrefAccessDependence()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00275">mlir::affine::getAffineAnalysisScope()</a>, <a class="el" href="Dialect_2Affine_2Analysis_2Utils_8cpp_source.html#l02108">mlir::affine::getNumCommonSurroundingLoops()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00181">mlir::affine::hasDependence()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00084">mlir::affine::MemRefAccess::opInst</a>, and <a class="el" href="LinalgTransformOps_8cpp_source.html#l02098">result</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00835">forwardStoreToLoad()</a>.</p>

</div>
</div>
<a id="a91ed5c48cf2d60834e274223a2fe3391" name="a91ed5c48cf2d60834e274223a2fe3391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ed5c48cf2d60834e274223a2fe3391">&#9670;&#160;</a></span>promoteIfBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvoid.html">void</a> promoteIfBlock </td>
          <td>(</td>
          <td class="paramtype">AffineIfOp</td>          <td class="paramname"><span class="paramname"><em>ifOp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a></td>          <td class="paramname"><span class="paramname"><em>elseBlock</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Promotes the <span class="tt">then</span> or the <span class="tt">else</span> block of <span class="tt">ifOp</span> (depending on whether <span class="tt">elseBlock</span> is false or true) into <span class="tt">ifOp</span>'s containing block, and discards the rest of the op. </p>

<p class="definition">Definition at line <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00246">246</a> of file <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00143">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00144">mlir::Block::end()</a>, and <a class="el" href="Block_8h_source.html#l00137">mlir::Block::getOperations()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Affine_2Utils_2Utils_8cpp_source.html#l00289">hoistAffineIfOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on <span class="timestamp"></span> for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
