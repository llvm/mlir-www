<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: lib/Dialect/SparseTensor/Transforms/Utils/CodegenUtils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">22.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_1a25ec519b6c1121408b67cc33ce3f15.html">Dialect</a></li><li class="navelem"><a class="el" href="dir_13082a6f4e9874f56b186194ab02bcf7.html">SparseTensor</a></li><li class="navelem"><a class="el" href="dir_0d456967b90db7a1f4f87da272c6d374.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_1500ad7e8d160703436e09fba8e2640d.html">Utils</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CodegenUtils.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mlir_2Dialect_2Arith_2IR_2Arith_8h_source.html">mlir/Dialect/Arith/IR/Arith.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Complex_8h_source.html">mlir/Dialect/Complex/IR/Complex.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="FuncOps_8h_source.html">mlir/Dialect/Func/IR/FuncOps.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVMDialect_8h_source.html">mlir/Dialect/LLVMIR/LLVMDialect.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Enums_8h_source.html">mlir/Dialect/SparseTensor/IR/Enums.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mlir_2Dialect_2SparseTensor_2IR_2SparseTensor_8h_source.html">mlir/Dialect/SparseTensor/IR/SparseTensor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SparseTensorType_8h_source.html">mlir/Dialect/SparseTensor/IR/SparseTensorType.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ReshapeOpsUtils_8h_source.html">mlir/Dialect/Utils/ReshapeOpsUtils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Builders_8h_source.html">mlir/IR/Builders.h</a>&quot;</code><br />
</div>
<p><a href="CodegenUtils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1sparse__tensor_1_1FuncCallOrInlineGenerator.html">mlir::sparse_tensor::FuncCallOrInlineGenerator&lt; SubClass &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to simplify lowering operations with/without function calls.  <a href="classmlir_1_1sparse__tensor_1_1FuncCallOrInlineGenerator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html">mlir</a></td></tr>
<tr class="memdesc:namespacemlir"><td class="mdescLeft">&#160;</td><td class="mdescRight">Include the generated interface declarations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1sparse__tensor"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html">mlir::sparse_tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af7ede6e23dd46be42eac24e06b29b2a2"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">mlir::sparse_tensor::EmitCInterface</a> : bool { <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2ad15305d7a4e34e02489c74a5ef542f36">mlir::sparse_tensor::Off</a> = false
, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2a521c36a31c2762741cf0f8890cbe05e3">mlir::sparse_tensor::On</a> = true
 }</td></tr>
<tr class="memdesc:af7ede6e23dd46be42eac24e06b29b2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shorthand aliases for the <code>emitCInterface</code> argument to <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code>, <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785" title="Creates a CallOp to the function reference returned by getFunc() in the builder&#39;s module.">createFuncCall()</a></code>, and <code>replaceOpWithFuncCall()</code>.  <a href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">More...</a><br /></td></tr>
<tr class="separator:af7ede6e23dd46be42eac24e06b29b2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a5913d5a1d9ef325b2c8c2a8b70843714">mlir::sparse_tensor::overheadTypeEncoding</a> (unsigned width)</td></tr>
<tr class="memdesc:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage bitwidth to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a5913d5a1d9ef325b2c8c2a8b70843714">More...</a><br /></td></tr>
<tr class="separator:a5913d5a1d9ef325b2c8c2a8b70843714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a9cb02cd2b1f8b3829133f8e05456ece9">mlir::sparse_tensor::overheadTypeEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage type to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a9cb02cd2b1f8b3829133f8e05456ece9">More...</a><br /></td></tr>
<tr class="separator:a9cb02cd2b1f8b3829133f8e05456ece9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae5f37309e9664d3b46e3ecac113e2fb1">mlir::sparse_tensor::getOverheadType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> ot)</td></tr>
<tr class="memdesc:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the internal type-encoding for overhead storage to an <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are uniqued, have an immutable identifier and an optional mutable compone...">mlir::Type</a>.  <a href="namespacemlir_1_1sparse__tensor.html#ae5f37309e9664d3b46e3ecac113e2fb1">More...</a><br /></td></tr>
<tr class="separator:ae5f37309e9664d3b46e3ecac113e2fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb0397fda5d40384bf6dd8677117f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a2cb0397fda5d40384bf6dd8677117f77">mlir::sparse_tensor::posTypeEncoding</a> (SparseTensorEncodingAttr enc)</td></tr>
<tr class="memdesc:a2cb0397fda5d40384bf6dd8677117f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OverheadType for position overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a2cb0397fda5d40384bf6dd8677117f77">More...</a><br /></td></tr>
<tr class="separator:a2cb0397fda5d40384bf6dd8677117f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c473163639e8d9624523f73000de43e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a3c473163639e8d9624523f73000de43e">mlir::sparse_tensor::crdTypeEncoding</a> (SparseTensorEncodingAttr enc)</td></tr>
<tr class="memdesc:a3c473163639e8d9624523f73000de43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the OverheadType for coordinate overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a3c473163639e8d9624523f73000de43e">More...</a><br /></td></tr>
<tr class="separator:a3c473163639e8d9624523f73000de43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb99cb0b7e9f6787952299a59609a7"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a68fb99cb0b7e9f6787952299a59609a7">mlir::sparse_tensor::overheadTypeFunctionSuffix</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a32a597cffeb76da76443c157781e9d60">OverheadType</a> ot)</td></tr>
<tr class="memdesc:a68fb99cb0b7e9f6787952299a59609a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert OverheadType to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#a68fb99cb0b7e9f6787952299a59609a7">More...</a><br /></td></tr>
<tr class="separator:a68fb99cb0b7e9f6787952299a59609a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebb2dcb33c43b890cb719a500d22077"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#afebb2dcb33c43b890cb719a500d22077">mlir::sparse_tensor::overheadTypeFunctionSuffix</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> overheadTp)</td></tr>
<tr class="memdesc:afebb2dcb33c43b890cb719a500d22077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an overhead storage type to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#afebb2dcb33c43b890cb719a500d22077">More...</a><br /></td></tr>
<tr class="separator:afebb2dcb33c43b890cb719a500d22077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d245959cdf73b056ffaefe11aee733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a79d245959cdf73b056ffaefe11aee733">mlir::sparse_tensor::primaryTypeEncoding</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> elemTp)</td></tr>
<tr class="memdesc:a79d245959cdf73b056ffaefe11aee733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a primary storage type to its internal type-encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a79d245959cdf73b056ffaefe11aee733">More...</a><br /></td></tr>
<tr class="separator:a79d245959cdf73b056ffaefe11aee733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb262d6ac8ec2bb016263171b219d769"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#adb262d6ac8ec2bb016263171b219d769">mlir::sparse_tensor::primaryTypeFunctionSuffix</a> (<a class="el" href="namespacemlir_1_1sparse__tensor.html#a6a7f4629fd99e5db6d08448472c904ab">PrimaryType</a> pt)</td></tr>
<tr class="memdesc:adb262d6ac8ec2bb016263171b219d769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert PrimaryType to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#adb262d6ac8ec2bb016263171b219d769">More...</a><br /></td></tr>
<tr class="separator:adb262d6ac8ec2bb016263171b219d769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d775351105b6d20ac0ec4712b14c4ab"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a1d775351105b6d20ac0ec4712b14c4ab">mlir::sparse_tensor::primaryTypeFunctionSuffix</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> elemTp)</td></tr>
<tr class="memdesc:a1d775351105b6d20ac0ec4712b14c4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a primary storage type to its function-name suffix.  <a href="namespacemlir_1_1sparse__tensor.html#a1d775351105b6d20ac0ec4712b14c4ab">More...</a><br /></td></tr>
<tr class="separator:a1d775351105b6d20ac0ec4712b14c4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9080cc103f52c0640615fe3044edcd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ad9080cc103f52c0640615fe3044edcd4">mlir::sparse_tensor::genCast</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> value, <a class="el" href="classmlir_1_1Type.html">Type</a> dstTy)</td></tr>
<tr class="memdesc:ad9080cc103f52c0640615fe3044edcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add type casting between arith and index types when needed.  <a href="namespacemlir_1_1sparse__tensor.html#ad9080cc103f52c0640615fe3044edcd4">More...</a><br /></td></tr>
<tr class="separator:ad9080cc103f52c0640615fe3044edcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c14cad562827c9eda2cf82d84e5fdc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a9c14cad562827c9eda2cf82d84e5fdc8">mlir::sparse_tensor::genScalarToTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> elem, <a class="el" href="classmlir_1_1Type.html">Type</a> dstTp)</td></tr>
<tr class="memdesc:a9c14cad562827c9eda2cf82d84e5fdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add conversion from scalar to given type (possibly a 0-rank tensor).  <a href="namespacemlir_1_1sparse__tensor.html#a9c14cad562827c9eda2cf82d84e5fdc8">More...</a><br /></td></tr>
<tr class="separator:a9c14cad562827c9eda2cf82d84e5fdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603c4c5f8fcdac6b72f0e33543cf2528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a603c4c5f8fcdac6b72f0e33543cf2528">mlir::sparse_tensor::genIndexLoad</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> mem, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> s)</td></tr>
<tr class="memdesc:a603c4c5f8fcdac6b72f0e33543cf2528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a pointer/index load from the sparse storage scheme.  <a href="namespacemlir_1_1sparse__tensor.html#a603c4c5f8fcdac6b72f0e33543cf2528">More...</a><br /></td></tr>
<tr class="separator:a603c4c5f8fcdac6b72f0e33543cf2528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015905d50b3f313d4796b5396dd8cd24"><td class="memItemLeft" align="right" valign="top">TypedAttr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a015905d50b3f313d4796b5396dd8cd24">mlir::sparse_tensor::getOneAttr</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a015905d50b3f313d4796b5396dd8cd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 1-valued attribute of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a015905d50b3f313d4796b5396dd8cd24">More...</a><br /></td></tr>
<tr class="separator:a015905d50b3f313d4796b5396dd8cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e5fa1625ec77aeb54ef34e01f02019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a95e5fa1625ec77aeb54ef34e01f02019">mlir::sparse_tensor::genIsNonzero</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> v)</td></tr>
<tr class="memdesc:a95e5fa1625ec77aeb54ef34e01f02019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the comparison <code>v != 0</code> where <code>v</code> is of numeric type.  <a href="namespacemlir_1_1sparse__tensor.html#a95e5fa1625ec77aeb54ef34e01f02019">More...</a><br /></td></tr>
<tr class="separator:a95e5fa1625ec77aeb54ef34e01f02019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49539586251ec5752e6d835944347ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac49539586251ec5752e6d835944347ec">mlir::sparse_tensor::genReshapeDstShape</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dstShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; srcShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1sparse__tensor.html#a67ac14ab2211bf43575a95cb3a07e7b2">Size</a> &gt; staticDstShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation)</td></tr>
<tr class="memdesc:ac49539586251ec5752e6d835944347ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the shape of destination tensor of a reshape operator.  <a href="namespacemlir_1_1sparse__tensor.html#ac49539586251ec5752e6d835944347ec">More...</a><br /></td></tr>
<tr class="separator:ac49539586251ec5752e6d835944347ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98c3f9a9e6a3da81f3f9d1a3ff20493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac98c3f9a9e6a3da81f3f9d1a3ff20493">mlir::sparse_tensor::reshapeCvs</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir.html#af66e7b63d5fa8a2a0339c23648a51fbe">ReassociationIndices</a> &gt; reassociation, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcSizes, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> srcCvs, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> dstSizes, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dstCvs)</td></tr>
<tr class="memdesc:ac98c3f9a9e6a3da81f3f9d1a3ff20493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape coordinates during a reshaping operation.  <a href="namespacemlir_1_1sparse__tensor.html#ac98c3f9a9e6a3da81f3f9d1a3ff20493">More...</a><br /></td></tr>
<tr class="separator:ac98c3f9a9e6a3da81f3f9d1a3ff20493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058ca7dd4f94a17037092388673ba6b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4">mlir::sparse_tensor::getFunc</a> (ModuleOp module, StringRef name, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a> emitCInterface)</td></tr>
<tr class="memdesc:a058ca7dd4f94a17037092388673ba6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a function reference (first hit also inserts into module).  <a href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4">More...</a><br /></td></tr>
<tr class="separator:a058ca7dd4f94a17037092388673ba6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="memItemLeft" align="right" valign="top">func::CallOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785">mlir::sparse_tensor::createFuncCall</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, StringRef name, <a class="el" href="classmlir_1_1TypeRange.html">TypeRange</a> resultType, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> operands, <a class="el" href="namespacemlir_1_1sparse__tensor.html#af7ede6e23dd46be42eac24e06b29b2a2">EmitCInterface</a> emitCInterface)</td></tr>
<tr class="memdesc:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code>CallOp</code> to the function reference returned by <code><a class="el" href="namespacemlir_1_1sparse__tensor.html#a058ca7dd4f94a17037092388673ba6b4" title="Returns a function reference (first hit also inserts into module).">getFunc()</a></code> in the builder's module.  <a href="namespacemlir_1_1sparse__tensor.html#aceb551c7fe08d4e0f1d6ac0cec343785">More...</a><br /></td></tr>
<tr class="separator:aceb551c7fe08d4e0f1d6ac0cec343785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0b0da7fb9ce4d310cf5627458db1ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a8e0b0da7fb9ce4d310cf5627458db1ba">mlir::sparse_tensor::getOpaquePointerType</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a8e0b0da7fb9ce4d310cf5627458db1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the equivalent of <code>void*</code> for opaque arguments to the execution engine.  <a href="namespacemlir_1_1sparse__tensor.html#a8e0b0da7fb9ce4d310cf5627458db1ba">More...</a><br /></td></tr>
<tr class="separator:a8e0b0da7fb9ce4d310cf5627458db1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d9913dd4bcc5fd07acd9b5b5d8f2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a89d9913dd4bcc5fd07acd9b5b5d8f2eb">mlir::sparse_tensor::getOpaquePointerType</a> (<a class="el" href="classmlir_1_1Builder.html">Builder</a> &amp;builder)</td></tr>
<tr class="separator:a89d9913dd4bcc5fd07acd9b5b5d8f2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45d3869f353db49776cf0b9dc4df1e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ab45d3869f353db49776cf0b9dc4df1e4">mlir::sparse_tensor::genAlloca</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> sz, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:ab45d3869f353db49776cf0b9dc4df1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer of the given size and type, but returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than as type <code>memref&lt;$sz x $tp&gt;</code>).  <a href="namespacemlir_1_1sparse__tensor.html#ab45d3869f353db49776cf0b9dc4df1e4">More...</a><br /></td></tr>
<tr class="separator:ab45d3869f353db49776cf0b9dc4df1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f18269772e31d0717f7884435d2f8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a16f18269772e31d0717f7884435d2f8b">mlir::sparse_tensor::genAlloca</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, unsigned sz, <a class="el" href="classmlir_1_1Type.html">Type</a> tp, bool staticShape=false)</td></tr>
<tr class="memdesc:a16f18269772e31d0717f7884435d2f8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer of the given size and type, and returns it as type <code>memref&lt;? x $tp&gt;</code> (staticShape=false) or <code>memref&lt;$sz x $tp&gt;</code> (staticShape=true).  <a href="namespacemlir_1_1sparse__tensor.html#a16f18269772e31d0717f7884435d2f8b">More...</a><br /></td></tr>
<tr class="separator:a16f18269772e31d0717f7884435d2f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a07e0fa74abcc8be1da4aa0790f20f9bc">mlir::sparse_tensor::genAllocaScalar</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Type.html">Type</a> tp)</td></tr>
<tr class="memdesc:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an uninitialized temporary buffer with room for one value of the given type, and returns the <code>memref&lt;$tp&gt;</code>.  <a href="namespacemlir_1_1sparse__tensor.html#a07e0fa74abcc8be1da4aa0790f20f9bc">More...</a><br /></td></tr>
<tr class="separator:a07e0fa74abcc8be1da4aa0790f20f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bd9dfa3427510908f7d75d58103357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a15bd9dfa3427510908f7d75d58103357">mlir::sparse_tensor::allocaBuffer</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> values)</td></tr>
<tr class="memdesc:a15bd9dfa3427510908f7d75d58103357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a temporary buffer, initializes it with the given contents, and returns it as type <code>memref&lt;? x $tp&gt;</code> (rather than specifying the size of the buffer).  <a href="namespacemlir_1_1sparse__tensor.html#a15bd9dfa3427510908f7d75d58103357">More...</a><br /></td></tr>
<tr class="separator:a15bd9dfa3427510908f7d75d58103357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af809e07ab59de56afba2b40b3fe317a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#af809e07ab59de56afba2b40b3fe317a8">mlir::sparse_tensor::allocDenseTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, RankedTensorType tensorTp, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> sizes)</td></tr>
<tr class="memdesc:af809e07ab59de56afba2b40b3fe317a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to allocate a buffer of the given type, and zero initialize it.  <a href="namespacemlir_1_1sparse__tensor.html#af809e07ab59de56afba2b40b3fe317a8">More...</a><br /></td></tr>
<tr class="separator:af809e07ab59de56afba2b40b3fe317a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6d589527be4ee54cb4452354afe6f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aaf6d589527be4ee54cb4452354afe6f9">mlir::sparse_tensor::deallocDenseTensor</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> buffer)</td></tr>
<tr class="memdesc:aaf6d589527be4ee54cb4452354afe6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to deallocate a dense buffer.  <a href="namespacemlir_1_1sparse__tensor.html#aaf6d589527be4ee54cb4452354afe6f9">More...</a><br /></td></tr>
<tr class="separator:aaf6d589527be4ee54cb4452354afe6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5700bf1db7b95b281f7c320acd94d06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae5700bf1db7b95b281f7c320acd94d06">mlir::sparse_tensor::sizesFromSrc</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;sizes, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> src)</td></tr>
<tr class="memdesc:ae5700bf1db7b95b281f7c320acd94d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates given sizes array from dense tensor or sparse tensor constant.  <a href="namespacemlir_1_1sparse__tensor.html#ae5700bf1db7b95b281f7c320acd94d06">More...</a><br /></td></tr>
<tr class="separator:ae5700bf1db7b95b281f7c320acd94d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82016f51c5f51422120acc4ac5143d91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a82016f51c5f51422120acc4ac5143d91">mlir::sparse_tensor::getTop</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a82016f51c5f51422120acc4ac5143d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans to top of generated loop.  <a href="namespacemlir_1_1sparse__tensor.html#a82016f51c5f51422120acc4ac5143d91">More...</a><br /></td></tr>
<tr class="separator:a82016f51c5f51422120acc4ac5143d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8e37ccdc30e3021751cbdfa83cb34a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0e8e37ccdc30e3021751cbdfa83cb34a">mlir::sparse_tensor::foreachInSparseConstant</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, SparseElementsAttr attr, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> order, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;, <a class="el" href="classmlir_1_1Value.html">Value</a>)&gt; callback)</td></tr>
<tr class="memdesc:a0e8e37ccdc30e3021751cbdfa83cb34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a sparse constant, generates constantOp for value and coordinates.  <a href="namespacemlir_1_1sparse__tensor.html#a0e8e37ccdc30e3021751cbdfa83cb34a">More...</a><br /></td></tr>
<tr class="separator:a0e8e37ccdc30e3021751cbdfa83cb34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7ada3d56fcb9a121b9424af7db02e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#abfd7ada3d56fcb9a121b9424af7db02e">mlir::sparse_tensor::loadAll</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, size_t size, <a class="el" href="classmlir_1_1Value.html">Value</a> mem, size_t offsetIdx=0, <a class="el" href="classmlir_1_1Value.html">Value</a> offsetVal=<a class="el" href="classmlir_1_1Value.html">Value</a>())</td></tr>
<tr class="memdesc:abfd7ada3d56fcb9a121b9424af7db02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads <code>size</code>-many values from the memref, which must have rank-1 and size greater-or-equal to <code>size</code>.  <a href="namespacemlir_1_1sparse__tensor.html#abfd7ada3d56fcb9a121b9424af7db02e">More...</a><br /></td></tr>
<tr class="separator:abfd7ada3d56fcb9a121b9424af7db02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5a2910559d8cddf01d1b4cb2150dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#afa5a2910559d8cddf01d1b4cb2150dca">mlir::sparse_tensor::storeAll</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> mem, <a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a> vs, size_t offsetIdx=0, <a class="el" href="classmlir_1_1Value.html">Value</a> offsetVal=<a class="el" href="classmlir_1_1Value.html">Value</a>())</td></tr>
<tr class="memdesc:afa5a2910559d8cddf01d1b4cb2150dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores all the values of <code>vs</code> into the memref <code>mem</code>, which must have rank-1 and size greater-or-equal to <code>vs.size()</code>.  <a href="namespacemlir_1_1sparse__tensor.html#afa5a2910559d8cddf01d1b4cb2150dca">More...</a><br /></td></tr>
<tr class="separator:afa5a2910559d8cddf01d1b4cb2150dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509d4ccd36918b592544c79b75193206"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a39768b5816332d4970911da09de5cec4">TypedValue</a>&lt; <a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a509d4ccd36918b592544c79b75193206">mlir::sparse_tensor::genToMemref</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor)</td></tr>
<tr class="separator:a509d4ccd36918b592544c79b75193206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16556111bb9a45d17f22f7947997cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae16556111bb9a45d17f22f7947997cc2">mlir::sparse_tensor::createOrFoldSliceOffsetOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> dim)</td></tr>
<tr class="memdesc:ae16556111bb9a45d17f22f7947997cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to retrieve the slice offset for the sparse tensor slice, return a constant if the offset is statically known.  <a href="namespacemlir_1_1sparse__tensor.html#ae16556111bb9a45d17f22f7947997cc2">More...</a><br /></td></tr>
<tr class="separator:ae16556111bb9a45d17f22f7947997cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be722792153393e30051e411df2cb32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a8be722792153393e30051e411df2cb32">mlir::sparse_tensor::createOrFoldSliceStrideOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="namespacemlir_1_1sparse__tensor.html#a39f7b45046f9cc6ee2490f64fdb564b0">Dimension</a> dim)</td></tr>
<tr class="memdesc:a8be722792153393e30051e411df2cb32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to retrieve the slice slice for the sparse tensor slice, return a constant if the offset is statically known.  <a href="namespacemlir_1_1sparse__tensor.html#a8be722792153393e30051e411df2cb32">More...</a><br /></td></tr>
<tr class="separator:a8be722792153393e30051e411df2cb32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977236e3292e49f064a84006a742ee38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a977236e3292e49f064a84006a742ee38">mlir::sparse_tensor::genReader</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> stt, <a class="el" href="classmlir_1_1Value.html">Value</a> tensor, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;dimSizesValues, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;dimSizesBuffer)</td></tr>
<tr class="memdesc:a977236e3292e49f064a84006a742ee38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code that opens a reader and sets the dimension sizes.  <a href="namespacemlir_1_1sparse__tensor.html#a977236e3292e49f064a84006a742ee38">More...</a><br /></td></tr>
<tr class="separator:a977236e3292e49f064a84006a742ee38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948d70cf72f61ed55a3f14007cbf376f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a948d70cf72f61ed55a3f14007cbf376f">mlir::sparse_tensor::genMapBuffers</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1sparse__tensor_1_1SparseTensorType.html">SparseTensorType</a> stt, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; dimSizesValues, <a class="el" href="classmlir_1_1Value.html">Value</a> dimSizesBuffer, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;lvlSizesValues, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;dim2lvlBuffer, <a class="el" href="classmlir_1_1Value.html">Value</a> &amp;lvl2dimBuffer)</td></tr>
<tr class="memdesc:a948d70cf72f61ed55a3f14007cbf376f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates code to set up the buffer parameters for a map.  <a href="namespacemlir_1_1sparse__tensor.html#a948d70cf72f61ed55a3f14007cbf376f">More...</a><br /></td></tr>
<tr class="separator:a948d70cf72f61ed55a3f14007cbf376f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc22f44748f0f59b4a61893c5d144e9"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0fc22f44748f0f59b4a61893c5d144e9">mlir::sparse_tensor::constantZero</a> (OpBuilder &amp;builder, Location loc, Type tp)</td></tr>
<tr class="memdesc:a0fc22f44748f0f59b4a61893c5d144e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 0-valued constant of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a0fc22f44748f0f59b4a61893c5d144e9">More...</a><br /></td></tr>
<tr class="separator:a0fc22f44748f0f59b4a61893c5d144e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31882503d2770c14e8fc599f3540c364"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a31882503d2770c14e8fc599f3540c364">mlir::sparse_tensor::constantOne</a> (OpBuilder &amp;builder, Location loc, Type tp)</td></tr>
<tr class="memdesc:a31882503d2770c14e8fc599f3540c364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a 1-valued constant of the given type.  <a href="namespacemlir_1_1sparse__tensor.html#a31882503d2770c14e8fc599f3540c364">More...</a><br /></td></tr>
<tr class="separator:a31882503d2770c14e8fc599f3540c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afca7b5c11b6824d49d422a154323d7"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a0afca7b5c11b6824d49d422a154323d7">mlir::sparse_tensor::constantIndex</a> (OpBuilder &amp;builder, Location loc, int64_t i)</td></tr>
<tr class="memdesc:a0afca7b5c11b6824d49d422a154323d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>index</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a0afca7b5c11b6824d49d422a154323d7">More...</a><br /></td></tr>
<tr class="separator:a0afca7b5c11b6824d49d422a154323d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac690096d7b30f2cbe74bdec480f6513a"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac690096d7b30f2cbe74bdec480f6513a">mlir::sparse_tensor::constantI64</a> (OpBuilder &amp;builder, Location loc, int64_t i)</td></tr>
<tr class="memdesc:ac690096d7b30f2cbe74bdec480f6513a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i64</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#ac690096d7b30f2cbe74bdec480f6513a">More...</a><br /></td></tr>
<tr class="separator:ac690096d7b30f2cbe74bdec480f6513a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae24cf7c247f3ed10a02ecb5c4884a3c1">mlir::sparse_tensor::constantI32</a> (OpBuilder &amp;builder, Location loc, int32_t i)</td></tr>
<tr class="memdesc:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i32</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#ae24cf7c247f3ed10a02ecb5c4884a3c1">More...</a><br /></td></tr>
<tr class="separator:ae24cf7c247f3ed10a02ecb5c4884a3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ac9f31d19a3deeff30f1ffdf9da90b1e4">mlir::sparse_tensor::constantI16</a> (OpBuilder &amp;builder, Location loc, int16_t i)</td></tr>
<tr class="memdesc:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i16</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#ac9f31d19a3deeff30f1ffdf9da90b1e4">More...</a><br /></td></tr>
<tr class="separator:ac9f31d19a3deeff30f1ffdf9da90b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e94d104c16a3cba747e3da258e0d5d"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a32e94d104c16a3cba747e3da258e0d5d">mlir::sparse_tensor::constantI8</a> (OpBuilder &amp;builder, Location loc, int8_t i)</td></tr>
<tr class="memdesc:a32e94d104c16a3cba747e3da258e0d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i8</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a32e94d104c16a3cba747e3da258e0d5d">More...</a><br /></td></tr>
<tr class="separator:a32e94d104c16a3cba747e3da258e0d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f64fbd97b3789823a56e49a293e1e6e"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a5f64fbd97b3789823a56e49a293e1e6e">mlir::sparse_tensor::constantI1</a> (OpBuilder &amp;builder, Location loc, bool b)</td></tr>
<tr class="memdesc:a5f64fbd97b3789823a56e49a293e1e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of <code>i1</code> type.  <a href="namespacemlir_1_1sparse__tensor.html#a5f64fbd97b3789823a56e49a293e1e6e">More...</a><br /></td></tr>
<tr class="separator:a5f64fbd97b3789823a56e49a293e1e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f7e5d153806f1c9506e6c4b38e8507"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a63f7e5d153806f1c9506e6c4b38e8507">mlir::sparse_tensor::constantAction</a> (OpBuilder &amp;builder, Location loc, Action action)</td></tr>
<tr class="memdesc:a63f7e5d153806f1c9506e6c4b38e8507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the given <code>Action</code>.  <a href="namespacemlir_1_1sparse__tensor.html#a63f7e5d153806f1c9506e6c4b38e8507">More...</a><br /></td></tr>
<tr class="separator:a63f7e5d153806f1c9506e6c4b38e8507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ab8f6c538a7e434c02147d7d95a0ceb34">mlir::sparse_tensor::constantOverheadTypeEncoding</a> (OpBuilder &amp;builder, Location loc, unsigned width)</td></tr>
<tr class="memdesc:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#ab8f6c538a7e434c02147d7d95a0ceb34">More...</a><br /></td></tr>
<tr class="separator:ab8f6c538a7e434c02147d7d95a0ceb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2075f93ba015f673f10b0f5b8462d9b5"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a2075f93ba015f673f10b0f5b8462d9b5">mlir::sparse_tensor::constantPosTypeEncoding</a> (OpBuilder &amp;builder, Location loc, SparseTensorEncodingAttr enc)</td></tr>
<tr class="memdesc:a2075f93ba015f673f10b0f5b8462d9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for position overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a2075f93ba015f673f10b0f5b8462d9b5">More...</a><br /></td></tr>
<tr class="separator:a2075f93ba015f673f10b0f5b8462d9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b3227aba0b971f98674d242cde08b9"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a68b3227aba0b971f98674d242cde08b9">mlir::sparse_tensor::constantCrdTypeEncoding</a> (OpBuilder &amp;builder, Location loc, SparseTensorEncodingAttr enc)</td></tr>
<tr class="memdesc:a68b3227aba0b971f98674d242cde08b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for coordinate overhead storage.  <a href="namespacemlir_1_1sparse__tensor.html#a68b3227aba0b971f98674d242cde08b9">More...</a><br /></td></tr>
<tr class="separator:a68b3227aba0b971f98674d242cde08b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#ae41c3450aa0396748a11b1ce7a4fa8e3">mlir::sparse_tensor::constantPrimaryTypeEncoding</a> (OpBuilder &amp;builder, Location loc, Type elemTp)</td></tr>
<tr class="memdesc:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal type-encoding for primary storage.  <a href="namespacemlir_1_1sparse__tensor.html#ae41c3450aa0396748a11b1ce7a4fa8e3">More...</a><br /></td></tr>
<tr class="separator:ae41c3450aa0396748a11b1ce7a4fa8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1288a146000a52410b068b893f2ec84b"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a1288a146000a52410b068b893f2ec84b">mlir::sparse_tensor::constantLevelTypeEncoding</a> (OpBuilder &amp;builder, Location loc, LevelType lt)</td></tr>
<tr class="memdesc:a1288a146000a52410b068b893f2ec84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a constant of the internal dimension level type encoding.  <a href="namespacemlir_1_1sparse__tensor.html#a1288a146000a52410b068b893f2ec84b">More...</a><br /></td></tr>
<tr class="separator:a1288a146000a52410b068b893f2ec84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f655facff34268bcf49d8f7c1123bd4"><td class="memItemLeft" align="right" valign="top">Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#a6f655facff34268bcf49d8f7c1123bd4">mlir::sparse_tensor::genValFromAttr</a> (OpBuilder &amp;builder, Location loc, Attribute attr)</td></tr>
<tr class="separator:a6f655facff34268bcf49d8f7c1123bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cfbb689a6cf4c8f4cfdf898cb890d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1sparse__tensor.html#aa9cfbb689a6cf4c8f4cfdf898cb890d1">mlir::sparse_tensor::isZeroRankedTensorOrScalar</a> (Type type)</td></tr>
<tr class="separator:aa9cfbb689a6cf4c8f4cfdf898cb890d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Sep 27 2025 16:33:09 for MLIR by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
